{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Python基础/2.1.python基本语法.html","text":"交互模式 Python是一种解释型语言，Python解释器通过一次执行一条语句的方式运行程序。从 tty 读取命令时, 我们称解释器工作于交互模式 (interactive mode)。可以在cmd窗口通过 python 命令启动CPython解释器的交互模式，交互模式下CPython通过主提示符 (primary prompt) 提示下一条命令, 主提示符为 >>> ，而从提示符 ··· 提示一条命令的续行。 加强的交互式解释器(IPython)的提示符是一种编号的风格，如 In[2] ，而不是标准的 >>> 。 python保留字 保留字（又称为关键字）， 不能把它们用作任何标识符名称 。Python的标准库提供了一个keyword模块，可以输出当前版本的所有关键字： import keyword keyword . kwlist print ( keyword . kwlist ) ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 注释 Python中单行注释以 # 开头。多行注释则使用： ''' 或者 \"\"\" 。实际上python只有单行注释。多行注释的本质是字符串对象。 # 这是单行注释 ''' 这是多行注释 这是多行注释 ''' 代码块 python最具特色的就是使用缩进来表示代码块，不是使用大括号{}。而冒号表示一段缩进代码块的开始，其后所有相同层次的代码必须保持相同的缩进量，缩进量则可以随意，直至代码块结束。 一般约定俗成使用4个空格的缩进。 if True : print ( \"True\" ) else : print ( \"False\" ) True 代码续行 如果语句很长，可以使用反斜杠 \\ 来续行，例如： a = 3 + \\ 4 + \\ 5 a 12 在 [] , {} , 或 () 中的多行语句 1 ，不需要使用反斜杠 \\ ，例如： total = [ 'item_one' , 'item_two' , 'item_three' , 'item_four' , 'item_five' ] total ['item_one', 'item_two', 'item_three', 'item_four', 'item_five'] 同一行书写多条语句 Python可以在同一行中使用多条语句，语句之间使用半角分号 ; 分隔。但这样的做法一般不推荐，因为会使代码的可读性变差。 空行 函数、类方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同， 空行并不是Python语法的一部分。 书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。空行也是程序代码的一部分。 Print 输出 print函数默认输出是换行的，如果要实现不换行打印，需要更改print函数的 end 参数： # 换行输出 print ( \"a\" ) print ( \"b\" ) print ( '-' * 10 ) # 不换行输出 print ( \"a\" , end = \" \" ) print ( \"b\" , end = \" \" ) print () a b ---------- a b import 与 from...import 在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块 ( module ) 导入： import somemodule 从某个模块中导入某个函数： from somemodule import somefunction 从某个模块中导入多个函数： from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入： from somemodule import * 转义符 \\ 如果要在字符串中输入一些特殊的字符（这些字符特殊之处在于不能直接输出），这就需要“转义符”。所谓转义，就是不采用符号原先的含义，而采用另外一含义。在Pyhton中， \\ 代表转义符。 下面表格中列出常用的转义符： 转义字符 描述 \\ 在字符串行尾的续行符 \\\\ 反斜杠符号 \\' 单引号 \\\" 双引号 \\a 蜂鸣器响铃（不是喇叭发声），现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效 \\b 退格（Backspace），将光标位置移到前一列 \\e 转义 \\000 空 \\n 换行符 \\v 纵向制表符 \\t 横向制表符，即 Tab 键，一般相当于四个空格 \\r 回车符 \\f 换页 \\oyy 八进制数，yy代表字符，例如： \\o12 代表换行 \\xyy 十六进制数，yy代表字符，例如： \\x0a 代表换行 \\other 其它的字符以普通格式输出 有时候，字符串包含了很多 \\ ，Python默认将'\\'作为转义符处理，但实际上我们想输出的是反斜杠符号 \\ ，（例如输入文件路径）。此时，自然可以在反斜杠前加上转义符 \\ ，但是这样未免太麻烦。Python提供了一个简化的操作，Pyhon允许用 r'字符串内容' 表示 '字符串内容' 内部的字符串默认不转义： print ( ' \\\\\\t\\\\ ' ) print ( '-' * 10 ) print ( r ' \\\\ \\t \\\\ ' ) \\ \\ ---------- \\\\\\t\\\\ name与object 提到编程语言，常常会提起变量这个概念，但在Python中，变量一词更准确的说法应该是name（名字）。有观点认为Python不存在变量这个概念，也有观点认为Python存在变量的概念（即name），只不过Python的变量的行为和其他编程语言有所区别。但在这里不深入探究，在本系列的文章中， 变量 和 名字（name） 具有等同的内涵； 变量值（变量的值） 和 对象（object） 具有等同的内涵。 Python是动态类型的语言，变量不需要声明、定义和初始化，变量会在赋值时被创建。 Objects 所有Python对象都有: 一个惟一的 identity （由id(x)返回的一个整数，注意：identity 不是 identifier） 一个类型（由type(x)返回） 一些值 无法改变对象的identity，也不能改变对象的类型。 改变位于某一地址的对象的引用与类型是不可能的，只能把对象销毁，然后重新创建。 Note 在CPython2.2及更新的版本中，你可以在相当有限的情况下更改对象的类型。 一些对象允许你改变它们的值（在不改变它们的identity和type的情况下），这种对象被称为 mutable object ；而一些对象并不允许你改变它们的值，它们被称为 immutable object 。 类型由 类对象 表示（类对象往往知道类的对象要占多少内存，有什么方法等等）。 一个对象可以有： 零个或多个方法（由类对象提供） 零个或多个 名字 某些对象具有允许你更改对象内容（即对其进行修改）的方法。某些对象仅具有允许您访问内容而不更改内容的方法。一些对象没有任何方法。即使对象具有方法，你也不能改变它们的类型或者identity。 Names name不是object的属性，object并不知道它们的name（名字）。 所有name在创建时必须关联（bind）到一个object，否则在需要引用该name时会报错。 name可以在创建以后指向任何一个object（包括不同类型），所以name本身没有类别，但name关联的object是有类别的。 在python中可以使用type（name）来查看name关联的object的类型。 一个对象可以关联（bind）多个名字，也可以没有名字。 Name存在于namespace（命名空间），例如模块命名空间、实例命名空间、函数的局部命名空间等等。 assignment Python也有assignment这个英文概念，它的中文或许译为 分配 或者 命名 更为恰当，因为在Python中，assignment语句会改动namespace，而不是改动了object。 换而言之，如果在python中有一个assignment statement如下： a = 10 这个assignment语句表示将名称a添加到namespace，并且namespace的a键 2 所对应的value为10。 如果名称已经存在，assignment语句将替换原始名称： a = 10 a = 20 这意味着首先要将名称a添加到namespace，并使其指向包含值10的整数对象。然后再使a其指向包含值20的整数对象。原来的整数对象10不受此操作的影响。 如果这样做： a = [] a . append （ 1 ） 第一条语句将 a 关联到一个空列表对象，这会修改命名空间，第二条语句修改了该列表的内容，这并不会触及namespace。 综上所述，assignment statement在python中有两个作用： 用于（重新）将名称绑定到对象 修改可变对象的属性（内容） 单引号与双引号 在Python中单引号和双引号都可以用来表示一个字符串，比如： str1 = 'python' str2 = \"python\" str1和str2是没有任何区别的。 Python以其易用性而著名，但单引号和双引号却不仅仅是为了方便。想想I'm a big fans of Python.这个字符串应该怎么定义？可以这样写： str3 = 'I \\' m a big fan of Python.' 那么We all know that 'A' and 'B' are two capital letters.又该怎么定义呢？ str4 = 'We all know that \\' A \\' and \\' B \\' are two capital letters.' 显然太多的转义符看起来并不好看，而且容易出错了。那么，在Python中，还可以这样写： str4 = \"We all know that 'A' and 'B' are two capital letters.\" 这样就人性化多了，这就是Python支持双引号和单引号都能用来定义字符串的原因。反之，如果字符串中有双引号，为了避免使用转义符，你可以使用单引号来定义这个字符串。比如： str5 = 'The teacher said: \"Practice makes perfect\" is a very famous proverb.' 这就是Python易用性和人性化的一个极致体现，当你用单引号' '定义字符串的时候，它就会认为你字符串里面的双引号\" \"是普通字符，从而不需要转义。反之当你用双引号定义字符串的时候，就会认为你字符串里面的单引号是普通字符无需转义。 Lambdas 正常创建函数（使用 def ）会自动将其赋值给变量，这与创建其他对象（例如字符串和整数）不同，后者可以动态创建，而无需将它们分配给变量。但只要使用lambda语法创建函数，函数也可以这样做，以这种方式创建的函数称为匿名（anonymous）函数。将简单函数作为参数传递给另一个函数时，最常使用此方法。语法如下： # my_func是正常创建的函数（named function） def my_func ( f , arg ): return f ( arg ) my_func ( lambda x : 2 * x * x , 5 ) 50 在上面的代码中，我们动态创建了一个匿名函数，并使用参数调用它。Lambda函数没有命名函数（named function）那么强大。Lambda函数只能包含一个表达式，通常相当于一行代码。实际上，Lambda函数可以分配给变量，并像普通函数一样使用。但是，很少有充分的理由这样做。通常使用 def 来定义函数通常更好。 double = lambda x : x * 2 print ( double ( 7 )) 14 运算符 算术运算符 运算符 描述 + 加 - 减 * 乘 / 除 % 取模 ** 幂 // 取整除 比较运算符 运算符 描述 == 等于 != 不等于 > 大于 < 小于 >= 大于等于 <= 小于等于 赋值运算符 运算符 描述 = 简单的赋值运算符 += 加法赋值运算符 -= 减法赋值运算符 *= 乘法赋值运算符 /= 除法赋值运算符 %= 取模赋值运算符 **= 幂赋值运算符 //= 取整除赋值运算符 位运算符 运算符 描述 & 按位与运算符：参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为0 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 ~ 按位取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1。 ~x 类似于 -x-1 << 左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数指定移动的位数，高位丢弃，低位补0 >> 右移动运算符：把 > 左边的运算数的各二进位全部右移若干位， >> 右边的数指定移动的位数 111 & 100 100 111 | 100 111 111 ^ 100 11 逻辑运算符 运算符 逻辑表达式 描述 and x and y x、y同时为真，则结果为真，否则为假 or x or y x、y两者有一个为真，则结果为真，否则为假 not not x x为真，结果为假；x为假，结果为真 成员运算符 运算符 描述 in 如果在指定的序列中找到值返回 True，否则返回 False not in 如果在指定的序列中没有找到值返回 True，否则返回 False 身份运算符 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b) 。如果引用的不是同一个对象则返回结果 True，否则返回 False 运算符优先级 运算符 描述 (expressions...), [expressions...], {key: value...}, {expressions...} 表示绑定或元组、表示列表、表示字典、表示集合 x[index], x[index:index], x(arguments...), xattribute 下标、切片、调用、属性引用 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +\\@ 和 -\\@) * / % // 乘，除，取模和取整除 + - 加法减法 >> << 右移，左移运算符 & 位 ‘AND’ ^ 按位异或运算符 <= < > >= 比较运算符 == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 and or not 逻辑运算符 if - else 条件表达式 lambda Lambda 表达式 具有相同优先级的运算符将从左至右的方式依次进行。用小括号 () 可以改变运算顺序。 包括函数、类的定义。 ↩ 目前Python的命名空间使用字典实现，但日后可能会改变。 ↩","text_tokens":["很多","‘","对应","原先","强大","然后","成员","相异","try","!","the","算术","capital","while","分配","等于","不仅","表格","name","了","中有","窗口","相当于","右边","]","但","这个","加上","整个","代表","特色","时候","可能","仅","约定","并","相应","这样","语言","e","未免太","str2","为","理由","变为","等等","准确","同一","应该","anonymous","append","teacher","左移","提示","\"","上面","占","we","xyy","12","实际上","这会","使用","及","反之","整除","-","译","只能","认为","其他","proverb","该","其",">","空间","程序","综上","、","function","最高","光标","对","麻烦","像","默认","一部","您","报错","x0a","#","回车","已经","↩","except","位置","3","变量值","采用","它们","还","因为","多个","结果","这里","想想","部分","易用","只有","+","动态创建","出错","关联","n","第二条","另","7","计算机","二进制位","有限","左边","系列","item","判断","a","语法","oyy","移到","取模","制表","使","不会","创建","除法","处","幂","随意","4","两","区别","返回","启动","变量","类别","’","支持","列出","由类","命名","加强","条件","）","第一条","*","现在","key","留字","are","with","更新","常常","变差","famous","横向","指向","[","太多",";","代码","单行","知道","str1","note","end","优先级","新","cmd","ipython","个","到","本","约定俗成",",","导入","one","此时","时会","本身","await","交互式","assignment","比如","m","文章","参与","多行","pyhon","从","位于","每个","表达","five","000","作为","fan","之","避免","数据","module","保留字","2","添加","一元","expressions","字典","意味","集合","bind","，","一词","号","异或","型","便于","定义","有","插入","某个","制表符","等同","know","一个","简化","除","日后","否则","当于","右移","综上所述","fans","100","比较","arguments","目前","o12","表达式","做","practice","原来","大括号","维护","想","却","看起","内部","进制","这些","输入","arg","前","格式","修改","简单","空格","首先","一次","于","把","或者","路径","一定","“","匿名","全部","更好","解释","符号","影响","丢弃","字符","不仅仅","字符串","：","而且","符","break","lambda","i","真","但是","普通","不能","优先","结束","可读","更","声明","加号","所以","secondfunc","只不过","tab","某些","即使","并不知道","小于","赋值","改变","关键字","编程语言","情况","什么","时","可以","将","未免","行为","易用性","that","标识符","%","减法","行中","@","另外","以其","用作","参数","按位","描述","原始","恰当","提供","写","常","yy","运算符","所谓","直接","不知","解释器","不过","推荐","有所区别","二条","四个","若干位","名为","该位","而言","func","蜂鸣器","不带","somemodule","内容","任何","入口","？","例如","查看","有效","一般","y","半角","里面","111","并且","释器","执行","你","要","有时","用来","str4","调用","减","属性","语句","分","elif","我们","取反","进行","5","in","充分","访问","指数","绑定","所","如","冒号","某一","续行","中","打印","said","大于","需要","空","极致","is","不","包括","是","或许","|","其它","斜杠","之间","起来","”","具有","参数传递","my","八进制","=","库","若干","为了","这","著名","模块","一些","f","很少","r","namespace","零个","最具","二进制","乘","工作","中文","算符","关键","销毁","实例","1","x","自动","两者","切片","常用","左","反","finally","用","双引号","一段","mode","pyhton","由","或","包含","提起","backspace","three","会","无需","true","def","后者","高位","python","nonlocal","很长","序列","改动","11","惟一","不是","其后","pass","英文","转义字符","输出","缩","都","二进位","突出","行尾","names","运行","not","mutable","as","str3","也","主","xattribute","补","identity","表示","处理","纵向","量值","发声","程序代码","注释","被","则","缩进","of","体现","编号","的","global","直至","替换","可变","换行","注意","重构","存在","类型","有所","str5","顺序","而","取","转义","初始化","从而","响铃","这种","容易","十六进制","identifier"," ","书写","观点","位数","four","键","big","交互","somefunction","更改","括号","小括号","以","正常","下标","十六","}","引用","模式","翻转","；","加法","false","保持","二个","各","称为","objects","else","raise","如果","多少","说法","一列","cpython2.2","意味着","行","kwlist","type","是不是","·","thirdfunc","运算","return","和","层次","(","一条","makes","一行","14","10","<","当前","呢","提示符","object","不同","all","做法","import","方法","就是","本质","cpython","乘法",")","有时候","又","达式",".","动态","id","同一个","b","指定","来","当","&","在","assert","操作","print","无法","引号","。","允许","初始","进位","命令","与","下面","深入","列表","就","内存","给","仅仅","continue","名称","内涵","更为","'","index","数","very","再","第二","功能","...","传递","怎么","perfect","\\","相当","primary","del","firstfunc","重新","文件","减号","即","多","元组","退格","换页","20","用于","value","称","此","喇叭","开头","续行符","自然","块","0","这是","double","显然","other","探究","对象","空行","方式","往往","那么","类","and","名字","读取","看起来","同时","一种","class","地址","换","如下","编程","保留","风格","分隔","async","可读性","v","statement","最后","一部分","触及","局部","~","人性","^","t","版本","通过","{","letters","位","_","for","好看","量","在于","换行符","含义","tty","多条","原因","/","函数","实现","低位","类似","if","最",":","方便","from","它","假","lambdas","named","依次","特殊","没有","不受","two","所述","标识","一样","算机","计算","概念","prompt","至","50","回车符","找到","第一","提到","数传","yield","none","加","开始","一","只要","immutable","两段","逻辑","标准","以后","两个","必须","值","进来","能","人性化","作用","相同","or","右","下","通常","自","所有","身份","实际","整数","移动","keyword","（","total","interactive","单引号"],"title":"2.1.python基本语法","title_tokens":["python","语法",".","2.1","基本"]},{"location":"Python基础/2.1.python基本语法.html#_1","text":"Python是一种解释型语言，Python解释器通过一次执行一条语句的方式运行程序。从 tty 读取命令时, 我们称解释器工作于交互模式 (interactive mode)。可以在cmd窗口通过 python 命令启动CPython解释器的交互模式，交互模式下CPython通过主提示符 (primary prompt) 提示下一条命令, 主提示符为 >>> ，而从提示符 ··· 提示一条命令的续行。 加强的交互式解释器(IPython)的提示符是一种编号的风格，如 In[2] ，而不是标准的 >>> 。","text_tokens":["主","语言","交互","mode","加强","为","读取","交互式","一种","是","风格","prompt","从","cpython","模式",")","提示","通过","primary","释器","执行","[","标准","编号","的","tty","时","一次","可以","2","于","python","语句","工作","在","我们","窗口","称","。","不是","cmd","命令","程序",">","·","ipython","解释","in","而","]","，","型","启动",",","下","如","(","解释器","一条"," ","续行","运行","方式","提示符","interactive"],"title":"交互模式","title_tokens":["交互","模式"]},{"location":"Python基础/2.1.python基本语法.html#python","text":"保留字（又称为关键字）， 不能把它们用作任何标识符名称 。Python的标准库提供了一个keyword模块，可以输出当前版本的所有关键字： import keyword keyword . kwlist print ( keyword . kwlist ) ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']","text_tokens":["is","import","try","库",")","while","又","模块",".","保留字","了","assert","print","关键","。","keyword","]","，","continue","名称","finally","一个","'","del","true","def","python","把","nonlocal","pass","输出","：","break","lambda","not","as","不能","and","except","class","它们","保留","async","版本","关键字","for","的","可以","global","标识符","用作","if","提供","from"," ","标识","）","留字","任何","with","yield","none","[","标准","false","称为","elif","else","raise","kwlist","in","or","return",",","所有","(","当前","（","await"],"title":"python保留字","title_tokens":["留字","保留","python","保留字"]},{"location":"Python基础/2.1.python基本语法.html#_2","text":"Python中单行注释以 # 开头。多行注释则使用： ''' 或者 \"\"\" 。实际上python只有单行注释。多行注释的本质是字符串对象。 # 这是单行注释 ''' 这是多行注释 这是多行注释 '''","text_tokens":["'","是","多行","本质","以","只有","\"","注释","则","实际上","的","使用","单行","python","或者","对象","。","开头","这是","字符","字符串","：","实际"," ","中","#"],"title":"注释","title_tokens":["注释"]},{"location":"Python基础/2.1.python基本语法.html#_3","text":"python最具特色的就是使用缩进来表示代码块，不是使用大括号{}。而冒号表示一段缩进代码块的开始，其后所有相同层次的代码必须保持相同的缩进量，缩进量则可以随意，直至代码块结束。 一般约定俗成使用4个空格的缩进。 if True : print ( \"True\" ) else : print ( \"False\" ) True","text_tokens":["一段","结束","表示","括号","就是","大括号","一般","}",")","{","\"","开始","缩进","则","true","空格","量","的","使用","代码","保持","可以","最具","直至","python","false","必须","进来","else","print","。","if","不是","其后","随意","4","相同","块","个",":","而","约定俗成","，","缩","冒号","所有","层次","(","特色"," ","约定"],"title":"代码块","title_tokens":["块","代码"]},{"location":"Python基础/2.1.python基本语法.html#_4","text":"如果语句很长，可以使用反斜杠 \\ 来续行，例如： a = 3 + \\ 4 + \\ 5 a 12 在 [] , {} , 或 () 中的多行语句 1 ，不需要使用反斜杠 \\ ，例如： total = [ 'item_one' , 'item_two' , 'item_three' , 'item_four' , 'item_five' ] total ['item_one', 'item_two', 'item_three', 'item_four', 'item_five']","text_tokens":["需要","'","3","或","不","斜杠","多行","例如","=","+","}","five",")","{","\\","three","_","[","12","的","使用","可以","item","很长","来","a","语句","在","如果","1","4","5","]","，",",","：","one","(","反","中"," ","续行","total","two","four"],"title":"代码续行","title_tokens":["代码","续行"]},{"location":"Python基础/2.1.python基本语法.html#_5","text":"Python可以在同一行中使用多条语句，语句之间使用半角分号 ; 分隔。但这样的做法一般不推荐，因为会使代码的可读性变差。","text_tokens":["这样","可读","做法","不","分隔","同一","之间","因为","可读性","一般","变差","半角","会",";","使用","多条","可以","的","代码","python","语句","分","在","行中","使","。","但","，","号","推荐"," "],"title":"同一行书写多条语句","title_tokens":["语句","同一","书写","行","多条"]},{"location":"Python基础/2.1.python基本语法.html#_6","text":"函数、类方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同， 空行并不是Python语法的一部分。 书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。空行也是程序代码的一部分。","text_tokens":["运行","也","一段","不同","表示","或","不","是","分隔","方法","入口","之间","功能","一部分","以","维护","程序代码","一部","部分","出错","开始","释器","缩进","两段","在于","的","代码","时","含义","函数","python","语法","不会","重构","。","作用","不是","新","程序","与","、","解释","，","和","便于","突出","插入","用","解释器","一行"," ","书写","空行","但是","日后","并","类"],"title":"空行","title_tokens":["空行"]},{"location":"Python基础/2.1.python基本语法.html#print","text":"print函数默认输出是换行的，如果要实现不换行打印，需要更改print函数的 end 参数： # 换行输出 print ( \"a\" ) print ( \"b\" ) print ( '-' * 10 ) # 不换行输出 print ( \"a\" , end = \" \" ) print ( \"b\" , end = \" \" ) print () a b ---------- a b","text_tokens":["需要","'","不","更改","是","*","=",")","\"","要","b","的","函数","a","-","实现","换行","print","如果","参数","end","输出","，",",","：","(","默认","打印"," ","10","#"],"title":"Print 输出","title_tokens":["print"," ","输出"]},{"location":"Python基础/2.1.python基本语法.html#import-fromimport","text":"在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块 ( module ) 导入： import somemodule 从某个模块中导入某个函数： from somemodule import somefunction 从某个模块中导入多个函数： from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入： from somemodule import *","text_tokens":["相应","somefunction","import","somemodule","*","secondfunc","多个","...","从",")","模块","firstfunc","module","的","将","函数","python","来","在","或者","。","thirdfunc","全部","from",",","整个","导入","：","(","某个","用"," ","中"],"title":"import 与 from...import","title_tokens":["from","import"," ","...","与"]},{"location":"Python基础/2.1.python基本语法.html#_7","text":"如果要在字符串中输入一些特殊的字符（这些字符特殊之处在于不能直接输出），这就需要“转义符”。所谓转义，就是不采用符号原先的含义，而采用另外一含义。在Pyhton中， \\ 代表转义符。 下面表格中列出常用的转义符： 转义字符 描述 \\ 在字符串行尾的续行符 \\\\ 反斜杠符号 \\' 单引号 \\\" 双引号 \\a 蜂鸣器响铃（不是喇叭发声），现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效 \\b 退格（Backspace），将光标位置移到前一列 \\e 转义 \\000 空 \\n 换行符 \\v 纵向制表符 \\t 横向制表符，即 Tab 键，一般相当于四个空格 \\r 回车符 \\f 换页 \\oyy 八进制数，yy代表字符，例如： \\o12 代表换行 \\xyy 十六进制数，yy代表字符，例如： \\x0a 代表换行 \\other 其它的字符以普通格式输出 有时候，字符串包含了很多 \\ ，Python默认将'\\'作为转义符处理，但实际上我们想输出的是反斜杠符号 \\ ，（例如输入文件路径）。此时，自然可以在反斜杠前加上转义符 \\ ，但是这样未免太麻烦。Python提供了一个简化的操作，Pyhon允许用 r'字符串内容' 表示 '字符串内容' 内部的字符串默认不转义： print ( ' \\\\\\t\\\\ ' ) print ( '-' * 10 ) print ( r ' \\\\ \\t \\\\ ' ) \\ \\ ---------- \\\\\\t\\\\","text_tokens":["需要","很多","空","原先","不","是","其它","斜杠","”","就是","pyhon","八进制","000","作为","这",")","之","有时候","一些","f","表格","b","r","了","在","操作","print","相当于","引号","。","允许","但","下面","，","常用","就","加上","代表","反","制表符","用","时候","一个","简化","双引号","'","当于","这样","pyhton","e","未免太","数","o12","包含","想","backspace","\"","\\","这些","输入","相当","前","进制","格式","内部","文件","xyy","空格","实际上","即","退格","换页","-","python","路径","一定","喇叭","“","不是","续行符","自然","转义字符","输出","符号","光标","字符","都","字符串","：","符","麻烦","行尾","other","默认","但是","普通","x0a","不能","回车","位置","表示","采用","所以","处理","v","纵向","发声","tab","t","n","计算机","在于","换行符","的","含义","将","可以","未免","a","oyy","移到","换行","另外","制表","处","描述","提供","而","转义","yy","所谓","直接","响铃","十六进制"," ","特殊","列出","四个","键","算机","计算","）","蜂鸣器","不带","现在","*","内容","回车符","例如","以","有效","一般","十六","横向","一","要","有时","我们","如果","一列","此时","(","实际","续行","中","10","（","单引号"],"title":"转义符\\","title_tokens":["\\","转义","符"]},{"location":"Python基础/2.1.python基本语法.html#nameobject","text":"提到编程语言，常常会提起变量这个概念，但在Python中，变量一词更准确的说法应该是name（名字）。有观点认为Python不存在变量这个概念，也有观点认为Python存在变量的概念（即name），只不过Python的变量的行为和其他编程语言有所区别。但在这里不深入探究，在本系列的文章中， 变量 和 名字（name） 具有等同的内涵； 变量值（变量的值） 和 对象（object） 具有等同的内涵。 Python是动态类型的语言，变量不需要声明、定义和初始化，变量会在赋值时被创建。","text_tokens":["需要","也","语言","名字","更","文章","）","不","变量值","是","编程","提起","概念","准确","观点","只不过","object","具有","应该","量值","这里","常常","提到","会","赋值","被","编程语言","动态","即","；","的","时","系列","name","行为","python","值","认为","在","内涵","其他","对象","说法","。","存在","类型","声明","初始","创建","有所","但","这个","本","、","区别","深入","，","一词","初始化","和","定义","变量","有","不过","等同","有所区别","探究","中"," ","（"],"title":"name与object","title_tokens":["name","object","与"]},{"location":"Python基础/2.1.python基本语法.html#objects","text":"所有Python对象都有: 一个惟一的 identity （由id(x)返回的一个整数，注意：identity 不是 identifier） 一个类型（由type(x)返回） 一些值 无法改变对象的identity，也不能改变对象的类型。 改变位于某一地址的对象的引用与类型是不可能的，只能把对象销毁，然后重新创建。 Note 在CPython2.2及更新的版本中，你可以在相当有限的情况下更改对象的类型。 一些对象允许你改变它们的值（在不改变它们的identity和type的情况下），这种对象被称为 mutable object ；而一些对象并不允许你改变它们的值，它们被称为 immutable object 。 类型由 类对象 表示（类对象往往知道类的对象要占多少内存，有什么方法等等）。 一个对象可以有： 零个或多个方法（由类对象提供） 零个或多个 名字 某些对象具有允许你更改对象内容（即对其进行修改）的方法。某些对象仅具有允许您访问内容而不更改内容的方法。一些对象没有任何方法。即使对象具有方法，你也不能改变它们的类型或者identity。","text_tokens":["不","是","然后","方法","具有","位于",")","一些","id","零个","在","无法","。","销毁","x","允许","与","，","内存","有","一个","可能","仅","并","由","或","等等","相当","占","重新","修改","即","及","python","把","只能","或者","惟一","不是","其","（","都","：","对","对象","往往","您","mutable","不能","类","也","名字","identity","地址","表示","它们","多个","某些","即使","版本","改变","被","情况","有限","什么","的","可以","注意","创建","类型",":","提供","而","返回","这种","identifier"," ","没有","由类","）","更改","内容","任何","更新","引用","你","要","immutable","；","称为","知道","值","note","多少","cpython2.2","进行","访问","下","和","所有","(","某一","整数","中","type","object"],"title":"Objects","title_tokens":["objects"]},{"location":"Python基础/2.1.python基本语法.html#names","text":"name不是object的属性，object并不知道它们的name（名字）。 所有name在创建时必须关联（bind）到一个object，否则在需要引用该name时会报错。 name可以在创建以后指向任何一个object（包括不同类型），所以name本身没有类别，但name关联的object是有类别的。 在python中可以使用type（name）来查看name关联的object的类型。 一个对象可以关联（bind）多个名字，也可以没有名字。 Name存在于namespace（命名空间），例如模块命名空间、实例命名空间、函数的局部命名空间等等。","text_tokens":["需要","否则","也","不同","名字","）","包括","是","它们","等等","所以","任何","object","多个","例如","查看","局部","并不知道","引用","关联","指向","模块","以后","的","时","可以","使用","name","namespace","知道","属性","python","来","必须","于","在","函数","对象","创建","。","类型","该","存在","不是","实例","type","空间","到","但","bind","、","，","不知","所有","时会","有","中","本身","类别"," ","一个","没有","（","报错","命名"],"title":"Names","title_tokens":["names"]},{"location":"Python基础/2.1.python基本语法.html#assignment","text":"Python也有assignment这个英文概念，它的中文或许译为 分配 或者 命名 更为恰当，因为在Python中，assignment语句会改动namespace，而不是改动了object。 换而言之，如果在python中有一个assignment statement如下： a = 10 这个assignment语句表示将名称a添加到namespace，并且namespace的a键 2 所对应的value为10。 如果名称已经存在，assignment语句将替换原始名称： a = 10 a = 20 这意味着首先要将名称a添加到namespace，并使其指向包含值10的整数对象。然后再使a其指向包含值20的整数对象。原来的整数对象10不受此操作的影响。 如果这样做： a = [] a . append （ 1 ） 第一条语句将 a 关联到一个空列表对象，这会修改命名空间，第二条语句修改了该列表的内容，这并不会触及namespace。 综上所述，assignment statement在python中有两个作用： 用于（重新）将名称绑定到对象 修改可变对象的属性（内容）","text_tokens":["空","assignment","对应","或许","然后","=","这","分配","之",".","namespace","2","添加","了","中文","在","中有","操作","。","1","意味","]","这个","列表","，","名称","有","一个","更为","并","这样","为","综上所述","包含","再","做","第二","append","会","重新","修改","首先","这会","20","python","译","用于","或者","value","改动","此","该","不是","其","空间","综上","英文","影响","（","：","对象","已经","也","表示","换","如下","因为","statement","触及","关联","第二条","的","将","a","替换","可变","使","不会","存在","原始","恰当","而","它","二条"," ","不受","命名","键","而言","所述","）","第一条","概念","内容","第一","指向","并且","要","[","两个","属性","语句","值","如果","作用","意味着","到","绑定","所","整数","一条","10","中","原来","object"],"title":"assignment","title_tokens":["assignment"]},{"location":"Python基础/2.1.python基本语法.html#_8","text":"在Python中单引号和双引号都可以用来表示一个字符串，比如： str1 = 'python' str2 = \"python\" str1和str2是没有任何区别的。 Python以其易用性而著名，但单引号和双引号却不仅仅是为了方便。想想I'm a big fans of Python.这个字符串应该怎么定义？可以这样写： str3 = 'I \\' m a big fan of Python.' 那么We all know that 'A' and 'B' are two capital letters.又该怎么定义呢？ str4 = 'We all know that \\' A \\' and \\' B \\' are two capital letters.' 显然太多的转义符看起来并不好看，而且容易出错了。那么，在Python中，还可以这样写： str4 = \"We all know that 'A' and 'B' are two capital letters.\" 这样就人性化多了，这就是Python支持双引号和单引号都能用来定义字符串的原因。反之，如果字符串中有双引号，为了避免使用转义符，你可以使用单引号来定义这个字符串。比如： str5 = 'The teacher said: \"Practice makes perfect\" is a very famous proverb.' 这就是Python易用性和人性化的一个极致体现，当你用单引号' '定义字符串的时候，它就会认为你字符串里面的双引号\" \"是普通字符，从而不需要转义。反之当你用双引号定义字符串的时候，就会认为你字符串里面的单引号是普通字符无需转义。","text_tokens":["需要","极致","比如","m","all","is","不","是","起来","就是","the","=","为了","capital","著名","fan","这","又","避免",".","不仅","b","了","来","当","中有","在","引号","。","但","这个","，","就","定义","仅仅","用","know","时候","一个","双引号","并","'","这样","str2","fans","very","practice","应该","teacher","却","看起","怎么","\"","\\","perfect","会","无需","we","多","使用","反之","python","认为","proverb","该","字符","都","字符串","：","不仅仅","符","而且","显然","i","那么","普通","str3","and","看起来","表示","还","想想","易用","人性","出错","letters","of","好看","体现","的","可以","原因","易用性","a","that","以其","str5",":","方便","区别","而","写","转义","从而","它","容易"," ","支持","没有","two","big","are","任何","？","famous","里面","你","用来","str4","太多","str1","能","如果","人性化","和","makes","said","中","呢","单引号"],"title":"单引号与双引号","title_tokens":["引号","双引号","与","单引号"]},{"location":"Python基础/2.1.python基本语法.html#lambdas","text":"正常创建函数（使用 def ）会自动将其赋值给变量，这与创建其他对象（例如字符串和整数）不同，后者可以动态创建，而无需将它们分配给变量。但只要使用lambda语法创建函数，函数也可以这样做，以这种方式创建的函数称为匿名（anonymous）函数。将简单函数作为参数传递给另一个函数时，最常使用此方法。语法如下： # my_func是正常创建的函数（named function） def my_func ( f , arg ): return f ( arg ) my_func ( lambda x : 2 * x * x , 5 ) 50 在上面的代码中，我们动态创建了一个匿名函数，并使用参数调用它。Lambda函数没有命名函数（named function）那么强大。Lambda函数只能包含一个表达式，通常相当于一行代码。实际上，Lambda函数可以分配给变量，并像普通函数一样使用。但是，很少有充分的理由这样做。通常使用 def 来定义函数通常更好。 double = lambda x : x * 2 print ( double ( 7 )) 14","text_tokens":["不同","强大","是","方法","参数传递","my","表达","=","作为","这",")","分配","达式","动态","f","很少","2","了","来","在","print","相当于","。","x","自动","但","与","，","给","定义","有","一个","并","这样","当于","理由","包含","表达式","做","anonymous","传递","会","arg","上面","相当","无需","简单","def","实际上","使用","后者","只能","其他","此","其","匿名","更好","function","字符","字符串","：","double","像","lambda","对象","方式","那么","普通","但是","#","也","如下","它们","动态创建","赋值","另","_","7","的","将","可以","时","函数","语法","参数","创建","最",":","而","常","这种","它","变量","named"," ","没有","命名","一样","func","）","*","50","例如","正常","以","数传","只要","调用","代码","称为","我们","5","充分","return",",","和","通常","(","整数","实际","一行","14","中","（"],"title":"Lambdas","title_tokens":["lambdas"]},{"location":"Python基础/2.1.python基本语法.html#_9","text":"","text_tokens":[],"title":"运算符","title_tokens":["算符","运算","运算符"]},{"location":"Python基础/2.1.python基本语法.html#_10","text":"运算符 描述 + 加 - 减 * 乘 / 除 % 取模 ** 幂 // 取整除","text_tokens":["运算","-","+","/","运算符","乘","%","取模","算符","加","取","整除","*","描述","幂","减"," ","除"],"title":"算术运算符","title_tokens":["算符","运算","运算符","算术"]},{"location":"Python基础/2.1.python基本语法.html#_11","text":"运算符 描述 == 等于 != 不等于 > 大于 < 小于 >= 大于等于 <= 小于等于","text_tokens":["运算","=","运算符","大于","算符","小于","不","描述","<"," ","等于",">","!"],"title":"比较运算符","title_tokens":["算符","运算","运算符","比较"]},{"location":"Python基础/2.1.python基本语法.html#_12","text":"运算符 描述 = 简单的赋值运算符 += 加法赋值运算符 -= 减法赋值运算符 *= 乘法赋值运算符 /= 除法赋值运算符 %= 取模赋值运算符 **= 幂赋值运算符 //= 取整除赋值运算符","text_tokens":["*","乘法","=","+","赋值","简单","加法","的","/","-","整除","减法","%","取模","算符","除法","描述","幂","运算","取","运算符"," "],"title":"赋值运算符","title_tokens":["算符","运算","运算符","赋值"]},{"location":"Python基础/2.1.python基本语法.html#_13","text":"运算符 描述 & 按位与运算符：参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为0 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 ~ 按位取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1。 ~x 类似于 -x-1 << 左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数指定移动的位数，高位丢弃，低位补0 >> 右移动运算符：把 > 左边的运算数的各二进位全部右移若干位， >> 右边的数指定移动的位数 111 & 100 100 111 | 100 111 111 ^ 100 11","text_tokens":["对应","参与","|","相异","每个","若干","数据","指定","二进制","&","当","算符","右边","。","1","x","进位","与","，","异或","就","左","有","一个","相应","否则","变为","由","为","右移","或","100","数","左移","进制","即","高位","于","-","把","11","0",">","全部","丢弃","都","：","二进位","对","补","结果","~","^","位","则","二进制位","的","时","左边","低位","按位","描述","类似","两","运算符"," ","若干位","位数","该位","111","只要","两个","二个","各","值","如果","取反","右","运算","移动","<"],"title":"位运算符","title_tokens":["算符","运算","运算符","位"]},{"location":"Python基础/2.1.python基本语法.html#_14","text":"运算符 逻辑表达式 描述 and x and y x、y同时为真，则结果为真，否则为假 or x or y x、y两者有一个为真，则结果为真，否则为假 not not x x为真，结果为假；x为假，结果为真","text_tokens":["and","否则","同时","为","表达式","结果","y","表达","达式","则","逻辑","；","算符","描述","x","两者","、","or","运算","，","运算符","假","有"," ","一个","真","not"],"title":"逻辑运算符","title_tokens":["算符","运算","运算符","逻辑"]},{"location":"Python基础/2.1.python基本语法.html#_15","text":"运算符 描述 in 如果在指定的序列中找到值返回 True，否则返回 False not in 如果在指定的序列中没有找到值返回 True，否则返回 False","text_tokens":["否则","找到","true","的","false","指定","序列","值","在","算符","如果","描述","in","运算","返回","，","运算符"," ","中","没有","not"],"title":"成员运算符","title_tokens":["算符","运算","成员","运算符"]},{"location":"Python基础/2.1.python基本语法.html#_16","text":"运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b) 。如果引用的不是同一个对象则返回结果 True，否则返回 False","text_tokens":["标识","否则","不同","is","是","同一","!","结果","y","=","引用",")","则","id","true","同一个","两个","的","b","false","判断","a","标识符","算符","如果","。","实例","描述","类似","不是","x","是不是","运算","返回","，","运算符",",","自","("," ","对象","一个","not"],"title":"身份运算符","title_tokens":["身份","运算","算符","运算符"]},{"location":"Python基础/2.1.python基本语法.html#_17","text":"运算符 描述 (expressions...), [expressions...], {key: value...}, {expressions...} 表示绑定或元组、表示列表、表示字典、表示集合 x[index], x[index:index], x(arguments...), xattribute 下标、切片、调用、属性引用 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +\\@ 和 -\\@) * / % // 乘，除，取模和取整除 + - 加法减法 >> << 右移，左移运算符 & 位 ‘AND’ ^ 按位异或运算符 <= < > >= 比较运算符 == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 and or not 逻辑运算符 if - else 条件表达式 lambda Lambda 表达式 具有相同优先级的运算符将从左至右的方式依次进行。用小括号 () 可以改变运算顺序。 包括函数、类的定义。 ↩ 目前Python的命名空间使用字典实现，但日后可能会改变。 ↩","text_tokens":["‘","is","包括","方法","成员","具有","从","!","=","表达",")","达式","等于","一元","乘","&","算符","expressions","。","x","字典","]","集合","但","列表","切片","，","异或","左","定义","用","可能","除","日后","右移","arguments","或","index","比较","目前","表达式","...","左移","\\","会","减号","元组","使用","整除","-","python","value",">","空间","、","最高","lambda","方式","not","↩","类","and","xattribute","优先","表示","加号","最后","~","+","^","{","位","赋值","改变","的","将","可以","/","函数","减法","%","实现","取模","@","按位","描述","if",":","顺序","取","运算符","’"," ","依次","名为","命名","条件","key","*","括号","至","小括号","下标","}","引用","翻转","[","逻辑","调用","加法","两个","属性","else","优先级","进行","相同","指数","in","or","右","运算","绑定",",","和","(","身份","<"],"title":"运算符优先级","title_tokens":["运算","运算符","优先","算符","优先级"]},{"location":"Python基础/2.2.语句.html","text":"语句 if 语句 if 语句的语法如下： age = 20 if age >= 18 : print ( 'your age is' , age ) print ( 'adult' ) else : print ( 'your age is' , age ) print ( 'teenager' ) your age is 20 adult 注意不要少写了冒号 : 。 类似R语言的else if，在python中则是使用 elif ： kid elif 是 else if 的缩写，使用缩写是为了避免过度缩进。完全可以有多个 elif ，所以 if 语句的完整形式就是： if < 条件判断1 > : < 执行1 > elif < 条件判断2 > : < 执行2 > elif < 条件判断3 > : < 执行3 > else : < 执行4 > if 判断条件还可以简写，比如写： if True : print ( 'True' ) True 在python中， False 、 0 、 '' 、 [] 、 () 、 {} 都视作False，否则为True。 注意，负值也是被判断为真。 断言 断言语句检查条件是否满足，如果不满足，就引发 AssertionError 异常（并可提供错误消息）。语法如下： assert condition 等价于 if not condition : crash program 例子： assert age >= 12 , 'Children under the age of 12 are not allowed' ---------------------------------------------------------------------------AssertionError Traceback (most recent call last)<ipython-input-1-7c799b440abf> in <module> ----> 1 assert age >= 12, 'Children under the age of 12 are not allowed' AssertionError: Children under the age of 12 are not allowed 循环 Python的循环有两种: for 循环 while 循环 for语句 for 循环， 依次把可迭代对象中的每个元素迭代出来 ，可包含 else 子句。看例子： # 执行这段代码，会依次打印`names`的每一个元素 names = [ 'Michael' , 'Bob' , 'Tracy' ] for name in names : print ( name ) Michael Bob Tracy 所以 for x in ... 循环就是把每个元素代入变量 x ，然后执行缩进块的语句。 while语句 while 语句用于在指定条件为真时反复地执行（循环），条件不满足时退出循环， 比如我们要计算100以内所有奇数之和，可以用while循环实现： sum = 0 n = 99 # 在循环内部变量`n`不断自减，直到变为`-1`时，不再满足while条件，循环退出 while n > 0 : sum = sum + n n = n - 2 print ( sum ) 2500 break 在循环中， break 语句可以提前退出循环。例如 注意 break语句只能用于循环中。 i = 1 while i < 100 : i = i + 1 print ( \"结束循环\" ) break print ( i ) 结束循环 break 的作用是退出当前循环， print(i) 语句不会执行。 continue continue 语句：跳过当前的这次循环，直接开始下一次循环。 注意 continue 语句只能用于循环中。 n = 0 while n < 10 : n = n + 1 print ( n , end = \" \" ) 1 2 3 4 5 6 7 8 9 10 上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用 continue 语句跳过某些循环： n = 0 while n < 10 : n = n + 1 if n % 2 == 0 : # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print ( n , end = \" \" ) 1 3 5 7 9 执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。 循环中的 else 子句 else 子句不仅可以用在 if 语句，还可以用在循环语句。循环语句中的 else 子句在循环迭代完成时、执行条件为 false （对于 while ）时执行，但循环被 break 中止的情况下不会执行。 # for循环 i = 1 for i in range ( 1 , 10 , 2 ): print ( i , end = \" \" ) else : print ( \"i=\" , i ) # while循环 i = 1 while i < 5 : print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) # break子句直接结束循环，循环语句一次也没有执行，此时else子句不会执行。 # 注意，这与while子句中条件为false，循环语句没有执行不同 i = 1 for i in range ( 1 , 10 , 2 ): break print ( i , end = \" \" ) else : print ( \"i=\" , i ) i = 1 while i < 5 : break print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) 1 3 5 7 9 i= 9 1 2 3 4 i= 5 小结 break 、 continue 语句通常都配合 if 语句使用。 要特别注意，不要滥用 break 和 continue 语句。 break 和 continue 会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到 break 和 continue 语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉 break 和 continue 语句。 pass 语句 pass 语句什么也不做。它用于那些语法上必须要有什么语句，但程序什么也不做的场合，例如: # 死循环 while True : pass # Busy-wait for keyboard interrupt (Ctrl+C) # 创建最小结构的类: class MyEmptyClass : pass return 语句 return 语句结束函数的执行并返回一个值。如果没有指定值，将返回 None 。示例： 注意 return 语句只能用于函数中。 def func1 (): return 4 , 2 def func2 (): return print ( func1 ()) print ( func2 ()) (4, 2) None","text_tokens":["需要","场合","不同","比如","引发","is","不","是","然后","奇数","就是","the","每个","=","9","last",")","为了","while","这","之","小结","对于","大多数","8","避免","`","module","跳过","不仅","例子","r","断言","name","2","指定","了","在","assert","print","recent","。","一次","1","x","]","不断","但","与","看到","，","～","就","滥用","出来","自减","continue","有","真时","用","一个","代入","而是","过多","视作","并","'","否则","语言","继续","变为","是否","为","100","包含","过度","做","...","18","形式","crash","想","示例","循环","内部","\"","会","上面","负值","修改","true","def","12","偶数","分叉","使用","错误","直到","这次","20","少写","python","于","-","把","只能","用于","assertionerror","等价","或者","6","上","完全",">","0","程序","块","call","michael","、","反复","sum","bob","pass","值","出","ctrl","用到","都","：","子句","break","func2","i","只","对象","真","names","not","但是","range","allowed","#","地","类","也","3","看","结束","class","如下","age","所以","还","特别","99","多个","最小","以内","某些","+","两种","出错","多数","{","通过","n","被","teenager","后续","缩进","of","7","for","情况","什么","的","可以","时","判断","将","函数","most","语法","实现","%","注意","满足","不会","并不需要","创建","简写","类似","if","可","busy","your",":","4","异常","提供","返回","写","一轮","每","直接","它","变量","容易","去掉","完整","依次"," ","中止","没有","造成","迭代","检查","元素","那些","condition","中则","计算","大多","条件","）","func1","完成","program","are","结构","children","死循环","tracy","例如","不要","配合","}","c","不再","none","开始","执行","traceback","wait","[","要","input","逻辑","kid","两个","7c799b440abf","false","代码","2500","提前","adult","语句","必须","else","elif","我们","如果","退出","改写","interrupt","myemptyclass","作用","代码执行","end","消息","ipython","in","5","under","缩写","return","段",",","和","下","此时","冒号","(","所有","通常","<","打印","中","当前","10","（","keyboard"],"title":"2.2.语句","title_tokens":[".","语句","2.2"]},{"location":"Python基础/2.2.语句.html#_1","text":"","text_tokens":[],"title":"语句","title_tokens":["语句"]},{"location":"Python基础/2.2.语句.html#if","text":"if 语句的语法如下： age = 20 if age >= 18 : print ( 'your age is' , age ) print ( 'adult' ) else : print ( 'your age is' , age ) print ( 'teenager' ) your age is 20 adult 注意不要少写了冒号 : 。 类似R语言的else if，在python中则是使用 elif ： kid elif 是 else if 的缩写，使用缩写是为了避免过度缩进。完全可以有多个 elif ，所以 if 语句的完整形式就是： if < 条件判断1 > : < 执行1 > elif < 条件判断2 > : < 执行2 > elif < 条件判断3 > : < 执行3 > else : < 执行4 > if 判断条件还可以简写，比如写： if True : print ( 'True' ) True 在python中， False 、 0 、 '' 、 [] 、 () 、 {} 都视作False，否则为True。 注意，负值也是被判断为真。","text_tokens":["比如","is","是","就是","=",")","为了","避免","r","2","了","在","print","。","1","]","，","有","视作","'","否则","语言","为","过度","18","形式","负值","true","使用","20","少写","python","完全",">","0","、","都","：","真","也","3","如下","age","所以","还","多个","{","被","teenager","缩进","的","可以","判断","语法","注意","简写","类似","if","your",":","4","写","完整"," ","中则","条件","不要","}","执行","[","kid","false","adult","语句","else","elif","缩写",",","冒号","(","<","中"],"title":"if 语句","title_tokens":["if","语句"," "]},{"location":"Python基础/2.2.语句.html#_2","text":"断言语句检查条件是否满足，如果不满足，就引发 AssertionError 异常（并可提供错误消息）。语法如下： assert condition 等价于 if not condition : crash program 例子： assert age >= 12 , 'Children under the age of 12 are not allowed' ---------------------------------------------------------------------------AssertionError Traceback (most recent call last)<ipython-input-1-7c799b440abf> in <module> ----> 1 assert age >= 12, 'Children under the age of 12 are not allowed' AssertionError: Children under the age of 12 are not allowed","text_tokens":["检查","'","是否","引发","condition","条件","）","不","如下","age","program","are","children","crash","the","=","last",")","traceback","of","module","12","input","例子","断言","7c799b440abf","错误","于","-","most","语句","语法","assertionerror","assert","如果","等价","满足","recent","。","可","if","1","消息",">",":","异常","ipython","call","提供","in","under","，","就",",","：","(","<"," ","not","（","allowed","并"],"title":"断言","title_tokens":["断言"]},{"location":"Python基础/2.2.语句.html#_3","text":"Python的循环有两种: for 循环 while 循环","text_tokens":["循环","python","两种","while","有","for"," ",":","的"],"title":"循环","title_tokens":["循环"]},{"location":"Python基础/2.2.语句.html#for","text":"for 循环， 依次把可迭代对象中的每个元素迭代出来 ，可包含 else 子句。看例子： # 执行这段代码，会依次打印`names`的每一个元素 names = [ 'Michael' , 'Bob' , 'Tracy' ] for name in names : print ( name ) Michael Bob Tracy 所以 for x in ... 循环就是把每个元素代入变量 x ，然后执行缩进块的语句。","text_tokens":["'","看","元素","包含","然后","所以","#","就是","...","tracy","循环","每个","=",")","这","会","执行","`","缩进","for","[","例子","names","的","代码","name","把","语句","else","print","。","可","x",":","]","michael","in","块","bob","，","出来","段","每",",","：","子句","(","变量","中","依次"," ","对象","打印","一个","代入","迭代"],"title":"for语句","title_tokens":["for","语句"]},{"location":"Python基础/2.2.语句.html#while","text":"while 语句用于在指定条件为真时反复地执行（循环），条件不满足时退出循环， 比如我们要计算100以内所有奇数之和，可以用while循环实现： sum = 0 n = 99 # 在循环内部变量`n`不断自减，直到变为`-1`时，不再满足while条件，循环退出 while n > 0 : sum = sum + n n = n - 2 print ( sum ) 2500","text_tokens":["变为","比如","为","计算","条件","）","不","100","奇数","99","以内","循环","=","+",")","while","内部","不再","之","n","执行","`","要","时","可以","直到","2500","指定","-","2","语句","实现","在","用于","我们","退出","print","满足","1","0",">",":","反复","不断","sum","，","和","：","所有","变量","自减","(","真时","用"," ","（","地","#"],"title":"while语句","title_tokens":["while","语句"]},{"location":"Python基础/2.2.语句.html#break","text":"在循环中， break 语句可以提前退出循环。例如 注意 break语句只能用于循环中。 i = 1 while i < 100 : i = i + 1 print ( \"结束循环\" ) break print ( i ) 结束循环 break 的作用是退出当前循环， print(i) 语句不会执行。","text_tokens":["结束","100","是","例如","循环","=","+",")","while","\"","执行","的","可以","提前","只能","语句","在","用于","退出","注意","print","不会","。","作用","1",":","，","(","break","<","i"," ","中","当前"],"title":"break","title_tokens":["break"]},{"location":"Python基础/2.2.语句.html#continue","text":"continue 语句：跳过当前的这次循环，直接开始下一次循环。 注意 continue 语句只能用于循环中。 n = 0 while n < 10 : n = n + 1 print ( n , end = \" \" ) 1 2 3 4 5 6 7 8 9 10 上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用 continue 语句跳过某些循环： n = 0 while n < 10 : n = n + 1 if n % 2 == 0 : # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print ( n , end = \" \" ) 1 3 5 7 9 执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。","text_tokens":["3","继续","是","奇数","某些","想","循环","=","+","9",")","while","\"","上面","n","会","开始","后续","8","执行","7","偶数","跳过","但是","的","可以","代码","一次","这次","2","只能","语句","%","用于","我们","注意","print","6","如果","不会","。","end","1","if","不再","0",":","4","5","程序","看到","，","～","出","一轮",",","直接","：","下","continue","(","用","<"," ","中","当前","10","打印","只","而是","#"],"title":"continue","title_tokens":["continue"]},{"location":"Python基础/2.2.语句.html#else","text":"else 子句不仅可以用在 if 语句，还可以用在循环语句。循环语句中的 else 子句在循环迭代完成时、执行条件为 false （对于 while ）时执行，但循环被 break 中止的情况下不会执行。 # for循环 i = 1 for i in range ( 1 , 10 , 2 ): print ( i , end = \" \" ) else : print ( \"i=\" , i ) # while循环 i = 1 while i < 5 : print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) # break子句直接结束循环，循环语句一次也没有执行，此时else子句不会执行。 # 注意，这与while子句中条件为false，循环语句没有执行不同 i = 1 for i in range ( 1 , 10 , 2 ): break print ( i , end = \" \" ) else : print ( \"i=\" , i ) i = 1 while i < 5 : break print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) 1 3 5 7 9 i= 9 1 2 3 4 i= 5","text_tokens":["也","3","不同","为","结束","条件","）","完成","还","没有","#","循环","=","+","9",")","while","\"","这","对于","被","执行","7","情况","for","不仅","的","时","可以","false","一次","2","语句","else","在","print","注意","不会","。","end","if","1",":","5","in","但","与","、","中止","4","，",",","下","直接","此时","子句","(","break","用","<","i"," ","中","range","10","（","迭代"],"title":"循环中的else子句","title_tokens":["循环","else","子句","中","的"]},{"location":"Python基础/2.2.语句.html#_4","text":"break 、 continue 语句通常都配合 if 语句使用。 要特别注意，不要滥用 break 和 continue 语句。 break 和 continue 会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到 break 和 continue 语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉 break 和 continue 语句。","text_tokens":["需要","大多","条件","特别","不要","循环","配合","大多数","出错","多数","会","上面","通过","执行","修改","要","逻辑","分叉","两个","的","使用","代码","例子","可以","语句","或者","注意","改写","并不需要","。","代码执行","if","、","，","滥用","过多","用到","都","和","通常","continue","容易","去掉","break"," ","造成"],"title":"小结","title_tokens":["小结"]},{"location":"Python基础/2.2.语句.html#pass","text":"pass 语句什么也不做。它用于那些语法上必须要有什么语句，但程序什么也不做的场合，例如: # 死循环 while True : pass # Busy-wait for keyboard interrupt (Ctrl+C) # 创建最小结构的类: class MyEmptyClass : pass","text_tokens":["也","场合","那些","class","不","结构","做","死循环","最小","例如","循环","+","c",")","while","true","wait","要","for","什么","的","-","语句","语法","用于","必须","myemptyclass","interrupt","创建","。","上","busy","pass","程序",":","但","，","ctrl","它","(","有"," ","keyboard","#","类"],"title":"pass 语句","title_tokens":["pass","语句"," "]},{"location":"Python基础/2.2.语句.html#return","text":"return 语句结束函数的执行并返回一个值。如果没有指定值，将返回 None 。示例： 注意 return 语句只能用于函数中。 def func1 (): return 4 , 2 def func2 (): return print ( func1 ()) print ( func2 ()) (4, 2) None","text_tokens":["结束","func1","示例",")","none","执行","def","的","将","指定","函数","2","只能","语句","值","用于","如果","注意","print","。",":","4","返回","，","return",",","：","(","中","func2"," ","一个","没有","并"],"title":"return 语句","title_tokens":[" ","语句","return"]},{"location":"Python基础/2.3.List.html","text":"列表的方 法 描 述 aList.append(obj) 等同于aList[len(aList):len(aList)] = [obj] aList.clear() 删除aList的所有元素 aList.count(obj) 返回aList中与obj相等的元素个数 aList.copy() 返回aList的副本。请注意，这是浅复制，即不会复制元素 aList.extend(sequence) 等同于aList[len(aList):len(aList)] = sequence aList.index(obj) 返回aList中第一个与obj相等的元素的索引；如果没有这样的元素，就引发 ValueError异常 aList.insert(index, obj) 如果index >= 0，就等同于aList[index:index] = [obj]；如果index < 0，就 将指定的对象加入到列表开头 aList.pop([index]) 删除并返回指定索引（默认为-1 )处的元素 aList.remove(obj) 等同于del aList[aList.index(obj)] aList.reverse。 就地按相反的顺序排列列表的元素 aList.sort([cmp][,key][,reverse]) 就地对aList的元素进行排序（稳定排序）。可通过提供比较函数cmp、键函数 key (创建用户排序的键）和降序标志reverse (—个布尔值）进行定制 list的方法 创建一个list # 查看list的方法、属性 [ method for method in dir ( list ()) if not method . startswith ( \"_\" )] ['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] 修改list元素的值 修改现有list的值，通过索引、切片来完成。 list_1 = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] # 修改某个索引对应元素的值 list_1 [ 0 ] = 12 ; list_1 [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 修改某个连续区域的值 # 切片的长度 和 用于赋值的列表长度 可以不同，如下： list_1 [ 0 : 5 ] = [ 11 , 12 , 13 , 14 , 15 , 16 , 17 ]; list_1 [11, 12, 13, 14, 15, 16, 17, 5, 6, 7, 8, 9, 10] 添加一个新元素到末尾 append 方法每次只能添加一个新元素 list_1 = list ( range ( 4 )); print ( list_1 ) list_1 . append ( 12 ); print ( list_1 ) [0, 1, 2, 3] [0, 1, 2, 3, 12] 添加任意个新元素到末尾 extend 方法允许我们通过另一个list来扩充当前的list。实际上，这看起来像是用 + 拼接list，但 extend 方法会直接修改原列表，不返回副本。 list_1 = list ( range ( 4 )) list_2 = [ '0' , '00' , '000' ] list_1 + list_2 # 此时list_1没有被修改 print ( \"使用+运算符：\" , list_1 ) list_1 . extend ( list_2 ) # 此时list_1被修改 print ( \"使用extend方法：\" , list_1 ) 使用+运算符： [0, 1, 2, 3] 使用extend方法： [0, 1, 2, 3, '0', '00', '000'] 可以看出，使用 + 拼接list会创建一个新对象，显然拼接的效率回比 extend 方法的效率低。 还可以借助切片来扩充list，像这样： list_1 = list ( range ( 4 )) list_2 = [ '0' , '00' , '000' ] # 这样做可读性不高 list_1 [ len ( list_1 ):] = list_2 list_1 [0, 1, 2, 3, '0', '00', '000'] 在任意位置插入新元素 insert 方法将一个对象插入指定位置 list_1 = list ( range ( 4 )); print ( \"原列表：\" , list_1 ) list_1 . insert ( 0 , \"新元素\" ); print ( \"新列表：\" , list_1 ) 原列表： [0, 1, 2, 3] 新列表： ['新元素', 0, 1, 2, 3] 当然，也可以借助切片在任意位置插入元素。注意的是，对一个list使用切片，必定会得到一个list，这就需要用一个list对切片赋值。 # 这样虽然巧妙，但是可读性比不上insert。 list_1 = list ( range ( 4 )); print ( \"原列表：\" , list_1 ) list_1 [ 0 : 0 ] = [ \"新元素\" ]; print ( \"新列表：\" , list_1 ) 原列表： [0, 1, 2, 3] 新列表： ['新元素', 0, 1, 2, 3] 删除\\取出最后一个（任意位置的）元素 list_2 = [ '0' , '00' , '000' ] # 注意，pop是list中唯一一个修改原列表，并且有返回值的方法 list_2 . pop () '000' list_2 = [ '0' , '00' , '000' ] # pop默认删除最后一个元素，但是也可以输入索引值，指定删除元素的位置 list_2 . pop ( 0 ) list_2 ['00', '000'] 删除第一次出现的元素 list_1 = [ 1 , 2 , 3 , 1 ] list_1 . remove ( 1 ) list_1 [2, 3, 1] 反序排序 list_1 = [ 1 , 2 , 3 ] list_1 . reverse () list_1 [3, 2, 1] 排序 方法 sort 接受两个可选参数： key 和 reverse 。将 key 设置为一个用于排序的**函数。然而，不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。对于另一个关键字参数 reverse ，只需将其指定为 True 或 False ，以指出是否要按相反的顺序对列表进行排序。 list_3 = [ 'aardvark' , 'abalone' , 'acme' , 'add' , 'aerate' ] list_3 . sort ( key = len ) list_3 ['add', 'acme', 'aerate', 'abalone', 'aardvark'] # 按照长度降序排序 list_3 . sort ( key = len , reverse = True ) list_3 ['aardvark', 'abalone', 'aerate', 'acme', 'add'] 统计元素出现的次数 list_1 = [ 1 , 2 , 3 , 1 ] list_1 . count ( 1 ) 2 得到某个值第一次出现时对应的索引值 list_1 = [ 1 , 2 , 3 , 1 ] list_1 . index ( 1 ) 0 深拷贝列表 list_1 = [ 1 , 2 , 3 ] list_4 = list_1 list_1 [ 0 ] = \"修改了\" print ( \"list_1：\" , list_1 ) print ( \"list_4：\" , list_4 ) list_1： ['修改了', 2, 3] list_4： ['修改了', 2, 3] # 深拷贝 list_1 = [ 1 , 2 , 3 ] list_5 = list_1 . copy () list_1 [ 0 ] = \"修改了\" print ( \"list_1：\" , list_1 ) print ( \"list_5：\" , list_5 ) list_1： ['修改了', 2, 3] list_5： [1, 2, 3] 清空列表 list_1 . clear () list_1 []","text_tokens":["相等","需要","不同","引发","对应","不高","sequence","不","是","出现","方法","原","起来","add","小","接受","请","每次","=","每个","9","000",")","这","需","remove","startswith","对于","abalone","8",".","00","选","指定","2","来","添加","个数","了","在","排序","算符","print","关键","。","复制","1","浅","允许","深","]","但","与","这个","列表","，","切片","就","述","dir","reverse","顺序排列","有","某个","用","等同","插入","当然","一个","而是","并","'","这样","是否","为","index","或","比较","末尾","再","做","copy","清空","—","副本","append","像是","看起","\"","会","\\","输入","这些","del","修改","看出","true","12","实际上","即","使用","一次","-","count","只能","根据","用于","aerate","6","11","比","其","回比","开头",">","0","布尔值","、","低","等同于","同于","16","连续","虽然","现有","用户","对","：","得到","显然","像","默认","对象","range","只","描","not","但是","地","#","也","位置","按照","3","看起来","可读","如下","还","method","可读性","第一次","比不上","cmp","最后","第一个","区域","+","list","通过","赋值","13","被","_","7","另","for","关键字","巧妙","必定会","的","将","可以","借助","判断","时","函数","acme","拼接","注意","不会","参数","创建","处","可","按","if","新元",":","异常","4","提供","索引","顺序","标志","返回","相反","运算符","直接","它","17","alist"," ","extend","没有","任意","aardvark","删除","键","15","稳定","定会","方","元素","valueerror","pop","唯一","key","）","*","完成","长度","返回值","insert","以","查看","加入","第一","并且","指出","次数","[","要","排列","；","设置","新元素",";","两个","然而","false","属性","效率","值","定制","我们","如果","len","法","clear","进行","扩充","到","sort","个","in","5","新","反序","运算","obj","必定","降序","统计","拷贝","布尔",",","和","此时","所有","(","取出","实际","14","<","10","中","当前","（"],"title":"2.3.List","title_tokens":["list",".","2.3"]},{"location":"Python基础/2.3.List.html#list","text":"创建一个list # 查看list的方法、属性 [ method for method in dir ( list ()) if not method . startswith ( \"_\" )] ['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']","text_tokens":["'","pop","index","方法","method","copy","insert","查看","append",")","list","\"","remove","startswith","_",".","[","for","的","属性","count","创建","if","clear","sort","in","]","、","dir",",","reverse","("," ","一个","extend","not","#"],"title":"list的方法","title_tokens":["list","方法","的"]},{"location":"Python基础/2.3.List.html#list_1","text":"修改现有list的值，通过索引、切片来完成。 list_1 = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] # 修改某个索引对应元素的值 list_1 [ 0 ] = 12 ; list_1 [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 修改某个连续区域的值 # 切片的长度 和 用于赋值的列表长度 可以不同，如下： list_1 [ 0 : 5 ] = [ 11 , 12 , 13 , 14 , 15 , 16 , 17 ]; list_1 [11, 12, 13, 14, 15, 16, 17, 5, 6, 7, 8, 9, 10]","text_tokens":["3","元素","对应","不同","如下","完成","长度","15","=","区域","9","list","通过","赋值","8","13","修改","_","7","[","12","的",";","可以","2","来","值","用于","6","11","。","1","0","4","5","]",":","、","索引","切片","，","列表","16","连续","现有",",","和","：","某个","17","14"," ","10","#"],"title":"修改list元素的值","title_tokens":["元素","值","list","修改","的"]},{"location":"Python基础/2.3.List.html#_1","text":"append 方法每次只能添加一个新元素 list_1 = list ( range ( 4 )); print ( list_1 ) list_1 . append ( 12 ); print ( list_1 ) [0, 1, 2, 3] [0, 1, 2, 3, 12]","text_tokens":["3","元素","方法","append","每次","=",")","list","_",".","[","12","新元素",";","2","添加","只能","print","1","新元","4","0","]",",","("," ","一个","range"],"title":"添加一个新元素到末尾","title_tokens":["添加","元素","末尾","一个","新元","到","新元素"]},{"location":"Python基础/2.3.List.html#_2","text":"extend 方法允许我们通过另一个list来扩充当前的list。实际上，这看起来像是用 + 拼接list，但 extend 方法会直接修改原列表，不返回副本。 list_1 = list ( range ( 4 )) list_2 = [ '0' , '00' , '000' ] list_1 + list_2 # 此时list_1没有被修改 print ( \"使用+运算符：\" , list_1 ) list_1 . extend ( list_2 ) # 此时list_1被修改 print ( \"使用extend方法：\" , list_1 ) 使用+运算符： [0, 1, 2, 3] 使用extend方法： [0, 1, 2, 3, '0', '00', '000'] 可以看出，使用 + 拼接list会创建一个新对象，显然拼接的效率回比 extend 方法的效率低。 还可以借助切片来扩充list，像这样： list_1 = list ( range ( 4 )) list_2 = [ '0' , '00' , '000' ] # 这样做可读性不高 list_1 [ len ( list_1 ):] = list_2 list_1 [0, 1, 2, 3, '0', '00', '000']","text_tokens":["不高","不","方法","原","起来","=","000",")","这",".","00","2","来","算符","print","。","1","允许","]","但","列表","，","切片","用","一个","'","这样","做","副本","像是","看起","\"","会","修改","看出","实际上","使用","回比","0","低","：","显然","像","range","对象","#","3","看起来","可读","还","可读性","+","list","通过","被","另","_","的","可以","借助","拼接","创建","4",":","返回","运算符","直接"," ","extend","没有","[","效率","我们","len","扩充","新","运算",",","此时","(","实际","当前"],"title":"添加任意个新元素到末尾","title_tokens":["添加","元素","新元素","末尾","新元","任意","到","个"]},{"location":"Python基础/2.3.List.html#_3","text":"insert 方法将一个对象插入指定位置 list_1 = list ( range ( 4 )); print ( \"原列表：\" , list_1 ) list_1 . insert ( 0 , \"新元素\" ); print ( \"新列表：\" , list_1 ) 原列表： [0, 1, 2, 3] 新列表： ['新元素', 0, 1, 2, 3] 当然，也可以借助切片在任意位置插入元素。注意的是，对一个list使用切片，必定会得到一个list，这就需要用一个list对切片赋值。 # 这样虽然巧妙，但是可读性比不上insert。 list_1 = list ( range ( 4 )); print ( \"原列表：\" , list_1 ) list_1 [ 0 : 0 ] = [ \"新元素\" ]; print ( \"新列表：\" , list_1 ) 原列表： [0, 1, 2, 3] 新列表： ['新元素', 0, 1, 2, 3]","text_tokens":["需要","'","位置","也","3","元素","任意","定会","这样","可读","是","方法","原","可读性","insert","比不上","=",")","这","list","\"","赋值","_",".","[","巧妙","必定会","新元素",";","将","可以","借助","的","指定","2","使用","在","print","注意","。","1","0","4","新元","新","]",":","列表","，","切片","必定","就","虽然",",","：","对","(","得到","插入","用","当然","一个","对象"," ","range","但是","#"],"title":"在任意位置插入新元素","title_tokens":["位置","任意","元素","在","插入","新元","新元素"]},{"location":"Python基础/2.3.List.html#_4","text":"list_2 = [ '0' , '00' , '000' ] # 注意，pop是list中唯一一个修改原列表，并且有返回值的方法 list_2 . pop () '000' list_2 = [ '0' , '00' , '000' ] # pop默认删除最后一个元素，但是也可以输入索引值，指定删除元素的位置 list_2 . pop ( 0 ) list_2 ['00', '000']","text_tokens":["'","也","位置","元素","pop","唯一","是","方法","原","返回值","最后","=","000",")","list","并且","输入","_","修改",".","[","的","00","可以","2","指定","值","注意","0","]","索引","列表","，","返回",",","(","有"," ","中","一个","默认","但是","删除","#"],"title":"删除\\取出最后一个（任意位置的）元素","title_tokens":["位置","元素","\\","）","取出","一个","任意","最后","（","的","删除"]},{"location":"Python基础/2.3.List.html#_5","text":"list_1 = [ 1 , 2 , 3 , 1 ] list_1 . remove ( 1 ) list_1 [2, 3, 1]","text_tokens":["2","=","3",")","list",",","remove","(","_",".","1","["," ","]"],"title":"删除第一次出现的元素","title_tokens":["第一","元素","出现","第一次","的","删除","一次"]},{"location":"Python基础/2.3.List.html#_6","text":"list_1 = [ 1 , 2 , 3 ] list_1 . reverse () list_1 [3, 2, 1]","text_tokens":["2","=","3",")","list",",","reverse","(","_",".","1","["," ","]"],"title":"反序排序","title_tokens":["排序","反序"]},{"location":"Python基础/2.3.List.html#_7","text":"方法 sort 接受两个可选参数： key 和 reverse 。将 key 设置为一个用于排序的**函数。然而，不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。对于另一个关键字参数 reverse ，只需将其指定为 True 或 False ，以指出是否要按相反的顺序对列表进行排序。 list_3 = [ 'aardvark' , 'abalone' , 'acme' , 'add' , 'aerate' ] list_3 . sort ( key = len ) list_3 ['add', 'acme', 'aerate', 'abalone', 'aardvark'] # 按照长度降序排序 list_3 . sort ( key = len , reverse = True ) list_3 ['aardvark', 'abalone', 'aerate', 'acme', 'add']","text_tokens":["方法","add","小","接受","每个","=","需",")","abalone","对于",".","选","指定","来","排序","关键","。","]","这个","列表","，","reverse","一个","而是","'","是否","为","或","再","这些","true","使用","根据","用于","aerate","比","其","：","对","只","#","按照","3","list","另","关键字","_","的","将","判断","函数","acme","参数","不会","创建","可","按","顺序","相反","直接","它"," ","aardvark","键","元素","key","*","长度","以","指出","要","[","设置","两个","然而","false","len","进行","sort","降序",",","和","("],"title":"排序","title_tokens":["排序"]},{"location":"Python基础/2.3.List.html#_8","text":"list_1 = [ 1 , 2 , 3 , 1 ] list_1 . count ( 1 ) 2","text_tokens":["2","=","3","count",")","list",",","(","_",".","1","["," ","]"],"title":"统计元素出现的次数","title_tokens":["统计","元素","出现","次数","的"]},{"location":"Python基础/2.3.List.html#_9","text":"list_1 = [ 1 , 2 , 3 , 1 ] list_1 . index ( 1 ) 0","text_tokens":["2","=","3",")","list",",","index","(","_",".","1","["," ","0","]"],"title":"得到某个值第一次出现时对应的索引值","title_tokens":["第一","值","对应","出现","得到","某个","第一次","的","时","索引","一次"]},{"location":"Python基础/2.3.List.html#_10","text":"list_1 = [ 1 , 2 , 3 ] list_4 = list_1 list_1 [ 0 ] = \"修改了\" print ( \"list_1：\" , list_1 ) print ( \"list_4：\" , list_4 ) list_1： ['修改了', 2, 3] list_4： ['修改了', 2, 3] # 深拷贝 list_1 = [ 1 , 2 , 3 ] list_5 = list_1 . copy () list_1 [ 0 ] = \"修改了\" print ( \"list_1：\" , list_1 ) print ( \"list_5：\" , list_5 ) list_1： ['修改了', 2, 3] list_5： [1, 2, 3]","text_tokens":["'","3","copy","=",")","list","\"","_","修改",".","[","2","了","print","1","0","4","深","]","5","拷贝",",","：","("," ","#"],"title":"深拷贝列表","title_tokens":["深","拷贝","列表"]},{"location":"Python基础/2.3.List.html#_11","text":"list_1 . clear () list_1 []","text_tokens":[")","list","(","_",".","1","clear"," ","[","]"],"title":"清空列表","title_tokens":["列表","清空"]},{"location":"Python基础/2.4.String.html","text":"多行字符串 str_1 = \"\"\" 这是一个多行字符串 这是第二行 \"\"\" print ( str_1 ) str_2 = \" \\n 这是一个多行字符串 \\n 这是第二行 \\n \" print ( str_2 ) str_1 == str_2 这是一个多行字符串 这是第二行 这是一个多行字符串 这是第二行 True 转义 如果要在字符串里面输入特殊字符，需要使用转义符\\，例如输入转义符本身： str_3 = \"12 \\\\ 14\" print ( str_3 ) 12\\14 前缀 在Python中，字符串可以添加前缀 r\\R 、 b 、 u\\U 、 f 。 r\\R ：表示非转义的原始字符串，常用于正则表达式。 b ：Python3里默认的str是(Python2里的)unicode，bytes是(Python2)的str， b前缀代表的就是bytes。Python2里, b前缀没什么具体意义，只是为了兼容Python3的这种写法 。 u\\U ：表示unicode字符串，代表是对字符串进行unicode编码。 一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。建议所有编码方式采用UTF-8。 f ：表示 f 格式字符串。 字符编码 Python有两种不同的字符串，一种存储文本，一种存储字节。对于文本，Python内部采用Unicode存储，而字节字符串显示原始字节序列或者ASCII。在Python3当中，文本字符串类型（使用Unicode数据存储）被命名为 str , 字节字符串类型被命名为 bytes 。但在python2中，文本字符串类型叫做 unicode ，字节字符串类型叫做 str 。也就是说： $$ \\begin{array}{} Python\\ 3\\ \\mathbf{str} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{unicode} \\\\ Python\\ 3\\ \\mathbf{bytes} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{str} \\end{array} $$ 所以，如果想将以unicode形式储存的字符串转换为二进制类型的字符串，需要将unicode字符串编码，反之，则需要解码。 编码：在python中，编码指的是将Unicode字符按照编码规则（如UTF-8）编成二进制序列。 在python3中实例化一个字符串 str_1 = \"中国\" # 编码 str_1 . encode () b'\\xe4\\xb8\\xad\\xe5\\x9b\\xbd' # 创建一个二进制字符串 str_2 = b ' \\xe4\\xb8\\xad\\xe5\\x9b\\xbd ' # 解码 str_2 . decode () '中国' bytes字符 文本字符类型在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把 str 变为以字节为单位的 bytes 。 Python3对 bytes 类型的数据用带 b 前缀的单引号或双引号表示。 bytes_8 = b \"ABC\" bytes_8 b'ABC' 要注意的是：bytes字面值中只允许ASCII字符（无论源代码声明的编码为何）。任何超出127的二进制值必须使用相应的转义序列形式加入bytes字面值。 例如，可以对str（unicode类型）对象使用 encode() 方法，编码为bytes的形式（16进制表示）。 '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 要注意的是， encode 的对象不能超出指定编码的范围，例如不能对中文字符使用 .encode(\"ascii\") ，因为中文不在ascii码的范围内。 '中文' . encode ( 'ascii' ) ---------------------------------------------------------------------------UnicodeEncodeError Traceback (most recent call last)<ipython-input-1-76f41cd8dafa> in <module> ----> 1 '中文'.encode('ascii') UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) 纯英文的str可以用ASCII编码为bytes，内容是一样的，但无法显示为ASCII字符的字节，用 \\x 显示（16进制转义表示）。 'ABC' . encode ( 'ascii' ) b'ABC' '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用 decode() 方法： b 'ABC' . decode ( 'ascii' ) 'ABC' b ' \\xe4\\xb8\\xad\\xe6\\x96\\x87 ' . decode ( 'utf-8' ) '中文' 如果bytes中包含无法解码的字节， decode() 方法会报错： b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' ) ---------------------------------------------------------------------------UnicodeDecodeError Traceback (most recent call last)<ipython-input-1-cd8de1b11dcd> in <module> ----> 1 b'\\xe4\\xb8\\xad\\xff'.decode('utf-8') UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte 但是，如果bytes中只有一小部分无效的字节，可以传入 errors = 'ignore' 忽略错误的字节： \"中\" . encode ( \"utf-8\" ) # 中 原来的编码 b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' , errors = 'ignore' ) '中' 在对str和bytes互相转换时，为了避免乱码问题，应该使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： # !/usr/bin/env python3 # -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释。第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，在源代码中写的中文输出可能会有乱码。 但是申明了UTF-8编码只是让Python解释器按UTF-8的编码规则读取源代码，并不意味着源代码一定是使用UT8-8编码保存的，必须并且要确保文本编辑器正在使用UTF-8编码。 格式化 C printf 样式的格式化 字符串具有一种特殊的内置操作：使用 % (取模)运算符，可以格式化字符串，此时 % 也被称为字符串的格式化运算符或插值运算符。对于format % values(其中format为一个字符串)，在format中的 % 转换标记符将被替换为零个或多个values条目。 其效果类似于在C语言中使用sprintf()。 'Hello, %s ' % 'world' # 省略括号 'Hello, world' 'Hi, %s , you have $ %d ' % ( 'Michael' , 10000.58 ) 'Hi, Michael, you have $10000' 转换标记符 包含两个或更多字符，由以下元素组成，且必须遵循此处规定的顺序： % 字符，用于标记转换符的起始。 映射键（可选），由加圆括号的字符序列组成(例如(somename))。 转换标志（可选） - 表示左对齐 + 表示转换后的内容前方加上正负号 空格 表示正数前方保留一个空格 0 表示如果转换位置位数不够时，用0填充 最小字段宽度（可选），转换后字段的最小宽度，如果不足自动用空格补齐；如果最小字段宽度值为 * ，则从元组中读取。 精度（可选），在 . 之后加精度值的形式给出。如果指定为为 * ，则从元组中读取。 长度修饰符（可选）。 转换类型。 Conversion Meaning d 格式化整数 i 格式化整数 o 8 进制 u 格式化无符号整型(已过时) x 16 进制， 小写字母 X 16 进制， 大写字母 e 浮点指数格式， 小写字母 E 浮点指数格式， 大写字母 f 浮点数 F 浮点数 g 浮点数， 如果指数小于 -4 或小于精度， 则使用小写指数格式， 否则使用小数格式 G 浮点数， 类似 g , 使用大写指数 c 单个字符， 格式化字符及其 ASCII 码 r 字符串， 使用 repr() 转换任何 Python 对象 s 字符串， 使用 str() 转换任何 Python 对象 % % 字符 # 映射键 ## 如果值是一个字典，那么必须使用映射键. 如： print ( ' %(num)d ' % { \"num\" : 10 }) 10 # 最小字段宽度 print ( ' %2s ' % 123456 ) print ( ' %8s ' % 123456 ) print ( ' %*s ' % ( 10 , 123456 )) 123456 123456 123456 # 精度 print ( ' %.2f ' % 100.256 ) print ( ' %.*f ' % ( 2 , 100.256 )) 100.26 100.26 # 转换标志 print ( ' %-8d ' % 123456 ) print ( ' %+8d ' % 123456 ) print ( ' %08d ' % 123456 ) 123456 +123456 00123456 format方法 < 模板字符串 >. format ( < 逗号分隔的参数 > ) <模板字符串> 由一系列的槽 {} 组成，用来控制修改字符串中嵌入值出现的位置，其基本思想是将format()方法的 <逗号分隔的参数> 中的参数按照序号关系替换到 <模板字符串> 的槽中。如果大括号中没有序号，则按照出现顺序替换。该方法会创建新字符串对象，不会修改原值。 {}中指定顺序，按指定的顺序替换 print ( \" {2} : {1} : {0} \" . format ( \"1\" , \"2\" , \"3\" )) 3 : 2 : 1 没有指定顺序，按出现的顺序依次替换 print ( \" {} : {} : {} \" . format ( \"1\" , \"2\" , \"3\" )) 1 : 2 : 3 format()方法中 <模板字符串> 的槽除了包括参数序号，还可以包括格式控制信息。此时，槽的内部样式如下： 替换字段 - replacement_field ::= \"{\" [ field_name ] [ \"!\" conversion ] [ \":\" format_spec ] \"}\" 字段名 - field_name ::= arg_name ( \".\" attribute_name | \"[\" element_index \"]\" ) * 参数名 - arg_name ::= [ identifier | integer ] 属性名 - attribute_name ::= identifier 元素索引 - element_index ::= integer | index_string 索引字符串 - index_string ::= < any source character except \"]\" > + 转换字段 - conversion ::= \"r\" | \"s\" 格式规范说明符 - format_spec ::= < described in the next section > 注意事项： 参数名 可以为 整数 或 关键字 。整数为位置参数， 关键字为命名关键字参数。 如果整数类似于 {0}{1}{2}, 则可以省略， 即： {}{}{} 等价于 {0}{1}{2}。 如果参数存在属性， 可以通过 arg_name.attribute_name 的形式获取属性值。 如果参数为可迭代对象， 可以通过 arg_name[integer|index_string] 的形式获取索引位置的元素。 转换字段 由 ! 开始， r 代表调用 repr(), s 代表调用 str(). 格式规范说明符 由 : 开始。 其中， <格式控制标记> 用来控制参数显示时的格式，可以使用的参数如下： format_spec ::= [ [fill ] align ] [ sign ][ # ][ 0 ][ width ][ grouping_option ][ .precision ][ type ] fill ::= < any character > align ::= \"<\" | \">\" | \"=\" | \"^\" sign ::= \"+\" | \"-\" | \" \" width ::= digit + grouping_option ::= \"_\" | \",\" precision ::= digit + type ::= \"b\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" | \"g\" | \"G\" | \"n\" | \"o\" | \"s\" | \"x\" | \"X\" | \"%\" 填充字符 ：如果指定了对齐选项，则可以使用填充字符。默认为空格. 对齐选项 ：默认右对齐，各种对齐选项的含义如下： 选项 意义 '<' 强制字段在可用空间内左对齐（这是大多数对象的默认值）。 '>' 强制字段在可用空间内右对齐（这是数字的默认值）。 '=' 强制将填充放置在符号（如果有）之后但在数字之前。这用于以“+000000120”形式打印字段。此对齐选项仅对数字类型有效。当'0'紧接在字段宽度之前时，它成为默认值。 '^' 强制字段在可用空间内居中。 sign ：仅对数字类型有效，可以是以下之一： 选项 意义 '+' 表示标志应该用于正数和负数。 '-' 表示标志应仅用于负数（这是默认行为）。 space 表示应在正数上使用前导空格，在负数上使用减号。 # ：仅适用于数字参数，同时仅适用于2、8、16进制的数字。会在输出的数字前添加 0b、0o、0x前缀。 宽度 ：指定最小字段宽度。 千位分隔符 ：只能使用 _ 或 , 作为千位分隔符。 精度 ： 类型 ：该选项决定了数据应该如何呈现。 可用的字符串表示类型： Type Meaning s 字符串格式， 字符串的默认类型， 可省略 None 同 s 可用的整数表示类型： Type Meaning b 输出为 2 进制整数 c 输出为为相应的 unicode 字符 d 输出为 10 进制整数 o 输出为 8 进制整数 x 输出为 16 进制整数， 使用小写字母 X 输出为 16 进制整数， 使用大写字母 n 类似 d , 会使用当前区域设置插入适当的数字分隔符 None 同 d 可用的浮点数和小数值表示类型： Type Meaning e 指数表示法， 使用字母 e 以科学记数法打印数字， 默认进度为 6 E 类似 e , 使用字母 E f 浮点数， 默认进度为 6 F 浮点数， 同 f g 一般形式， 受 precision 选项影响 G 类似 g , 当使用指数表示法时， 使用 E 而不是 e n 和 g 相同， 会使用当前区域设置插入适当的数字分隔符 % 百分数表示 None 同 g # 填充、对齐、符号、宽度、分组选项、精度 # 填充*号、居中、正号标记、2精度 \" {0:*^+20.2f} \" . format ( 120 ) '******+120.00*******' # 填充*号、居中、正号标记、_分隔符、2精度 \"{0:*^+20_.2f}\" . format ( 12000 ) '*****+12_000.00*****' # 填充*号、居中、正号标记、,分隔符、2精度 \" {0:*^+20,.2f} \" . format ( 12000 ) '*****+12,000.00*****' # 填充*号、左对齐、正号标记、2精度 \" {0:*<+20.2f} \" . format ( - 120 ) '-120.00*************' # 填充*号、左对齐、负号标记、2精度 \" {0:*>-20.2f} \" . format ( - 120 ) '*************-120.00' 方法 逻辑方法 方法 描述 .isalnum if all characters in the string are alpha-numeric and there is at least one character .isalpha if all characters in the string are alphabetic and there is at least one character .isnumeric if all characters in the string are numeric and there is at least one character .isascii ASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too . .isdecimal if all characters in the string are decimal and there is at least one character .isdigit if all characters in the string are digits and there is at least one character .isidentifier Use keyword.iskeyword() to test for reserved identifiers such as \"def\" and \"class\". .islower if all cased characters in the string are lowercase and there is at least one cased character .isupper if all cased characters in the string are uppercase and there is at least one cased character .isprintable if all of its characters are considered printable in repr() or if it is empty. .isspace if all characters in the string are whitespace and there is at least one character .istitle In a title-cased string, upper- and title-case characters may only follow uncased characters and lowercase characters only cased ones. 方法 描述 .startswith(prefix[, start[, end]]) 如果字符串以 prefix 开头 .endswith(suffix[, start[, end]]) 如果字符串以 suffix 结尾 大小字母转换 方法 描述 .lower 返回转换为小写的字符串的副本。 .upper 返回转换为大写的字符串的副本。 .capitalize 使第一个字符字母大写，其余字符字母小写，返回副本。 .swapcase 将大写字符转换为小写，将小写字符转换为大写，返回副本。 .title 每个单词都用大写字母开头，返回副本。 拆分字符串 方法 描述 .split(sep=None, maxsplit=-1) 从左到右以 sep 分割字符串 .rsplit(sep=None, maxsplit=-1) 从右到左以 sep 分割字符串 .splitlines(keepends=False) 以回车符或换行符分割字符串 .partition(sep, /) 从左到右以第一个出现的 sep 分割字符串，返回包括3个元素的元组 \"123#456#789\" . split ( sep = \"#\" , maxsplit = 1 ) ['123', '456#789'] \"123#456#789\" . rsplit ( sep = \"#\" , maxsplit = 1 ) ['123#456', '789'] \"123 \\r\\n 456 \\r\\n 789\" . splitlines ( keepends = False ) ['123', '456', '789'] \"123 \\r\\n 456 \\r\\n 789\" . splitlines ( keepends = True ) ['123\\r\\n', '456\\r\\n', '789'] \"123#456#789\" . partition ( \"#\" ) ('123', '#', '456#789') 合并字符串 \"_\" . join ([ \"a\" , \"b\" , \"c\" ]) 'a_b_c' 替换字符串 方法 描述 .replace(old, new, count=-1) 返回一个副本，其中所有出现的子字符串 old 都替换为 new 。 .strip(chars=None) 返回字符串的副本，其中前导和尾随空格删除。 .lstrip(chars=None) 返回删除前导空格的字符串副本。 .rstrip(chars=None) 返回删除尾随空格的字符串副本。 .expandtabs(tabsize=8) 返回一个副本，其中所有制表符都使用 tabsize 个空格代替。 \" \\n abc \\t\\n\\r \" . strip () 'abc' \" \\n abc \\t\\n\\r \" . lstrip () 'abc\\t\\n\\r ' \" \\n abc \\t\\n\\r \" . rstrip () ' \\nabc' \" \\n abc \\t\\n\\r \" . expandtabs ( tabsize = 8 ) ' \\nabc \\n\\r ' 格式化字符串 方法 描述 .format 格式化字符串。 .format_map 格式化字符串。 .ljust(width, fillchar=' ') 返回长度为 width 的左对齐字符串。使用 fillchar 填充。 .rjust(width, fillchar=' ') 返回长度为 width 的右对齐字符串。使用 fillchar 填充。 .center(width, fillchar=' ') 返回长度为 width 的居中字符串。使用 fillchar 填充。 .zfill(width) 返回长度为 width 的字符串，若长度不够，用零从左边填充。 .format_map 与 .format 在用法上大体一致，但有一个区别： # format_map 和 format 的区别 # 如果要使用关键字 format必须这样使用 \" {name} , {sex} \" . format ( name = \"Jack\" , sex = \"male\" ) # format_map 可以用dict \" {name} , {sex} \" . format_map ({ \"name\" : \"Jack\" , \"sex\" : \"male\" }) 'Jack, male' print ( \"abc\" . ljust ( 10 , \"#\" )) print ( \"abc\" . rjust ( 10 , \"#\" )) print ( \"abc\" . center ( 10 , \"#\" )) print ( \"123\" . zfill ( 10 )) # 非数字字符串也可以 print ( \"abc\" . zfill ( 10 )) abc####### #######abc ###abc#### 0000000123 0000000abc 统计子字符串出现次数 \"abcAbc\" . count ( \"c\" , 0 , 6 ) 2 查找子字符串第一次出现的位置 .index 与 .find 的功能是一样的，只不过 .index 方法若找不到子字符串会抛出ValueError，而 .find 会返回 -1 。 \"abcAbc\" . index ( \"bc\" , 0 , 6 ) \"abcAbc\" . find ( \"bc\" , 0 , 6 ) 1 \"abcAbc\" . index ( \"bc\" , 0 , 2 ) ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-f8cead4644a3> in <module> ----> 1 \"abcAbc\".index(\"bc\", 0, 2) ValueError: substring not found \"abcAbc\" . find ( \"bc\" , 0 , 2 ) -1","text_tokens":["系统","一系列","对应","isnumeric","紧接","出现","说明符","记数","000.00","100.26","expandtabs","rjust","space","问题","!","the","isdigit","可执行程序","需","写字","大多数","单词","sex","c语言","对于","超出","position","负号","正","encode","somename","section","isascii","name","前导","了","存储","ones","点数","precision","大体","##","传入","]","但","这个","百分数","加上","hello","###","代表","时候","字段","可能","源代码","仅","0000","并","起始","相应","这样","语言","e","变为","为","第一行","中国","you","二行","补齐","应该","正数","alpha","\"","里","12","000000120","使用","xe4","反之","windows","-","sprintf","文本文件","只能","env","0xff","保存","6","100.256","之前","上","该","其",">","空间","程序","、","兼容","codec","成为","10000.58","usr","对","xb8","maxsplit","默认","只","之一","报错","#","小数","回车","位置","except","3","适当","repr","采用","还","因为","多个","反过","最小","identifiers","部分","只有","+","区域","两种","若干个","多数","圆括号","第一个","n","xad","规定","to","控制参数","123456","左边","系列","a","取模","制表","文本","使","join","不会","找","创建","printable","4","居中","center","dict","索引","标志","返回","width","区别","精度","同","it","从左到右","受","0000000abc","命名","如何","字母","元素","记数法","第二行","）","rstrip","*","长度","样式","are","rsplit","内","cd8de1b11dcd","字","特殊字符","小写","%+","[","isidentifier","sign","代码","接在","前方","面值","points","紧接在","use","end","xff","08d","新","到","ipython","capitalize","个","过来",",","解码","one","此时","12000","there","unicodeencodeerror","本身","整型","表明","符将","申明","utf","嵌入","follow","digits","多行","从","若","小","每个","表达","作为","且","避免","数据","module","keepends","单位","规范","选","2","添加","用法","os","recent","#######","呈现","errors","字典","意味","fillchar","由加","，","号","nabc","序号","正则","有","插入","千位","制表符","一个","field","名","省略","否则","叫做","byte","120.00","无论","表达式","bin","大括号","想","unicodedecodeerror","宽度","内部","printf","进制","arg","输入","unicode","前","格式","修改","前缀","浮点","空格","d","一次","于","把","0o","具体","或者","一定","isspace","title","“","原值","code","call","michael","解释","符号","isdecimal","影响","负数","默认值","字符","字符串","：","符","integer","decimal","abc","正负","cased","i","但是","内右","不能","linux","789","更","声明","条目","所以","只不过","第一次","xbd","whitespace","xe6","也就是说","小于","least","信息","关键字","告诉","什么","当中","过时","纯","可以","将","时","行为","alphabetic","只是","most","%","后字","element","test","python3","显示","参数","原始","可","小字","描述","old","可用","120","不够","写","运算符","conversion","适用","解释器","不过","can","给出","f8cead4644a3","删除","coding","本文","valueerror","范围","大多","不带","iskeyword","内容","xe5","任何","例如","无","有效","一般","c","里面","并且","大写字母","释器","决定","你","执行","8s","要","反过来","o","用来","调用","化","传输","属性","进度","非","我们","储存","进行","in","指数","内置","注意事项","python2","所","除了","如","male","编码","打印","中","查找","需要","chars","prefix","从右到左","修饰符","百分","逗号","is","不","包括","是","|","转义序列","具有","”","大体一致","swapcase","=","让","若干","为了","last","这","startswith","8","f","uppercase","r","读到","零个","二进制","中文","算符","正在","str","character","关键","实例","1","x","自动","bytes","found","各种","忽略","之后","常用","左","replacement","numeric","suffix","用","一致","小部","map","双引号","两行","%.","流","lower","0b","由","或","case","包含","find","8d","ordinal","由于","形式","没什么","source","映射","会","isalnum","码","true","def","写法","456","错误","python","序列","等价","isupper","不是","replace","无效","123","基本","英文","指","decode","输出","正负号","16","islower","都","splitlines","0x","磁盘","range","not","其中","as","填充","也","格式化","x96","表示","too","ljust","分隔符","一小部分","大小","中以","分组","注释","被","尾随","则","of","建议","就是说","jack","的","务必","替换","乱码","插值","2s","注意","遵循","换行","小写字母","存在","类型","may","按","正则表达式","顺序","而","转义","这种","considered","对齐","have","start","identifier"," ","分割","位数","键","迭代","编码方式","new","option","括号","正常","以","中写","控制","思想","next","}","修饰","意义","值为","0000000123","确保","input","；","设置","false","放置","称为","一小","ignore","s","如果","槽","begin","10000","意味着","type","num","c#","规则","运算","sep","和","说明","(","网络","lowercase","零","14","<","一行","10","empty","当前","substring","不同","all","子","mathbf","行程","此处","及其","127","方法","就是","2f","spec","tabsize","不到","invalid","获取",")","一系","不足","达式",".","b","指定","其余","ab","g","&","当","在","无法","操作","print","引号","。","istitle","允许","strip","lstrip","keyword","数字","与","就","科学","内存","reserved","大写","partition","单个","文本编辑","后","互相","'","编辑","字节","效果","index","分数","第二","功能","副本","一旦","endswith","\\","为何","abcabc","ascii","meaning","关系","文件","减号","world","结尾","即","多","元组","字段名","器","20","fill","count","用于","hi","表示法","此","拆分","0","开头","应仅","$","这是","（","数值","only","抛出","用带","digit","zfill","对象","方式","那么","_.","and","按照","007f","longleftrightarrow","强制","读取","同时","一种","array","u","如下","class","bc","保留","分隔","split","grouping","标记","^","t","{","通过","_","事项","for","upper","换行符","format","含义","解析","/","uncased","######","x87","类似","if","最","its","76f41cd8dafa",":","attribute","浮点数","ut8","它","依次","特殊","没有","described","一样","characters","isprintable","组成","at","选项","00123456","回车符","加入","合并","第一","any","模板","20.2","加","x9b","none","开始","isalpha","such","traceback","次数","应","逻辑","128","两个","代替","align","必须","值","转换","相同","以下","右","or","已","string","统计","段","下","通常","所有","values","整数","原来","编成","单引号"],"title":"2.4.String","title_tokens":[".","2.4","string"]},{"location":"Python基础/2.4.String.html#_1","text":"str_1 = \"\"\" 这是一个多行字符串 这是第二行 \"\"\" print ( str_1 ) str_2 = \" \\n 这是一个多行字符串 \\n 这是第二行 \\n \" print ( str_2 ) str_1 == str_2 这是一个多行字符串 这是第二行 这是一个多行字符串 这是第二行 True","text_tokens":["第二行","二行","第二","多行","=",")","\"","\\","n","_","true","2","print","str","1","这是","字符","字符串","("," ","一个"],"title":"多行字符串","title_tokens":["字符串","字符","多行"]},{"location":"Python基础/2.4.String.html#_2","text":"如果要在字符串里面输入特殊字符，需要使用转义符\\，例如输入转义符本身： str_3 = \"12 \\\\ 14\" print ( str_3 ) 12\\14","text_tokens":["需要","3","例如","=","特殊字符","里面","\"","\\",")","输入","_","要","12","使用","在","如果","str","print","，","转义","字符","字符串","：","符","(","14","本身"," ","特殊"],"title":"转义","title_tokens":["转义"]},{"location":"Python基础/2.4.String.html#_3","text":"在Python中，字符串可以添加前缀 r\\R 、 b 、 u\\U 、 f 。 r\\R ：表示非转义的原始字符串，常用于正则表达式。 b ：Python3里默认的str是(Python2里的)unicode，bytes是(Python2)的str， b前缀代表的就是bytes。Python2里, b前缀没什么具体意义，只是为了兼容Python3的这种写法 。 u\\U ：表示unicode字符串，代表是对字符串进行unicode编码。 一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。建议所有编码方式采用UTF-8。 f ：表示 f 格式字符串。","text_tokens":["utf","出现","是","就是","表达","需",")","为了","达式","8","f","b","r","添加","中文","在","str","。","bytes","各种","，","常用","就","代表","正则","否则","表达式","没什么","一旦","\\","会","unicode","格式","里","前缀","写法","使用","于","python","-","具体","基本","英文","、","兼容","字符","都","字符串","：","对","默认","方式","但是","表示","u","采用","所以","建议","什么","的","可以","解析","只是","乱码","python3","原始","正则表达式","转义","这种"," ","编码方式","不带","正常","一般","意义","；","非","必须","转换","进行","python2","所",",","下","编码","(","所有","中","表明"],"title":"前缀","title_tokens":["前缀"]},{"location":"Python基础/2.4.String.html#_4","text":"Python有两种不同的字符串，一种存储文本，一种存储字节。对于文本，Python内部采用Unicode存储，而字节字符串显示原始字节序列或者ASCII。在Python3当中，文本字符串类型（使用Unicode数据存储）被命名为 str , 字节字符串类型被命名为 bytes 。但在python2中，文本字符串类型叫做 unicode ，字节字符串类型叫做 str 。也就是说： $$ \\begin{array}{} Python\\ 3\\ \\mathbf{str} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{unicode} \\\\ Python\\ 3\\ \\mathbf{bytes} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{str} \\end{array} $$ 所以，如果想将以unicode形式储存的字符串转换为二进制类型的字符串，需要将unicode字符串编码，反之，则需要解码。 编码：在python中，编码指的是将Unicode字符按照编码规则（如UTF-8）编成二进制序列。 在python3中实例化一个字符串 str_1 = \"中国\" # 编码 str_1 . encode () b'\\xe4\\xb8\\xad\\xe5\\x9b\\xbd' # 创建一个二进制字符串 str_2 = b ' \\xe4\\xb8\\xad\\xe5\\x9b\\xbd ' # 解码 str_2 . decode () '中国'","text_tokens":["需要","utf","不同","mathbf","是","就是","=",")","对于","8","数据",".","encode","b","2","二进制","&","存储","在","str","。","实例","1","bytes","但","，","有","一个","叫做","'","字节","为","中国","形式","想","内部","\"","\\","进制","unicode","ascii","使用","xe4","反之","-","python","序列","或者","指","decode","$","字符","字符串","：","xb8","#","按照","3","longleftrightarrow","一种","array","采用","所以","xbd","也就是说","两种","{","xad","被","则","_","当中","就是说","的","将","文本","python3","显示","创建","类型","原始","而"," ","命名","）","xe5","以","}","编成","x9b","化","转换","如果","begin","储存","end","规则","python2",",","解码","如","编码","(","中","（"],"title":"字符编码","title_tokens":["编码","字符"]},{"location":"Python基础/2.4.String.html#bytes","text":"文本字符类型在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把 str 变为以字节为单位的 bytes 。 Python3对 bytes 类型的数据用带 b 前缀的单引号或双引号表示。 bytes_8 = b \"ABC\" bytes_8 b'ABC' 要注意的是：bytes字面值中只允许ASCII字符（无论源代码声明的编码为何）。任何超出127的二进制值必须使用相应的转义序列形式加入bytes字面值。 例如，可以对str（unicode类型）对象使用 encode() 方法，编码为bytes的形式（16进制表示）。 '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 要注意的是， encode 的对象不能超出指定编码的范围，例如不能对中文字符使用 .encode(\"ascii\") ，因为中文不在ascii码的范围内。 '中文' . encode ( 'ascii' ) ---------------------------------------------------------------------------UnicodeEncodeError Traceback (most recent call last)<ipython-input-1-76f41cd8dafa> in <module> ----> 1 '中文'.encode('ascii') UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) 纯英文的str可以用ASCII编码为bytes，内容是一样的，但无法显示为ASCII字符的字节，用 \\x 显示（16进制转义表示）。 'ABC' . encode ( 'ascii' ) b'ABC' '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用 decode() 方法： b 'ABC' . decode ( 'ascii' ) 'ABC' b ' \\xe4\\xb8\\xad\\xe6\\x96\\x87 ' . decode ( 'utf-8' ) '中文' 如果bytes中包含无法解码的字节， decode() 方法会报错： b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' ) ---------------------------------------------------------------------------UnicodeDecodeError Traceback (most recent call last)<ipython-input-1-cd8de1b11dcd> in <module> ----> 1 b'\\xe4\\xb8\\xad\\xff'.decode('utf-8') UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte 但是，如果bytes中只有一小部分无效的字节，可以传入 errors = 'ignore' 忽略错误的字节： \"中\" . encode ( \"utf-8\" ) # 中 原来的编码 b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' , errors = 'ignore' ) '中' 在对str和bytes互相转换时，为了避免乱码问题，应该使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： # !/usr/bin/env python3 # -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释。第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，在源代码中写的中文输出可能会有乱码。 但是申明了UTF-8编码只是让Python解释器按UTF-8的编码规则读取源代码，并不意味着源代码一定是使用UT8-8编码保存的，必须并且要确保文本编辑器正在使用UTF-8编码。","text_tokens":["需要","utf","系统","申明","对应","不","行程","是","127","转义序列","方法","就是","从","问题","!","=","invalid","让","若干",")","last","为了","这","可执行程序","8","超出","position","数据",".","module","避免","单位","encode","b","读到","指定","了","二进制","当","中文","在","无法","os","正在","str","recent","引号","。","1","允许","x","bytes","errors","传入","意味","但","这个","忽略","，","就","内存","有","用","时候","小部","一个","可能","源代码","文本编辑","双引号","两行","并","互相","'","相应","流","否则","变为","字节","为","byte","第一行","编辑","或","二行","无论","包含","bin","第二","ordinal","由于","形式","应该","unicodedecodeerror","\"","为何","进制","\\","unicode","ascii","码","会","前缀","文件","使用","xe4","错误","windows","器","-","python","把","序列","文本文件","或者","0xff","保存","env","一定","上",">","0","无效","开头","call","英文","decode","解释","这是","程序","输出","codec","16","字符","usr","对","用带","：","xb8","磁盘","abc","只","对象","range","那么","not","但是","报错","不能","#","也","linux","按照","3","x96","读取","表示","声明","所以","因为","反过","一小部分","xe6","部分","中以","只有","若干个","t","注释","xad","_","告诉","纯","的","可以","时","务必","/","只是","most","乱码","x87","文本","python3","注意","显示","类型","按","76f41cd8dafa",":","转义","写","ut8","它","解释器","start","can"," ","一样","characters","本文","coding","第二行","范围","）","*","内容","任何","内","cd8de1b11dcd","字","以","例如","加入","中写","第一","并且","释器","traceback","你","执行","要","反过来","确保","input","传输","128","代码","面值","值","必须","一小","我们","ignore","如果","转换","意味着","xff","进行","到","ipython","in","规则","过来","解码",",","和","通常","编码","网络","(","unicodeencodeerror","<","一行","中","原来","（","单引号"],"title":"bytes字符","title_tokens":["字符","bytes"]},{"location":"Python基础/2.4.String.html#_5","text":"","text_tokens":[],"title":"格式化","title_tokens":["格式化","格式"]},{"location":"Python基础/2.4.String.html#c-printf","text":"字符串具有一种特殊的内置操作：使用 % (取模)运算符，可以格式化字符串，此时 % 也被称为字符串的格式化运算符或插值运算符。对于format % values(其中format为一个字符串)，在format中的 % 转换标记符将被替换为零个或多个values条目。 其效果类似于在C语言中使用sprintf()。 'Hello, %s ' % 'world' # 省略括号 'Hello, world' 'Hi, %s , you have $ %d ' % ( 'Michael' , 10000.58 ) 'Hi, Michael, you have $10000' 转换标记符 包含两个或更多字符，由以下元素组成，且必须遵循此处规定的顺序： % 字符，用于标记转换符的起始。 映射键（可选），由加圆括号的字符序列组成(例如(somename))。 转换标志（可选） - 表示左对齐 + 表示转换后的内容前方加上正负号 空格 表示正数前方保留一个空格 0 表示如果转换位置位数不够时，用0填充 最小字段宽度（可选），转换后字段的最小宽度，如果不足自动用空格补齐；如果最小字段宽度值为 * ，则从元组中读取。 精度（可选），在 . 之后加精度值的形式给出。如果指定为为 * ，则从元组中读取。 长度修饰符（可选）。 转换类型。 Conversion Meaning d 格式化整数 i 格式化整数 o 8 进制 u 格式化无符号整型(已过时) x 16 进制， 小写字母 X 16 进制， 大写字母 e 浮点指数格式， 小写字母 E 浮点指数格式， 大写字母 f 浮点数 F 浮点数 g 浮点数， 如果指数小于 -4 或小于精度， 则使用小写指数格式， 否则使用小数格式 G 浮点数， 类似 g , 使用大写指数 c 单个字符， 格式化字符及其 ASCII 码 r 字符串， 使用 repr() 转换任何 Python 对象 s 字符串， 使用 str() 转换任何 Python 对象 % % 字符 # 映射键 ## 如果值是一个字典，那么必须使用映射键. 如： print ( ' %(num)d ' % { \"num\" : 10 }) 10 # 最小字段宽度 print ( ' %2s ' % 123456 ) print ( ' %8s ' % 123456 ) print ( ' %*s ' % ( 10 , 123456 )) 123456 123456 123456 # 精度 print ( ' %.2f ' % 100.256 ) print ( ' %.*f ' % ( 2 , 100.256 )) 100.26 100.26 # 转换标志 print ( ' %-8d ' % 123456 ) print ( ' %+8d ' % 123456 ) print ( ' %08d ' % 123456 ) 123456 +123456 00123456","text_tokens":["修饰符","此处","是","及其","100.26","具有","从","2f","写字",")","c语言","对于","且","不足","8",".","f","负号","somename","r","选","零个","指定","2","g","操作","算符","在","print","str","点数","。","##","x","自动","字典","由加","之后","，","加上","左","hello","大写","用","一个","单个","省略","后","起始","%.","'","否则","语言","e","由","为","效果","或","you","包含","补齐","8d","形式","正数","宽度","映射","进制","\"","meaning","ascii","格式","码","浮点","world","空格","多","元组","使用","d","于","sprintf","-","序列","python","用于","hi","100.256","其","0","michael","$","正负号","符号","16","字符","10000.58","字符串","：","符","正负","i","对象","那么","其中","#","填充","小数","也","格式化","位置","repr","读取","更","一种","表示","u","条目","保留","多个","最小","标记","+","圆括号","小于","{","规定","被","则","过时","的","可以","format","时","123456","替换","%","后字","取模","插值","2s","遵循","小写字母","类型","类似","可","小字","最","4",":","顺序","不够","标志","浮点数","运算符","conversion","精度","对齐","have","给出"," ","特殊","位数","键","字母","元素","组成","）","*","长度","括号","内容","任何","例如","无","00123456","修饰","c","}","小写","%+","加","大写字母","值为","8s","o","；","两个","称为","前方","必须","值","转换","s","如果","10000","08d","指数","num","内置","以下","运算","已","段",",","如","此时","(","values","整数","整型","中","10","（","符将"],"title":"C printf 样式的格式化","title_tokens":["格式化","c","printf","格式","样式"," ","的"]},{"location":"Python基础/2.4.String.html#format","text":"< 模板字符串 >. format ( < 逗号分隔的参数 > ) <模板字符串> 由一系列的槽 {} 组成，用来控制修改字符串中嵌入值出现的位置，其基本思想是将format()方法的 <逗号分隔的参数> 中的参数按照序号关系替换到 <模板字符串> 的槽中。如果大括号中没有序号，则按照出现顺序替换。该方法会创建新字符串对象，不会修改原值。 {}中指定顺序，按指定的顺序替换 print ( \" {2} : {1} : {0} \" . format ( \"1\" , \"2\" , \"3\" )) 3 : 2 : 1 没有指定顺序，按出现的顺序依次替换 print ( \" {} : {} : {} \" . format ( \"1\" , \"2\" , \"3\" )) 1 : 2 : 3 format()方法中 <模板字符串> 的槽除了包括参数序号，还可以包括格式控制信息。此时，槽的内部样式如下： 替换字段 - replacement_field ::= \"{\" [ field_name ] [ \"!\" conversion ] [ \":\" format_spec ] \"}\" 字段名 - field_name ::= arg_name ( \".\" attribute_name | \"[\" element_index \"]\" ) * 参数名 - arg_name ::= [ identifier | integer ] 属性名 - attribute_name ::= identifier 元素索引 - element_index ::= integer | index_string 索引字符串 - index_string ::= < any source character except \"]\" > + 转换字段 - conversion ::= \"r\" | \"s\" 格式规范说明符 - format_spec ::= < described in the next section > 注意事项： 参数名 可以为 整数 或 关键字 。整数为位置参数， 关键字为命名关键字参数。 如果整数类似于 {0}{1}{2}, 则可以省略， 即： {}{}{} 等价于 {0}{1}{2}。 如果参数存在属性， 可以通过 arg_name.attribute_name 的形式获取属性值。 如果参数为可迭代对象， 可以通过 arg_name[integer|index_string] 的形式获取索引位置的元素。 转换字段 由 ! 开始， r 代表调用 repr(), s 代表调用 str(). 格式规范说明符 由 : 开始。 其中， <格式控制标记> 用来控制参数显示时的格式，可以使用的参数如下： format_spec ::= [ [fill ] align ] [ sign ][ # ][ 0 ][ width ][ grouping_option ][ .precision ][ type ] fill ::= < any character > align ::= \"<\" | \">\" | \"=\" | \"^\" sign ::= \"+\" | \"-\" | \" \" width ::= digit + grouping_option ::= \"_\" | \",\" precision ::= digit + type ::= \"b\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" | \"g\" | \"G\" | \"n\" | \"o\" | \"s\" | \"x\" | \"X\" | \"%\" 填充字符 ：如果指定了对齐选项，则可以使用填充字符。默认为空格. 对齐选项 ：默认右对齐，各种对齐选项的含义如下： 选项 意义 '<' 强制字段在可用空间内左对齐（这是大多数对象的默认值）。 '>' 强制字段在可用空间内右对齐（这是数字的默认值）。 '=' 强制将填充放置在符号（如果有）之后但在数字之前。这用于以“+000000120”形式打印字段。此对齐选项仅对数字类型有效。当'0'紧接在字段宽度之前时，它成为默认值。 '^' 强制字段在可用空间内居中。 sign ：仅对数字类型有效，可以是以下之一： 选项 意义 '+' 表示标志应该用于正数和负数。 '-' 表示标志应仅用于负数（这是默认行为）。 space 表示应在正数上使用前导空格，在负数上使用减号。 # ：仅适用于数字参数，同时仅适用于2、8、16进制的数字。会在输出的数字前添加 0b、0o、0x前缀。 宽度 ：指定最小字段宽度。 千位分隔符 ：只能使用 _ 或 , 作为千位分隔符。 精度 ： 类型 ：该选项决定了数据应该如何呈现。 可用的字符串表示类型： Type Meaning s 字符串格式， 字符串的默认类型， 可省略 None 同 s 可用的整数表示类型： Type Meaning b 输出为 2 进制整数 c 输出为为相应的 unicode 字符 d 输出为 10 进制整数 o 输出为 8 进制整数 x 输出为 16 进制整数， 使用小写字母 X 输出为 16 进制整数， 使用大写字母 n 类似 d , 会使用当前区域设置插入适当的数字分隔符 None 同 d 可用的浮点数和小数值表示类型： Type Meaning e 指数表示法， 使用字母 e 以科学记数法打印数字， 默认进度为 6 E 类似 e , 使用字母 E f 浮点数， 默认进度为 6 F 浮点数， 同 f g 一般形式， 受 precision 选项影响 G 类似 g , 当使用指数表示法时， 使用 E 而不是 e n 和 g 相同， 会使用当前区域设置插入适当的数字分隔符 % 百分数表示 None 同 g # 填充、对齐、符号、宽度、分组选项、精度 # 填充*号、居中、正号标记、2精度 \" {0:*^+20.2f} \" . format ( 120 ) '******+120.00*******' # 填充*号、居中、正号标记、_分隔符、2精度 \"{0:*^+20_.2f}\" . format ( 12000 ) '*****+12_000.00*****' # 填充*号、居中、正号标记、,分隔符、2精度 \" {0:*^+20,.2f} \" . format ( 12000 ) '*****+12,000.00*****' # 填充*号、左对齐、正号标记、2精度 \" {0:*<+20.2f} \" . format ( - 120 ) '-120.00*************' # 填充*号、左对齐、负号标记、2精度 \" {0:*>-20.2f} \" . format ( - 120 ) '*************-120.00'","text_tokens":["一系列","紧接","出现","说明符","记数","000.00","space","!","the","写字","大多数","正","负号","section","name","前导","了","点数","precision","]","但","百分数","代表","字段","仅","相应","e","为","应该","正数","\"","12","000000120","使用","-","只能","6","之前","上","该","其",">","空间","、","成为","对","默认","之一","#","位置","except","3","适当","repr","还","+","区域","多数","n","控制参数","系列","不会","创建","居中","索引","标志","width","精度","同","受","命名","如何","字母","元素","记数法","）","*","样式","内","字","小写","[","sign","接在","紧接在","新","到",",","此时","12000","嵌入","小","作为","数据","规范","2","添加","呈现","，","号","序号","有","插入","千位","field","名","省略","120.00","大括号","宽度","内部","arg","进制","unicode","前","格式","修改","前缀","浮点","空格","d","于","0o","“","原值","符号","影响","负数","默认值","字符","字符串","：","integer","内右","信息","关键字","将","可以","时","行为","element","%","显示","参数","可","小字","可用","120","conversion","适用","大多","有效","一般","c","大写字母","决定","o","用来","调用","属性","进度","in","指数","注意事项","除了","打印","中","百分","逗号","包括","是","|","”","=","这","8","f","r","character","关键","str","1","x","各种","之后","左","replacement","0b","由","或","形式","source","会","等价","不是","基本","输出","16","0x","其中","填充","表示","分隔符","分组","则","的","替换","注意","小写字母","存在","类型","按","顺序","而","对齐","identifier"," ","迭代","option","括号","以","控制","思想","next","}","意义","设置","放置","s","如果","槽","说明","和","(","<","10","当前","方法","2f","spec","获取",")","一系",".","b","指定","g","当","在","print","。","数字","科学","大写","'","分数","index","meaning","关系","减号","即","字段名","20","fill","用于","表示法","此","0","应仅","这是","数值","digit","对象","_.","按照","强制","同时","如下","分隔","grouping","标记","^","{","通过","_","事项","format","含义","类似","最",":","attribute","浮点数","它","依次","没有","described","组成","选项","any","模板","20.2","none","开始","应","align","值","转换","相同","以下","右","string","段","整数","type","（"],"title":"format方法","title_tokens":["方法","format"]},{"location":"Python基础/2.4.String.html#_6","text":"","text_tokens":[],"title":"方法","title_tokens":["方法"]},{"location":"Python基础/2.4.String.html#_7","text":"方法 描述 .isalnum if all characters in the string are alpha-numeric and there is at least one character .isalpha if all characters in the string are alphabetic and there is at least one character .isnumeric if all characters in the string are numeric and there is at least one character .isascii ASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too . .isdecimal if all characters in the string are decimal and there is at least one character .isdigit if all characters in the string are digits and there is at least one character .isidentifier Use keyword.iskeyword() to test for reserved identifiers such as \"def\" and \"class\". .islower if all cased characters in the string are lowercase and there is at least one cased character .isupper if all cased characters in the string are uppercase and there is at least one cased character .isprintable if all of its characters are considered printable in repr() or if it is empty. .isspace if all characters in the string are whitespace and there is at least one character .istitle In a title-cased string, upper- and title-case characters may only follow uncased characters and lowercase characters only cased ones. 方法 描述 .startswith(prefix[, start[, end]]) 如果字符串以 prefix 开头 .endswith(suffix[, start[, end]]) 如果字符串以 suffix 结尾","text_tokens":["prefix","all","follow","digits","is","isnumeric","方法","the","isdigit",")","startswith",".","uppercase","isascii","ones","character","istitle","]","reserved","numeric","suffix","0000","case","alpha","\"","endswith","isalnum","ascii","def","结尾","-","isspace","isupper","title","开头","code","isdecimal","islower","字符","only","字符串","decimal","cased","range","as","and","007f","repr","class","u","too","whitespace","identifiers","+","to","least","of","for","upper","alphabetic","uncased","a","test","may","描述","if","printable","its","considered","it","have","start"," ","characters","isprintable","iskeyword","are","at","以","isalpha","such","[","isidentifier","points","如果","use","end","in","or","string",",","one","there","(","lowercase","empty","keyword"],"title":"逻辑方法","title_tokens":["方法","逻辑"]},{"location":"Python基础/2.4.String.html#_8","text":"方法 描述 .lower 返回转换为小写的字符串的副本。 .upper 返回转换为大写的字符串的副本。 .capitalize 使第一个字符字母大写，其余字符字母小写，返回副本。 .swapcase 将大写字符转换为小写，将小写字符转换为大写，返回副本。 .title 每个单词都用大写字母开头，返回副本。","text_tokens":["lower","字母","为","方法","副本","swapcase","第一","每个","第一个","单词","写字","小写","大写字母",".","upper","的","将","其余","转换","使","title","。","描述","开头","capitalize","返回","，","字符","都","字符串","大写","用"," ","一个"],"title":"大小字母转换","title_tokens":["转换","字母","大小"]},{"location":"Python基础/2.4.String.html#_9","text":"方法 描述 .split(sep=None, maxsplit=-1) 从左到右以 sep 分割字符串 .rsplit(sep=None, maxsplit=-1) 从右到左以 sep 分割字符串 .splitlines(keepends=False) 以回车符或换行符分割字符串 .partition(sep, /) 从左到右以第一个出现的 sep 分割字符串，返回包括3个元素的元组 \"123#456#789\" . split ( sep = \"#\" , maxsplit = 1 ) ['123', '456#789'] \"123#456#789\" . rsplit ( sep = \"#\" , maxsplit = 1 ) ['123#456', '789'] \"123 \\r\\n 456 \\r\\n 789\" . splitlines ( keepends = False ) ['123', '456', '789'] \"123 \\r\\n 456 \\r\\n 789\" . splitlines ( keepends = True ) ['123\\r\\n', '456\\r\\n', '789'] \"123#456#789\" . partition ( \"#\" ) ('123', '#', '456#789')","text_tokens":["'","从右到左","3","元素","789","或","出现","包括","rsplit","方法","split","#","回车符","以","从左到右","第一","=","第一个",")","\"","none","\\","n",".","true","keepends","[","换行符","的","元组","false","456","r","/","-","换行","描述","1","个","123","]","返回","，","sep","字符",",","字符串","splitlines","(","partition","maxsplit"," ","分割","一个","回车"],"title":"拆分字符串","title_tokens":["字符串","字符","拆分"]},{"location":"Python基础/2.4.String.html#_10","text":"\"_\" . join ([ \"a\" , \"b\" , \"c\" ]) 'a_b_c'","text_tokens":["'","a","c",")","\"",",","]","join","(","_",".","["," ","b"],"title":"合并字符串","title_tokens":["字符串","合并","字符"]},{"location":"Python基础/2.4.String.html#_11","text":"方法 描述 .replace(old, new, count=-1) 返回一个副本，其中所有出现的子字符串 old 都替换为 new 。 .strip(chars=None) 返回字符串的副本，其中前导和尾随空格删除。 .lstrip(chars=None) 返回删除前导空格的字符串副本。 .rstrip(chars=None) 返回删除尾随空格的字符串副本。 .expandtabs(tabsize=8) 返回一个副本，其中所有制表符都使用 tabsize 个空格代替。 \" \\n abc \\t\\n\\r \" . strip () 'abc' \" \\n abc \\t\\n\\r \" . lstrip () 'abc\\t\\n\\r ' \" \\n abc \\t\\n\\r \" . rstrip () ' \\nabc' \" \\n abc \\t\\n\\r \" . expandtabs ( tabsize = 8 ) ' \\nabc \\n\\r '","text_tokens":["chars","new","'","子","为","出现","rstrip","方法","expandtabs","副本","tabsize","=",")","t","\"","none","\\","n","尾随","8",".","空格","的","使用","代替","r","前导","-","替换","count","制表","删除","。","描述","old","1","replace","strip","lstrip","个","返回","，","字符","nabc",",","字符串","都","和","所有","(","abc","制表符"," ","一个","其中"],"title":"替换字符串","title_tokens":["字符串","替换","字符"]},{"location":"Python基础/2.4.String.html#_12","text":"方法 描述 .format 格式化字符串。 .format_map 格式化字符串。 .ljust(width, fillchar=' ') 返回长度为 width 的左对齐字符串。使用 fillchar 填充。 .rjust(width, fillchar=' ') 返回长度为 width 的右对齐字符串。使用 fillchar 填充。 .center(width, fillchar=' ') 返回长度为 width 的居中字符串。使用 fillchar 填充。 .zfill(width) 返回长度为 width 的字符串，若长度不够，用零从左边填充。 .format_map 与 .format 在用法上大体一致，但有一个区别： # format_map 和 format 的区别 # 如果要使用关键字 format必须这样使用 \" {name} , {sex} \" . format ( name = \"Jack\" , sex = \"male\" ) # format_map 可以用dict \" {name} , {sex} \" . format_map ({ \"name\" : \"Jack\" , \"sex\" : \"male\" }) 'Jack, male' print ( \"abc\" . ljust ( 10 , \"#\" )) print ( \"abc\" . rjust ( 10 , \"#\" )) print ( \"abc\" . center ( 10 , \"#\" )) print ( \"123\" . zfill ( 10 )) # 非数字字符串也可以 print ( \"abc\" . zfill ( 10 )) abc####### #######abc ###abc#### 0000000123 0000000abc","text_tokens":["方法","rjust","从","若","大体一致","=","sex",")",".","name","ab","用法","在","print","关键","大体","。","#######","fillchar","但","与","数字","，","左","###","有","用","一致","一个","map","'","这样","为","\"","格式","使用","上","123","字符","字符串","：","zfill","abc","#","填充","也","格式化","ljust","{","_","关键字","jack","format","的","左边","可以","######","描述","dict","center","居中",":","不够","区别","返回","width","对齐"," ","0000000abc","长度","}","0000000123","要","必须","非","如果","c#","右",",","和","male","(","零","10"],"title":"格式化字符串","title_tokens":["字符串","格式化","字符","格式"]},{"location":"Python基础/2.4.String.html#_13","text":"\"abcAbc\" . count ( \"c\" , 0 , 6 ) 2","text_tokens":["2","count","c",")","abcabc","\"",",","6","(","."," ","0"],"title":"统计子字符串出现次数","title_tokens":["统计","字符","子","字符串","出现","次数"]},{"location":"Python基础/2.4.String.html#_14","text":".index 与 .find 的功能是一样的，只不过 .index 方法若找不到子字符串会抛出ValueError，而 .find 会返回 -1 。 \"abcAbc\" . index ( \"bc\" , 0 , 6 ) \"abcAbc\" . find ( \"bc\" , 0 , 6 ) 1 \"abcAbc\" . index ( \"bc\" , 0 , 2 ) ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-f8cead4644a3> in <module> ----> 1 \"abcAbc\".index(\"bc\", 0, 2) ValueError: substring not found \"abcAbc\" . find ( \"bc\" , 0 , 2 ) -1","text_tokens":["一样","子","valueerror","index","bc","是","方法","只不过","find","功能","若","不到","last",")","abcabc","\"","会","traceback",".","module","input","的","2","-","most","6","recent","找","。","1","0",">","ipython","in","call","与",":","found","而","返回","，","字符",",","字符串","抛出","(","不过","<"," ","not","f8cead4644a3","substring"],"title":"查找子字符串第一次出现的位置","title_tokens":["第一","位置","字符","子","字符串","第一次","出现","查找","的","一次"]},{"location":"Python基础/2.5.Tuple.html","text":"tuple是一种一维的，定长的、不可变的Python对象序列，元素写在小括号 () 里，元素之间用逗号隔开，元组中的元素类型可以不相同。 不可变的tuple有什么意义？ 因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 Tuple的陷阱——1个元素的Tuple 定义个一个Tuple，需要传入一个iterable对象。 tuple ( \"123\" ) ('1', '2', '3') 如果需要定义一个空的Tuple，则可以这样定义： # 通过tuple类来定义 a = tuple () type ( a ) # 或者用 () 定义 a = () type ( a ) # 是的，通过()可以定义一个空tuple tuple 但是如果要定义一个只有一个元素的tuple，就得要注意了。如果我们这样定义，则是错误的： b = ( \"123\" ) type ( b ) str 定义只有一个元素的tuple，需要这样定义： b = ( \"123\" ,) type ( b ) tuple 或者这样定义： b = tuple ([ \"123\" ]) type ( b ) tuple 为什么会这样呢？因为 () 在python中可以表示运算符的 () ，也可以表示Tuple。这就不可避免地产生了歧义，为了消除歧义，Python规定括号里面只有一个元素时，按运算符的 () 进行解析。 Tuple的陷阱——“可变的”Tuple 前面说过，Tuple是一种不可变的对象。但是有时我们又会发现Tuple是“可变的”。 c = ( 'a' , 'b' , [ 'A' , 'B' ]) print ( \"原始的Tuple：\" , c ) c [ 2 ][ 0 ] = 'X' c [ 2 ][ 1 ] = 'Y' print ( \"修改后的Tuple：\" , c ) 原始的Tuple： ('a', 'b', ['A', 'B']) 修改后的Tuple： ('a', 'b', ['X', 'Y']) 前面说过tuple一旦定义后就不可变，那上面的c怎么就改变了呢？其实，c的元素并没有改变，改变的只是list中的元素，tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素的指向永远不变。即指向 a ，就不能改成指向 b ，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 所以要创建一个内容也不变的tuple，那就必须保证tuple的每一个元素本身也不能变。 Tuple的方法 因为Tuple是一个不可变的列表，没有用于修改列表的方法，所以Tuple对象的方法很少。 d = ( 0 , 1 , 2 , 3 , 4 , 4 ) [ method for method in dir ( d ) if not method . startswith ( \"_\" )] ['count', 'index'] 统计元素出现的次数 d . count ( 4 ) 2 元素第一次出现时对应的索引值 d . index ( 4 ) 4","text_tokens":["需要","空","保证","比如","对应","逗号","不","出现","是","方法","之间","”","每个","=",")","这","不可避免","为了","startswith","又","避免",".","很少","b","不可","2","了","在","算符","print","str","。","1","x","尽量","传入","]","但","这个","列表","，","就","dir","定义","产生","有","用","一个","可能","后","并","'","这样","index","说","包含","得","—","！","怎么","一旦","\"","会","上面","里","修改","隔开","即","元组","d","错误","一次","python","序列","安全","count","tuple","定长","或者","其他","用于","“","0","123","、","前面","虽然","陷阱","：","对象","过","但是","not","地","#","不能","歧义","也","变","3","能用","更","一种","表示","所以","method","因为","第一次","只有","list","通过","规定","改变","消除","则","_","iterable","for","什么","的","可以","时","解析","a","只是","改成","可变","类来","注意","创建","类型","原始","if","按","4","索引","写","运算符","每","所谓","它"," ","没有","元素","括号","内容","？","小括号","一维","那","第一","y","其实","c","意义","里面","指向","开始","一","为什么","不变","次数","要","[","有时","别的","发现","代码","代替","必须","值","我们","如果","永远","进行","相同","个","in","运算","统计",",","(","本身","中","type","呢"],"title":"2.5.Tuple","title_tokens":["tuple",".","2.5"]},{"location":"Python基础/2.5.Tuple.html#tuple1tuple","text":"定义个一个Tuple，需要传入一个iterable对象。 tuple ( \"123\" ) ('1', '2', '3') 如果需要定义一个空的Tuple，则可以这样定义： # 通过tuple类来定义 a = tuple () type ( a ) # 或者用 () 定义 a = () type ( a ) # 是的，通过()可以定义一个空tuple tuple 但是如果要定义一个只有一个元素的tuple，就得要注意了。如果我们这样定义，则是错误的： b = ( \"123\" ) type ( b ) str 定义只有一个元素的tuple，需要这样定义： b = ( \"123\" ,) type ( b ) tuple 或者这样定义： b = tuple ([ \"123\" ]) type ( b ) tuple 为什么会这样呢？因为 () 在python中可以表示运算符的 () ，也可以表示Tuple。这就不可避免地产生了歧义，为了消除歧义，Python规定括号里面只有一个元素时，按运算符的 () 进行解析。","text_tokens":["需要","空","是","=",")","这","不可避免","为了","避免","b","不可","2","了","在","算符","str","。","1","传入","]","，","就","定义","产生","用","一个","'","这样","得","\"","会","错误","python","tuple","或者","123","：","对象","但是","地","#","歧义","也","3","表示","因为","只有","通过","规定","消除","则","iterable","什么","的","可以","时","解析","a","类来","注意","按","运算符"," ","元素","括号","？","里面","为什么","要","[","我们","如果","进行","个","运算",",","(","中","type","呢"],"title":"Tuple的陷阱——1个元素的Tuple","title_tokens":["元素","tuple","陷阱","1","—","个","的"]},{"location":"Python基础/2.5.Tuple.html#tupletuple","text":"前面说过，Tuple是一种不可变的对象。但是有时我们又会发现Tuple是“可变的”。 c = ( 'a' , 'b' , [ 'A' , 'B' ]) print ( \"原始的Tuple：\" , c ) c [ 2 ][ 0 ] = 'X' c [ 2 ][ 1 ] = 'Y' print ( \"修改后的Tuple：\" , c ) 原始的Tuple： ('a', 'b', ['A', 'B']) 修改后的Tuple： ('a', 'b', ['X', 'Y']) 前面说过tuple一旦定义后就不可变，那上面的c怎么就改变了呢？其实，c的元素并没有改变，改变的只是list中的元素，tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素的指向永远不变。即指向 a ，就不能改成指向 b ，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 所以要创建一个内容也不变的tuple，那就必须保证tuple的每一个元素本身也不能变。","text_tokens":["保证","是","”","每个","=",")","又","b","不可","2","了","print","。","1","x","]","但","这个","，","就","定义","一个","后","并","'","说","！","怎么","一旦","\"","会","上面","修改","即","tuple","其他","“","0","前面","：","过","对象","但是","不能","也","变","一种","所以","list","改变","的","a","只是","改成","可变","创建","原始","每","所谓"," ","没有","元素","内容","？","那","y","其实","c","指向","开始","一","不变","有时","[","要","别的","发现","必须","我们","永远",",","(","本身","中","呢"],"title":"Tuple的陷阱——“可变的”Tuple","title_tokens":["可变","tuple","陷阱","“","—","”","的"]},{"location":"Python基础/2.5.Tuple.html#tuple","text":"因为Tuple是一个不可变的列表，没有用于修改列表的方法，所以Tuple对象的方法很少。 d = ( 0 , 1 , 2 , 3 , 4 , 4 ) [ method for method in dir ( d ) if not method . startswith ( \"_\" )] ['count', 'index']","text_tokens":["'","变","3","index","是","所以","方法","method","因为","=",")","\"","startswith","修改",".","_","[","for","很少","的","d","不可","2","count","tuple","用于","。","1","if","0","4","in","]","列表","，","dir",",","(","一个","对象","没有"," ","not"],"title":"Tuple的方法","title_tokens":["tuple","方法","的"]},{"location":"Python基础/2.5.Tuple.html#_1","text":"d . count ( 4 ) 2","text_tokens":["2","count",")","(","."," ","4","d"],"title":"统计元素出现的次数","title_tokens":["统计","元素","出现","次数","的"]},{"location":"Python基础/2.5.Tuple.html#_2","text":"d . index ( 4 ) 4","text_tokens":[")","index","(","."," ","4","d"],"title":"元素第一次出现时对应的索引值","title_tokens":["第一","元素","对应","值","出现","第一次","的","时","索引","一次"]},{"location":"Python基础/2.6.Dict.html","text":"映射（mapping）是通过名称来访问其各个值的数据结构。字典是Python中唯一的内置映射类型，其中的值不按顺序排列，而是存储在键下。键可能是数、字符串或元组。 创建dict 字典以类似于下面的方式表示： phonebook = { 'Alice' : '2341' , 'Beth' : '9102' , 'Cecil' : '3258' } 字典由键及其相应的值组成，这种键--值对称为项（item）。每个键与其值之间都用冒号 : 分隔，item之间用逗号分隔，而整个字典放在花括号内。空字典（没有任何项）用两个花括号 {} 表示。 注意 在字典（以及其他映射类型）中，键必须是独一无二的，而字典中的值无需如此。 可使用dict类从其他映射（如其他字典）或键–值对序列创建字典。 items = [( 'name' , 'Gumby' ), ( 'age' , 42 )] dict ( items ) {'name': 'Gumby', 'age': 42} 还可使用关键参数，如下所示： dict ( name = 'Gumby' , age = 42 ) {'name': 'Gumby', 'age': 42} Dict的方法 字典的基本行为在很多方面都类似于序列。 len(d)返回字典d包含的项（键--值对）数。 d[k]返回与键k相关联的值。 d[k] = v将值v关联到键k。 del d[k]删除键为k的项。 k in d检查字典d是否包含键为k的项。 虽然字典和列表有多个相同之处，但也有一些重要的不同之处。 自动添加。 dict可以给不存在的项赋值，即是字典中原本没有的键，也可以给它赋值。而如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值。 成员资格。 表达式k in d (其中d是一个字典）査找的是键而不是值；而表达式v in 1 (其中1是一个列表）查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自然。毕竟如果字典包含指定的键，检查相应的值就很容易。 clear 删除所有的字典项 要注意的是，clear是清除了一个字典对象，而不是解除了名称与字典对象的绑定。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a a . clear () # 可以看到，a、b都变成了字典 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {} b的值: {} copy 浅拷贝 a = { \"a\" : 1 , \"b\" : 2 , \"c\" :[ 1 , 2 ]} b = a . copy () b [ \"c\" ][ 0 ] = 10 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {'a': 1, 'b': 2, 'c': [10, 2]} b的值: {'a': 1, 'b': 2, 'c': [10, 2]} fromkeys dict . fromkeys ( key , value ) 方法 fromkeys 创建一个新字典，其中包含指定的键，且每个键对应的值都是None，也可以指定值， dict . fromkeys ([ \"a\" , \"b\" ]) {'a': None, 'b': None} dict . fromkeys ([ \"a\" , \"b\" ], 10 ) {'a': 10, 'b': 10} get 方法 get 为访问字典项提供了宽松的环境。通常，如果你试图访问字典中没有的项，将引发错误。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a [ \"d\" ] ---------------------------------------------------------------------------KeyError Traceback (most recent call last)<ipython-input-1-b0ca58477f0c> in <module> 1 a = {\"a\":1,\"b\": 2,\"c\":3} ----> 2 a[\"d\"] KeyError: 'd' 而使用 get 不会这样 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . get ( \"d\" ) # 默认返回None，也可以指定返回值 a . get ( \"d\" , \"N/A\" ) 'N/A' items 方法 items 返回一个包含所有字典项的列表，其中每个元素都为 (key, value) 的形式。字典项在列表中的排列顺序不确定。返回值属于一种名为字典视图的特殊类型。字典视图可用于迭代。另外，你还可确定其长度以及对其执行成员资格检查。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . items () dict_items([('a', 1), ('b', 2), ('c', 3)]) # dict_items类型 type ( a . items ()) dict_items # 迭代 for i in a . items (): print ( i ) ('a', 1) ('b', 2) ('c', 3) # 迭代 for key , value in a . items (): print ( key , end = \" \" ) print ( value ) a 1 b 2 c 3 # 检查成员资格 ( \"a\" , 1 ) in a . items () True keys 和 values 方法 keys 返回一个字典视图，其中包含字典中的键。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . keys () dict_keys(['a', 'b', 'c']) 方法 values 返回一个字典视图，其中包含字典中的键。 a . values () dict_values([1, 2, 3]) pop 方法pop可用于获取与指定键相关联的值，并将该键-值对从字典中删除。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a . pop ( \"a\" ) print ( \"b的值\" , b ) print ( \"a的值\" , a ) b的值 1 a的值 {'b': 2, 'c': 3} popitem 方法 popitem 类似于 list.pop ，但 list.pop 弹出列表中的最后一个元素，而 popitem 随机地弹出一个字典项，因为字典项的顺序是不确定的，没有“最后一个元素”的概念。如果你要以高效地方式 逐个 删除并处理所有字典项，这可能很有用，因为这样无需先获取键列表。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . popitem () ('c', 3) a {'a': 1, 'b': 2} setdefault 方法 setdefault 有点像get，因为它也获取与指定键相关联的值，但除此之外，setdefault还在字典不包含指定的键时，在字典中添加指定的键-值对。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . setdefault ( \"a\" ) a a . setdefault ( \"d\" ) a {'a': 1, 'b': 2, 'c': 3, 'd': None} 如你所见，指定的键不存在时，setdefault返回指定的值并相应地更新字典。如果指定的键存在，就返回其值，并保持字典不变。与 get 一样，值是可选的，如果没有指定，默认为None。 update 方法update使用一个字典中的项来更新另一个字典。对于通过参数提供的字典，将其项添加到当前字典中。如果当前字典包含键相同的项，就替换它。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . update ({ \"d\" : 4 }) a {'a': 1, 'b': 2, 'c': 3, 'd': 4} 可像调用本章前面讨论的函数dict（类型构造函数）那样调用方法update。这意味着调用update时，可向它提供一个映射、一个由键-值对组成的序列（或其他可迭代对象）或关键字参数。 a . update ( zip ([ \"e\" , \"f\" ],[ 5 , 6 ])) a {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}","text_tokens":["很多","对应","或键","清除","成员","可选","对于","2341","name","了","存储","]","但","整个","之处","而是","可能","并","相应","这样","e","为","本章","k","append","\"","使用","phonebook","-","其他","6","其",">","地弹","、","出","属于","视图","对","解除","默认","地","#","3","项来","还","与其","因为","多个","花","关联","n","各个","另","item","觉得","a","不会","找","创建","dict","4","索引","返回","元素","唯一","pop","到键","）","key","结构","长度","内","更新","不变","[","3258","原本","end","新","ipython","到","拷贝",",","beth","从","每个","表达","相关联","且","数据","module","2","添加","可向","recent","9102","字典","确定","意味","，","顺序排列","有","一个","习惯","表达式","d","于","“","call","方面","相同之处","字符","虽然","字符串","：","i","不能","age","–","list","赋值","关键字","除此之外","之外","可以","将","时","行为","most","另外","参数","可","alice","提供","环境","名为","删除","重要","先","任何","返回值","所示","c","不太","你","执行","要","排列","调用","gumby","len","有点像","5","in","访问","内置","査","高效","绑定","如","冒号","项","查找","中","空","引发","逗号","不","是","之间","”","=","last","这","一些","其值","f","相关","关键","zip","1","浅","自动","用","一致","有点","构造函数","是否","或","包含","copy","形式","弹","映射","会","b0ca58477f0c","无需","true","错误","python","序列","以及","不是","keys","基本","将值","都","随机","构造","资格","其中","也","表示","处理","keyerror","其项","所见","的","替换","注意","宽松","存在","类型","按","顺序","而","这种","容易"," ","键","迭代","cecil","括号","以","}","可像","input","；","保持","称为","setdefault","试图","如果","意味着","如此","讨论","和","(","<","10","当前","除此","不同","及其","该键","方法","获取",")","popitem","达式",".","b","指定","来","在","print","。","42","与","下面","列表","看到","就","给","毕竟","名称","独一无二","后","放在","'","与键","很","数","相当","fromkeys","不同之处","del","update","即","元组","用于","value","mapping","0","由键","自然","前面","变成","对象","方式","类","一种","如下","分隔","items","逐个","v","最后","{","通过","_","独一","键为","for","/","函数","那样","类似",":","数据结构","看似","它","特殊","没有","一样","检查","组成","概念","none","traceback","get","两个","值","必须","clear","相同","下","通常","所有","values","type","有用","（"],"title":"2.6.Dict","title_tokens":["dict","2.6","."]},{"location":"Python基础/2.6.Dict.html#dict","text":"字典以类似于下面的方式表示： phonebook = { 'Alice' : '2341' , 'Beth' : '9102' , 'Cecil' : '3258' } 字典由键及其相应的值组成，这种键--值对称为项（item）。每个键与其值之间都用冒号 : 分隔，item之间用逗号分隔，而整个字典放在花括号内。空字典（没有任何项）用两个花括号 {} 表示。 注意 在字典（以及其他映射类型）中，键必须是独一无二的，而字典中的值无需如此。 可使用dict类从其他映射（如其他字典）或键–值对序列创建字典。 items = [( 'name' , 'Gumby' ), ( 'age' , 42 )] dict ( items ) {'name': 'Gumby', 'age': 42} 还可使用关键参数，如下所示： dict ( name = 'Gumby' , age = 42 ) {'name': 'Gumby', 'age': 42}","text_tokens":["空","逗号","或键","beth","是","及其","之间","从","每个","=",")","2341","name","在","关键","。","42","9102","字典","]","下面","，","整个","用","独一无二","放在","'","相应","映射","无需","使用","phonebook","于","-","序列","其他","以及","由键","都","：","对","方式","类","表示","如下","age","分隔","还","与其","items","–","花","{","独一","的","item","注意","参数","创建","类型","类似","可","alice",":","dict","而","这种"," ","没有","键","组成","）","cecil","括号","任何","内","以","所示","}","[","3258","两个","称为","值","必须","gumby","如此",",","如","冒号","(","项","中","（"],"title":"创建dict","title_tokens":["创建","dict"]},{"location":"Python基础/2.6.Dict.html#dict_1","text":"字典的基本行为在很多方面都类似于序列。 len(d)返回字典d包含的项（键--值对）数。 d[k]返回与键k相关联的值。 d[k] = v将值v关联到键k。 del d[k]删除键为k的项。 k in d检查字典d是否包含键为k的项。 虽然字典和列表有多个相同之处，但也有一些重要的不同之处。 自动添加。 dict可以给不存在的项赋值，即是字典中原本没有的键，也可以给它赋值。而如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值。 成员资格。 表达式k in d (其中d是一个字典）査找的是键而不是值；而表达式v in 1 (其中1是一个列表）查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自然。毕竟如果字典包含指定的键，检查相应的值就很容易。","text_tokens":["很多","不同","不","是","方法","成员","=","表达",")","这","相关联","达式","一些","指定","添加","在","相关","。","1","自动","字典","]","但","列表","，","就","给","毕竟","有","之处","查找","一致","一个","习惯","后","相应","与键","是否","很","或","数","包含","表达式","k","append","会","相当","不同之处","del","即","d","使用","于","-","序列","其他","不是","自然","基本","方面","相同之处","虽然","将值","都","对","资格","其中","不能","也","v","多个","关联","赋值","键为","的","可以","行为","觉得","找","存在","类似","dict","索引","而","返回","看似","它","容易"," ","没有","删除","键","检查","重要","元素","到键","）","不太","你","[","；","原本","值","如果","len","相同","in","査","和","(","项","中","（"],"title":"Dict的方法","title_tokens":["dict","方法","的"]},{"location":"Python基础/2.6.Dict.html#clear","text":"要注意的是，clear是清除了一个字典对象，而不是解除了名称与字典对象的绑定。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a a . clear () # 可以看到，a、b都变成了字典 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {} b的值: {}","text_tokens":["3","是","清除","=","}","c",")","{","\"",".","要","b","的","可以","2","了","a","值","注意","print","。","1","clear","不是","字典",":","与","、","而","看到","，","绑定",",","都","解除","(","名称","变成","一个","对象"," ","#"],"title":"clear删除所有的字典项","title_tokens":["所有","项","clear","字典","的","删除"]},{"location":"Python基础/2.6.Dict.html#copy","text":"a = { \"a\" : 1 , \"b\" : 2 , \"c\" :[ 1 , 2 ]} b = a . copy () b [ \"c\" ][ 0 ] = 10 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {'a': 1, 'b': 2, 'c': [10, 2]} b的值: {'a': 1, 'b': 2, 'c': [10, 2]}","text_tokens":["'","copy","=","}","c",")","\"","{",".","[","b","的","2","a","值","print","1","0",":","]",",","("," ","10"],"title":"copy浅拷贝","title_tokens":["拷贝","copy","浅"]},{"location":"Python基础/2.6.Dict.html#fromkeys","text":"dict . fromkeys ( key , value ) 方法 fromkeys 创建一个新字典，其中包含指定的键，且每个键对应的值都是None，也可以指定值， dict . fromkeys ([ \"a\" , \"b\" ]) {'a': None, 'b': None} dict . fromkeys ([ \"a\" , \"b\" ], 10 ) {'a': 10, 'b': 10}","text_tokens":["也","'","对应","key","是","包含","方法","每个","}",")","\"","none","fromkeys","{","且",".","[","b","的","可以","指定","a","值","value","创建","新","字典","dict","]",":","，",",","都","("," ","一个","10","其中","键"],"title":"fromkeys","title_tokens":["fromkeys"]},{"location":"Python基础/2.6.Dict.html#get","text":"方法 get 为访问字典项提供了宽松的环境。通常，如果你试图访问字典中没有的项，将引发错误。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a [ \"d\" ] ---------------------------------------------------------------------------KeyError Traceback (most recent call last)<ipython-input-1-b0ca58477f0c> in <module> 1 a = {\"a\":1,\"b\": 2,\"c\":3} ----> 2 a[\"d\"] KeyError: 'd' 而使用 get 不会这样 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . get ( \"d\" ) # 默认返回None，也可以指定返回值 a . get ( \"d\" , \"N/A\" ) 'N/A'","text_tokens":["'","这样","也","3","引发","为","方法","keyerror","返回值","=","}","c","last",")","{","\"","b0ca58477f0c","none","n","你","traceback",".","[","module","get","input","b","的","将","错误","d","使用","2","-","了","a","most","可以","指定","试图","/","如果","宽松","recent","不会","。","1",">","字典",":","]","call","提供","访问","ipython","in","而","，","返回",",","通常","(","环境","项","<"," ","中","没有","默认","#"],"title":"get","title_tokens":["get"]},{"location":"Python基础/2.6.Dict.html#items","text":"方法 items 返回一个包含所有字典项的列表，其中每个元素都为 (key, value) 的形式。字典项在列表中的排列顺序不确定。返回值属于一种名为字典视图的特殊类型。字典视图可用于迭代。另外，你还可确定其长度以及对其执行成员资格检查。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . items () dict_items([('a', 1), ('b', 2), ('c', 3)]) # dict_items类型 type ( a . items ()) dict_items # 迭代 for i in a . items (): print ( i ) ('a', 1) ('b', 2) ('c', 3) # 迭代 for key , value in a . items (): print ( key , end = \" \" ) print ( value ) a 1 b 2 c 3 # 检查成员资格 ( \"a\" , 1 ) in a . items () True","text_tokens":["检查","'","3","元素","为","一种","key","不","特殊","包含","长度","还","方法","成员","items","返回值","#","形式","每个","=","}","c",")","{","\"","你","执行",".","_","[","for","true","排列","b","的","2","a","在","用于","value","另外","print","。","类型","end","可","其","以及","1","字典","确定",":","dict","]","顺序","in","返回","列表","，","属于","都",",","视图","对","所有","(","项","中","资格","i","一个"," ","type","名为","其中","迭代"],"title":"items","title_tokens":["items"]},{"location":"Python基础/2.6.Dict.html#keysvalues","text":"方法 keys 返回一个字典视图，其中包含字典中的键。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . keys () dict_keys(['a', 'b', 'c']) 方法 values 返回一个字典视图，其中包含字典中的键。 a . values () dict_values([1, 2, 3])","text_tokens":["'","3","包含","方法","=","}","c",")","{","\"","_",".","[","b","的","2","a","。","1","keys",":","字典","dict","]","返回","，","视图",",","(","values","一个","中"," ","其中","键"],"title":"keys和values","title_tokens":["values","和","keys"]},{"location":"Python基础/2.6.Dict.html#pop","text":"方法pop可用于获取与指定键相关联的值，并将该键-值对从字典中删除。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a . pop ( \"a\" ) print ( \"b的值\" , b ) print ( \"a的值\" , a ) b的值 1 a的值 {'b': 2, 'c': 3}","text_tokens":["'","3","pop","该键","方法","从","键","=","}","c","获取",")","关联","{","\"","相关联",".","b","的","将","指定","-","a","2","值","用于","相关","print","。","可","1","字典",":","与","，",",","对","("," ","中","删除","并"],"title":"pop","title_tokens":["pop"]},{"location":"Python基础/2.6.Dict.html#popitem","text":"方法 popitem 类似于 list.pop ，但 list.pop 弹出列表中的最后一个元素，而 popitem 随机地弹出一个字典项，因为字典项的顺序是不确定的，没有“最后一个元素”的概念。如果你要以高效地方式 逐个 删除并处理所有字典项，这可能很有用，因为这样无需先获取键列表。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . popitem () ('c', 3) a {'a': 1, 'b': 2}","text_tokens":["'","这样","先","元素","pop","很","3","不","是","概念","方法","没有","处理","因为","逐个","”","最后","弹","可能","以","键","=","}","c","获取",")","这","list","popitem","{","\"","无需","你",".","要","b","的","2","于","a","如果","删除","“","。","类似","1","字典","确定","地弹","但",":","顺序","而","列表","，","出","高效",",","所有","(","随机","项"," ","中","一个","方式","有用","地","并"],"title":"popitem","title_tokens":["popitem"]},{"location":"Python基础/2.6.Dict.html#setdefault","text":"方法 setdefault 有点像get，因为它也获取与指定键相关联的值，但除此之外，setdefault还在字典不包含指定的键时，在字典中添加指定的键-值对。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . setdefault ( \"a\" ) a a . setdefault ( \"d\" ) a {'a': 1, 'b': 2, 'c': 3, 'd': None} 如你所见，指定的键不存在时，setdefault返回指定的值并相应地更新字典。如果指定的键存在，就返回其值，并保持字典不变。与 get 一样，值是可选的，如果没有指定，默认为None。","text_tokens":["一样","也","'","相应","3","为","不","是","包含","还","方法","因为","所见","更新","=","}","c","获取",")","关联","{","\"","none","可选","相关联","你","其值",".","不变","get","除此之外","b","的","之外","时","d","保持","指定","-","添加","setdefault","a","值","2","在","相关","如果","存在","。","1","有点像","字典",":","但","与","返回","，","就",",","对","它","如","("," ","中","没有","默认","并","有点","地","键","除此"],"title":"setdefault","title_tokens":["setdefault"]},{"location":"Python基础/2.6.Dict.html#update","text":"方法update使用一个字典中的项来更新另一个字典。对于通过参数提供的字典，将其项添加到当前字典中。如果当前字典包含键相同的项，就替换它。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . update ({ \"d\" : 4 }) a {'a': 1, 'b': 2, 'c': 3, 'd': 4} 可像调用本章前面讨论的函数dict（类型构造函数）那样调用方法update。这意味着调用update时，可向它提供一个映射、一个由键-值对组成的序列（或其他可迭代对象）或关键字参数。 a . update ( zip ([ \"e\" , \"f\" ],[ 5 , 6 ])) a {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}","text_tokens":["方法","=",")","这","对于",".","f","b","2","添加","可向","关键","。","zip","1","字典","意味","]","，","就","一个","构造函数","'","e","或","包含","本章","\"","映射","update","使用","d","-","序列","其他","6","由键","、","前面","对","构造","对象","3","项来","其项","{","通过","另","关键字","的","将","时","函数","a","替换","那样","参数","类型","可",":","4","dict","提供","它"," ","键","迭代","组成","）","更新","}","c","可像","[","调用","值","如果","意味着","到","相同","5","讨论",",","(","项","中","当前","（"],"title":"update","title_tokens":["update"]},{"location":"Python基础/2.7.推导式.html","text":"import pprint 列表推导式 列表推导式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的推导式。 运用列表推导式， 可以写出非常简洁的代码 。 举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 可以用 list(range(1, 11)) ： list ( range ( 1 , 11 )) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成 [1x1, 2x2, 3x3, ..., 10x10] 怎么做？方法一是循环： L = [] for x in range ( 1 , 11 ): L . append ( x * x ) pprint . pprint ( L ) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表推导式则可以用一行语句代替循环生成上面的list： [ x * x for x in range ( 1 , 11 )] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 写列表推导式时，把 要生成的元素 x * x 放到前面 ，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： [ x * x for x in range ( 1 , 11 ) if x % 2 == 0 ] [4, 16, 36, 64, 100] 还可以使用两层循环，可以生成全排列： [ m + n for m in 'ABC' for n in 'XYZ' ] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 三层和三层以上的循环就很少用到了。 for 循环其实可以同时使用两个甚至多个变量，比如 dict 的 items() 可以同时迭代key和value： d = { 'x' : 'A' , 'y' : 'B' , 'z' : 'C' } for k , v in d . items (): print ( k , '=' , v ) x = A y = B z = C 因此，列表推导式也可以使用两个变量来生成list： d = { 'x' : 'A' , 'y' : 'B' , 'z' : 'C' } [ k + '=' + v for k , v in d . items ()] ['x=A', 'y=B', 'z=C'] 最后把一个list中所有的字符串变成小写： L = [ 'Hello' , 'World' , 'IBM' , 'Apple' ] [ s . lower () for s in L ] ['hello', 'world', 'ibm', 'apple'] 字典推导式 字典推导式和列表推导式是类似的： { key : value for key , value in enumerate ( range ( 4 ))} {0: 0, 1: 1, 2: 2, 3: 3}","text_tokens":["m","比如","很快","强大","import","是","方法","两层","举个","=","9","1x1",")","8",".","很少","例子","b","2","ax","了","来","print","。","1","x","字典","]","但","列表","，","就","加上","出来","comprehensions","hello","81","cy","用","一个","'","这样","lower","z","100","非常","做","cz","几次","后面","k","...","az","append","一是","全","循环","却","apple","怎么","上面","式","简单","偶数","world","即","使用","d","python","把","value","6","甚至","11","生成","0","太","前面","16","字符","用到","字符串","：","变成","abc","出仅","range","但是","也","3","同时","十分","3x3","还","放到","items","多个","v","最后","l","筛选","+","list","{","n","25","xyz","7","则","for","的","可以","时","判断","a","多写","语法","%","创建","类似","if","4",":","非常简单","dict","而","跟","写","enumerate","by","bz","这种","熟悉","变量","写出"," ","ibm","迭代","bx","ay","元素","49","繁琐","key","*","？","y","其实","}","运用","c","小写","因此","36","要","用来","pprint","[","排列","两个","简洁","代码","代替","2x2","语句","我们","s","如果","cx","推导","10x10","5","in","内置","平方","以上",",","三层","和","所有","(","64","一行","10","中","有用"],"title":"2.7.推导式","title_tokens":["推导",".","式","2.7"]},{"location":"Python基础/2.7.推导式.html#_1","text":"列表推导式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的推导式。 运用列表推导式， 可以写出非常简洁的代码 。 举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 可以用 list(range(1, 11)) ： list ( range ( 1 , 11 )) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成 [1x1, 2x2, 3x3, ..., 10x10] 怎么做？方法一是循环： L = [] for x in range ( 1 , 11 ): L . append ( x * x ) pprint . pprint ( L ) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表推导式则可以用一行语句代替循环生成上面的list： [ x * x for x in range ( 1 , 11 )] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 写列表推导式时，把 要生成的元素 x * x 放到前面 ，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： [ x * x for x in range ( 1 , 11 ) if x % 2 == 0 ] [4, 16, 36, 64, 100] 还可以使用两层循环，可以生成全排列： [ m + n for m in 'ABC' for n in 'XYZ' ] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 三层和三层以上的循环就很少用到了。 for 循环其实可以同时使用两个甚至多个变量，比如 dict 的 items() 可以同时迭代key和value： d = { 'x' : 'A' , 'y' : 'B' , 'z' : 'C' } for k , v in d . items (): print ( k , '=' , v ) x = A y = B z = C 因此，列表推导式也可以使用两个变量来生成list： d = { 'x' : 'A' , 'y' : 'B' , 'z' : 'C' } [ k + '=' + v for k , v in d . items ()] ['x=A', 'y=B', 'z=C'] 最后把一个list中所有的字符串变成小写： L = [ 'Hello' , 'World' , 'IBM' , 'Apple' ] [ s . lower () for s in L ] ['hello', 'world', 'ibm', 'apple']","text_tokens":["m","比如","很快","强大","是","方法","两层","举个","=","9","1x1",")","8",".","很少","例子","b","2","ax","了","来","print","。","1","x","]","但","列表","，","就","加上","出来","comprehensions","hello","81","cy","用","一个","'","这样","lower","z","100","非常","做","cz","几次","后面","k","...","az","append","一是","全","循环","却","apple","怎么","上面","式","简单","偶数","world","即","使用","d","python","把","value","6","甚至","11","生成","0","太","前面","16","字符","用到","字符串","：","变成","abc","出仅","range","但是","也","3","同时","十分","3x3","还","放到","items","多个","v","最后","l","筛选","+","list","{","n","25","xyz","7","则","for","的","可以","时","判断","a","多写","语法","%","创建","if","4",":","非常简单","dict","而","跟","写","by","bz","这种","熟悉","变量","写出"," ","ibm","迭代","bx","ay","元素","49","繁琐","key","*","？","y","其实","}","运用","c","小写","因此","36","要","用来","[","pprint","排列","两个","简洁","代码","代替","2x2","语句","我们","s","如果","cx","推导","10x10","5","in","内置","平方","以上",",","三层","和","所有","(","64","一行","10","中","有用"],"title":"列表推导式","title_tokens":["推导","列表","式"]},{"location":"Python基础/2.7.推导式.html#_2","text":"字典推导式和列表推导式是类似的： { key : value for key , value in enumerate ( range ( 4 ))} {0: 0, 1: 1, 2: 2, 3: 3}","text_tokens":["3","key","是","}",")","{","式","for","的","2","value","类似","1","推导",":","字典","in","4","0","列表","enumerate",",","和","：","("," ","range"],"title":"字典推导式","title_tokens":["推导","字典","式"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html","text":"赋值 引用（reference） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。 一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。因此，引用亦常被称为该资料的指标或位址。 Python的赋值都是传引用，即name是value的引用。 在python里面，一个变量保存的值是某个对象的引用。Python赋值语句将左侧的符号名称与右侧的值 相关联 。在Python中，我们说名称引用值，或者名称是对值的引用。 下次我们使用这个名称时，便得到与名称相关联的值。 assignment永远不会复制数据，并且多个name可以引用同一个value。 当值具有多个名称时，很容易混淆并将其视为两个名称和两个值。： x = 23 y = x 但将已有的变量赋值给新变量时，Python永远不会复制值。分配只是使左侧的名称引用右侧的值。在这种情况下，我们只有一个23， x 和 y 都引用它，就像我们在上图中看到的那样。 名称是独立于其他名称重新分配的。 如果两个名称引用相同的值，则不会链接这两个名称。重新分配其中一个不会导致另一个也被重新分配： x = 23 y = x x = 12 如果上面嵌入的网页失效，可以参考以下动图： 值一直存在，直到没有名称引用它。 Python会跟踪每个值有多少引用，并自动清除没有引用的值。这被称为“垃圾收集”，意味着你不必清楚值，当它们不再需要时它们会自行消失。 mutable 和 immutable Python的数据类型可以分为原子类型和容器类器： 原子类型：string、number 容器类型：list、tuple、dict、set 原子类型只能保存一个值；容器类型则可以保存多个值。 虽然string可以包含多个字符，但Python中没有字符类型，因此字符串也属于原子类型。 Python对原子类型和容器类型的赋值方式都是一样的： 对于原子类型，name直接指向object 对于容器类器，name指向容器类型对象，容器的每一个元素指向各个元素对象 Python的数据类型还可以分为 immutable 和 mutable ： immutable object : string、tuple、number mutable object : list、dict、set 所谓的mutable、immutable是指name指向的object可不可以在原地址被修改。如果不可以在原地址修改，就只能在新地址创建新对象，name指向新对象（旧对象若没有引用，则会被内存回收机制销毁）： name = 10 print ( \"name的id：\" , id ( name )) name = 20 print ( \"name的id：\" , id ( name )) name的id： 140724285510752 name的id： 140724285511072 如果可以在原地址被修改，那么name的指向就不会改变（容器类型的对象实际上保存的是元素的引用）： name = [ 1 , 2 , 3 , 4 , 5 ] print ( \"name的值:\" , name , \" \" , \"name的id：\" , id ( name )) for num , i in enumerate ( name ): print ( f \"第 {num} 个元素的id\" , id ( i )) name [ 0 ] = 20 print ( \"name的值:\" , name , \" \" , \"name的id：\" , id ( name )) for num , i in enumerate ( name ): print ( f \"第 {num} 个元素的id\" , id ( i )) name的值: [1, 2, 3, 4, 5] name的id： 1441647216520 第0个元素的id 140724285510464 第1个元素的id 140724285510496 第2个元素的id 140724285510528 第3个元素的id 140724285510560 第4个元素的id 140724285510592 name的值: [20, 2, 3, 4, 5] name的id： 1441647216520 第0个元素的id 140724285511072 第1个元素的id 140724285510496 第2个元素的id 140724285510528 第3个元素的id 140724285510560 第4个元素的id 140724285510592 immutable的本质 神话：Python以不同的方式分配可变和不可变的值。 因为mutable对象是可变的，immutable对象不可变，人们可能会觉得mutable对象和immutable对象的值分配方式不一样。但事实上，mutable对象和immutable对象所有的赋值的方式都是一样的。 mutable、immutable只是python语言的一个规定。 从硬件角度说，硬件提供给用户的接口是按照规定设定好的。比如说，操作内存的方式是固定的，不存在可变和不可变。实现python的mutable、immutable就是调用了不同的底层API，或者是不同底层API相互组合来实现的。python将这些规定以python语法的形式提供给用户使用，最后还是编译成0、1去让计算机执行。对于用户来说，可变和不可变对象是语言提供的一个特性，可以完成一些功能，但是对于计算机其实是没区别的。 因此，mutable和immutable的本质区别是Python有没有提供修改值的方法。 不管是可变对象还是不可变对象，Python的赋值方式都是一样的，都是将对象绑定到名字（参见上面的图示和示例代码）。 赋值陷阱——浅拷贝和深拷贝 神话：值是有范围的。 在python中存在作用域这样的概念，人们可能会觉得作用域指的是值（对象）的作用范围，但事实上， 值是没有范围的，作用域指的是名称的作用范围。 我们可以定义一个简单的函数与验证这点。 def check_name_space_range ( x ): print ( \"x的内存地址是：\" + str ( id ( x ))) # 先在最外层的作用域赋值，并打印地址 a = 10 print ( \"a的内存地址是：\" + str ( id ( a ))) check_name_space_range ( a ) a的内存地址是：140724285510752 x的内存地址是：140724285510752 很明显，在内外层作用域的值都是同一个。 陷阱：因为值没有范围，并且赋值不会复制值，这就可能出现可变对象被意外地改变： def variable_change ( x ): x [ 0 ] = 10 return x a = [ 1 , 2 , 3 ] a_other = variable_change ( a ) print ( a ) print ( a_other ) [10, 2, 3] [10, 2, 3] 可以看到， a 、 a_other 都被改变了，因为 a 、 a_other 都是同一个对象。 print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) a的内存地址是：1441620592200 a_other的内存地址是：1441620592200 因此，如果要在函数里面更改可变对象参数的值，最好复制一个副本。 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ] = 10 else : pass return x a = [ 1 , 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [1, 2, 3] [10, 2, 3] a的内存地址是：1441623564040 a_other的内存地址是：1441647218056 a 的值并没有改变，上面的结果看似是没问题的，但还是会有新的”惊喜“。 我们来修改一下 variable_change_shallow 函数 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ][ 0 ] = 10 else : pass return x a = [[ 1 , 2 ], 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [[10, 2], 2, 3] [[10, 2], 2, 3] a的内存地址是：1441667197256 a_other的内存地址是：1441648401544 ”惊喜“就是 a 的值也改变了。因为 x.copy() 只是浅拷贝。 在python里面有三种方式去引用某个值： 引用另一个变量 浅拷贝 深拷贝 这三种方式是有区别的。 import copy a = [ 1 , 2 ,[ 1 , 2 ]] a_reference = a a_shallow = copy . copy ( a ) a_deep_copy = copy . deepcopy ( a ) 变量 a 和 a_reference 都是同一个对象的名称。 浅拷贝得到变量 a_shallow ，它是一个新对象，但 a_shallow 的第三个元素 a_shallow[2] 却是一个已经存在的对象，这和 a 、 a_reference 一样。 深拷贝得到变量 a_deep_copy ，它是一个新对象，并且它的每一个元素也是新的对象。 如果浅拷贝的对象包含了mutable对象，则mutable对象不会拷贝；而深拷贝则会完整拷贝对象。 赋值陷阱——引用不仅仅限于名称 以上所有示例都使用名称作为值的引用，但引用也可以是其他东西。 Python有许多复合数据结构，每个结构都包含对值的引用：列表元素，字典键和值，对象属性等。 其中每一个都可以在赋值符号的左侧使用，以上所有细节都适用于它们。 任何可以出现在赋值语句左侧的内容都是引用 ，在本文中说“名称”的任何地方都可以用“引用”替换。 在上面的示意图中，数字被显示为元素，但实际上，每个元素都是对数字的引用，因此它应该像这样绘制： nums = [ 1 , 2 , 3 ] 但这很快变得复杂，所以上面的绘图用了视觉速记： 如果你有列表元素引用其他可变值，例如子列表，请务必记住列表元素只是对值的引用。 这是一些其他assignment的例子。这些左侧中的每一个都是引用（reference）： my_obj . attr = 23 # 类属性 my_dict [ key ] = 24 # 字典 my_list [ index ] = 25 # 列表 my_obj . attr [ key ][ index ] . attr = \"etc, etc\" # 多个对象嵌套 i = x 指定了名称 i ，但 i[0] = x 并不是指定名称 i ，而是指定了 i 的值的第一个元素。 很多东西都是Assignment。 正如上面所说，许多东西都可以作为引用，python里面有很多东西可以作为assignments。 这些行中的每一行都是名称 X 的赋值： X = ... for X in ... [ ... for X in ... ] ( ... for X in ... ) { ... for X in ... } class X ( ... ): def X ( ... ): def fn ( X ): ... ; fn ( 12 ) with ... as X : except ... as X : import X from ... import X import ... as X from ... import ... as X 注意，我并不是说这些语句像assignments，我的意思是这些语句都是赋值。它们都使名称 X 引用某个值。上面所说的关于赋值的所有内容都适用于所有这些赋值。 在大多数情况下，这些语句将 X 定义在与语句相同的作用域内。Python 2和Python 3之间的细节略有不同。但它们都是真正的赋值，而且每个事实都是关于赋值适用于所有这些。 Python通过赋值来传递函数参数。 让我们来看看这些上面assignment列表中最有趣的一个：调用一个函数。当我定义一个函数时，我将其参数命名为： def my_func ( x , y ): return x + y 这里 x 和 y 是函数 my_func 的参数。当我调用 my_func 时，我提供了实际值作为函数的参数。这些值分配给 参数名称 ，就像使用了赋值语句一样： def my_func ( x , y ): return x + y print ( my_func ( 8 , 9 )) 17 调用 my_func 时，8被赋值给名称 x ，9被赋值给名称 y 。该赋值与我们一直在讨论的简单赋值语句完全相同。名称 x 和 y 是函数的本地名称（local），因此当函数返回时，这些名称就会消失。但是，如果它们引用的值仍然被其他名称引用，则值仍然存在。 就像所有其他赋值一样，可变值可以传递给函数，并且通过其所有名称可以看到对值的更改。这在<浅拷贝和深拷贝>中已经提到。 名称和值的一些细节 任何名称都可以随时引用任何值。 Python是动态类型的，这意味着名称没有类型。任何名称都可以随时引用任何值。名称可以引用整数，然后引用字符串，然后引用函数，然后引用模块。当然，这可能是一个非常混乱的程序，你不应该这样做，但Python语言不会介意。 名称没有类型，值没有范围。 正如名称没有类型一样，值也没有范围。当我们说一个函数有一个局部变量时，我们的意思是该名称的作用域是函数：你不能在函数外部使用该名称，当函数返回时，名称将被销毁。但是正如我们所看到的，如果名称的值具有其他引用，它将继续在函数调用之外。它是本地名称，而不是本地值。 值不能删除，只有名称可以删除。 Python的内存管理对其行为至关重要，你不仅不必删除值，而且无法删除值。 nums = [ 1 , 2 , 3 ] del nums 这不会删除值 nums ，它会删除名称 nums 。该名称将从其范围中删除，然后通常的引用计数开始执行：如果 nums 的值只有一个引用，则将回收该值。但如果它有其他引用，那么它不会被回收。 神话：Python没有变量。 有些人喜欢说，“Python没有变量，它有名字。”这个口号具有误导性。事实是Python有变量，它们的工作方式与C中的变量不同。 名称是Python的变量：它们引用值，并且这些值可以在程序的过程中发生变化（变化）。仅仅因为另一种语言（尽管是一种重要的语言）表现不同，没有理由将Python描述为没有变量。","text_tokens":["很多","意图","出现","对值","清除","然后","原","space","问题","大多数","收集","分配","该值","对于","不仅","不可","name","了","三个","不必","]","但","这个","类器","绘制","而是","可能","并","这样","语言","继续","为","理由","非常","同一","验证","应该","硬件","fn","\"","上面","change","12","实际上","使用","只能","tuple","其他","保存","没","上","该","完全","其",">","140724285510528","程序","、","底层","译成","属于","用户","编译","对","最好","函数调用","140724285511072","像","许多","地","#","已经","except","变","3","还是","它们","还","因为","多个","旧","结果","这里","只有","+","第一个","多数","关联","记住","规定","各个","另","计算机","在内","至关","误导","140724285510752","视觉","觉得","a","语法","使","不会","创建","一下","本质区别","人","dict","4","接口","中说","区别","返回","每","变量","完整","17","命名","分为","元素","）","key","完成","结构","内","介意","with","attr","表现","固定","其实","不再","指向","过程","[","复杂",";","代码","正如","永远","新","到","个","发生","拷贝","随时",",","assignment","嵌入","比如","第三","绘图","从","若","相互","请","每个","9","作为","deepcopy","事实上","相关联","存取","数据","局部变量","特定","编译成","2","尽管","示意图","组合","字典","意味","，","亦","定义","有","某个","一个","回收","24","说","做","嵌套","外部","这些","记忆","数据类型","修改","简单","140724285510464","关于","于","或者","“","人们","符号","虽然","字符","不仅仅","字符串","：","而且","1441648401544","示意","check","i","但是","不能","电脑","去","这点","所以","细节","管理","list","25","赋值","改变","独立","情况","可不","我","之外","可以","将","时","事实","行为","只是","东西","行中","重新分配","显示","参数","已有","set","variable","描述","提供","enumerate","常","所谓","直接","适用","跟踪","删除","而言","本文","先","重要","范围","大多","func","内容","真正","任何","例如","一般","23","y","c","里面","并且","你","消失","执行","要","调用","等","属性","语句","参考","我们","储存","略有","5","in","图","绑定","所","打印","中","动图","需要","不","是","不管","之间","具有","”","my","1441647218056","=","让","好","这","8","一些","失效","f","模块","工作","相关","str","混淆","复合","销毁","1","x","自动","浅","网页","变得","用","容器","略有不同","或","包含","copy","发生变化","—","形式","示例","140724285510496","会","def","程式","参见","直到","python","1441620592200","不是","pass","指","链接","资料","本地","都","得到","range","mutable","其中","as","也","变化","1441667197256","被","则","清楚","的","isinstance","务必","外层","替换","可变","注意","存在","类型","而","这种","容易","图示","实体"," ","至关重要","间接","看看","更改","local","口号","以","自行","}","引用","右侧","它会","设定","；","来说","机制","称为","else","nums","多少","如果","特性","喜欢","意味着","比如说","num","角度","shallow","讨论","obj","以上","一直","return","和","有没有","(","指标","一行","<","10","object","不同","传","子","很快","import","一般而言","方法","140724285510592","就是","本质","速记","神话",")","值有","有些","etc","id",".","同一个","动态","例子","三种","指定","来","当","在","操作","无法","print","原子","。","复制","深","数字","与","却是","看到","列表","就","内存","给","仅仅","名称","当然","很","下次","中一","index","功能","副本","...","传递","重新","del","即","意思","20","value","reference","0","number","api","140724285510560","这是","陷阱","other","对象","方式","那么","类","按照","名字","地址","class","一种","最后","有趣","局部","{","assignments","所说","通过","_","可不可以","for","地方","传递函数","视为","计数","装置","函数","实现","左侧","那样","内存地址","if","deep","最",":","第三个","from","看似","数据结构","完全相同","便","它","仍然","变得复杂","没有","一样","算机","计算","概念","1441623564040","第一","1441647216520","提到","第","开始","因此","immutable","限于","明显","两个","作用域","生变","值","误导性","当值","作用","导致","意外","相同","并打印","以下","string","混乱","下","通常","惊喜","所有","垃圾","实际","整数","记忆体","（","键和值","位址"],"title":"2.8.赋值、immutable、深拷贝","title_tokens":["拷贝","赋值","2.8",".","immutable","深","、"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#_1","text":"引用（reference） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。 一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。因此，引用亦常被称为该资料的指标或位址。 Python的赋值都是传引用，即name是value的引用。 在python里面，一个变量保存的值是某个对象的引用。Python赋值语句将左侧的符号名称与右侧的值 相关联 。在Python中，我们说名称引用值，或者名称是对值的引用。 下次我们使用这个名称时，便得到与名称相关联的值。 assignment永远不会复制数据，并且多个name可以引用同一个value。 当值具有多个名称时，很容易混淆并将其视为两个名称和两个值。： x = 23 y = x 但将已有的变量赋值给新变量时，Python永远不会复制值。分配只是使左侧的名称引用右侧的值。在这种情况下，我们只有一个23， x 和 y 都引用它，就像我们在上图中看到的那样。 名称是独立于其他名称重新分配的。 如果两个名称引用相同的值，则不会链接这两个名称。重新分配其中一个不会导致另一个也被重新分配： x = 23 y = x x = 12 如果上面嵌入的网页失效，可以参考以下动图： 值一直存在，直到没有名称引用它。 Python会跟踪每个值有多少引用，并自动清除没有引用的值。这被称为“垃圾收集”，意味着你不必清楚值，当它们不再需要时它们会自行消失。","text_tokens":["需要","assignment","传","嵌入","是","对值","清除","一般而言","具有","”","每个","=","让","收集","这","值有","分配","相关联","存取","数据","失效","同一个","特定","name","当","在","相关","混淆","。","不必","复制","x","自动","网页","意味","但","与","这个","看到","，","就","给","亦","名称","某个","一个","并","很","下次","中一","或","说","同一","会","上面","记忆","重新","12","即","程式","使用","直到","于","python","或者","其他","value","保存","上","“","该","reference","其","链接","资料","符号","都","：","得到","像","对象","其中","也","电脑","它们","多个","只有","关联","被","赋值","则","另","独立","情况","清楚","的","可以","将","时","视为","装置","只是","左侧","重新分配","使","那样","不会","已有","存在","记忆体","常","便","这种","它","变量","容易","实体"," ","没有","跟踪","而言","间接","）","一般","23","y","自行","引用","右侧","里面","不再","并且","因此","你","消失","两个","称为","值","语句","参考","我们","当值","如果","多少","储存","永远","导致","意味着","新","相同","以下","一直","图","和","下","指标","垃圾","中","动图","（","位址"],"title":"赋值","title_tokens":["赋值"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#mutable-immutable","text":"Python的数据类型可以分为原子类型和容器类器： 原子类型：string、number 容器类型：list、tuple、dict、set 原子类型只能保存一个值；容器类型则可以保存多个值。 虽然string可以包含多个字符，但Python中没有字符类型，因此字符串也属于原子类型。 Python对原子类型和容器类型的赋值方式都是一样的： 对于原子类型，name直接指向object 对于容器类器，name指向容器类型对象，容器的每一个元素指向各个元素对象 Python的数据类型还可以分为 immutable 和 mutable ： immutable object : string、tuple、number mutable object : list、dict、set 所谓的mutable、immutable是指name指向的object可不可以在原地址被修改。如果不可以在原地址修改，就只能在新地址创建新对象，name指向新对象（旧对象若没有引用，则会被内存回收机制销毁）： name = 10 print ( \"name的id：\" , id ( name )) name = 20 print ( \"name的id：\" , id ( name )) name的id： 140724285510752 name的id： 140724285511072 如果可以在原地址被修改，那么name的指向就不会改变（容器类型的对象实际上保存的是元素的引用）： name = [ 1 , 2 , 3 , 4 , 5 ] print ( \"name的值:\" , name , \" \" , \"name的id：\" , id ( name )) for num , i in enumerate ( name ): print ( f \"第 {num} 个元素的id\" , id ( i )) name [ 0 ] = 20 print ( \"name的值:\" , name , \" \" , \"name的id：\" , id ( name )) for num , i in enumerate ( name ): print ( f \"第 {num} 个元素的id\" , id ( i )) name的值: [1, 2, 3, 4, 5] name的id： 1441647216520 第0个元素的id 140724285510464 第1个元素的id 140724285510496 第2个元素的id 140724285510528 第3个元素的id 140724285510560 第4个元素的id 140724285510592 name的值: [20, 2, 3, 4, 5] name的id： 1441647216520 第0个元素的id 140724285511072 第1个元素的id 140724285510496 第2个元素的id 140724285510528 第3个元素的id 140724285510560 第4个元素的id 140724285510592","text_tokens":["不","是","原","140724285510592","若","=",")","对于","数据","id","f","不可","name","2","在","print","原子","。","销毁","1","]","但","类器","，","就","内存","一个","容器","回收","包含","140724285510496","\"","会","数据类型","修改","实际上","140724285510464","20","python","只能","tuple","保存","0","140724285510528","number","指","140724285510560","、","虽然","字符","属于","都","字符串","：","对","140724285511072","i","对象","方式","那么","mutable","也","3","地址","还","多个","旧","object","list","{","赋值","各个","被","则","可不可以","改变","for","可不","140724285510752","的","可以","不会","创建","类型","set","dict",":","4","enumerate","每","所谓","直接"," ","没有","分为","一样","元素","）","}","1441647216520","引用","指向","第","因此","[","immutable","；","机制","值","如果","新","5","in","个","num","string",",","和","(","实际","10","中","（"],"title":"mutable 和 immutable","title_tokens":["和","mutable","immutable"," "]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#immutable","text":"神话：Python以不同的方式分配可变和不可变的值。 因为mutable对象是可变的，immutable对象不可变，人们可能会觉得mutable对象和immutable对象的值分配方式不一样。但事实上，mutable对象和immutable对象所有的赋值的方式都是一样的。 mutable、immutable只是python语言的一个规定。 从硬件角度说，硬件提供给用户的接口是按照规定设定好的。比如说，操作内存的方式是固定的，不存在可变和不可变。实现python的mutable、immutable就是调用了不同的底层API，或者是不同底层API相互组合来实现的。python将这些规定以python语法的形式提供给用户使用，最后还是编译成0、1去让计算机执行。对于用户来说，可变和不可变对象是语言提供的一个特性，可以完成一些功能，但是对于计算机其实是没区别的。 因此，mutable和immutable的本质区别是Python有没有提供修改值的方法。 不管是可变对象还是不可变对象，Python的赋值方式都是一样的，都是将对象绑定到名字（参见上面的图示和示例代码）。","text_tokens":["不同","比如","不","是","方法","不管","就是","从","本质","相互","神话","让","好","分配","事实上","对于","一些","编译成","不可","了","来","操作","组合","。","1","但","，","内存","给","一个","可能","语言","说","功能","形式","硬件","示例","会","这些","上面","修改","参见","使用","python","或者","没","人们","0","api","、","底层","译成","编译","都","用户","：","对象","方式","但是","mutable","按照","变","还是","名字","去","因为","最后","规定","赋值","计算机","的","事实","将","可以","觉得","只是","可变","实现","语法","存在","本质区别","接口","提供","区别","图示"," ","没有","一样","算机","计算","）","完成","以","固定","其实","因此","执行","设定","immutable","调用","来说","代码","值","特性","比如说","到","角度","绑定","和","有没有","所有","（"],"title":"immutable的本质","title_tokens":["本质","的","immutable"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#_2","text":"神话：值是有范围的。 在python中存在作用域这样的概念，人们可能会觉得作用域指的是值（对象）的作用范围，但事实上， 值是没有范围的，作用域指的是名称的作用范围。 我们可以定义一个简单的函数与验证这点。 def check_name_space_range ( x ): print ( \"x的内存地址是：\" + str ( id ( x ))) # 先在最外层的作用域赋值，并打印地址 a = 10 print ( \"a的内存地址是：\" + str ( id ( a ))) check_name_space_range ( a ) a的内存地址是：140724285510752 x的内存地址是：140724285510752 很明显，在内外层作用域的值都是同一个。 陷阱：因为值没有范围，并且赋值不会复制值，这就可能出现可变对象被意外地改变： def variable_change ( x ): x [ 0 ] = 10 return x a = [ 1 , 2 , 3 ] a_other = variable_change ( a ) print ( a ) print ( a_other ) [10, 2, 3] [10, 2, 3] 可以看到， a 、 a_other 都被改变了，因为 a 、 a_other 都是同一个对象。 print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) a的内存地址是：1441620592200 a_other的内存地址是：1441620592200 因此，如果要在函数里面更改可变对象参数的值，最好复制一个副本。 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ] = 10 else : pass return x a = [ 1 , 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [1, 2, 3] [10, 2, 3] a的内存地址是：1441623564040 a_other的内存地址是：1441647218056 a 的值并没有改变，上面的结果看似是没问题的，但还是会有新的”惊喜“。 我们来修改一下 variable_change_shallow 函数 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ][ 0 ] = 10 else : pass return x a = [[ 1 , 2 ], 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [[10, 2], 2, 3] [[10, 2], 2, 3] a的内存地址是：1441667197256 a_other的内存地址是：1441648401544 ”惊喜“就是 a 的值也改变了。因为 x.copy() 只是浅拷贝。 在python里面有三种方式去引用某个值： 引用另一个变量 浅拷贝 深拷贝 这三种方式是有区别的。 import copy a = [ 1 , 2 ,[ 1 , 2 ]] a_reference = a a_shallow = copy . copy ( a ) a_deep_copy = copy . deepcopy ( a ) 变量 a 和 a_reference 都是同一个对象的名称。 浅拷贝得到变量 a_shallow ，它是一个新对象，但 a_shallow 的第三个元素 a_shallow[2] 却是一个已经存在的对象，这和 a 、 a_reference 一样。 深拷贝得到变量 a_deep_copy ，它是一个新对象，并且它的每一个元素也是新的对象。 如果浅拷贝的对象包含了mutable对象，则mutable对象不会拷贝；而深拷贝则会完整拷贝对象。","text_tokens":["第三","出现","import","是","”","space","问题","就是","1441647218056","神话","=",")","这","deepcopy","事实上","id",".","同一个","三种","name","2","了","来","三个","在","print","str","。","复制","1","x","浅","深","]","但","与","却是","看到","，","就","内存","定义","名称","有","某个","一个","可能","并","这样","很","包含","copy","同一","验证","副本","\"","会","上面","change","简单","修改","def","python","1441620592200","没","“","人们","reference","0","pass","指","、","都","最好","：","陷阱","1441648401544","得到","check","other","range","对象","方式","mutable","地","#","已经","也","还是","3","地址","去","这点","因为","结果","1441667197256","+","list","赋值","被","改变","_","另","则","在内","140724285510752","的","事实","可以","isinstance","觉得","函数","外层","a","只是","可变","不会","参数","存在","内存地址","variable","if","一下","最","deep",":","区别","而","第三个","每","看似","它","变量","完整"," ","没有","一样","先","元素","范围","）","更改","概念","1441623564040","引用","里面","并且","因此","[","要","明显","；","作用域","值","else","我们","如果","作用","意外","新","并打印","shallow","拷贝","return",",","和","惊喜","(","打印","中","10","（"],"title":"赋值陷阱——浅拷贝和深拷贝","title_tokens":["拷贝","和","陷阱","赋值","浅","—","深"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#_3","text":"以上所有示例都使用名称作为值的引用，但引用也可以是其他东西。 Python有许多复合数据结构，每个结构都包含对值的引用：列表元素，字典键和值，对象属性等。 其中每一个都可以在赋值符号的左侧使用，以上所有细节都适用于它们。 任何可以出现在赋值语句左侧的内容都是引用 ，在本文中说“名称”的任何地方都可以用“引用”替换。 在上面的示意图中，数字被显示为元素，但实际上，每个元素都是对数字的引用，因此它应该像这样绘制： nums = [ 1 , 2 , 3 ] 但这很快变得复杂，所以上面的绘图用了视觉速记： 如果你有列表元素引用其他可变值，例如子列表，请务必记住列表元素只是对值的引用。 这是一些其他assignment的例子。这些左侧中的每一个都是引用（reference）： my_obj . attr = 23 # 类属性 my_dict [ key ] = 24 # 字典 my_list [ index ] = 25 # 列表 my_obj . attr [ key ][ index ] . attr = \"etc, etc\" # 多个对象嵌套 i = x 指定了名称 i ，但 i[0] = x 并不是指定名称 i ，而是指定了 i 的值的第一个元素。 很多东西都是Assignment。 正如上面所说，许多东西都可以作为引用，python里面有很多东西可以作为assignments。 这些行中的每一行都是名称 X 的赋值： X = ... for X in ... [ ... for X in ... ] ( ... for X in ... ) { ... for X in ... } class X ( ... ): def X ( ... ): def fn ( X ): ... ; fn ( 12 ) with ... as X : except ... as X : import X from ... import X import ... as X from ... import ... as X 注意，我并不是说这些语句像assignments，我的意思是这些语句都是赋值。它们都使名称 X 引用某个值。上面所说的关于赋值的所有内容都适用于所有这些赋值。 在大多数情况下，这些语句将 X 定义在与语句相同的作用域内。Python 2和Python 3之间的细节略有不同。但它们都是真正的赋值，而且每个事实都是关于赋值适用于所有这些。 Python通过赋值来传递函数参数。 让我们来看看这些上面assignment列表中最有趣的一个：调用一个函数。当我定义一个函数时，我将其参数命名为： def my_func ( x , y ): return x + y 这里 x 和 y 是函数 my_func 的参数。当我调用 my_func 时，我提供了实际值作为函数的参数。这些值分配给 参数名称 ，就像使用了赋值语句一样： def my_func ( x , y ): return x + y print ( my_func ( 8 , 9 )) 17 调用 my_func 时，8被赋值给名称 x ，9被赋值给名称 y 。该赋值与我们一直在讨论的简单赋值语句完全相同。名称 x 和 y 是函数的本地名称（local），因此当函数返回时，这些名称就会消失。但是，如果它们引用的值仍然被其他名称引用，则值仍然存在。 就像所有其他赋值一样，可变值可以传递给函数，并且通过其所有名称可以看到对值的更改。这在<浅拷贝和深拷贝>中已经提到。","text_tokens":["很多","不同","assignment","子","意图","绘图","很快","时","出现","import","是","对值","之间","”","my","速记","请","每个","=","让","大多数","9","作为","这",")","分配","etc","8","一些","数据",".","例子","2","指定","了","来","当","在","示意图","print","复合","。","1","x","浅","深","字典","]","但","数字","变得","与","列表","，","看到","就","给","定义","名称","有","绘制","用","某个","一个","而是","并","略有不同","这样","24","为","index","说","包含","...","应该","嵌套","fn","传递","示例","\"","上面","这些","会","简单","def","12","实际上","关于","使用","意思","于","python","其他","“","该","完全","reference","不是","其","0",">","符号","这是","本地","都","而且","：","对","示意","像","i","对象","许多","但是","其中","#","类","as","也","except","已经","3","class","它们","所以","多个","细节","这里","有趣","第一个","+","多数","list","assignments","记住","25","所说","赋值","被","{","_","通过","则","for","情况","我","地方","的","可以","将","视觉","务必","事实","函数","传递函数","东西","替换","可变","只是","左侧","行中","注意","使","显示","参数","存在","最","dict",":","中说","提供","返回","from","每","数据结构","完全相同","它","仍然","适用","变得复杂","17"," ","命名","一样","本文","元素","大多","func","）","key","看看","更改","结构","内容","真正","任何","local","内","with","例如","attr","23","第一","y","}","提到","引用","里面","并且","因此","你","消失","[","复杂","等","调用",";","正如","作用域","属性","值","语句","nums","我们","如果","作用","略有","相同","in","讨论","拷贝","obj","以上","return","一直",",","下","和","所有","(","实际","一行","<","中","（","键和值"],"title":"赋值陷阱——引用不仅仅限于名称","title_tokens":["引用","不仅仅","陷阱","仅仅","赋值","名称","限于","—","不仅"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#_4","text":"任何名称都可以随时引用任何值。 Python是动态类型的，这意味着名称没有类型。任何名称都可以随时引用任何值。名称可以引用整数，然后引用字符串，然后引用函数，然后引用模块。当然，这可能是一个非常混乱的程序，你不应该这样做，但Python语言不会介意。 名称没有类型，值没有范围。 正如名称没有类型一样，值也没有范围。当我们说一个函数有一个局部变量时，我们的意思是该名称的作用域是函数：你不能在函数外部使用该名称，当函数返回时，名称将被销毁。但是正如我们所看到的，如果名称的值具有其他引用，它将继续在函数调用之外。它是本地名称，而不是本地值。 值不能删除，只有名称可以删除。 Python的内存管理对其行为至关重要，你不仅不必删除值，而且无法删除值。 nums = [ 1 , 2 , 3 ] del nums 这不会删除值 nums ，它会删除名称 nums 。该名称将从其范围中删除，然后通常的引用计数开始执行：如果 nums 的值只有一个引用，则将回收该值。但如果它有其他引用，那么它不会被回收。 神话：Python没有变量。 有些人喜欢说，“Python没有变量，它有名字。”这个口号具有误导性。事实是Python有变量，它们的工作方式与C中的变量不同。 名称是Python的变量：它们引用值，并且这些值可以在程序的过程中发生变化（变化）。仅仅因为另一种语言（尽管是一种重要的语言）表现不同，没有理由将Python描述为没有变量。","text_tokens":["不同","不","是","然后","具有","从","”","神话","=","这","该值","有些","模块","动态","局部变量","不仅","2","尽管","当","工作","在","无法","。","销毁","不必","1","意味","]","但","这个","与","看到","，","内存","仅仅","名称","有","当然","一个","可能","回收","这样","语言","继续","理由","为","说","非常","做","发生变化","应该","外部","这些","del","意思","使用","python","其他","“","该","不是","其","程序","本地","字符","都","字符串","：","函数调用","对","而且","那么","但是","方式","不能","也","3","名字","一种","它们","因为","变化","管理","局部","只有","被","则","另","至关","误导","之外","的","可以","时","将","行为","函数","计数","事实","不会","类型","描述","人","而","返回","它","变量"," ","没有","删除","一样","至关重要","重要","范围","）","口号","任何","介意","表现","c","引用","它会","过程","并且","开始","你","执行","[","调用","正如","作用域","生变","值","误导性","我们","nums","如果","喜欢","作用","意味着","发生","随时","混乱","所",",","通常","整数","中","（"],"title":"名称和值的一些细节","title_tokens":["细节","值","和","名称","一些","的"]},{"location":"Python基础/2.9.函数.html","text":"函数 关键字 def 引入了一个函数定义。后面必须跟上函数名和在圆括号里的参数序列。函数体从第一行开始，并且一定要缩进。 def func (): pass 函式体的第一个语句可以是字串。这个字串就是函式的文档字符串，或称为 docstring。有很多能将文档字串自动转换为在线或可打印文档的工具，或让用户在代码中交互地浏览它的工具。 执行函数会引入局部命名空间。所有在函数中被赋值的变量和值都将存储在局部命名空间中。 变量引用会首先在函数的局部命名空间里寻找，然后才是闭包函数的局部命名空间，再然后是全局命名空间，最后是内置命名空间。在函数中可以引用全局变量，但是不可直接赋值 (除非用 global 语句进行声明)。 具体细节参考 命名空间和作用域。 根据其它语言的经验，你可能会指出 fib 不是一个函数，而是一个程序，因为它不返回值。事实上，即使没有写 return 语句的函数也会返回一个值—— None 。如果要唯一输出的值是 None，那么解释器会正当的抑制这次返回。如你实在想看看这个值，可以使用 print() 函数。 return 语句从函式中返回一个值。没有表达式参数的 return 语句返回 None。直到函式结束也没有 return 语句也返回 。 函数传参 刚学Python的人可能会疑惑，Python函数传参，到底是传值，还是传引用？ 答案很直接，Python函数传参永远都是传引用。 实际上，Python函数传参就是赋值，所以传参的行为和赋值的行为是一样的。在对可变对象的参数进行操作前，最好先深拷贝参数的值，否则可能会影响全局变量。 参数 函数有四种参数概念：位置参数、默认参数、关键字参数、可变参数。 函数有三种合法调用形式： 仅给出强制参数 给出所有强制参数和部分可选参数 给出所有参数 位置参数 调用函数时可以省略形参名字，根据函数定义的参数位置来传递参数。传入的参数顺序必须和定义参数的顺序一致，且少一个参数都不可以。 def print_hello ( name , sex ): sex_dict = { 1 : u '先生' , 2 : u '女士' } print ( 'hello %s %s , welcome to python world!' % ( name , sex_dict . get ( sex , u '先生' ))) print_hello ( 'Jack' , 1 ) hello Jack 先生, welcome to python world! 关键字参数 函数调用时，可以通过“键=值”形式指定。这可以让函数更加清晰、容易使用，同时关键字参数不需要按顺序指定。 # 以下是用关键字参数正确调用函数的实例 print_hello ( 'tanggu' , sex = 1 ) print_hello ( name = 'tanggu' , sex = 1 ) print_hello ( sex = 1 , name = 'tanggu' ) hello tanggu 先生, welcome to python world! hello tanggu 先生, welcome to python world! hello tanggu 先生, welcome to python world! # 以下是错误的调用方式 print_hello ( 1 , name = 'tanggu' ) print_hello ( name = 'tanggu' , 1 ) print_hello ( sex = 1 , 'tanggu' ) 通过上面的代码可以发现： 有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序的 。 默认参数 用于定义函数，为参数提供默认值，调用函数时可传可不传该默认参数的值。 注意：所有位置参数必须出现在默认参数前，包括函数定义和调用。 # 正确的默认参数定义方式--> 位置参数在前，默认参数在后 def print_hello ( name , sex = 1 ): .... # 错误的定义方式 def print_hello ( sex = 1 , name ): .... # 调用时不传sex的值，则使用默认值1 # print_hello('tanggu') # 调用时传入sex的值，并指定为2 # print_hello('tanggu', 2) 可变参数 定义函数时，有时候我们不确定调用的时候会传递多少个参数（不传参也可以）。此时，可用包裹（packing）位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。 包裹位置传递 def func ( * args ): .... ↓ # func() # func(a) # func(a, b, c) 我们传进的所有参数都会被 args 变量收集，它会根据传进参数的位置合并为一个元组(tuple)， args 是元组类型，这就是包裹位置传递。 包裹关键字传递 def func ( ** kargs ): .... ↓ # func(a=1) # func(a=1, b=2, c=3) kargs是一个字典(dict)，收集所有关键字参数 解包裹参数 * 和 ** ，也可以在函数调用的时候使用，称之为解包裹(unpacking) 在传递元组时，让元组的每一个元素对应一个位置参数 def print_hello ( name , sex ): print name , sex # args = ('tanggu', '男') # print_hello(*args) # tanggu 男 在传递字典时，让字典的每个键值对作为一个关键字参数传递给函数 def print_hello ( kargs ): print kargs # kargs = {'name': 'tanggu', 'sex', u'男'} # print_hello(**kargs) # {'name': 'tanggu', 'sex', u'男'} 位置参数、默认参数、可变参数的混合使用 顺序是：位置参数、默认参数、包裹位置、包裹关键字，定义和调用都应遵循这个顺序。 def func ( name , age , sex = 1 , * args , ** kargs ): print name , age , sex , args , kargs # func('tanggu', 25, 2, 'music', 'sport', class=2) # tanggu 25 1 ('music', 'sport') {'class'=2}","text_tokens":["很多","对应","出现","然后","!","sex","args","收集","女士","函式体","不可","name","了","存储","到底","传入","但","这个","跟上","hello","时候","而是","可能","仅","时可传","并","语言","music","为","第一行","非常","后面","上面","传该","里","实际上","使用","抑制","这次","-","tuple","空间",">","程序","、","用户","最好","对","函数调用","默认","地","#","位置","还是","3","因为","部分","第一个","圆括号","包裹","to","四种","闭包","a","浏览","unpacking","人","dict","返回","实在","每","变量","....","传进","命名","字串","元素","唯一","）","fib","*","形参","docstring","刚学","packing","指出","代码","永远","称之为","个","显得","拷贝","不传",",","此时","传值","全局变量","工具","从","每个","表达","作为","事实上","且","选","2","正确","寻找","先深","确定","字典","，","合法","welcome","定义","有","调用函数","一个","名","省略","sport","全局","否则","表达式","可传","想","前","之为","首先","答案","具体","或者","一定","“","解释","影响","默认值","字符","字符串","：","但是","结束","声明","age","所以","细节","即使","25","赋值","关键字","可不","可以","将","事实","时","行为","引入","%","参数","可","可用","提供","写","直接","男","解释器","给出","func","↓","返回值","？","文档","c","并且","释器","执行","你","要","有时","调用","发现","语句","参考","我们","进行","内置","如","打印","中","需要","不","包括","是","经验","其它","之间","”","参数传递","=","让","才","这","操作前","关键","函式","实例","1","自动","先生","键值","用","一致","体从","或","—","形式","解","会","def","错误","直到","python","序列","根据","不是","pass","输出","更加","都","疑惑","也","被","缩进","清晰","则","jack","的","global","永远都是","可变","注意","遵循","存在","类型","按","顺序","容易","先后顺序"," ","键","交互","看看","括号","}","引用","它会","称为","s","如果","多少","return","和","(","一行","kargs","传","就是",")","有时候","达式",".","三种","b","指定","来","在","操作","print","。","给","后","'","很","再","传递","tanggu","world","时不传","传参","元组","用于","前面","对象","那么","方式","强制","名字","同时","class","u","最后","先后","局部","少","{","通过","_","函数","除非",":","方便","它","参","没有","在线","一样","概念","合并","第一","数传","none","开始","混合","get","应","作用域","必须","值","能","转换","作用","以下","正当","所有","实际","（"],"title":"2.9.函数","title_tokens":["2.9",".","函数"]},{"location":"Python基础/2.9.函数.html#_1","text":"关键字 def 引入了一个函数定义。后面必须跟上函数名和在圆括号里的参数序列。函数体从第一行开始，并且一定要缩进。 def func (): pass 函式体的第一个语句可以是字串。这个字串就是函式的文档字符串，或称为 docstring。有很多能将文档字串自动转换为在线或可打印文档的工具，或让用户在代码中交互地浏览它的工具。 执行函数会引入局部命名空间。所有在函数中被赋值的变量和值都将存储在局部命名空间中。 变量引用会首先在函数的局部命名空间里寻找，然后才是闭包函数的局部命名空间，再然后是全局命名空间，最后是内置命名空间。在函数中可以引用全局变量，但是不可直接赋值 (除非用 global 语句进行声明)。 具体细节参考 命名空间和作用域。 根据其它语言的经验，你可能会指出 fib 不是一个函数，而是一个程序，因为它不返回值。事实上，即使没有写 return 语句的函数也会返回一个值—— None 。如果要唯一输出的值是 None，那么解释器会正当的抑制这次返回。如你实在想看看这个值，可以使用 print() 函数。 return 语句从函式中返回一个值。没有表达式参数的 return 语句返回 None。直到函式结束也没有 return 语句也返回 。","text_tokens":["很多","全局变量","不","是","然后","经验","工具","其它","就是","从","表达","让","才",")","事实上","达式","函式体","不可","了","寻找","在","存储","print","关键","函式","。","自动","这个","跟上","，","定义","有","用","一个","名","可能","而是","全局","语言","为","体从","第一行","或","表达式","再","后面","—","想","会","里","def","首先","使用","抑制","这次","直到","序列","根据","具体","一定","不是","空间","pass","程序","解释","输出","字符","用户","字符串","都","那么","但是","地","也","结束","声明","因为","最后","细节","局部","即使","第一个","圆括号","被","赋值","关键字","缩进","闭包","的","可以","将","global","事实","函数","引入","除非","参数","浏览","可",":","返回","写","实在","直接","它","变量","解释器"," ","没有","命名","在线","字串","交互","唯一","func","看看","fib","括号","返回值","文档","docstring","第一","引用","none","并且","开始","指出","释器","执行","你","要","代码","作用域","称为","必须","语句","能","转换","值","参考","如果","作用","进行","内置","正当","return","和","如","所有","(","一行","打印","中"],"title":"函数","title_tokens":["函数"]},{"location":"Python基础/2.9.函数.html#_2","text":"刚学Python的人可能会疑惑，Python函数传参，到底是传值，还是传引用？ 答案很直接，Python函数传参永远都是传引用。 实际上，Python函数传参就是赋值，所以传参的行为和赋值的行为是一样的。在对可变对象的参数进行操作前，最好先深拷贝参数的值，否则可能会影响全局变量。","text_tokens":["一样","否则","传值","还是","很","传","全局变量","是","所以","？","就是","刚学","引用","会","操作前","赋值","实际上","传参","的","永远都是","行为","函数","python","答案","可变","值","在","操作","参数","到底","永远","。","先深","人","进行","拷贝","影响","，","最好","直接","和","对","变量","疑惑","实际"," ","对象","可能","全局"],"title":"函数传参","title_tokens":["传参","函数"]},{"location":"Python基础/2.9.函数.html#_3","text":"函数有四种参数概念：位置参数、默认参数、关键字参数、可变参数。 函数有三种合法调用形式： 仅给出强制参数 给出所有强制参数和部分可选参数 给出所有参数","text_tokens":["位置","强制","概念","形式","部分","四种","关键字","调用","三种","选","函数","可变","关键","参数","。","可","、","合法","和","：","所有","有","给出","默认"," ","仅"],"title":"参数","title_tokens":["参数"]},{"location":"Python基础/2.9.函数.html#_4","text":"调用函数时可以省略形参名字，根据函数定义的参数位置来传递参数。传入的参数顺序必须和定义参数的顺序一致，且少一个参数都不可以。 def print_hello ( name , sex ): sex_dict = { 1 : u '先生' , 2 : u '女士' } print ( 'hello %s %s , welcome to python world!' % ( name , sex_dict . get ( sex , u '先生' ))) print_hello ( 'Jack' , 1 ) hello Jack 先生, welcome to python world!","text_tokens":["'","位置","名字","不","u","形参","!","传递","少","=","sex","}",")","{","to","女士","且","_",".","def","world","get","调用","jack","的","时","可以","name","2","函数","来","python","根据","必须","%","s","print","参数","。","1",":","传入","dict","顺序","先生","，","hello","welcome","都","和",",","定义","(","调用函数","一致","一个"," ","省略"],"title":"位置参数","title_tokens":["位置","参数"]},{"location":"Python基础/2.9.函数.html#_5","text":"函数调用时，可以通过“键=值”形式指定。这可以让函数更加清晰、容易使用，同时关键字参数不需要按顺序指定。 # 以下是用关键字参数正确调用函数的实例 print_hello ( 'tanggu' , sex = 1 ) print_hello ( name = 'tanggu' , sex = 1 ) print_hello ( sex = 1 , name = 'tanggu' ) hello tanggu 先生, welcome to python world! hello tanggu 先生, welcome to python world! hello tanggu 先生, welcome to python world! # 以下是错误的调用方式 print_hello ( 1 , name = 'tanggu' ) print_hello ( name = 'tanggu' , 1 ) print_hello ( sex = 1 , 'tanggu' ) 通过上面的代码可以发现： 有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序的 。","text_tokens":["需要","'","位置","同时","不","是","之间","#","”","形式","!","先后","=","让","sex",")","这","通过","to","上面","tanggu","关键字","清晰","_","world","调用","的","可以","时","使用","name","指定","函数","正确","python","错误","值","必须","在","发现","print","关键","参数","存在","“","。","实例","1","按","但","、","顺序","以下","更加","，","先生","前面","hello","welcome","函数调用",",","：","容易","(","有","先后顺序","用","调用函数"," ","方式","键","代码"],"title":"关键字参数","title_tokens":["关键字","关键","参数"]},{"location":"Python基础/2.9.函数.html#_6","text":"用于定义函数，为参数提供默认值，调用函数时可传可不传该默认参数的值。 注意：所有位置参数必须出现在默认参数前，包括函数定义和调用。 # 正确的默认参数定义方式--> 位置参数在前，默认参数在后 def print_hello ( name , sex = 1 ): .... # 错误的定义方式 def print_hello ( sex = 1 , name ): .... # 调用时不传sex的值，则使用默认值1 # print_hello('tanggu') # 调用时传入sex的值，并指定为2 # print_hello('tanggu', 2)","text_tokens":["'","位置","为","出现","包括","#","可传","=","sex",")","并","传该","前","tanggu","_","则","def","时不传","可不","调用","的","使用","错误","时","name","正确","函数","-","指定","2","值","必须","用于","在","注意","print","参数","。","1",">",":","传入","提供","，","默认值","hello",",","和","：","定义","所有","(","调用函数","默认"," ","方式","....","后","时可传"],"title":"默认参数","title_tokens":["参数","默认"]},{"location":"Python基础/2.9.函数.html#_7","text":"定义函数时，有时候我们不确定调用的时候会传递多少个参数（不传参也可以）。此时，可用包裹（packing）位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。","text_tokens":["也","位置","）","不","非常","参数传递","传递","packing","数传","会","包裹","有时候","关键字","有时","调用","的","时","可以","函数","来","我们","多少","或者","关键","参数","。","进行","确定","可用","个","方便","显得","，","不传","定义","此时","时候","参","（"],"title":"可变参数","title_tokens":["参数","可变"]},{"location":"Python基础/2.9.函数.html#_8","text":"def func ( * args ): .... ↓ # func() # func(a) # func(a, b, c) 我们传进的所有参数都会被 args 变量收集，它会根据传进参数的位置合并为一个元组(tuple)， args 是元组类型，这就是包裹位置传递。","text_tokens":["位置","为","func","↓","*","是","就是","传递","合并","args","c","收集",")","它会","这","会","包裹","被","def","b","的","元组","a","根据","tuple","我们","参数","类型","。",":","，",",","都","所有","(","....","变量"," ","一个","传进","#"],"title":"包裹位置传递","title_tokens":["包裹","位置","传递"]},{"location":"Python基础/2.9.函数.html#_9","text":"def func ( ** kargs ): .... ↓ # func(a=1) # func(a=1, b=2, c=3) kargs是一个字典(dict)，收集所有关键字参数","text_tokens":["3","func","↓","*","是","=","c","收集",")","关键字","def","b","2","a","关键","参数","1",":","字典","dict","，",",","所有","("," ","一个","....","kargs","#"],"title":"包裹关键字传递","title_tokens":["关键字","包裹","传递","关键"]},{"location":"Python基础/2.9.函数.html#_10","text":"* 和 ** ，也可以在函数调用的时候使用，称之为解包裹(unpacking) 在传递元组时，让元组的每一个元素对应一个位置参数 def print_hello ( name , sex ): print name , sex # args = ('tanggu', '男') # print_hello(*args) # tanggu 男 在传递字典时，让字典的每个键值对作为一个关键字参数传递给函数 def print_hello ( kargs ): print kargs # kargs = {'name': 'tanggu', 'sex', u'男'} # print_hello(**kargs) # {'name': 'tanggu', 'sex', u'男'}","text_tokens":["也","位置","'","元素","对应","u","*","参数传递","传递","解","每个","=","让","sex","args",")","作为","数传","包裹","{","}","之为","tanggu","_","关键字","def","调用","的","使用","可以","元组","时","name","函数","在","print","关键","参数","unpacking","称之为",":","字典","，","每","hello","给","函数调用","和",",","男","键值","(","对","时候"," ","一个","kargs","#"],"title":"解包裹参数","title_tokens":["解","包裹","参数"]},{"location":"Python基础/2.9.函数.html#_11","text":"顺序是：位置参数、默认参数、包裹位置、包裹关键字，定义和调用都应遵循这个顺序。 def func ( name , age , sex = 1 , * args , ** kargs ): print name , age , sex , args , kargs # func('tanggu', 25, 2, 'music', 'sport', class=2) # tanggu 25 1 ('music', 'sport') {'class'=2}","text_tokens":["'","位置","music","func","class","age","是","*","=","sex","args","}",")","{","包裹","25","tanggu","关键字","def","应","调用","name","2","print","遵循","关键","参数","。","1",":","这个","、","顺序","，","都","和","：","定义",",","(","默认"," ","sport","kargs","#"],"title":"位置参数、默认参数、可变参数的混合使用","title_tokens":["位置","可变","参数","混合","默认","的","使用","、"]},{"location":"Python基础/3.1.异常.html","text":"异常处理机制 异常处理无外乎几件事: 断言（assert） 抛错（raise） 检查（try） 捕获（except） 处理（except, else, finally） 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。当Python脚本发生异常时，异常会从发生异常的位置向程序上层传播。例如异常从函数向外传播到调用函数的地方，如果在这里没有被捕获，则继续向上传播，如果一直都没有被捕获，则传播到程序的最顶层，即主程序（全局作用域）。如果在主程序中也没有处理异常的程序，python将调用默认的异常处理程序，自动匹配异常的类型，然后中止程序并显示栈跟踪信息。 # 在cause_error函数中抛出异常 def cause_error (): raise Exception ( \"Somrthing is wrong\" ) # 在call_cause_error函数中调用cause_error函数 def call_cause_error (): cause_error () def deal_error (): try : cause_error () except : print ( \"Exception handled\" ) call_cause_error () ---------------------------------------------------------------------------Exception Traceback (most recent call last)<ipython-input-1-eb81f11bf5d9> in <module> ----> 1 call_cause_error() <ipython-input-1-ec5e029839e0> in call_cause_error() 1 def call_cause_error(): ----> 2 cause_error() 3 <ipython-input-1-11326a099618> in cause_error() 1 def cause_error(): ----> 2 raise Exception(\"Somrthing is wrong\") 3 Exception: Somrthing is wrong deal_error () Exception handled 如你所见，cause_error中引发的异常依次从cause_error和call_cause_error向外传播，最终导致显示一条栈跟踪信息。调用deal_error时，异常在传播到deal_error时被捕获，并被这里的try/except语句处理。 异常是Python对象，表示一个错误。异常可以作为类被定义, 也可以人为引发异常。 异常处理语句 try : < statement > #' try语句中代码首先被运行 except ： < statement > #' 捕获任何在try中引发的异常 except < name > ： < statement > #' 捕获在try中引发的<name>异常 except < name > ， < data > : < statement > #' 如果引发了'name'异常，获得附加的数据 except ( < name1 > , < name2 >... ): < statement > #' 捕获列出的多个异常 else : < statement > #' 如果没有异常发生 finally : < statement > #' 退出try时总会执行 raise #' 人为引发错误 assert < judgement > #' 断言,判断一定要返回True否则会引发AssertionError raise语句 使用raise...from...语句来提供自己的异常上下文，也可以使用None来禁止上下文。 # 默认输出异常上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 1 try: ----> 2 1/0 3 except ZeroDivisionError: ZeroDivisionError: division by zero During handling of the above exception, another exception occurred: ValueError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError 5 ValueError: # 自定义上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from ZeroDivisionError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)ZeroDivisionError: The above exception was the direct cause of the following exception: ValueError Traceback (most recent call last)<ipython-input-1-00ed5b67ecd8> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from ZeroDivisionError 5 ValueError: # 禁止上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from None ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-d9388897f61c> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from None ValueError: 内置异常 异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告 参考 Python异常处理 python在异常捕获里抛出异常 异常处理","text_tokens":["系统","然后","try","the","对于","超出","断言","name","keyboardinterrupt","了","indexerror","自定","00ed5b67ecd8","传入","这个","并","继续","ec5e029839e0","during","\"","里","typeerror","unboundlocalerror","使用","-","warning","生成","该",">","中断","程序","eof","name2","用户","对","futurewarning","默认","#","建","已经","except","位置","3","userwarning","多个","到达","旧","long","提升","这里","referenceerror","above","判断","语法","程序执行","取模","上下","zerodivisionerror","taberror","data","4","索引","返回","syntaxerror","变量","语义","following","几件","中止","列出","）","将来","内","nameerror","过程","overflowwarning","处理程序","judgement","代码","限制","代码生成","到","发生","ipython","警告",",","解码","导入","unicodeencodeerror","error","整型","匹配","从","顶层","作为","baseexception","数据","module","ioerror","成器","2","recent","向","，","定义","有","调用函数","一个","栈","除","全局","回收","否则","exception","未声明","通知","失败","unicodedecodeerror","zero","输入","数据类型","unicode","stopiteration","浮点","首先","空格","关于","操作系统","内建","抛错","assertionerror","一定","behavior","call","解释","影响","runtimeerror","：","脚本","generatorexit","eoferror","更","声明","几件事","常规","tab","未","arithmeticerror","弱","改变","信息","情况","deprecationwarning","时","主程序","将","可以","行为","most","显示","参数","禁止","描述","提供","将会","解释器","unicodetranslateerror","跟踪","floatingpointerror","valueerror","被弃","任何","例如","division","一般","c","可疑","释器","执行","你","overflowerror","要","handled","调用","属性","somrthing","语句","unicodeerror","参考","下文","5","in","访问","内置","查询","如","自己","编码","中","引发","is","是","last","模块","上下文","相关","人为","11326a099618","1","自动","attributeerror","算错","weak","向上","finally","用","或","自定义","附加","映射","会","true","def","总会","无外乎","错误","python","序列","不是","无效","输出","本地","都","计算错误","importerror","构造","运行","尚未","也","最终","表示","处理","keyerror","所见","被","则","of","缩进","的","致命","deal","indentationerror","类型","生成器","pendingdeprecationwarning","syntaxwarning","初始化","by","为长"," ","56b5a2b441f0","迭代","键","d9388897f61c","systemexit","事件","正常","another","引用","input","机制","notimplementederror","occurred","else","试图","raise","如果","退出","特性","运算","一直","和","(","一条","零","<","eb81f11bf5d9","方法",")","generator","lookuperror","来","handling","当","在","assert","无法","捕获","print","standarderror","操作","。","初始","就","内存","名称","'","基类","index","oserror","...","请求","runtime","废弃","即","上层","多","器","最大","was","此","语法错误","reference","特征","0","混用","获得","数值","抛出","向外","对象","类","statement","systemerror","标记","^","_","地方","/","函数","实现","最",":","异常","memoryerror","from","依次","没有","wrong","检查","传播","计算","none","溢出","traceback","cause","标准","作用域","name1","值","environmenterror","转换","windowserror","作用","导致","direct","下","通常","所有","垃圾","（","runtimewarning"],"title":"3.1.异常","title_tokens":["3.1",".","异常"]},{"location":"Python基础/3.1.异常.html#_1","text":"异常处理无外乎几件事: 断言（assert） 抛错（raise） 检查（try） 捕获（except） 处理（except, else, finally） 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。当Python脚本发生异常时，异常会从发生异常的位置向程序上层传播。例如异常从函数向外传播到调用函数的地方，如果在这里没有被捕获，则继续向上传播，如果一直都没有被捕获，则传播到程序的最顶层，即主程序（全局作用域）。如果在主程序中也没有处理异常的程序，python将调用默认的异常处理程序，自动匹配异常的类型，然后中止程序并显示栈跟踪信息。 # 在cause_error函数中抛出异常 def cause_error (): raise Exception ( \"Somrthing is wrong\" ) # 在call_cause_error函数中调用cause_error函数 def call_cause_error (): cause_error () def deal_error (): try : cause_error () except : print ( \"Exception handled\" ) call_cause_error () ---------------------------------------------------------------------------Exception Traceback (most recent call last)<ipython-input-1-eb81f11bf5d9> in <module> ----> 1 call_cause_error() <ipython-input-1-ec5e029839e0> in call_cause_error() 1 def call_cause_error(): ----> 2 cause_error() 3 <ipython-input-1-11326a099618> in cause_error() 1 def cause_error(): ----> 2 raise Exception(\"Somrthing is wrong\") 3 Exception: Somrthing is wrong deal_error () Exception handled 如你所见，cause_error中引发的异常依次从cause_error和call_cause_error向外传播，最终导致显示一条栈跟踪信息。调用deal_error时，异常在传播到deal_error时被捕获，并被这里的try/except语句处理。 异常是Python对象，表示一个错误。异常可以作为类被定义, 也可以人为引发异常。","text_tokens":["匹配","引发","is","是","然后","从","try","顶层","last",")","作为","module","断言","2","了","当","在","assert","无法","捕获","print","recent","人为","。","11326a099618","1","自动","向","，","就","向上","定义","finally","调用函数","一个","栈","并","全局","继续","exception","ec5e029839e0","\"","会","def","即","无外乎","上层","错误","-","python","抛错","该",">","程序","call","影响","都","抛出","向外","脚本","默认","对象","#","类","也","except","位置","3","最终","表示","几件事","处理","所见","这里","被","则","信息","_","情况","地方","的","时","主程序","将","可以","/","函数","most","程序执行","deal","显示","类型","最",":","异常","几件","依次"," ","中止","没有","跟踪","wrong","检查","传播","事件","）","例如","正常","一般","过程","处理程序","执行","traceback","你","handled","调用","cause","input","作用域","somrthing","语句","else","raise","如果","作用","导致","到","发生","ipython","in","一直",",","下","如","和","(","一条","<","error","中","（","eb81f11bf5d9"],"title":"异常处理机制","title_tokens":["异常","处理","机制"]},{"location":"Python基础/3.1.异常.html#_2","text":"try : < statement > #' try语句中代码首先被运行 except ： < statement > #' 捕获任何在try中引发的异常 except < name > ： < statement > #' 捕获在try中引发的<name>异常 except < name > ， < data > : < statement > #' 如果引发了'name'异常，获得附加的数据 except ( < name1 > , < name2 >... ): < statement > #' 捕获列出的多个异常 else : < statement > #' 如果没有异常发生 finally : < statement > #' 退出try时总会执行 raise #' 人为引发错误 assert < judgement > #' 断言,判断一定要返回True否则会引发AssertionError","text_tokens":["'","except","否则","引发","任何","附加","没有","多个","...","try","statement",")","会","被","执行","数据","true","要","首先","总会","judgement","的","代码","时","name1","name","错误","断言","了","判断","语句","在","else","raise","捕获","如果","退出","人为","assert","一定","assertionerror",">",":","异常","data","发生","name2","，","返回","获得",",","：","(","finally","<"," ","中","运行","列出","#"],"title":"异常处理语句","title_tokens":["异常","处理","语句"]},{"location":"Python基础/3.1.异常.html#raise","text":"使用raise...from...语句来提供自己的异常上下文，也可以使用None来禁止上下文。 # 默认输出异常上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 1 try: ----> 2 1/0 3 except ZeroDivisionError: ZeroDivisionError: division by zero During handling of the above exception, another exception occurred: ValueError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError 5 ValueError: # 自定义上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from ZeroDivisionError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)ZeroDivisionError: The above exception was the direct cause of the following exception: ValueError Traceback (most recent call last)<ipython-input-1-00ed5b67ecd8> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from ZeroDivisionError 5 ValueError: # 禁止上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from None ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-d9388897f61c> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from None ValueError:","text_tokens":["00ed5b67ecd8","也","except","d9388897f61c","3","valueerror","exception","自定义","...","try","division","the","during","another","above","zero","last",")","none","traceback","上下文","of","module","input","cause","的","可以","使用","/","-","来","2","most","语句","handling","occurred","上下","raise","was","recent","。","zerodivisionerror","禁止","1","下文","自定","0",":","异常","ipython","call","提供",">","输出","in","4","，","5","direct","from","by",",","自己","定义","(","following","<"," ","默认","56b5a2b441f0","#"],"title":"raise语句","title_tokens":["raise","语句"]},{"location":"Python基础/3.1.异常.html#_3","text":"异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告","text_tokens":["系统","是","方法",")","generator","baseexception","对于","超出","模块","数据","ioerror","成器","断言","lookuperror","keyboardinterrupt","来","了","操作","standarderror","相关","indexerror","初始","自动","传入","这个","attributeerror","算错","内存","weak","名称","有","用","除","回收","基类","exception","或","index","oserror","未声明","通知","失败","请求","unicodedecodeerror","映射","会","输入","数据类型","unicode","runtime","废弃","stopiteration","浮点","空格","typeerror","关于","unboundlocalerror","多","错误","内建","操作系统","器","python","序列","assertionerror","最大","此","warning","生成","语法错误","behavior","不是","reference","特征","无效","中断","解释","eof","输出","本地","混用","runtimeerror","数值","用户","计算错误","对","importerror","构造","futurewarning","对象","运行","建","generatorexit","已经","eoferror","尚未","更","声明","userwarning","keyerror","到达","旧","long","常规","tab","systemerror","提升","referenceerror","标记","^","未","arithmeticerror","弱","改变","被","缩进","deprecationwarning","的","时","/","行为","致命","实现","语法","取模","indentationerror","参数","生成器","zerodivisionerror","描述","类型","pendingdeprecationwarning","taberror","memoryerror","异常","索引","syntaxerror","将会","syntaxwarning","初始化","变量","语义","为长","解释器","unicodetranslateerror"," ","没有","迭代","键","systemexit","floatingpointerror","valueerror","计算","被弃","将来","内","一般","c","nameerror","引用","overflowwarning","可疑","溢出","释器","执行","overflowerror","调用","标准","代码","属性","notimplementederror","值","语句","environmenterror","限制","试图","退出","windowserror","unicodeerror","转换","特性","代码生成","发生","访问","警告","运算","查询",",","和","通常","导入","所有","(","垃圾","解码","unicodeencodeerror","零","编码","整型","中","runtimewarning"],"title":"内置异常","title_tokens":["异常","内置"]},{"location":"Python基础/3.1.异常.html#_4","text":"Python异常处理 python在异常捕获里抛出异常 异常处理","text_tokens":["python","在","抛出","捕获","里","处理"," ","异常"],"title":"参考","title_tokens":["参考"]},{"location":"Python基础/3.2.命名空间和作用域.html","text":"命名空间 Namespace : namespace 是一个从 name 到 object 的映射。现在大部分的 namespace 通过Python字典 1 实现，将来可能会改变实现方式。 namespace：中文称为命名空间，或者名字空间。 命名空间的最重要的作用是避免名字冲突，各个命名空间是独立的，因此不同的命名空间可以重名。 Namespace 的种类 一般而言，name 产生地点决定其所处的 namespace。例如，在函数内定义的 name 会位于（函数的）局部命名空间。但使用了 global 、 nonlocal 语句会改变这种情况，这个在后面会说到。 built-in namespace ：builtins 模块定义的所有名字存在内置命名空间，这些名字包括内置函数、内置异常、内置常量、内置类型。如果是Python 2，则是 __builtin__ 模块。 global namespace ：每个模块都有全局命名空间，包括所有在模块最外层的作用域中定义的名字，例如类、函数、常量、被导入的模块。 local namespace ：相对于全局命名空间，每一个局部作用域都有一个局部命名空间。例如，函数或类所定义的命名空间，记录了函数参数、函数内的变量、类属性、类方法等。 enclosing namespace ：闭包命名空间不仅记录了当前嵌套函数内定义的变量，还记录了嵌套函数引用的外部变量。 Namespace生命周期 不同类型的命名空间有不同的生命周期： built-in：在 Python 解释器启动时创建，解释器退出时销毁 global：在模块定义被解释器读入时创建，通常也会一直保存到解释器退出，除非使用 del 语句。 local：这里要区分 function 以及 class 定义： 函数的局部命名空间：在函数调用时创建，函数返回或者产生未被捕获的异常时销毁 - 类定义的局部命名空间：在解释器读到类定义创建，离开类定义时创建class object。这个类对象实际上就是这个局部命名空间的包装（见官方对类定义的 说明 ）。 查看Namespace 局部命名空间可以通过 locals() 来访问 全局 （模块级别）命名空间可以通过 globals() 来访问 虽然都是返回命名空间，但 globals() 和 locals() 有一点不一样。 locals() 返回的是局部命名空间的副本，所以修改 locals() 对象并不会影响局部名字空间。 globals 返回是全局命名空间，而不是副本，所以修改 globals() 对象会影响全局命名空间。 # 修改局部命名空间无效 def change_local (): x = 123 print ( \"当前的局部命名空间\" , locals (), sep = \"：\" ) locals ()[ \"x\" ] = 6789 print ( \"修改locals()，并不影响x的值\" , f \"x= {x} \" , sep = \"：\" ) change_local () 当前的局部命名空间：{'x': 123} 修改locals()，并不影响x的值：x=123 # 修改全局命名空间生效 y = 123 globals ()[ \"y\" ] = 456 print ( \"修改全局命名空间生效：\" , f \"y= {y} \" ) 修改全局命名空间生效： y=456 作用域 scope : scope 是Python程序的一块文本区域（即一个代码区域），在这个区域可以直接访问namespace 。 直接访问意味着无须特性的指明引用。在Python中，直接访问是指直接使用name访问对象，如 name ，这会在命名空间搜索名字 name ；而间接访问是指使用形如 objname.attrname 的方式，即引用对象的属性，这不会在命名空间搜索名字 attrname ，而是搜索名字 objname ，再访问其属性。 换而言之，作用域其实就是一个命名空间可以发生作用的代码区域，发生作用是指命名空间可以被作用域直接访问。 作用域与命名空间的关系 命名空间保存着名字到对象的映射，映射关系在作用域中被定义，同时作用域可以通过引用命名空间的名字访问对象。代码区域可以直接引用哪个命名空间中的名字，它也就是哪个命名空间的作用域。有些代码区域可以访问多个命名空间的名字，那么它同时是多个命名空间的作用域。 作用域是静态的（它只是代码文本），而命名空间是动态的，命名空间随着解释器的执行而产生。 有些文章认为动态的作用域就是命名空间。其实并不是，命名空间是一种映射，作用域是一块代码区域。 Python对象通过命名空间被访问，而作用域则限制了Python对象的使用范围。 名字搜索顺序（LEGB） 当一行代码需要使用名字 X 所对应的值， Python会从当前层级的Namespace开始 ，并根据以下顺序，去查找名字 X ： local namespace ：包含局部名字的最内层（innermost）作用域，如函数、方法、类的内部局部作用域。 Enclosing ：根据嵌套层次从内到外搜索，包含非局部（nonlocal）非全局（nonglobal）名字的任意封闭函数的作用域。如两个嵌套的函数，内层函数的作用域是局部作用域，外层函数作用域就是内层函数的 Enclosing 作用域。 global built-in NameError ：如果 Python 在以上4个namespace找不到 X ，将放弃搜索并抛出 NameError 异常： NameError: name 'a' is not defined 程序在运行时，local、global、built-in三个namespace一定存在，但Enclosing namespace不一定存在。 Namespace和scope总结 不能在名字未定义前引用该名字（命名空间不存在该映射关系）。 built-in、global两个命名空间的引入是不能够通过代码操作的，Python 解释器会自动引入它们。注意，这里说的是引入，而不是修改。built-in命名空间是不能被修改的（已经预定义好），但global命名空间可以被Python代码修改。 类定义、函数定义、推导式会引入local命名空间 ，闭包函数定义会引入enclosing命名空间。 会导致命名空间被修改的情况： 类定义、函数定义 2. 赋值语句 3. import 语句、 if 语句、 for 语句、 while 语句5. if 、 for 、 while 语句并不会引入新的命名空间。 作用范围最大的命名空间是global namespace，但global namespace也只是模块级别的。 a 模块不能直接引用在 b 模块定义的name，即使 a 模块已经导入了整个 b 模块： import b 。除非直接导入name： from b import name 。 导入 b 模块中其中一个name： from b import name ，整个 b 模块都会被执行。因为 Python 并不知道 name 在 b.py 文档的何处，为了能够找到 name ，Python 需要执行整个 b.py。 import 语句不一定会改变global namespace，例如 import 语句写在函数内。 根据LEGB搜索规则，外层作用域不能引用内层作用域的变量。 def try_to_define_name (): '''函数中定义了名字i，并绑定了一个整数对象1''' i = 1 # 引用名字i之前，先调用函数定义i try_to_define_name () # 在引用名字i之前，明明调用了函数，定义了名字i，可是还是找不到这个名字。 print ( i ) NameError : name 'i' is not defined 虽然定义了名字 i ，但是定义在了函数的局部作用域对应的局部命名空间中，按照 LEGB 搜索规则，在全局作用域中自然访问不到局部作用域的命名空间；再者，函数调用结束后，这个命名空间被销毁了。 global 和 nonlocal 根据LEGB搜索规则，任何时候，Python程序都可以直接读取全局变量，但是却不可以在内层作用域直接改写上层变量。 可以读取全部变量，这容易理解，因为任何时候，global namespace都可以被访问。但为什么在内层作用域全局变量可以被访问，却不能被修改呢？这看起来像是Python的一个规定，但其实是很自然的事情。在Python中修改变量意味着将一个名字绑定到另一个对象，这需要使用assignment运算符 = 。 这意味着 = 左边的名字会被加入当前的命名空间，名字对应着 = 右边的对象。 例如下面的代码： a = 1 def change_a (): a = 10 change_a () a # 1 1 a = 10 语句在函数作用域中，当它被Python执行时，Python会将 a 加入函数的局部命名空间，而不会将 a 视作全局命名空间的 a 。当我们在最外层作用域引用 a 时，按照LEGB搜索规则，Python会从 a 所在的作用域对应的命名空间（即全局命名空间）开始搜索 a 对应的对象，而不会搜索局部命名空间。再者，此时函数 change_a() 执行完之后，局部命名空间已经被销毁，即使想搜索也搜索不到。 相信你从上面的叙述已经意识到，如果想让Python在内层作用域修改外层作用域的变量，那就需要让Python知道这个变量来自外层作用域。 global 语句和 nonlocal 语句正是可以起到这样的作用。 global 语句声明列在其后的所有标识符将被解析为全局变量。 使用global时有以下两条限制： 在同一代码块中，列在global语句中的所有标识符不能在该global语句前出现。 列在global 语句后的标识符不能被定义成形参，不能出现在for循环控制的目标、类定义和函数定义，或者import语句中。 CPython实现细节：当前实现并未强制履行上面两条限制 2 ，但程序不应该滥用这种自由，因为未来的版本可能会强制履行它们或者不留痕迹的改变程序含义。 nonlocal 语句声明列在其后的所有标识符 关联 到 最近的 enclosing 作用域里定义过的同名变量（不包括全局变量，只是最近的 enclosing 作用域的变量）。 def scope_test (): def do_local (): spam = \"local spam of do_local\" def do_nonlocal (): nonlocal spam spam = \"nonlocal spam of do_nonlocal\" def do_global (): global spam spam = \"global spam of do_global\" spam = \"test spam of scope_test\" # do_local函数内部的赋值不影响scope_test作用域的spam do_local () print ( \"After local assignment:\" , spam ) # do_nonlocal函数内部的赋值影响scope_test作用域的spam，但是不影响全局的spam do_nonlocal () print ( \"After nonlocal assignment:\" , spam ) # do_global 函数内声明的spam存在于全局作用域，而不影响scope_test作用域的 do_global () print ( \"After global assignment:\" , spam ) scope_test () print ( \"In global scope:\" , spam ) After local assignment: test spam of scope_test After nonlocal assignment: nonlocal spam of do_nonlocal After global assignment: nonlocal spam of do_nonlocal In global scope: global spam of do_global nonlocal 语句和 global 语句有两个不同点： 其一， global 语句只是声明标识符来存在于全局命名空间，并不会在当前作用域创建该标识符； nonlocal 语句则会在子函数命名空间中创建与父函数变量同名的标识符： gv = 'a global var' def func (): global gv lv = 'a local var' print ( locals ()) def inn_func (): nonlocal lv global gv print ( locals ()) return inn_func a = func () a () {'lv': 'a local var'} {'lv': 'a local var'} 之所以 nonlocal 语句与 global 语句的处理不同，是因为全局变量的作用域生存期很长，在模块内随时都可以访问，而父函数的局部作用域在父函数执行完毕后便会直接释放，因此 nonlocal 语句必须将父函数的标识符和引用写入enclosing namespace。 其二， global 语句可以声明全局作用域还没存在的名字，而 nonlocal 语句只能将它声明的名字关联到enclosing作用域中已经存在的绑定： # nonlocal 语句之前的eclosing作用域不存在spam 则报错 def scope_test (): def do_nonlocal (): # 父函数作用域要先定义spam，否则报错 nonlocal spam spam = \"nonlocal spam of do_nonlocal\" scope_test () File \"<ipython-input-1-e77162de9535>\", line 5 nonlocal spam ^ SyntaxError: no binding for nonlocal 'spam' found nonlocal 语句只能声明的名字会绑定到离 nonlocal 语句最近的enclosing 作用域（如果enclosing 作用域存在 nonlocal 语句声明的名字）： def scope_test (): spam = \"local spam of scope_test\" def do_local (): spam = \"local spam of do_local\" print ( \"After local assignment:\" , spam ) def do_nonlocal (): # 通过nonlocal声明将spam和最近的enclosing作用域的spam关联 # 所以关联的是do_local函数的spam nonlocal spam spam = \"nonlocal spam of do_nonlocal\" do_nonlocal () print ( \"After nonlocal assignment:\" , spam ) do_local () print ( \"After nonlocal assignment, scope_test's spam:\" , spam ) scope_test () After local assignment: local spam of do_local After nonlocal assignment: nonlocal spam of do_nonlocal After nonlocal assignment, scope_test's spam: local spam of scope_test 因此 nonlocal 语句重新绑定的name的真实作用域是不清楚的，这取决于已经存在的name本来位于那一层作用域。 nonlocal 语句和 global 语句有一个相同点： 当前作用域不能在 nonlocal 语句和 global 语句之前绑定两者声明的标识符： # global def scope_test (): spam = \"conflict\" global spam spam = \"nonlocal spam of do_nonlocal\" scope_test () # nonlocal def scope_test (): spam = \"local spam of scope_test\" def do_nonlocal (): spam = \"conflict\" nonlocal spam spam = \"nonlocal spam of do_nonlocal\" do_nonlocal () print ( \"After nonlocal assignment, scope_test's spam:\" , spam ) scope_test () File \"<ipython-input-1-d9548726e53c>\", line 5 global spam ^ SyntaxError: name 'spam' is assigned to before global declaration 类的作用域和命名空间 类定义的作用域和函数定义的作用域都可以产生局部命名空间，但它们执行机制不一样，有不小的区别。 其一，函数初始化时不会被执行，类初始化时会被执行。 Python读入函数定义时，函数不会被执行： def func (): print ( \"executed\" ) Python读入类定义时，类作用域的代码会被执行： class A : print ( \"executed_A\" ) def A_func ( self ): print ( \"executed_A_func\" ) class B : print ( \"executed_B\" ) class C : print ( \"executed_C\" ) executed_A executed_B executed_C 这看起来感觉有点不可思议，大家都是定义，为什么类定义会被执行，难道不应该是定义被引用时才执行吗？ 其实这也是很自然的事情。Python解释器读入函数定义时，只需要在当前命名空间绑定函数名，不需要创建函数的局部命名空间，自然不需要执行函数作用域的代码。 命名空间的动态性：命名空间在作用域被执行时才产生。 而类定义实际上是类局部命名空间的包装，因此Python解释器读入类定义时，不仅需要在当前命名空间绑定类名，还需要创建类局部命名空间。而命名空间在作用域被执行时才会产生，因此类定义需要在读入的时候就被执行。注意：类方法内的作用域和函数一样，是不会被执行的。 为什么读入类定义就需要创建类局部命名空间？ 因为类具有属性和方法，创建类属性就必须执行代码（进行赋值）。那为什么在读入类定义就创建类属性呢？因为类是创建实例、生成其他类（涉及继承、重载等）的对象，必须在实例之前被创建，在代码加载时就被创建有助于提高效率和降低逻辑复杂度。 另外，类还有一个特点：类可以直接被调用，不一定要先创建实例。这个特点就要求类初始化时就创建类命名空间。例如，创建一个类用于统一管理某一类常量： class Math_Constant : pi = 3.1415926 e = 2.7182818 sqrt_2 = 1.4142135 rho = 1.3247195 如果 Math_Constant 的类属性需要创建一个实例才能被调用，那就太麻烦了，而且类方法、静态方法也就没了意义。 而方法本质是函数，不会在读入定义时被执行。 为什么读入函数定义时不需要创建函数局部命名空间？ 一般来说，函数的局部命名空间主要与参数有关，而参数在函数被调用时才传入，创建了命名空间也意义不大。另外函数不像类那么复杂，也就没必要读入定义时就创建局部命名空间。 其二，类的局部命名空间不在名字搜索路径中。 例如： class A : pi = 3.1415926 def print_pi ( self ): print ( pi ) A () . print_pi () NameError : name 'pi' is not defined 类 A 是 print_pi 方法的外层作用域，按照设想， print_pi 方法中找不到变量 pi ，应该会到上一层作用域中查找，但是 print_pi 方法并没有在类 A 的作用域中查找，而是直接抛出异常。 又例如： class A (): a = 1 b = [ a + i for i in range ( 3 )] #NameError: name 'a' is not defined 执行上段代码，我们可以发现在类 A 内列表推导式无法调取 a 的值。 列表推导式也会产生局部命名空间。 但在函数中，完全没问题： def func (): a = 1 b = [ a + i for i in range ( 3 )] print ( b ) func () # [ 1 , 2 , 3 ] 因此，类 A 中的 a 不同于函数 func 中的 a 在局部命名空间中可以被任意引用。之所以强调”不可以被任意读取”，原因在于在类 A 的局部空间内， a 在当前层级的作用域是可以被直接引用的： class A (): a = 1 c = a + 2 A . c # 3 3 因此，类内可以产生局部命名空间的代码（方法、推导式等）严格上不是作用域。 脚注 参考 python的嵌套函数中局部作用域问题? Python进阶 - 对象，名字以及绑定 即 {name:object} 。 ↩ 当前的CPython已经实现第一条限制，至少在0.29.14版本的CPython中已经实现。 ↩","text_tokens":["对应","innermost","builtins","出现","同点","而类","after","try","问题","while","defined","不留","离开","不仅","所在","可是","形","name","不可","了","叙述","三个","相同点","右边","传入","]","但","这个","何处","一类","滥用","预定","整个","离","类内","不同于","常量","时候","而是","可能","并","这样","e","为","eclosing","有助于","同一","感觉","后面","应该","像是","循环","动态性","sqrt","\"","上面","change","式","写入","里","实际上","这会","使用","-","只能","认为","其他","保存","__","之前","没","生成","该","上","其","目标","完全","空间",">","程序","、","function","随着","函数调用","才能","麻烦","line","只","报错","着","#","已经","↩","还是","3","静态方法","它们","还","不同点","因为","多个","这里","部分","区域","+","关联","to","规定","各个","另","闭包","左边","冲突","a","或类","地点","文本","不会","找","创建","对类","4","built","自由","区别","返回","syntaxerror","每","启动","locals","同名","继承","变量","命名","所处","）","第一条","现在","成形","spam","将来","内","其实","进阶","nameerror","生存期","attrname","gv","[","复杂","不能引用","代码","知道","限制","改写","取决","新","到","发生","个","ipython","随时",",","导入","此时","至少","生存","时会","do","assignment","全局变量","文章","不可思议","从","位于","父","每个","之","难道","避免","相对","2","再者","nonglobal","e77162de9535","字典","意味","意识","有关","，","指明","时才","级别","理解","一点","严格","定义","产生","有","调用函数","能够","完毕","一个","名","助于","记录","视作","全局","否则","2.7182818","而父","说","嵌套","想","却","看起","外部","py","内部","这些","前","修改","真实","于","包装","或者","路径","一定","加载","不像","一层","是因为","全部","时有","解释","太","影响","虽然","而且","：","?","pi","i","过","但是","不能","读入","结束","声明","去","所以","细节","管理","即使","并不知道","未","改变","内层","赋值","独立","情况","什么","列","可以","时","将","只是","引入","标识符","test","另外","参数","1.4142135","正是","释放","写","运算符","直接","不知","其二","解释器","before","而言","重要","先","范围","大","func","吗","constant","任何","？","文档","主要","大部分","例如","查看","那","一般","y","c","其所处","决定","释器","执行","你","assigned","提高效率","要","等","调用","发现","属性","效率","语句","非","还有","我们","参考","进行","5","in","访问","内置","高效","绑定","所","如","查找","中","复杂度","需要","特点","is","var","包括","不","是","起来","具有","”","生命","binding","=","让","为了","这","模块","f","最近","读到","namespace","中文","算符","统一","区分","销毁","self","实例","1","x","自动","两者","found","之后","enclosing","将父","define","未定义","有点","痕迹","生命周期","子函数","未定","包含","履行","强调","起到","相信","映射","会","def","456","python","nonlocal","根据","很长","之所以","以及","不是","其后","无效","123","指","必要","种类","都","搜索","range","运行","not","其中","义好","也","静态","lv","重名","处理","被","则","of","清楚","的","global","1.3247195","外层","注意","存在","类型","scope","顺序","而","哪个","初始化","这种","容易"," ","某","任意","间接","local","控制","}","引用","意义","改变程序","见","为什么","input","；","来说","机制","d9548726e53c","称为","globals","大家","s","如果","退出","特性","意味着","有助","推导","调取","其一","提高","规则","运算","以上","生效","objname","一直","sep","两条","说明","和","return","层次","(","会到","取决于","一条","一行","<","10","14","当前","呢","object","不同","6789","官方","import","一般而言","方法","类名","就是","本质","cpython","不到",")","有些","又",".","动态","事情","b","来","当","在","操作","无法","捕获","print","rho","。","初始","脚注","与","下面","列表","思议","就","一块","0.29","后","高效率","'","很","无须","总结","大部","再","file","副本","周期","executed","del","重新","函数参数","关系","即","上层","来自","用于","最大","builtin","自然","块","外","同于","抛出","对象","方式","那么","inn","declaration","类","按照","名字","同时","读取","看起来","一种","class","换","强制","降低","math","要求","不小","no","涉及","局部","^","重载","{","通过","版本","3.1415926","一般来说","_","for","在于","legb","含义","原因","解析","函数","实现","除非","if","最",":","异常","from","便","它","封闭","参","没有","完","一样","放弃","标识","存期","conflict","找到","加入","第一","层级","并未","明明","开始","因此","逻辑","设想","两个","本来","作用域","值","必须","作用","导致","相同","以下","未来","段","通常","所有","实际","整数","（"],"title":"3.2.命名空间和作用域","title_tokens":["3.2","和","作用",".","空间","命名","作用域"]},{"location":"Python基础/3.2.命名空间和作用域.html#_1","text":"Namespace : namespace 是一个从 name 到 object 的映射。现在大部分的 namespace 通过Python字典 1 实现，将来可能会改变实现方式。 namespace：中文称为命名空间，或者名字空间。 命名空间的最重要的作用是避免名字冲突，各个命名空间是独立的，因此不同的命名空间可以重名。","text_tokens":["重要","不同","名字","是","现在","大部","重名","将来","从","大部分","部分","映射","通过","会","改变","各个","避免","因此","独立","的","可以","namespace","冲突","name","称为","python","实现","中文","或者","。","作用","1","最","空间","字典",":","到","，","："," ","一个","可能","方式","object","命名"],"title":"命名空间","title_tokens":["空间","命名"]},{"location":"Python基础/3.2.命名空间和作用域.html#namespace","text":"一般而言，name 产生地点决定其所处的 namespace。例如，在函数内定义的 name 会位于（函数的）局部命名空间。但使用了 global 、 nonlocal 语句会改变这种情况，这个在后面会说到。 built-in namespace ：builtins 模块定义的所有名字存在内置命名空间，这些名字包括内置函数、内置异常、内置常量、内置类型。如果是Python 2，则是 __builtin__ 模块。 global namespace ：每个模块都有全局命名空间，包括所有在模块最外层的作用域中定义的名字，例如类、函数、常量、被导入的模块。 local namespace ：相对于全局命名空间，每一个局部作用域都有一个局部命名空间。例如，函数或类所定义的命名空间，记录了函数参数、函数内的变量、类属性、类方法等。 enclosing namespace ：闭包命名空间不仅记录了当前嵌套函数内定义的变量，还记录了嵌套函数引用的外部变量。","text_tokens":["builtins","包括","是","一般而言","方法","位于","每个","模块","相对","不仅","namespace","name","2","了","在","。","但","这个","，","enclosing","定义","产生","有","常量","一个","记录","全局","说","后面","嵌套","外部","会","这些","函数参数","使用","于","-","nonlocal","python","__","builtin","空间","、","都","：","类","名字","还","局部","改变","被","则","闭包","情况","的","global","函数","外层","或类","地点","参数","存在","类型","最","异常","built","每","这种","变量"," ","命名","而言","所处","）","local","内","例如","一般","引用","其所处","决定","等","作用域","属性","语句","如果","作用","到","in","内置","所","导入","所有","中","当前","（"],"title":"Namespace 的种类","title_tokens":["种类"," ","的","namespace"]},{"location":"Python基础/3.2.命名空间和作用域.html#namespace_1","text":"不同类型的命名空间有不同的生命周期： built-in：在 Python 解释器启动时创建，解释器退出时销毁 global：在模块定义被解释器读入时创建，通常也会一直保存到解释器退出，除非使用 del 语句。 local：这里要区分 function 以及 class 定义： 函数的局部命名空间：在函数调用时创建，函数返回或者产生未被捕获的异常时销毁 - 类定义的局部命名空间：在解释器读到类定义创建，离开类定义时创建class object。这个类对象实际上就是这个局部命名空间的包装（见官方对类定义的 说明 ）。","text_tokens":["也","不同","读入","class","）","官方","local","就是","周期","生命","这里","局部","未","会","释器","模块","被","del","见","要","实际上","离开","调用","的","时","global","使用","读到","-","python","函数","语句","除非","在","或者","包装","退出","保存","区分","捕获","创建","类型","销毁","。","以及","空间","对类","到","in","异常","built","解释","function","这个","返回","，","一直","（","启动","函数调用","说明","：","定义","通常","产生","有","解释器","实际"," ","对象","object","命名","生命周期","类"],"title":"Namespace生命周期","title_tokens":["生命周期","周期","生命","namespace"]},{"location":"Python基础/3.2.命名空间和作用域.html#namespace_2","text":"局部命名空间可以通过 locals() 来访问 全局 （模块级别）命名空间可以通过 globals() 来访问 虽然都是返回命名空间，但 globals() 和 locals() 有一点不一样。 locals() 返回的是局部命名空间的副本，所以修改 locals() 对象并不会影响局部名字空间。 globals 返回是全局命名空间，而不是副本，所以修改 globals() 对象会影响全局命名空间。 # 修改局部命名空间无效 def change_local (): x = 123 print ( \"当前的局部命名空间\" , locals (), sep = \"：\" ) locals ()[ \"x\" ] = 6789 print ( \"修改locals()，并不影响x的值\" , f \"x= {x} \" , sep = \"：\" ) change_local () 当前的局部命名空间：{'x': 123} 修改locals()，并不影响x的值：x=123 # 修改全局命名空间生效 y = 123 globals ()[ \"y\" ] = 456 print ( \"修改全局命名空间生效：\" , f \"y= {y} \" ) 修改全局命名空间生效： y=456","text_tokens":["一样","'","名字","6789","）","不","是","所以","local","#","副本","局部","y","=","}",")","\"","通过","会","change","{","模块","修改","_","def","[","f","的","可以","456","globals","来","值","print","不会","。","不是","x","空间","无效",":","123","但","访问","]","而","返回","，","影响","生效","虽然","级别","sep","locals","都","和","一点",",","(","：","有"," ","对象","当前","（","命名","并","全局"],"title":"查看Namespace","title_tokens":["namespace","查看"]},{"location":"Python基础/3.2.命名空间和作用域.html#_2","text":"scope : scope 是Python程序的一块文本区域（即一个代码区域），在这个区域可以直接访问namespace 。 直接访问意味着无须特性的指明引用。在Python中，直接访问是指直接使用name访问对象，如 name ，这会在命名空间搜索名字 name ；而间接访问是指使用形如 objname.attrname 的方式，即引用对象的属性，这不会在命名空间搜索名字 attrname ，而是搜索名字 objname ，再访问其属性。 换而言之，作用域其实就是一个命名空间可以发生作用的代码区域，发生作用是指命名空间可以被作用域直接访问。","text_tokens":["间接","名字","）","无须","换","是","再","就是","区域","其实","引用","这","attrname","之","被",".","即","；","这会","的","可以","代码","namespace","使用","name","形","python","属性","作用域","在","文本","特性","对象","不会","。","作用","意味着","scope","其","空间",":","程序","意味","指","这个","访问","发生","而","，","指明","一块","objname","直接","如","搜索","中"," ","一个","而是","方式","（","命名","而言"],"title":"作用域","title_tokens":["作用","作用域"]},{"location":"Python基础/3.2.命名空间和作用域.html#_3","text":"命名空间保存着名字到对象的映射，映射关系在作用域中被定义，同时作用域可以通过引用命名空间的名字访问对象。代码区域可以直接引用哪个命名空间中的名字，它也就是哪个命名空间的作用域。有些代码区域可以访问多个命名空间的名字，那么它同时是多个命名空间的作用域。 作用域是静态的（它只是代码文本），而命名空间是动态的，命名空间随着解释器的执行而产生。 有些文章认为动态的作用域就是命名空间。其实并不是，命名空间是一种映射，作用域是一块代码区域。 Python对象通过命名空间被访问，而作用域则限制了Python对象的使用范围。","text_tokens":["也","名字","同时","范围","文章","一种","）","是","静态","多个","就是","区域","其实","引用","映射","通过","有些","被","释器","执行","关系","动态","则","的","可以","代码","作用域","使用","python","只是","了","认为","在","限制","保存","对象","文本","作用","。","那么","不是","空间","到","访问","解释","而","，","哪个","随着","一块","直接","定义","它","产生","解释器"," ","中","着","（","命名","并"],"title":"作用域与命名空间的关系","title_tokens":["与","作用","关系","空间","的","命名","作用域"]},{"location":"Python基础/3.2.命名空间和作用域.html#legb","text":"当一行代码需要使用名字 X 所对应的值， Python会从当前层级的Namespace开始 ，并根据以下顺序，去查找名字 X ： local namespace ：包含局部名字的最内层（innermost）作用域，如函数、方法、类的内部局部作用域。 Enclosing ：根据嵌套层次从内到外搜索，包含非局部（nonlocal）非全局（nonglobal）名字的任意封闭函数的作用域。如两个嵌套的函数，内层函数的作用域是局部作用域，外层函数作用域就是内层函数的 Enclosing 作用域。 global built-in NameError ：如果 Python 在以上4个namespace找不到 X ，将放弃搜索并抛出 NameError 异常： NameError: name 'a' is not defined 程序在运行时，local、global、built-in三个namespace一定存在，但Enclosing namespace不一定存在。","text_tokens":["需要","对应","innermost","is","不","是","方法","就是","从","不到","defined","namespace","name","当","三个","在","nonglobal","。","x","但","，","enclosing","并","全局","'","包含","嵌套","内部","会","使用","-","python","nonlocal","根据","一定","程序","、","外","抛出","：","搜索","运行","not","类","名字","去","局部","内层","的","global","将","时","函数","外层","a","找","存在","最","4","异常",":","built","顺序","封闭"," ","任意","放弃","）","local","内","层级","nameerror","开始","两个","代码","作用域","值","非","如果","作用","到","in","个","以下","以上","所","如","层次","一行","查找","当前","（"],"title":"名字搜索顺序（LEGB）","title_tokens":["（","名字","）","搜索","legb","顺序"]},{"location":"Python基础/3.2.命名空间和作用域.html#namespacescope","text":"不能在名字未定义前引用该名字（命名空间不存在该映射关系）。 built-in、global两个命名空间的引入是不能够通过代码操作的，Python 解释器会自动引入它们。注意，这里说的是引入，而不是修改。built-in命名空间是不能被修改的（已经预定义好），但global命名空间可以被Python代码修改。 类定义、函数定义、推导式会引入local命名空间 ，闭包函数定义会引入enclosing命名空间。 会导致命名空间被修改的情况： 类定义、函数定义 2. 赋值语句 3. import 语句、 if 语句、 for 语句、 while 语句5. if 、 for 、 while 语句并不会引入新的命名空间。 作用范围最大的命名空间是global namespace，但global namespace也只是模块级别的。 a 模块不能直接引用在 b 模块定义的name，即使 a 模块已经导入了整个 b 模块： import b 。除非直接导入name： from b import name 。 导入 b 模块中其中一个name： from b import name ，整个 b 模块都会被执行。因为 Python 并不知道 name 在 b.py 文档的何处，为了能够找到 name ，Python 需要执行整个 b.py。 import 语句不一定会改变global namespace，例如 import 语句写在函数内。 根据LEGB搜索规则，外层作用域不能引用内层作用域的变量。 def try_to_define_name (): '''函数中定义了名字i，并绑定了一个整数对象1''' i = 1 # 引用名字i之前，先调用函数定义i try_to_define_name () # 在引用名字i之前，明明调用了函数，定义了名字i，可是还是找不到这个名字。 print ( i ) NameError : name 'i' is not defined 虽然定义了名字 i ，但是定义在了函数的局部作用域对应的局部命名空间中，按照 LEGB 搜索规则，在全局作用域中自然访问不到局部作用域的命名空间；再者，函数调用结束后，这个命名空间被销毁了。","text_tokens":["需要","对应","is","不","import","是","try","不到","=","为了","while",")","defined","模块",".","b","namespace","可是","name","2","了","再者","在","操作","print","。","销毁","1","自动","但","何处","这个","，","级别","enclosing","预定","整个","定义","调用函数","能够","一个","define","未定义","后","并","全局","'","说","未定","py","映射","会","式","前","关系","修改","def","-","python","根据","最大","一定","之前","该","不是","空间","自然","、","解释","虽然","都","函数调用","：","搜索","i","对象","not","但是","其中","不能","类","义好","已经","也","#","3","还是","按照","名字","结束","它们","因为","这里","局部","即使","并不知道","通过","to","被","赋值","改变","内层","闭包","_","情况","for","legb","的","global","可以","函数","a","只是","引入","外层","除非","注意","不会","找","存在","if",":","built","而","写","from","直接","不知","变量","解释器"," ","命名","先","范围","）","local","内","文档","例如","找到","明明","引用","nameerror","释器","执行","调用","；","两个","不能引用","代码","作用域","知道","语句","作用","导致","推导","新","5","in","访问","规则","绑定","导入","(","整数","中","（"],"title":"Namespace和scope总结","title_tokens":["scope","和","总结","namespace"]},{"location":"Python基础/3.2.命名空间和作用域.html#global-nonlocal","text":"根据LEGB搜索规则，任何时候，Python程序都可以直接读取全局变量，但是却不可以在内层作用域直接改写上层变量。 可以读取全部变量，这容易理解，因为任何时候，global namespace都可以被访问。但为什么在内层作用域全局变量可以被访问，却不能被修改呢？这看起来像是Python的一个规定，但其实是很自然的事情。在Python中修改变量意味着将一个名字绑定到另一个对象，这需要使用assignment运算符 = 。 这意味着 = 左边的名字会被加入当前的命名空间，名字对应着 = 右边的对象。 例如下面的代码： a = 1 def change_a (): a = 10 change_a () a # 1 1 a = 10 语句在函数作用域中，当它被Python执行时，Python会将 a 加入函数的局部命名空间，而不会将 a 视作全局命名空间的 a 。当我们在最外层作用域引用 a 时，按照LEGB搜索规则，Python会从 a 所在的作用域对应的命名空间（即全局命名空间）开始搜索 a 对应的对象，而不会搜索局部命名空间。再者，此时函数 change_a() 执行完之后，局部命名空间已经被销毁，即使想搜索也搜索不到。 相信你从上面的叙述已经意识到，如果想让Python在内层作用域修改外层作用域的变量，那就需要让Python知道这个变量来自外层作用域。 global 语句和 nonlocal 语句正是可以起到这样的作用。 global 语句声明列在其后的所有标识符将被解析为全局变量。 使用global时有以下两条限制： 在同一代码块中，列在global语句中的所有标识符不能在该global语句前出现。 列在global 语句后的标识符不能被定义成形参，不能出现在for循环控制的目标、类定义和函数定义，或者import语句中。 CPython实现细节：当前实现并未强制履行上面两条限制 2 ，但程序不应该滥用这种自由，因为未来的版本可能会强制履行它们或者不留痕迹的改变程序含义。 nonlocal 语句声明列在其后的所有标识符 关联 到 最近的 enclosing 作用域里定义过的同名变量（不包括全局变量，只是最近的 enclosing 作用域的变量）。 def scope_test (): def do_local (): spam = \"local spam of do_local\" def do_nonlocal (): nonlocal spam spam = \"nonlocal spam of do_nonlocal\" def do_global (): global spam spam = \"global spam of do_global\" spam = \"test spam of scope_test\" # do_local函数内部的赋值不影响scope_test作用域的spam do_local () print ( \"After local assignment:\" , spam ) # do_nonlocal函数内部的赋值影响scope_test作用域的spam，但是不影响全局的spam do_nonlocal () print ( \"After nonlocal assignment:\" , spam ) # do_global 函数内声明的spam存在于全局作用域，而不影响scope_test作用域的 do_global () print ( \"After global assignment:\" , spam ) scope_test () print ( \"In global scope:\" , spam ) After local assignment: test spam of scope_test After nonlocal assignment: nonlocal spam of do_nonlocal After global assignment: nonlocal spam of do_nonlocal In global scope: global spam of do_global nonlocal 语句和 global 语句有两个不同点： 其一， global 语句只是声明标识符来存在于全局命名空间，并不会在当前作用域创建该标识符； nonlocal 语句则会在子函数命名空间中创建与父函数变量同名的标识符： gv = 'a global var' def func (): global gv lv = 'a local var' print ( locals ()) def inn_func (): nonlocal lv global gv print ( locals ()) return inn_func a = func () a () {'lv': 'a local var'} {'lv': 'a local var'} 之所以 nonlocal 语句与 global 语句的处理不同，是因为全局变量的作用域生存期很长，在模块内随时都可以访问，而父函数的局部作用域在父函数执行完毕后便会直接释放，因此 nonlocal 语句必须将父函数的标识符和引用写入enclosing namespace。 其二， global 语句可以声明全局作用域还没存在的名字，而 nonlocal 语句只能将它声明的名字关联到enclosing作用域中已经存在的绑定： # nonlocal 语句之前的eclosing作用域不存在spam 则报错 def scope_test (): def do_nonlocal (): # 父函数作用域要先定义spam，否则报错 nonlocal spam spam = \"nonlocal spam of do_nonlocal\" scope_test () File \"<ipython-input-1-e77162de9535>\", line 5 nonlocal spam ^ SyntaxError: no binding for nonlocal 'spam' found nonlocal 语句只能声明的名字会绑定到离 nonlocal 语句最近的enclosing 作用域（如果enclosing 作用域存在 nonlocal 语句声明的名字）： def scope_test (): spam = \"local spam of scope_test\" def do_local (): spam = \"local spam of do_local\" print ( \"After local assignment:\" , spam ) def do_nonlocal (): # 通过nonlocal声明将spam和最近的enclosing作用域的spam关联 # 所以关联的是do_local函数的spam nonlocal spam spam = \"nonlocal spam of do_nonlocal\" do_nonlocal () print ( \"After nonlocal assignment:\" , spam ) do_local () print ( \"After nonlocal assignment, scope_test's spam:\" , spam ) scope_test () After local assignment: local spam of do_local After nonlocal assignment: nonlocal spam of do_nonlocal After nonlocal assignment, scope_test's spam: local spam of scope_test 因此 nonlocal 语句重新绑定的name的真实作用域是不清楚的，这取决于已经存在的name本来位于那一层作用域。 nonlocal 语句和 global 语句有一个相同点： 当前作用域不能在 nonlocal 语句和 global 语句之前绑定两者声明的标识符： # global def scope_test (): spam = \"conflict\" global spam spam = \"nonlocal spam of do_nonlocal\" scope_test () # nonlocal def scope_test (): spam = \"local spam of scope_test\" def do_nonlocal (): spam = \"conflict\" nonlocal spam spam = \"nonlocal spam of do_nonlocal\" do_nonlocal () print ( \"After nonlocal assignment, scope_test's spam:\" , spam ) scope_test () File \"<ipython-input-1-d9548726e53c>\", line 5 global spam ^ SyntaxError: name 'spam' is assigned to before global declaration","text_tokens":["需要","不同","assignment","对应","全局变量","is","var","不","出现","是","import","包括","同点","after","起来","从","位于","cpython","父","不到","=","让","binding","含义",")","这","不留","模块","事情","最近","所在","namespace","name","2","来","当","再者","叙述","在","算符","print","相同点","右边","。","销毁","1","e77162de9535","意识","意味","两者","但","这个","与","下面","之后","found","，","就","滥用","理解","enclosing","离","定义","有","将父","时候","完毕","一个","可能","后","痕迹","视作","全局","并","子函数","这样","'","否则","很","为","而父","eclosing","履行","file","同一","应该","想","像是","起到","却","看起","相信","循环","内部","\"","会","上面","change","写入","前","重新","里","修改","def","上层","即","真实","使用","相同","于","python","来自","根据","nonlocal","很长","之所以","或者","只能","-","之前","没","一层","该","目标","其后","空间","自然","程序","块","全部","时有","、","是因为",">","影响","都","：","搜索","line","对象","过","inn","但是","declaration","报错","着","不能","#","已经","按照","也","类","看起来","读取","名字","强制","声明","它们","lv","所以","还","不同点","处理","因为","细节","no","局部","即使","^","关联","版本","{","通过","to","规定","被","内层","改变","另","_","of","for","赋值","则","什么","列","清楚","legb","的","可以","global","将","左边","时","函数","a","外层","标识符","解析","实现","只是","test","不会","存在","创建","最","scope",":","正是","自由","而","释放","syntaxerror","运算符","locals","直接","同名","它","这种","变量","容易","便","其二","参"," ","before","完","命名","标识","存期","conflict","先","func","）","spam","成形","local","任何","？","内","例如","那","加入","控制","其实","并未","}","引用","生存期","改变程序","开始","gv","因此","为什么","执行","你","assigned","要","input","；","两个","代码","本来","作用域","d9548726e53c","知道","语句","必须","我们","限制","改写","如果","s","取决","作用","意味着","到","in","其一","访问","以下","ipython","规则","运算","随时","5","两条","return","绑定","未来",",","和","此时","所有","(","生存","取决于","<","10","中","当前","呢","（","do"],"title":"global和 nonlocal","title_tokens":["和","nonlocal","global"," "]},{"location":"Python基础/3.2.命名空间和作用域.html#_4","text":"类定义的作用域和函数定义的作用域都可以产生局部命名空间，但它们执行机制不一样，有不小的区别。 其一，函数初始化时不会被执行，类初始化时会被执行。 Python读入函数定义时，函数不会被执行： def func (): print ( \"executed\" ) Python读入类定义时，类作用域的代码会被执行： class A : print ( \"executed_A\" ) def A_func ( self ): print ( \"executed_A_func\" ) class B : print ( \"executed_B\" ) class C : print ( \"executed_C\" ) executed_A executed_B executed_C 这看起来感觉有点不可思议，大家都是定义，为什么类定义会被执行，难道不应该是定义被引用时才执行吗？ 其实这也是很自然的事情。Python解释器读入函数定义时，只需要在当前命名空间绑定函数名，不需要创建函数的局部命名空间，自然不需要执行函数作用域的代码。 命名空间的动态性：命名空间在作用域被执行时才产生。 而类定义实际上是类局部命名空间的包装，因此Python解释器读入类定义时，不仅需要在当前命名空间绑定类名，还需要创建类局部命名空间。而命名空间在作用域被执行时才会产生，因此类定义需要在读入的时候就被执行。注意：类方法内的作用域和函数一样，是不会被执行的。 为什么读入类定义就需要创建类局部命名空间？ 因为类具有属性和方法，创建类属性就必须执行代码（进行赋值）。那为什么在读入类定义就创建类属性呢？因为类是创建实例、生成其他类（涉及继承、重载等）的对象，必须在实例之前被创建，在代码加载时就被创建有助于提高效率和降低逻辑复杂度。 另外，类还有一个特点：类可以直接被调用，不一定要先创建实例。这个特点就要求类初始化时就创建类命名空间。例如，创建一个类用于统一管理某一类常量： class Math_Constant : pi = 3.1415926 e = 2.7182818 sqrt_2 = 1.4142135 rho = 1.3247195 如果 Math_Constant 的类属性需要创建一个实例才能被调用，那就太麻烦了，而且类方法、静态方法也就没了意义。 而方法本质是函数，不会在读入定义时被执行。 为什么读入函数定义时不需要创建函数局部命名空间？ 一般来说，函数的局部命名空间主要与参数有关，而参数在函数被调用时才传入，创建了命名空间也意义不大。另外函数不像类那么复杂，也就没必要读入定义时就创建局部命名空间。 其二，类的局部命名空间不在名字搜索路径中。 例如： class A : pi = 3.1415926 def print_pi ( self ): print ( pi ) A () . print_pi () NameError : name 'pi' is not defined 类 A 是 print_pi 方法的外层作用域，按照设想， print_pi 方法中找不到变量 pi ，应该会到上一层作用域中查找，但是 print_pi 方法并没有在类 A 的作用域中查找，而是直接抛出异常。 又例如： class A (): a = 1 b = [ a + i for i in range ( 3 )] #NameError: name 'a' is not defined 执行上段代码，我们可以发现在类 A 内列表推导式无法调取 a 的值。 列表推导式也会产生局部命名空间。 但在函数中，完全没问题： def func (): a = 1 b = [ a + i for i in range ( 3 )] print ( b ) func () # [ 1 , 2 , 3 ] 因此，类 A 中的 a 不同于函数 func 中的 a 在局部命名空间中可以被任意引用。之所以强调”不可以被任意读取”，原因在于在类 A 的局部空间内， a 在当前层级的作用域是可以被直接引用的： class A (): a = 1 c = a + 2 A . c # 3 3 因此，类内可以产生局部命名空间的代码（方法、推导式等）严格上不是作用域。","text_tokens":["需要","特点","不同","不可思议","is","不","而类","是","方法","类名","起来","具有","”","问题","本质","不到","=",")","这","defined","难道","又","事情","动态",".","不仅","b","不可","name","2","了","复杂度","在","无法","统一","print","rho","。","self","实例","1","初始","传入","]","但","这个","与","有关","一类","，","思议","时才","就","列表","严格","定义","类内","产生","不同于","有","常量","查找","时候","一个","名","助于","而是","高效率","有点","并","2.7182818","'","e","很","有助于","强调","感觉","应该","sqrt","动态性","看起","\"","会","executed","式","def","实际上","python","包装","用于","之所以","其他","路径","一定","加载","之前","没","生成","不像","上","一层","完全","不是","空间","自然","太","解释","、","必要","同于","都","才能","：","而且","pi","抛出","麻烦","搜索","i","只","对象","range","那么","not","但是","#","类","也","按照","3","看起来","读入","降低","math","静态方法","class","名字","读取","静态","它们","要求","还","所以","因为","不小","涉及","局部","管理","+","重载","3.1415926","一般来说","被","赋值","_","for","什么","在于","的","可以","时","原因","1.3247195","函数","a","外层","注意","另外","不会","参数","创建","找","1.4142135",":","异常","区别","而","初始化","继承","直接","其二","变量","解释器"," ","某","没有","任意","命名","一样","先","大","func","吗","）","constant","？","内","主要","例如","那","一般","层级","其实","c","引用","意义","nameerror","释器","因此","执行","为什么","提高效率","复杂","要","[","逻辑","等","调用","设想","来说","发现","代码","机制","作用域","属性","效率","必须","大家","还有","我们","值","如果","作用","有助","进行","推导","in","其一","提高","调取","高效","绑定","会到","段","和",",","(","时会","实际","中","当前","呢","（"],"title":"类的作用域和命名空间","title_tokens":["和","作用","类","空间","的","命名","作用域"]},{"location":"Python基础/3.2.命名空间和作用域.html#_5","text":"","text_tokens":[],"title":"脚注","title_tokens":["脚注"]},{"location":"Python基础/3.2.命名空间和作用域.html#_6","text":"python的嵌套函数中局部作用域问题? Python进阶 - 对象，名字以及绑定 即 {name:object} 。 ↩ 当前的CPython已经实现第一条限制，至少在0.29.14版本的CPython中已经实现。 ↩","text_tokens":["名字","第一条","问题","嵌套","cpython","局部","第一","进阶","}","{","版本",".","即","的","作用域","name","函数","python","-","实现","在","限制","作用","。","以及",":","，","绑定","?","至少","一条","中","14"," ","对象","当前","0.29","object","↩","已经"],"title":"参考","title_tokens":["参考"]},{"location":"Python基础/3.3.闭包.html","text":"闭包的概念 以下引用自维基百科中关于闭包的介绍： 在 计算机科学 中， 闭包 （英语：Closure），又称 词法闭包 （Lexical Closure）或 函数闭包 （function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 闭包的概念出现于60年代，最早实现闭包的程序语言是 Scheme 。之后，闭包被广泛使用于 函数式编程 语言如 ML语言 和 LISP 。很多命令式程序语言也开始支持闭包。 在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。运行时，一旦外部的函数被执行，一个闭包就形成了，闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。其中所引用的变量称作 上值 (upvalue)。 维基百科中对于闭包的介绍，应该还是比较直观的。简而言之：内嵌函数引用了外部函数的变量，这个内嵌函数被执行时，就形成一个闭包。例如： def outside ( a , b ): a = a b = b def inner (): y = a + b print ( locals ()) inner () # 调用outside函数 inner被执行 形成闭包 outside ( 1 , 2 ) {'y': 3, 'a': 1, 'b': 2} inner() 被执行时，创建的局部命名空间会包括其引用的外层函数的变量，这样的局部命名空间被称为闭包命名空间（enclosing namespace）。 注意，在Python中，内嵌函数可以被外层函数返回，也就是Python函数可以返回闭包。 理解什么是闭包不难，但问题在于闭包有什么作用呢？ 闭包的作用 闭包的独特之处在于它可以绑定外部函数的变量，即使生成闭包的环境（外层函数）已经释放，闭包仍然存在。 这个过程很像类生成实例，不同的是外部函数只在调用时生成命名空间，执行完毕后其命名空间就会释放，而类的命名空间在读入定义时创建，一般Python解释器退出才释放命名空间。因此对一些需要重用的功能且不足以定义为类的行为，使用闭包会比使用类占用更少的资源，且更轻巧灵活。 例如：假设我们仅仅想打印出各类动物的叫声，分别以类和闭包来实现： # 类实现 class Animal ( object ): def __init__ ( self , animal ): self . animal = animal def sound ( self , voice ): print ( self . animal , ':' , voice , \"...\" ) dog = Animal ( \"dog\" ) dog . sound ( \"wangwang\" ) dog . sound ( \"wowo\" ) dog : wangwang ... dog : wowo ... # 闭包实现 def voice ( animal ): def sound ( voc ): print ( animal , ':' , voc , \"...\" ) return sound dog = voice ( \"dog\" ) dog ( \"wangwang\" ) dog ( \"wowo\" ) dog : wangwang ... dog : wowo ... 输出结果是完全一样的，但显然类的实现相对繁琐，且这里只是想输出一下动物的叫声，定义一个 Animal 类未免小题大做，而且 voice 函数在执行完毕后，其命名空间就已经释放，但 Animal 类及其实例 dog 的相应属性却一直贮存在内存中。而这种内存占用是没有必要的。 除此之外，闭包还有其他作用。闭包可以减少函数参数的数目，因此可以用于封装。这对并行计算也非常有用，比如可以让每台电脑负责一个函数的计算。另外，闭包在Python中有一种重要的应用——装饰器。这个会在装饰器的文章讲述。 闭包作用域与命名空间 来看一个典型的 闭包 结构： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv = [ 'gv' ] + gv # UnboundLocalError:local variable 'gv' referenced before assignment lv = [] def inn_func (): lv = lv + [ v ] # UnboundLocalError:local variable 'lv' referenced before assignment gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 这段代码似乎没有问题，赋值操作从右到左执行，先从右边的 gv 、 lv 开始执行代码，此时局部作用域还没有 gv 变量，局部作用域也没有 lv 变量，Python应该会访问外层作用域的 gv 、 lv 变量。但实际调用 func() 函数时，上面两处对 gv 和 lv 进行赋值操作的地方都会触发 UnboundLocalError 。 这是因为 Python 在执行函数前，会首先生成各层命名空间和作用域 ，因此 Python 在执行赋值前会将 func 内的 'gv' 'lv' 写入局部命名空间和闭包命名空间： dict_局部命名空间.update({“gv”:['gv'] + gv}) dict_闭包命名空间.update({“lv”:['lv'] + lv}) 当 Python 执行赋值时，按照LEGB搜索规则，会先在局部作用域、闭包作用域内发现 gv 和 lv 标识符，但 gv 和 lv 在局部命名空间和闭包命名空间内都没有绑定对象，从而引发错误。 这段代码本意只是想让具有对象的全局变量 gv 和局部变量 lv 参与运算，而不是局部命名空间中的 gv 和闭包命名空间中的 lv 。为了避免类似的情况发生， Python 引入了 global 、 nonlocal 语句来说明所修饰的 gv 、 lv 分别来自全局命名空间和局部命名空间 ，声明之后，就可以在 func 和 inn_func 内直接改写上层命名空间内 gv 和 lv 的值： gv = [ 'a' , 'global' , 'var' ] print ( \"gv的内存地址\" , id ( gv )) def func ( v ): global gv print ( \"gv的内存地址\" , id ( gv )) gv = [ 'gv' ] + gv lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): nonlocal lv print ( \"lv的内存地址\" , id ( lv )) lv = lv + [ v ] gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () gv的内存地址 1484188467336 gv的内存地址 1484188467336 lv的内存地址 1484188467336 lv的内存地址 1484188467336 ['gv', 'is', 'a', 'global', 'var'] 如上，全局变量 gv 值被函数改写了， inn_func 修改的也确实是父函数 lv 的值 （依据内存地址判断）。 借壳 那么是不是不使用 global 和 nonlocal 就不能达到上面的目的呢？来看看下面这段代码： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv . insert ( 0 , 'gv' ) lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): lv . append ( v ) print ( \"lv的内存地址\" , id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () print ( gv ) lv的内存地址 1484150018632 lv的内存地址 1484150018632 ['gv', 'is', 'a', 'global', 'var'] 可以发现，执行结果同上面完全一致，问题自然来了：“为什么不用 global nonlocal 也可以改写全局变量 gv 和父函数变量 lv 的值？ 为了看清楚这个过程，我们将上面的 gv.insert(0, 'gv') 和 lv.append(v) 改写为 gv[0:0] = ['gv'] 和 lv[:] = [v] ： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv [ 0 : 0 ] = [ 'gv' ] lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): lv [:] = [ v ] print ( \"lv的内存地址\" , id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () print ( gv ) lv的内存地址 1484192557512 lv的内存地址 1484192557512 ['gv', 'is', 'a', 'global', 'var'] 执行结果完全一致，事实上两者之间的本质也是完全一样的。 .insert() 、 .append() 方法并没有修改 gv 和 lv ，而是修改 gv 和 lv 的元素 gv[0:0] 和 lv[:] ，因此 gv 和 lv 并没有被加入局部命名空间。因此，不需要 global 和 nonlocal 修饰就可以直接改写， 这就是“借壳”。 另外，也是借助了list对象的mutable性质。 在 nonlocal 尚未引入 Python 中，比如 Python 2.x 若要在子函数中改写父函数变量的值就得通过这种方法。","text_tokens":["很多","出现","而类","问题","需","对于","1484192557512","叫声","离开","贮存","了","占用","中有","右边","两者之间","]","但","这个","而是","可能","并","相应","这样","语言","为","非常","应该","append","来看","\"","上面","式","写入","unboundlocalerror","使用","lexical","例外","认为","其他","__","不足以","生成","上","完全","其","空间","程序","、","function","出","确实","对","看清","像","只","#","已经","还是","3","lisp","还","与其","因为","多个","达到","结果","这里","前会","+","animal","并行","另","闭包","计算机","判断","a","各层","创建","处","一下","dict","自由","返回","性质","locals","变量","同","支持","命名","元素","）","维基百科","结构","referenced","内","足以","过程","gv","[","代码","改写","灵活","发生",",","此时","本意","维基","voice","比如","assignment","全局变量","维基百","文章","参与","从","父","之","事实上","且","避免","局部变量","相对","2","负责","组合","闭","会先","，","理解","定义","产生","有","完毕","一个","全局","词法","比较","一同","嵌套","想","却","外部","借壳","内部","前","修改","首先","关于","以类","于","称作","“","是因为","解释","各类","而且","：","形成","不能","电脑","读入","更","声明","包被","所以","即使","list","赋值","wowo","情况","什么","小题大做","除此之外","之外","将","时","可以","事实","行为","未免","只是","标识符","引入","另外","参数","variable","又称","释放","直接","环境","解释器","before","计算机科学","而言","重要","先","func","？","例如","一般","数目","y","释器","执行","调用","发现","百科","属性","语句","还有","我们","wangwang","60","进行","访问","资源","程序语言","绑定","所","如","重用","打印","中","scheme","需要","从右到左","引发","is","var","不","包括","是","之间","”","具有","=","减少","让","才","为了","这","一些","namespace","inner","相关","实例","self","1","x","两者","分别","之后","enclosing","一致","子函数","由","或","包含","得","—","典型","会","def","动物","错误","组合而成","python","nonlocal","以及","不是","看清楚","输出","必要","都","搜索","运行","触发","其中","mutable","尚未","也","介绍","dog","讲述","应用","lv","closures","init","被","似乎","则","清楚","更少","的","global","外层","注意","存在","上值","而","不用","最早","从而","这种","为类","实体"," ","繁琐","看看","local","闭包会","}","修饰","引用","为什么","upvalue","并行计算","称为","如果","退出","说法","是不是","规则","运算","1484188467336","一直","return","和","说明","ml","(","小题","1484150018632","呢","object","除此","不同","及其","方法","就是","目的","轻巧","本质","简而言之",")","不足",".","id","完全一致","b","来","当","在","操作","print","年代","。","命令","每台","与","下面","就","科学","内存","sound","仅仅","封装","后","'","不难","outside","很","两处","voc","功能","...","一旦","若要","函数参数","update","上层","器","来自","用于","比","0","自然","创造","直观","显然","对象","inn","那么","类","按照","装饰","一种","class","地址","编程","独特","v","局部","{","通过","_","假设","在于","地方","legb","借助","函数","实现","内存地址","类似",":","它","仍然","依据","没有","closure","一样","标识","算机","计算","概念","insert","加入","开始","因此","英语","作用域","值","广泛","作用","相同","命令式","以下","段","自","实际","包来","有用","（","内嵌"],"title":"3.3.闭包","title_tokens":["闭包",".","3.3"]},{"location":"Python基础/3.3.闭包.html#_1","text":"以下引用自维基百科中关于闭包的介绍： 在 计算机科学 中， 闭包 （英语：Closure），又称 词法闭包 （Lexical Closure）或 函数闭包 （function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 闭包的概念出现于60年代，最早实现闭包的程序语言是 Scheme 。之后，闭包被广泛使用于 函数式编程 语言如 ML语言 和 LISP 。很多命令式程序语言也开始支持闭包。 在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。运行时，一旦外部的函数被执行，一个闭包就形成了，闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。其中所引用的变量称作 上值 (upvalue)。 维基百科中对于闭包的介绍，应该还是比较直观的。简而言之：内嵌函数引用了外部函数的变量，这个内嵌函数被执行时，就形成一个闭包。例如： def outside ( a , b ): a = a b = b def inner (): y = a + b print ( locals ()) inner () # 调用outside函数 inner被执行 形成闭包 outside ( 1 , 2 ) {'y': 3, 'a': 1, 'b': 2} inner() 被执行时，创建的局部命名空间会包括其引用的外层函数的变量，这样的局部命名空间被称为闭包命名空间（enclosing namespace）。 注意，在Python中，内嵌函数可以被外层函数返回，也就是Python函数可以返回闭包。 理解什么是闭包不难，但问题在于闭包有什么作用呢？","text_tokens":["很多","不同","维基百","不","出现","是","包括","就是","问题","简而言之","=","需",")","对于","一些","离开","b","namespace","inner","2","了","在","相关","组合","闭","print","年代","。","实例","1","命令","但","这个","之后","，","就","科学","enclosing","理解","定义","产生","有","一个","可能","词法","'","这样","语言","不难","outside","由","或","比较","一同","包含","嵌套","应该","外部","内部","一旦","会","式","def","关于","使用","组合而成","lexical","于","例外","python","认为","称作","以及","其","空间","程序","function","创造","直观","：","形成","运行","其中","#","已经","也","介绍","还是","3","一种","lisp","包被","编程","所以","与其","多个","局部","即使","+","{","closures","被","另","闭包","则","计算机","什么","在于","的","将","时","可以","函数","a","外层","实现","注意","存在","创建","又称",":","上值","自由","返回","最早","locals","它","变量","环境","实体"," ","支持","closure","计算机科学","而言","命名","算机","计算","）","维基百科","概念","？","例如","y","}","引用","开始","执行","upvalue","调用","代码","英语","百科","称为","如果","60","说法","广泛","作用","相同","命令式","以下","程序语言","所",",","自","和","如","ml","(","维基","中","呢","（","内嵌","scheme"],"title":"闭包的概念","title_tokens":["闭包","的","概念"]},{"location":"Python基础/3.3.闭包.html#_2","text":"闭包的独特之处在于它可以绑定外部函数的变量，即使生成闭包的环境（外层函数）已经释放，闭包仍然存在。 这个过程很像类生成实例，不同的是外部函数只在调用时生成命名空间，执行完毕后其命名空间就会释放，而类的命名空间在读入定义时创建，一般Python解释器退出才释放命名空间。因此对一些需要重用的功能且不足以定义为类的行为，使用闭包会比使用类占用更少的资源，且更轻巧灵活。 例如：假设我们仅仅想打印出各类动物的叫声，分别以类和闭包来实现： # 类实现 class Animal ( object ): def __init__ ( self , animal ): self . animal = animal def sound ( self , voice ): print ( self . animal , ':' , voice , \"...\" ) dog = Animal ( \"dog\" ) dog . sound ( \"wangwang\" ) dog . sound ( \"wowo\" ) dog : wangwang ... dog : wowo ... # 闭包实现 def voice ( animal ): def sound ( voc ): print ( animal , ':' , voc , \"...\" ) return sound dog = voice ( \"dog\" ) dog ( \"wangwang\" ) dog ( \"wowo\" ) dog : wangwang ... dog : wowo ... 输出结果是完全一样的，但显然类的实现相对繁琐，且这里只是想输出一下动物的叫声，定义一个 Animal 类未免小题大做，而且 voice 函数在执行完毕后，其命名空间就已经释放，但 Animal 类及其实例 dog 的相应属性却一直贮存在内存中。而这种内存占用是没有必要的。 除此之外，闭包还有其他作用。闭包可以减少函数参数的数目，因此可以用于封装。这对并行计算也非常有用，比如可以让每台电脑负责一个函数的计算。另外，闭包在Python中有一种重要的应用——装饰器。这个会在装饰器的文章讲述。","text_tokens":["需要","不同","比如","文章","而类","是","及其","轻巧","=","减少","让","才",")","这","之","且","不足","一些","叫声",".","相对","贮存","负责","占用","中有","在","print","闭","。","实例","self","每台","但","这个","分别","，","就","内存","sound","定义","仅仅","封装","完毕","一个","后","'","相应","很","voc","非常","功能","—","...","想","却","外部","\"","会","函数参数","def","动物","以类","使用","器","python","用于","其他","__","不足以","生成","比","完全","其","空间","解释","输出","必要","各类","出","而且","对","：","像","显然","中","只","#","类","已经","也","dog","电脑","讲述","读入","装饰","更","一种","class","应用","独特","object","结果","这里","即使","animal","init","并行","闭包","假设","wowo","在于","小题大做","除此之外","更少","的","可以","时","之外","行为","函数","外层","只是","未免","实现","另外","参数","存在","创建","处","一下",":","释放","而","它","仍然","变量","这种","环境","解释器","为类"," ","没有","命名","一样","重要","繁琐","计算","）","闭包会","例如","足以","一般","数目","过程","释器","因此","执行","并行计算","调用","属性","还有","我们","退出","wangwang","作用","灵活","资源","return","绑定","一直",",","和","(","小题","重用","打印","包来","有用","（","voice","除此"],"title":"闭包的作用","title_tokens":["作用","闭包","的"]},{"location":"Python基础/3.3.闭包.html#_3","text":"来看一个典型的 闭包 结构： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv = [ 'gv' ] + gv # UnboundLocalError:local variable 'gv' referenced before assignment lv = [] def inn_func (): lv = lv + [ v ] # UnboundLocalError:local variable 'lv' referenced before assignment gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 这段代码似乎没有问题，赋值操作从右到左执行，先从右边的 gv 、 lv 开始执行代码，此时局部作用域还没有 gv 变量，局部作用域也没有 lv 变量，Python应该会访问外层作用域的 gv 、 lv 变量。但实际调用 func() 函数时，上面两处对 gv 和 lv 进行赋值操作的地方都会触发 UnboundLocalError 。 这是因为 Python 在执行函数前，会首先生成各层命名空间和作用域 ，因此 Python 在执行赋值前会将 func 内的 'gv' 'lv' 写入局部命名空间和闭包命名空间： dict_局部命名空间.update({“gv”:['gv'] + gv}) dict_闭包命名空间.update({“lv”:['lv'] + lv}) 当 Python 执行赋值时，按照LEGB搜索规则，会先在局部作用域、闭包作用域内发现 gv 和 lv 标识符，但 gv 和 lv 在局部命名空间和闭包命名空间内都没有绑定对象，从而引发错误。 这段代码本意只是想让具有对象的全局变量 gv 和局部变量 lv 参与运算，而不是局部命名空间中的 gv 和闭包命名空间中的 lv 。为了避免类似的情况发生， Python 引入了 global 、 nonlocal 语句来说明所修饰的 gv 、 lv 分别来自全局命名空间和局部命名空间 ，声明之后，就可以在 func 和 inn_func 内直接改写上层命名空间内 gv 和 lv 的值： gv = [ 'a' , 'global' , 'var' ] print ( \"gv的内存地址\" , id ( gv )) def func ( v ): global gv print ( \"gv的内存地址\" , id ( gv )) gv = [ 'gv' ] + gv lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): nonlocal lv print ( \"lv的内存地址\" , id ( lv )) lv = lv + [ v ] gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () gv的内存地址 1484188467336 gv的内存地址 1484188467336 lv的内存地址 1484188467336 lv的内存地址 1484188467336 ['gv', 'is', 'a', 'global', 'var'] 如上，全局变量 gv 值被函数改写了， inn_func 修改的也确实是父函数 lv 的值 （依据内存地址判断）。","text_tokens":["从右到左","assignment","引发","全局变量","is","var","参与","是","”","从","问题","具有","父","=","让",")","这","为了","避免",".","id","局部变量","了","来","当","操作","在","print","右边","。","1","]","但","会先","分别","之后","，","就","内存","一个","全局","'","两处","典型","应该","想","来看","\"","会","上面","写入","前","修改","def","update","首先","上层","unboundlocalerror","错误","python","nonlocal","来自","生成","“","上","不是","0","空间","是因为","、","都","确实","：","对","搜索","对象","inn","触发","#","也","按照","声明","地址","lv","还","因为","v","局部","前会","+","{","赋值","被","似乎","_","闭包","情况","地方","legb","的","global","时","将","可以","判断","函数","a","外层","标识符","只是","引入","各层","内存地址","variable","类似",":","dict","而","从而","直接","变量","before"," ","依据","没有","命名","标识","先","func","）","结构","local","referenced","内","insert","}","修饰","开始","gv","因此","执行","[","调用","发现","代码","作用域","语句","值","改写","作用","进行","发生","访问","规则","运算","1484188467336","return","段","绑定",",","和","说明","此时","本意","(","所","如","实际","中","（"],"title":"闭包作用域与命名空间","title_tokens":["与","作用","闭包","空间","命名","作用域"]},{"location":"Python基础/3.3.闭包.html#_4","text":"那么是不是不使用 global 和 nonlocal 就不能达到上面的目的呢？来看看下面这段代码： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv . insert ( 0 , 'gv' ) lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): lv . append ( v ) print ( \"lv的内存地址\" , id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () print ( gv ) lv的内存地址 1484150018632 lv的内存地址 1484150018632 ['gv', 'is', 'a', 'global', 'var'] 可以发现，执行结果同上面完全一致，问题自然来了：“为什么不用 global nonlocal 也可以改写全局变量 gv 和父函数变量 lv 的值？ 为了看清楚这个过程，我们将上面的 gv.insert(0, 'gv') 和 lv.append(v) 改写为 gv[0:0] = ['gv'] 和 lv[:] = [v] ： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv [ 0 : 0 ] = [ 'gv' ] lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): lv [:] = [ v ] print ( \"lv的内存地址\" , id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () print ( gv ) lv的内存地址 1484192557512 lv的内存地址 1484192557512 ['gv', 'is', 'a', 'global', 'var'] 执行结果完全一致，事实上两者之间的本质也是完全一样的。 .insert() 、 .append() 方法并没有修改 gv 和 lv ，而是修改 gv 和 lv 的元素 gv[0:0] 和 lv[:] ，因此 gv 和 lv 并没有被加入局部命名空间。因此，不需要 global 和 nonlocal 修饰就可以直接改写， 这就是“借壳”。 另外，也是借助了list对象的mutable性质。 在 nonlocal 尚未引入 Python 中，比如 Python 2.x 若要在子函数中改写父函数变量的值就得通过这种方法。","text_tokens":["需要","比如","全局变量","is","var","不","是","方法","之间","就是","目的","问题","本质","”","父","=",")","这","为了","事实上","1484192557512",".","id","完全一致","2","来","了","在","print","。","1","两者之间","x","两者","]","这个","下面","，","就","内存","一致","而是","并","全局","子函数","'","为","得","append","借壳","若要","\"","上面","修改","def","使用","python","nonlocal","“","完全","不是","0","自然","空间","看清楚","、","：","看清","对象","inn","那么","mutable","不能","尚未","也","地址","lv","达到","v","结果","局部","list","通过","被","_","什么","清楚","的","global","可以","将","事实","借助","函数","a","引入","另外","内存地址",":","不用","性质","直接","这种","变量","同"," ","没有","命名","一样","元素","func","看看","？","insert","加入","修饰","过程","gv","因此","执行","为什么","[","发现","代码","值","我们","改写","是不是","return","段",",","和","(","1484150018632","中","呢"],"title":"借壳","title_tokens":["借壳"]},{"location":"Python基础/3.4.装饰器.html","text":"装饰器简述 有时候，我们需要给一个函数添加新功能。那么有一种做法就是修改原函数的代码，直接添加新功能。但这总做法有时未免太繁琐。在python中，直接给原函数套上装饰就可以实现这个需求。 假设有一个这样的函数： def hello (): return 'hello world' # hello函数的名字 print ( \"hello函数的名字：\" , hello . __name__ ) hello函数的名字： hello 现在我们想增强 hello() 函数的功能，希望给返回加上 HTML 标签，比如 <i>hello world</i> ，但有一个要求，不改变原来 hello() 函数的定义。 那么可以这样做： def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped 要注意的是，makeitalic函数的参数是一个函数，返回的结果是wrapped函数。 # 给hello函数套上makeitalic函数 # makeitalic函数返回wrapped函数 # 实际上此时hello变成了wrapped函数 hello = makeitalic ( hello ) 将 hello 函数作为参数传入 makeitalic 函数， makeitalic 函数返回wrapped函数，名字 hello 与 wrapped 函数绑定。此时名字 hello 代表了一个函数，也就是 wrapped 函数有了新的名字—— hello 。 # 可以看出hello函数的名字变了 print ( \"hello函数的名字：\" , hello . __name__ ) hello函数的名字： wrapped 总结一下：为了增强原函数 hello 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数。 事实上， makeitalic 就是一个装饰器（decorator），它『装饰』了函数 hello ，并返回一个函数，将其赋给 hello 。 像上面的情况，可以动态修改函数（或类）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 hello ）为参数，并返回一个包装后的函数（比如上面的 wrapped ）给被装饰函数（ hello ）。 装饰器的一般使用形式 在python中，装饰器一般这样用： @decorator def func (): pass 等价于下面的形式 ： def func (): pass func = decorator ( func ) 装饰器可以定义多个，离函数定义最近的装饰器先被调用，比如 @decorator_one @decorator_two def func (): pass 等价于： def func (): pass func = decorator_one ( decorator_two ( func )) 装饰器还可以带参数，比如： @decorator ( arg1 , arg2 ) def func (): pass 等价于： def func (): pass func = decorator ( arg1 , arg2 )( func ) 例子： def makeitalic2 ( func ): return \"<i>\" + func () + \"</i>\" @makeitalic def hello_2 (): return 'hello world' def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped hello_2 () ' <i> hello world </i> ' 如果返回的不是函数就会这样： @makeitalic def hello_3 (): return 'hello world' def makeitalic ( func ): return \"<i>\" + func () + \"</i>\" hello_3 <function __main__.makeitalic.<locals>.wrapped()> 对带参数的函数进行装饰 前面的例子中，被装饰的函数 hello() 是没有带参数的，我们看看被装饰函数带参数的情况。对前面例子中的 hello() 函数进行改写，使其带参数，如下： def makeitalic ( func ): def wrapped ( * args , ** kwargs ): ret = func ( * args , ** kwargs ) return '<i>' + ret + '</i>' return wrapped @makeitalic def hello ( name ): return 'hello %s ' % name @makeitalic def hello2 ( name1 , name2 ): return 'hello %s , %s ' % ( name1 , name2 ) hello ( 'Jack' ) hello2 ( 'Jack' , \"Lusis\" ) 由于函数 hello 带参数，因此内嵌包装函数 wrapped 需要改变。 带参数的装饰器 上面的例子，我们增强了函数 hello 的功能，给它的返回加上了标签 <i>...</i> ，现在，我们想改用标签 <b>...</b> 或 <p>...</p> 。是不是要像前面一样，再定义一个类似 makeitalic 的装饰器呢？其实，我们可以定义一个函数，将标签作为参数，返回一个装饰器，比如： def wrap_in_tag ( tag ): def decorator ( func ): def wrapped ( * args , ** kwargs ): ret = func ( * args , ** kwargs ) return '<' + tag + '>' + ret + '</' + tag + '>' return wrapped return decorator 生成想要的装饰器了： makebold = wrap_in_tag ( 'b' ) # 根据 'b' 返回 makebold 生成器 @makebold def hello ( name ): return 'hello %s ' % name hello ( 'world' ) ' <b> hello world </b> ' 上面的形式也可以写得更加简洁： @wrap_in_tag ( 'b' ) def hello ( name ): return 'hello %s ' % name 多个装饰器 现在，让我们来看看多个装饰器的例子，为了简单起见，下面的例子就不使用带参数的装饰器。 def makebold ( func ): def wrapped (): return '<b>' + func () + '</b>' return wrapped def makeitalic ( func ): def wrapped (): return '<i>' + func () + '</i>' return wrapped @makebold @makeitalic def hello (): return 'hello world' 上面定义了两个装饰器，对 hello 进行装饰，上面的最后几行代码相当于： def hello (): return 'hello world' hello = makebold ( makeitalic ( hello )) 调用函数 hello： hello () ' <b><i> hello world </i></b> ' 基于类的装饰器 前面的装饰器都是一个函数，其实也可以基于类定义装饰器，看下面的例子： class Bold ( object ): def __init__ ( self , func ): self . func = func def __call__ ( self , * args , ** kwargs ): return '<b>' + self . func ( * args , ** kwargs ) + '</b>' @Bold def hello ( name ): return 'hello %s ' % name hello ( 'world' ) 可以看到，类 Bold 有两个方法： __init__() ：它接收一个函数作为参数，也就是被装饰的函数 __call__() ：让类对象可调用，就像函数调用一样，在调用被装饰函数时被调用 还可以让类装饰器带参数： class Tag ( object ): def __init__ ( self , tag ): self . tag = tag def __call__ ( self , func ): def wrapped ( * args , ** kwargs ): return \"< {tag} > {res} </ {tag} >\" . format ( res = func ( * args , ** kwargs ), tag = self . tag ) return wrapped @Tag ( 'b' ) def hello ( name ): return 'hello %s ' % name 需要注意的是，如果类装饰器有参数， 则 __init__ 接收参数，而 __call__ 接收 func。 装饰器的副作用 前面提到，使用装饰器有一个瑕疵，就是被装饰的函数，它的函数名称已经不是原来的名称了，回到最开始的例子： def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped @makeitalic def hello (): return 'hello world' 函数 hello 被 makeitalic 装饰后，它的函数名称已经改变了： hello . __name__ 'wrapped' 为了消除这样的副作用，Python 中的 functools 包提供了一个 wraps 的装饰器： from functools import wraps def makeitalic ( func ): @wraps ( func ) # 加上 wraps 装饰器 def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped @makeitalic def hello (): return 'hello world' hello . __name__ 'hello' 事实上，装饰器就是闭包的一种应用，但它比较特别，接收被装饰函数为参数，并返回一个函数，赋给被装饰函数，闭包则没这种限制。","text_tokens":["需要","比如","res","做法","不","import","是","arg2","方法","就是","本质","=","args","让",")","这","作为","为了","事实上","有时候",".","动态","ret","最近","例子","b","成器","name","2","bold","添加","套上","了","希望","tag","在","来","print","相当于","起","。","self","传入","但","这个","与","下面","看到","，","就","加上","hello","给","代表","离","总","定义","名称","有","用","调用函数","时候","一个","后","并","未免太","这样","'","当于","为","或","总结","比较","包","再","做","功能","—","回到","由于","形式","...","想","其带","\"","上面","会","相当","修改","看出","def","简单","world","实际上","简述","使用","几行","器","于","python","器有","根据","包装","赋给","等价","__","没","上","生成","基于","不是",">","pass","call","function","原函数","前面","hello2","name2","更加","器先","makeitalic","：","对","都","函数调用","变成","p","『","像","i","main","对象","那么","#","类","已经","也","变","3","看","名字","装饰","__.","一种","class","对带","如下","应用","要求","还","特别","其赋","多个","object","最后","makebold","结果","写得","器带","+","』","{","wraps","init","改变","被","消除","_","则","假设","情况","闭包","改用","makeitalic2","的","可以","将","html","事实","/","函数","未免","jack","时","实现","或类","%","@","注意","带","使","参数","生成器","一下","类似","可","最",":","wrapped","提供","瑕疵","decorator","返回","而","functools","from","locals","直接","它","这种"," ","lusis","没有","two","想要","一样","标签","繁琐","func","）","看看","*","现在","接收","？","以","一般","kwargs","其实","}","提到","format","开始","见","因此","有时","要","高阶","调用","wrap","两个","简洁","代码","name1","需求","我们","s","如果","改写","限制","作用","副作用","是不是","新","进行","增强","in","return","绑定",",","one","此时","arg1","(","实际","<","中","原来","呢","（","内嵌"],"title":"3.4.装饰器","title_tokens":["装饰","器","3.4","."]},{"location":"Python基础/3.4.装饰器.html#_1","text":"有时候，我们需要给一个函数添加新功能。那么有一种做法就是修改原函数的代码，直接添加新功能。但这总做法有时未免太繁琐。在python中，直接给原函数套上装饰就可以实现这个需求。 假设有一个这样的函数： def hello (): return 'hello world' # hello函数的名字 print ( \"hello函数的名字：\" , hello . __name__ ) hello函数的名字： hello 现在我们想增强 hello() 函数的功能，希望给返回加上 HTML 标签，比如 <i>hello world</i> ，但有一个要求，不改变原来 hello() 函数的定义。 那么可以这样做： def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped 要注意的是，makeitalic函数的参数是一个函数，返回的结果是wrapped函数。 # 给hello函数套上makeitalic函数 # makeitalic函数返回wrapped函数 # 实际上此时hello变成了wrapped函数 hello = makeitalic ( hello ) 将 hello 函数作为参数传入 makeitalic 函数， makeitalic 函数返回wrapped函数，名字 hello 与 wrapped 函数绑定。此时名字 hello 代表了一个函数，也就是 wrapped 函数有了新的名字—— hello 。 # 可以看出hello函数的名字变了 print ( \"hello函数的名字：\" , hello . __name__ ) hello函数的名字： wrapped 总结一下：为了增强原函数 hello 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数。 事实上， makeitalic 就是一个装饰器（decorator），它『装饰』了函数 hello ，并返回一个函数，将其赋给 hello 。 像上面的情况，可以动态修改函数（或类）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 hello ）为参数，并返回一个包装后的函数（比如上面的 wrapped ）给被装饰函数（ hello ）。","text_tokens":["需要","比如","做法","不","是","就是","本质","=",")","这","作为","为了","事实上","有时候",".","动态","name","添加","套上","了","希望","在","print","。","传入","但","这个","与","，","就","加上","hello","给","代表","总","定义","有","时候","一个","后","并","未免太","这样","'","为","总结","做","功能","—","想","\"","上面","修改","看出","def","world","实际上","器","python","包装","__","上",">","原函数","makeitalic","：","变成","『","像","i","那么","#","也","变","名字","装饰","一种","要求","其赋","结果","+","』","改变","被","假设","情况","的","可以","将","html","事实","/","未免","函数","实现","或类","注意","参数","一下",":","wrapped","decorator","返回","直接","它"," ","标签","繁琐","func","）","现在","接收","以","有时","要","高阶","代码","需求","我们","新","增强","return","绑定",",","此时","(","实际","<","中","原来","（"],"title":"装饰器简述","title_tokens":["装饰","器","简述"]},{"location":"Python基础/3.4.装饰器.html#_2","text":"在python中，装饰器一般这样用： @decorator def func (): pass 等价于下面的形式 ： def func (): pass func = decorator ( func ) 装饰器可以定义多个，离函数定义最近的装饰器先被调用，比如 @decorator_one @decorator_two def func (): pass 等价于： def func (): pass func = decorator_one ( decorator_two ( func )) 装饰器还可以带参数，比如： @decorator ( arg1 , arg2 ) def func (): pass 等价于： def func (): pass func = decorator ( arg1 , arg2 )( func ) 例子： def makeitalic2 ( func ): return \"<i>\" + func () + \"</i>\" @makeitalic def hello_2 (): return 'hello world' def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped hello_2 () ' <i> hello world </i> ' 如果返回的不是函数就会这样： @makeitalic def hello_3 (): return 'hello world' def makeitalic ( func ): return \"<i>\" + func () + \"</i>\" hello_3 <function __main__.makeitalic.<locals>.wrapped()>","text_tokens":["'","这样","3","比如","__.","装饰","func","arg2","还","多个","形式","一般","=","+",")","\"","会","被","_",".","def","world","最近","调用","例子","makeitalic2","的","可以","器","于","python","函数","/","2","在","@","等价","如果","带","参数","__","不是",">","pass",":","wrapped","locals","下面","decorator","返回","，","function","就","return","hello","器先",",","：","定义","离","(","one","arg1","makeitalic","用","<","i"," ","中","main","two"],"title":"装饰器的一般使用形式","title_tokens":["一般","器","装饰","形式","的","使用"]},{"location":"Python基础/3.4.装饰器.html#_3","text":"前面的例子中，被装饰的函数 hello() 是没有带参数的，我们看看被装饰函数带参数的情况。对前面例子中的 hello() 函数进行改写，使其带参数，如下： def makeitalic ( func ): def wrapped ( * args , ** kwargs ): ret = func ( * args , ** kwargs ) return '<i>' + ret + '</i>' return wrapped @makeitalic def hello ( name ): return 'hello %s ' % name @makeitalic def hello2 ( name1 , name2 ): return 'hello %s , %s ' % ( name1 , name2 ) hello ( 'Jack' ) hello2 ( 'Jack' , \"Lusis\" ) 由于函数 hello 带参数，因此内嵌包装函数 wrapped 需要改变。","text_tokens":["需要","'","装饰","func","看看","如下","*","是","由于","kwargs","=","args","+",")","其带","\"","被","因此","改变","def","情况","ret","例子","jack","的","name1","name","/","函数","%","包装","我们","@","改写","带","使","参数","s","。","进行",":",">","wrapped","lusis","前面","hello2","，","name2","return","hello",",","makeitalic","对","：","(","<","i"," ","中","没有","内嵌"],"title":"对带参数的函数进行装饰","title_tokens":["函数","装饰","对带","参数","进行","的"]},{"location":"Python基础/3.4.装饰器.html#_4","text":"上面的例子，我们增强了函数 hello 的功能，给它的返回加上了标签 <i>...</i> ，现在，我们想改用标签 <b>...</b> 或 <p>...</p> 。是不是要像前面一样，再定义一个类似 makeitalic 的装饰器呢？其实，我们可以定义一个函数，将标签作为参数，返回一个装饰器，比如： def wrap_in_tag ( tag ): def decorator ( func ): def wrapped ( * args , ** kwargs ): ret = func ( * args , ** kwargs ) return '<' + tag + '>' + ret + '</' + tag + '>' return wrapped return decorator 生成想要的装饰器了： makebold = wrap_in_tag ( 'b' ) # 根据 'b' 返回 makebold 生成器 @makebold def hello ( name ): return 'hello %s ' % name hello ( 'world' ) ' <b> hello world </b> ' 上面的形式也可以写得更加简洁： @wrap_in_tag ( 'b' ) def hello ( name ): return 'hello %s ' % name","text_tokens":["比如","=","args","作为",")","ret","例子","b","成器","name","了","tag","。","，","加上","hello","给","定义","一个","'","或","再","功能","...","形式","想","上面","def","world","器","根据","生成","不是",">","前面","更加","makeitalic","：","p","像","i","#","也","装饰","makebold","写得","+","_","改用","的","可以","将","/","函数","%","@","参数","生成器","类似",":","wrapped","decorator","返回","它"," ","想要","一样","标签","func","*","现在","？","kwargs","其实","要","wrap","简洁","我们","s","是不是","增强","in","return",",","(","<","呢"],"title":"带参数的装饰器","title_tokens":["器","装饰","带","参数","的"]},{"location":"Python基础/3.4.装饰器.html#_5","text":"现在，让我们来看看多个装饰器的例子，为了简单起见，下面的例子就不使用带参数的装饰器。 def makebold ( func ): def wrapped (): return '<b>' + func () + '</b>' return wrapped def makeitalic ( func ): def wrapped (): return '<i>' + func () + '</i>' return wrapped @makebold @makeitalic def hello (): return 'hello world' 上面定义了两个装饰器，对 hello 进行装饰，上面的最后几行代码相当于： def hello (): return 'hello world' hello = makebold ( makeitalic ( hello )) 调用函数 hello： hello () ' <b><i> hello world </i></b> '","text_tokens":["'","当于","装饰","func","看看","不","现在","多个","最后","makebold","+","让","=","为了",")","上面","相当","见","简单","def","world","调用","例子","b","的","使用","两个","代码","几行","器","/","来","了","函数","我们","@","带","起","参数","相当于","。",">",":","进行","wrapped","下面","，","就","return","hello","makeitalic","对","定义","：","(","调用函数","<","i"," "],"title":"多个装饰器","title_tokens":["装饰","器","多个"]},{"location":"Python基础/3.4.装饰器.html#_6","text":"前面的装饰器都是一个函数，其实也可以基于类定义装饰器，看下面的例子： class Bold ( object ): def __init__ ( self , func ): self . func = func def __call__ ( self , * args , ** kwargs ): return '<b>' + self . func ( * args , ** kwargs ) + '</b>' @Bold def hello ( name ): return 'hello %s ' % name hello ( 'world' ) 可以看到，类 Bold 有两个方法： __init__() ：它接收一个函数作为参数，也就是被装饰的函数 __call__() ：让类对象可调用，就像函数调用一样，在调用被装饰函数时被调用 还可以让类装饰器带参数： class Tag ( object ): def __init__ ( self , tag ): self . tag = tag def __call__ ( self , func ): def wrapped ( * args , ** kwargs ): return \"< {tag} > {res} </ {tag} >\" . format ( res = func ( * args , ** kwargs ), tag = self . tag ) return wrapped @Tag ( 'b' ) def hello ( name ): return 'hello %s ' % name 需要注意的是，如果类装饰器有参数， 则 __init__ 接收参数，而 __call__ 接收 func。","text_tokens":["需要","res","是","方法","就是","=","args","让",")","作为",".","例子","b","bold","name","tag","在","。","self","下面","看到","，","就","hello","定义","有","一个","'","\"","def","world","器","器有","__","基于",">","call","前面","都","函数调用","：","像","对象","类","也","看","装饰","class","还","器带","+","{","init","被","则","的","可以","时","format","/","函数","%","@","注意","参数","可",":","wrapped","而","它"," ","一样","func","*","接收","kwargs","其实","}","调用","两个","s","如果","return",",","(","<","object"],"title":"基于类的装饰器","title_tokens":["器","装饰","基于","的","类"]},{"location":"Python基础/3.4.装饰器.html#_7","text":"前面提到，使用装饰器有一个瑕疵，就是被装饰的函数，它的函数名称已经不是原来的名称了，回到最开始的例子： def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped @makeitalic def hello (): return 'hello world' 函数 hello 被 makeitalic 装饰后，它的函数名称已经改变了： hello . __name__ 'wrapped' 为了消除这样的副作用，Python 中的 functools 包提供了一个 wraps 的装饰器： from functools import wraps def makeitalic ( func ): @wraps ( func ) # 加上 wraps 装饰器 def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped @makeitalic def hello (): return 'hello world' hello . __name__ 'hello' 事实上，装饰器就是闭包的一种应用，但它比较特别，接收被装饰函数为参数，并返回一个函数，赋给被装饰函数，闭包则没这种限制。","text_tokens":["import","就是",")","为了","事实上",".","例子","name","了","。","但","，","加上","hello","名称","一个","后","并","'","这样","为","比较","包","回到","\"","def","world","使用","器","器有","python","赋给","__","没","不是",">","前面","makeitalic","：","i","#","已经","装饰","一种","应用","特别","+","wraps","被","改变","消除","则","闭包","的","事实","/","函数","@","参数","最",":","wrapped","提供","瑕疵","返回","functools","from","它","这种"," ","func","接收","提到","开始","限制","作用","副作用","return","(","<","中","原来"],"title":"装饰器的副作用","title_tokens":["器","装饰","作用","副作用","的"]},{"location":"Python基础/4.1.类.html","text":"类提供了一种组合数据和功能的方法。类通常是由函数（称为方法，method）、变量（称为类变量，class variable）和计算出的属性（称为特性，property）组成的集合。创建一个新类意味着创建一个新类型的对象，从而允许创建一个该类型的新实例。每个类的实例可以拥有保存自己状态的属性。 Python 的类提供了面向对象编程的所有标准特性：类继承机制允许多个基类，派生类可以覆盖它基类的任何方法，一个方法可以调用基类中相同名称的的方法。对象可以包含任意数量和类型的数据。和模块一样，类也拥有 Python 天然的动态特性：它们在运行时创建，可以在创建后修改。 在Python中，约定使用单数并将首字母大写。 类中定义的函数称为 实例方法 。实例方法是一种在类的实例上进行操作的函数，类实例作为第一个参数传递。根据约定，这个参数称为self，尽管所有合法的标识符都可以使用。 self 参数指向对象本身。 self 很有用，甚至必不可少。如果没有它，所有的方法都无法访问对象本身（要操作的属性所属的对象）。 类变量 是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。 类实例 类的实例是以函数形式调用类对象来创建的。这种方法将创建一个新实例，然后将该实例传递给类的 __init__() 方法。 __init__() 方法的参数包括新创建的实例 self 和在调用类对象时提供的参数。 在 __init__() 内，通过将属性分配给 self 来将其保存到实例中。例如， self.name = name 表示将 name 属性保存在实例中。其中，点 . 运算符用于属性绑定。在新创建的实例返回到用户之后，使用点 . 运算符即可访问这些属性以及类的属性。 访问属性时，结果值可能来自多个不同的地方。可能来自实例独有的属性，也可能来自类的属性。访问属性时，Python 首先会检查实例，如果不知道该属性的任何信息，则会对实例的类进行搜索。这是类与其所有实例共享其属性的底层机制。 继承 继承是一种创建新类的机制，目的是使用或修改现有类的行为。原始类称为 基类 或 超类 。新类称为 派生类 或 子类 。 通过继承创建类时，所创建的类将“继承”其基类定义的属性。==但是，==派生类可以重新定义任何这些属性并添加自己的新属性。 在class语句中用以逗号分隔的基类名称列表来指定继承。如果没有有效的基类，类将继承object。object是所有Python对象的根类，提供了一些常见方法（如 __str__() ，它可创建供打印函数使用的字符串）的默认实现。 继承通常用于重新定义现有方法的行为。 继承是用功能稍微增强的点 . 运算符实现的。具体来讲，如果搜索一个属性时未在实例或实例的类中找到匹配项，将会继续搜索基类。这个过程会一直继续下去，直到没有更多的基类可供搜索为止。 派生类重定义 __init__() 时，不会自动调用基类的 __init__() 方法。因此，如果派生类想重定义 __init__() ，还想调用基类的 __init__() 方法，那么要由派生类调用基类的 __init__() 方法来对它们进行恰当的初始化。如果基类未定义 __init__() ，就可以忽略这一步。如果不知道基类是否定义了 __init__() ，可在不提供任何参数的情况下调用它，因为始终存在一个不执行任何操作的默认 __init__() 实现。 # 定义一个人类 class Person : def __init__ ( self , name , age ): self . name = name self . age = age def get_name ( self ): return self . name def get_age ( self ): return self . age # 定义一个美国人类 ## 现在想给美国人在初始化的时候加上 性别 的属性 class American ( Person ): # 重新定义__init__()会覆盖Person的__init__()方法 def __init__ ( self , name , age , gender ): Person . __init__ ( self , name , age ) self . gender = gender def get_gender ( self ): return self . gender jackson = American ( name = \"Cesar T. Mauck\" , age = 14 , gender = \"male\" ) jackson . get_age () 14 jackson . get_gender () 'male' # 有时，派生类将重新实现方法，但是还想调用原始的实现。 为此，有一种方法可以显式地调用基类中的原始方法，将实例 self 作为第一个参数传递即可，如下所示： # 定义一个华盛顿人类 class Washington ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 age = American . get_age () age += 1 self . age = age print ( \"Washington people grow up one year old\" ) 这个例子的微妙之处在于，American这个类其实没有实现 get_age() 方法。该方法是在Person类中实现的。尽管这段代码能够运行，但它可能会引起一些混淆（例如，American是否应该实现 get_age() ? ）。因此，替代解决方案是用 super() 函数，如下所示： # 定义一个加利福尼亚人类 class California ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 ## 实际上，因为get_age()方法在Person中定义 ## 这里可以传入Person的任何一个派生类 age = super ( California , self ) . get_age () age += 1 self . age = age print ( \"Californians grow up one year old\" ) Terri = California ( \"Terri H. Booth\" , 25 , \"female\" ) Terri . growing_up () Californians grow up one year old super(cls, instance) 会返回一个特殊对象，该对象支持在基类上执行属性查找。如果使用该函数，Python将使用本来应该在基类上使用的正常搜索规则来搜索属性。有了这种方式，就无需写死方法位置，并且能更清晰地陈述你的意图（即你希望调用以前的实现，无论它是哪个基类定义的）。然而， super() 的语法尚有不足之处。如果使用Python 3，可以使用简化的语句 super().get_age() 来执行上面示例中的计算。 多重继承 Python支持多重继承。通过让一个类列出多个基类即可指定多重继承。例如，下面给出了一个类集合： # 定义一个圣拉蒙人类 class San_Ramon ( American , California , Washington ): def growing_up ( self ): pass Edwin = San_Ramon ( \"Edwin A. Marcotte\" , 37 , \"male\" ) Edwin . get_age () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-6c60ffbe4e5a> in <module> 1 # 定义一个圣拉蒙人类 ----> 2 class San_Ramon(American, California, Washington): 3 def growing_up(self): 4 pass 5 TypeError: Cannot create a consistent method resolution order (MRO) for bases American, California, Washington 使用多重继承时，属性的解析会变得非常复杂，因为可以使用很多搜索路径来绑定属性。 在查找使用了多重继承的属性时，会将所有基类按从“最特殊”的类到“最不特殊”的类这种顺序进行排列。然后在搜索属性时，就会按这个顺序搜索，直至找到该属性的第一个定义。对于任何给定的类，通过打印它的 mro 属性即可查看基类的顺序，例如： 在大多数情况下，这个列表基于“有意义”的规则排列得出。也就是说，始终先检查派生类，然后再检查其基类，如果一个类具有多个父类，那么始终按类定义中列出的父类顺序检查这些父类。但是，基类的准确顺序实际上非常复杂，不是基于任何“简单的”算法，如深度优先或广度优先搜索。实际上，基类的顺序由 C3 线性化算法确定，可以在论文“A Monotonic Superclass Linearization for Dylan”（K. Barrett 等，发表于 OOPSLA’96）中找到该算法的介绍。该算法的一个需要注意的地方是，某些类层次结构将被 Python 拒绝并会抛出 TypeError 错误，例如： 一般来说，在大多数程序中最好避免使用多重继承。但是，多重继承有时可用于定义所谓的混合（mixin）类。混合类通常定义了要“混合到”其他类中的一组方法，目的是添加更多的功能（这与宏很类似）。通常，混合类中的方法将假定其他方法存在，并将以这些方法为基础构建。 多态动态绑定和鸭子类型 动态绑定（在继承背景下使用时，有时也称为多态性）是指在不考虑实例类型的情况下使用实例只要以 obj.attr 的形式访问属性，就会按照一定的顺序搜索并定位 attr ： 首先是实例本身，接着是实例的类定义，然后是基类。 查找过程会返回第一个匹配项。 这种绑定过程的关键在于，它不受对象 obj 的类型影响。因此，如果执行像 obj.name 这样的查找，对所有拥有 name 属性的 obj 都是适用的。这种行为有时被称为“鸭子类型”（duck typing），这个名称来源于一句谚语：“如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子。” Python 程序员经常编写利用这种行为的程序。例如，如果想编写现有对象的自定义版本，可以继承该对象，也可以创建一个外观和行为像它但与它无任何关系的全新对象。后一种方法通常用于保持程序组件的松散耦合。例如，可以编写代码来处理任何种类的对象，只要该对象拥有特定的方法集。最常见的例子就是利用标准库中定义的各种“类似文件”的对象。尽管这些对象的工作方式像文件，但它们并不是继承自内置文件对象的。 实例方法 类中最常用的方法是实例方法，即 将实例作为第一个参数传递给该方法。 例如，基本的实例方法如下： class Kls ( object ): def __init__ ( self , data ): self . data = data def printd ( self ): print ( self . data ) ik1 = Kls ( 'arun' ) ik2 = Kls ( 'seema' ) ik1 . printd () ik2 . printd () arun seema 然后看一下代码和示例图片: 在1、2中，参数传递给方法。 在3中， self参数指向当前实例。 在4中，我们不需要给方法提供实例， Python解释器自己会做这些操作 。 静态方法 Note 以下两个代码示例介绍了静态方法的两个应用场景： 不需要访问实例对象或类对象的方法和属性，但与类有关的功能 创建构造函数 经常有一些跟类有关系的功能，但在运行时又不需要实例和类参与（比如更改环境变量或者修改其他类的属性），当然可以在类定义之外写一个函数实现这些功能，但这样会扩散类内部的代码，不利于代码的维护。比如这样： IND = 'ON' def checkind (): return ( IND == 'ON' ) class Kls ( object ): def __init__ ( self , data ): self . data = data def do_reset ( self ): if checkind (): print ( 'Reset done for:' , self . data ) def set_db ( self ): if checkind (): self . db = 'new db connection' print ( 'DB connection made for:' , self . data ) ik1 = Kls ( 12 ) do_reset ( ik1 ) # Reset done for: 12 set_db ( ik1 ) # DB connection made for: 12 如果使用 @staticmethod 就能把相关的代码放到对应的位置了。 IND = 'ON' class Kls ( object ): def __init__ ( self , data ): self . data = data @staticmethod def checkind (): return ( IND == 'ON' ) def do_reset ( self ): if self . checkind (): print ( 'Reset done for:' , self . data ) def set_db ( self ): if self . checkind (): self . db = 'New db connection' print ( 'DB connection made for: ' , self . data ) ik1 = Kls ( 12 ) ik1 . do_reset () ik1 . set_db () Reset done for: 12 DB connection made for: 12 实际上，静态方法是一种普通函数，只不过它们正好位于类定义的命名空间中， 因为它不会对任何实例类型进行操作 。 如果在编写类时需要采用很多不同的方式来创建新实例，则常常使用静态方法。因为类中只能有一个 __init__() 函数，所以替代的创建函数通常按如下方式定义： import time class Date ( object ): def __init__ ( self , year , month , day ): self . year = year self . month = month self . day = day @staticmethod def now (): t = time . localtime () return Date ( t . tm_year , t . tm_mon , t . tm_mday ) @staticmethod def tomorrow (): t = time . localtime ( time . time () + 86400 ) return Date ( t . tm_year , t . tm_mon , t . tm_mday ) # 创建日期的示例 a = Date ( 1967 , 4 , 9 ) b = Date . now () # 调用静态方法now() c = Date . tomorrow () # 调用静态方法tomorrow() 类方法 Note 以下两个代码示例介绍了类方法的两个应用场景： 创建构造函数 动态更新类 类方法是将类本身作为对象进行操作的方法。类方法使用 @classmethod 装饰器定义，与实例方法不同，Python解释器会将类本身传递给类方法的第一个参数（一般将该参数命名为 cls ）。例如： class Times ( object ): factor = 1 @classmethod def mul ( cls , x ): return cls . factor * x class TwoTimes ( Times ): factor = 2 x = TwoTimes . mul ( 4 ) # 调用Times.mul(TwoTimes, 4) -> 8 在这个例子中，请注意类 TwoTimes 是如何作为对象传递给 mul() 的。尽管这个例子有些深奥，但类方法还有一些实用且巧妙的用法。例如，你定义了一个类，它继承自前面给出的 Date 类并对其略加定制： class EuroDate ( Date ): # 修改字符串转换，以使用欧洲日期格式 def __str__ ( self ): return \" %02d / %02d / %4d \" % ( self . day , self . month , self . year ) 由于该类继承自 Date，所以它拥有 Date 的所有特性。但是 now() 和 tomorrow() 方法稍微有点不同。例如，如果调用 EuroDate.now()，则会返回 Date 对象，而不是 EuroDate 对象。类方法可以解决该问题： class Date ( object ): def __init__ ( self , year , month , day ): self . year = year self . month = month self . day = day @classmethod def now ( cls ): t = time . localtime () return cls ( t . tm_year , t . tm_mon , t . tm_mday ) @classmethod def tomorrow ( cls ): t = time . localtime ( time . time () + 86400 ) return cls ( t . tm_year , t . tm_mon , t . tm_mday ) class EuroDate ( Date ): # 修改字符串转换，以使用欧洲日期格式 def __str__ ( self ): return \" %02d / %02d / %4d \" % ( self . day , self . month , self . year ) a = Date . now () # 调用Date.now(Date)并返回Date b = EuroDate . now () # 调用Date.now(EuroDate)并返回EuroDate print ( type ( a )) print ( type ( b )) <class '__main__.Date'> <class '__main__.EuroDate'> 类方法除了用于创建构造函数，另一个例子是动态更新类。例如我们想动态更新一个类属性： class Kls ( object ): models = {} def __init__ ( self , model_name ): # 加载模型 pass @classmethod def load_model ( cls , model_name ): cls . models [ model_name ] = cls ( model_name ) @classmethod def get_model ( cls , model_name ): return cls . models . get ( model_name , None ) def predict ( self ): return \"预测结果为1\" model_name = \"svm\" Kls . load_model ( model_name ) model = Kls . get_model ( model_name ) model . predict () '预测结果为1' Kls . models {'svm': <__main__.Kls at 0x215c1ba3d30>} 当然，除了使用类方法，也可以在实例方法中显式调用类属性，达到动态更新类的效果，例如我们要获取实例数： class Kls ( object ): no_inst = 0 def __init__ ( self ): Kls . no_inst = Kls . no_inst + 1 @classmethod def get_no_of_instance ( cls_obj ): return cls_obj . no_inst ik1 = Kls () ik2 = Kls () print ( ik1 . get_no_of_instance ()) print ( Kls . get_no_of_instance ()) 2 2 但是如果要用实例方法实现的话，就得创建一个实例对象，这意味着我们必须要给这个实例对象命名。在编程中，给过多的变量命名，有时是一个头疼的问题。 在类外面写一个函数也可以实现这样的效果，但不利于代码的维护。 def get_no_of_instances ( cls_obj ): return cls_obj . no_inst class Kls ( object ): no_inst = 0 def __init__ ( self ): Kls . no_inst = Kls . no_inst + 1 ik1 = Kls () ik2 = Kls () print ( get_no_of_instances ( Kls )) 2 实例方法、静态方法、类方法对比 在实例方法和类方法中，Python默认将当前实例或者类对象传给方法的第一个参数（非指定默认值的参数），如果方法不设置参数，便会报错： class Kls ( object ): def __init__ ( self , data ): self . data = data def imethod1 (): print ( \"不接收实例\" ) def imethod2 ( * arg ): print ( 'Instance:' , arg ) @staticmethod def smethod ( * arg ): print ( 'Static:' , arg ) @classmethod def cmethod1 (): print ( \"不接收类对象\" ) @classmethod def cmethod2 ( * arg ): print ( 'Class:' , arg ) ik3 = Kls ( 'arun' ) ik3 . imethod1 () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-82fbcd62768a> in <module> 1 ik3 = Kls('arun') ----> 2 ik3.imethod1() TypeError: imethod1() takes 0 positional arguments but 1 was given ik3 . cmethod1 () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-6055e1d64eee> in <module> ----> 1 ik3.cmethod1() TypeError: cmethod1() takes 0 positional arguments but 1 was given 实例方法、类方法必须设置参数接收类对象： ik3 . imethod2 () ik3 . cmethod2 () Instance: (<__main__.Kls object at 0x00000215C1B91F28>,) Class: (<class '__main__.Kls'>,) 静态方法则不会传入实例或类对象： ik3 . smethod () Static: () 如果方法不设置参数，只能通过类去调用，应该避免这种用法，没参数的方法应该加上 @staticmethod 装饰器： Kls . imethod1 () 不接收实例 关于静态方法和类方法需要注意的一点是，Python 不会在与实例方法独立的命名空间中管理它们。因此，可以通过实例或类调用它们。例如： Kls . cmethod2 () Kls ( 'arun' ) . cmethod2 () Kls . smethod () Kls ( 'arun' ) . smethod () Class: (<class '__main__.Kls'>,) Class: (<class '__main__.Kls'>,) Static: () Static: () 这可能很容易引起混淆，因为对 Kls('arun').cmethod2() 的调用与实例 Kls('arun') 没有任何关系。 这种行为是 Python 对象系统与其他面向对象语言（如 Smalltalk 和 Ruby）对象系统的区别之一。在这些语言中，类方法与实例方法是严格分开的。 而实例方法必须通过实例调用，因为需要传入实例。 特性 @property ——把方法变为属性 通常，访问实例或类的属性时，返回的会是所存储的相关值。特性（property）是一种特殊的属性，访问它时会计算它的值。下面是一个简单的例子： import math class Circle ( object ): def __init__ ( self , radius ): self . radius = radius # Circle的一些附加特性 @property def area ( self ): return math . pi * self . radius ** 2 @property def preimeter ( self ): return 2 * math . pi * self . radius 得到的Circle对象的行为如下： c = Circle ( 4.0 ) c . radius 4.0 c . area 50.26548245743669 c . preimeter 25.132741228718345 c . area = 2 ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-0dac39a0c579> in <module> ----> 1 c.area = 2 AttributeError: can't set attribute 在这个例子中，Circle 实例存储了一个实例变量 c.radius 。 c.area 和 c.perimeter 是根据该值计算得来的。 @property 装饰器支持以简单属性的形式访问后面的方法，无需像平常一样添加额外的 () 来调用该方法。对象的使用者很难发现正在计算一个属性，除非在试图重新定义该属性时生成了错误消息（如上面的 AttributeError 异常所示）。 这种特性使用方式遵循所谓的统一访问原则。 实际上，如果定义一个类，尽可能保持编程接口的统一总是不错的。如果没有特性，将会以简单属性（如 c.radius ）的形式访问对象的某些属性，而其他属性将以方法（如 c.area() ）的形式访问。费力去了解何时添加额外的 () 会带来不必要的混淆。特性可以解决该问题。 Python 程序员很少认识到， 方法本身是被隐式地作为一类特性处理的。 考虑下面这个类： class Foo ( object ): def __init__ ( self , name ): self . name = name def spam ( self , x ): print ( \" %s , %s \" % ( self . name , x )) Foo ( \"d\" ) . spam <bound method Foo.spam of <__main__.Foo object at 0x00000215C1BB43C8>> 用户创建 f = Foo(\"Guido\") 这样的实例然后访问 f.spam 时，不会返回原始函数对象 spam ，而是会得到所谓的绑定方法（bound method），绑定方法是一个对象，代表将在对象上调用 () 运算符时执行的方法调用。绑定方法有点类似于已部分计算的函数，其中的self参数已经填入，但其他参数仍然需要在使用 () 调用该函数时提供。这种绑定方法对象是由在后台执行的特性函数静默地创建的。 使用 @staticmethod 和 @classmethod 定义静态方法和类方法时，实际上就指定了使用不同的特性函数，以不同的方式处理对这些方法的访问。 例如， @staticmethod 仅“按原样”返回方法函数，不会进行任何特殊的包装或处理。 特性还可以截获操作权，以设置和删除属性。这是通过向特性附加其他 setter 和 deleter 方法来实现的，如下所示： class Foo ( object ): def __init__ ( self , name ): self . __name = name @property def name ( self ): return self . __name @name . setter def name ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value @name . deleter def name ( self ): raise TypeError ( \"Can't delete name\" ) 在这个例子中，首先使用 @property 装饰器和相关方法将属性 name 定义为只读特性。后面的 @name.setter 和 @name.deleter 装饰器将其他方法与 name 属性上的设置和删除操作相关联。这些方法的名称必须与原始特性的名称完全匹配。在这些方法中，请注意实际的名称值存储在属性 __name 中。所存储属性的名称无需遵循任何约定，但它必须与特性名称不同，以便将它与特性的名称区分开。 在以前的代码中，通常会看到用 property(getf=None, setf=None, delf=None, doc=None) 函数来定义特性，往其中传入一组名称不同的方法，用于执行相关操作。例如： class Foo ( object ): def getname ( self ): return self . __name def setname ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value def delname ( self ): raise TypeError ( \"Can't delete name\" ) name = property ( getname , setname , delname ) 这种老方法仍然可以使用，但装饰器版本会让类看起来更整洁。 例如，如果使用装饰器，get、 set 和 delete 函数将不会显示为方法。 数据封装和私有属性 默认情况下，类的所有属性和方法都是“公共的”。这意味着对它们的访问没有任何限制。这还暗示着，在基类中定义的所有内容都会被派生类继承，并可从派生类内进行访问。在面向对象的应用程序中，通常我们不希望发生这种行为，因为它会暴露对象的内部实现，可能导致在派生类中定义的对象与在基类中定义的对象之间发生命名空间冲突。 Note 这意味着派生类可以覆盖基类的定义。 为了解决该问题， 类中所有以双下划线开头的名称（如 __Foo ）都会自动变形，形成具有 _Classname__Foo 形式的新名称。 这提供了一种在类中添加私有属性和方法的有效方式，因为派生类中使用的私有名称不会与基类中使用的相同私有名称发生冲突，如下所示： class A ( object ): def __init__ ( self ): self . __X = 3 # 变形为self._A__X def __spam ( self ): # 变形为_A__spam() print ( \"A\" ) def bar ( self ): self . __spam () # 只调用A.__spam() class B ( A ): def __init__ ( self ): A . __init__ ( self ) self . __X = 37 # 变形为self._B__X def __spam ( self ): # 变形为_B__spam() print ( \"B\" ) b = B () # 派生类的定义没有覆盖基类的定义 b . bar () A 尽管这种方案似乎隐藏了数据，但并没有严格的机制来实际阻止对类的“私有”属性进行访问。特别是如果已知类名称和相应私有属性的名称，则可以使用变形后的名称来访问它们。通过重定义 dir() 方法，类可以降低这些属性的可见性， dir() 方法提供了检查对象的 dir() 函数所返回的名称列表。 尽管这种名称变形似乎是一个额外的处理步骤，但变形过程实际上只在定义类时发生一次。它不会在方法执行期间发生，也不会为程序的执行添加额外的开销。而且要知道，名称变形不会在 getattr() 、 hasattr() 、 setattr() 或 delattr() 等函数中发生，在这些函数中，属性名被指定为字符串。对于这些函数，需要显式使用变形名称（如 __Classname__name ）来访问属性。 建议在定义可变属性时，通过特性来使用私有属性。这样，就可鼓励用户使用特性名称，而无需直接访问底层实例数据（如果你在实例开头添加了一个特性，可能不想采用这种访问方式）。 通过为方法提供私有名称，超类可以阻止派生类重新定义和更改方法的实现。 例如，示例中的 A.bar() 方法只调用 A.__spam() ，无论 self 具有何种类型，或者派生类中是否存在不同的 __spam() 方法都是如此。 最后，不要混淆私有类属性的命名和模块中“私有”定义的命名。一个常见的错误是，在定义类时，在属性名上使用单个前导下划线来隐藏属性值（如 _name ）。 在模块中，这种命名约定可以阻止通过 from module import * 语句导出名称。 这意味着单下划线开头的定义只能被类本身和其派生类访问。但是在类中，这种命名约定既不能隐藏属性，在某个类继承该类并使用相同名称定义一个新属性或方法时，也不能阻止出现名称冲突。 对象表示和属性绑定 从内部实现上看，实例是使用字典来实现的，可以通过实例的 __dict__ 属性访问该字典。这个字典包含的数据对每个实例而言都是唯一的，如下所示： class Account ( object ): def __init__ ( self , name , balance ): self . name = name self . balance = balance a = Account ( \"Guido\" , 1100.0 ) a . __dict__ {'name': 'Guido', 'balance': 1100.0} 可以在任何时候向实例添加新属性，例如： a . number = 123456 # 将属性'number'添加到 a.__dict__ 对实例的修改始终会反映到局部 __dict__ 属性中。同样，如果直接对 __dict__ 进行修改，所做的修改也会反映在实例的属性中。 实例通过特殊属性 __class__ 链接回它们的类。类本身也只是对字典的浅层包装，你可以在实例的 __dict__ 属性中找到这个字典。可以在类字典中找到各种方法。例如： a . __class__ __main__.Account Account . __dict__ . keys () dict_keys(['__module__', '__init__', '__dict__', '__weakref__', '__doc__']) 最后，通过特殊属性 __bases__ 中将类链接到它们的基类，该属性是一个基类元组。这种底层结构是获取、设置和删除对象属性的所有操作的基础。 只要使用 obj.name = value 设置了属性，特殊方法 obj.__setattr__(\"name\", value) 就会被调用。如果使用 del obj.name 删除了一个属性，就会调用特殊方法 obj.__delattr__(\"name\") 。 这些方法的默认行为是修改或删除 obj 的局部 __dict__ 的值，除非请求的属性正好是一个特性或描述符。在这种情况下，设置和删除操作将由与该特性相关联的设置和删除函数执行。 在查找属性（如 obj.name ）时，将调用特殊方法 obj.__getattrribute__(\"name\") 。该方法执行搜索来查找该属性，这通常涉及检查特性、查找局部 __dict__ 属性、检查类字典以及搜索基类。如果搜索过程失败，最终会尝试调用类的 __getattr__() 方法（如果已定义）来查找该属性。如果这也失败，就会抛出 AttributeError 异常。 如果有必要，用户定义的类可以实现其自己的属性访问函数。例如： import math class Circle ( object ): def __init__ ( self , radius ): self . radius = radius def __getattr__ ( self , name ): if name == 'area' : return math . pi * self . radius ** 2 elif name == 'perimeter' : return 2 * math . pi * self . radius else : return object . __getattr__ ( self , name ) def __setattr__ ( self , name , value ): if name in [ 'area' , 'perimeter' ]: raise TypeError ( \" %s is readonly\" % name ) from None object . __setattr__ ( self , name , value ) c = Circle ( 2 ) c . area 12.566370614359172 c . area = 10 ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-52599b4ddcfc> in <module> ----> 1 c.area = 10 <ipython-input-1-a1a0cdcb1eb3> in __setattr__(self, name, value) 13 def __setattr__(self,name,value): 14 if name in ['area','perimeter']: ---> 15 raise TypeError(\"%s is readonly\" % name) from None 16 object.__setattr__(self,name,value) TypeError: area is readonly 重新实现这些方法的类应该可以依靠 object 中的默认实现来执行实际的工作。这是因为默认实现能够处理类的更高级特性，如描述符和特性。 一般来讲，类很少重新定义属性访问运算符。但是，在编写通用的包装器和现有对象的代理时，通常会使用属性访问运算符。通过重新定义 __getattr__() 、 __setattr__() 和 __delattr__() ，代理可以捕获属性访问操作，并透明地将这些操作转发给另一个对象。 __slots__ 通过定义特殊变量 slots ，类可以限制对合法实例属性名称的设置，如下所示： class Account ( object ): def __init__ ( self , name , balance ): self . name = name self . balance = balance __slots__ = ( 'name' , 'balance' ) a = Account ( \"Guido\" , 1100.0 ) a . date = \"12-12\" ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-b978ca4ed4ad> in <module> 7 8 a = Account(\"Guido\", 1100.0) ----> 9 a.date = \"12-12\" AttributeError: 'Account' object has no attribute 'date' 定义 __slots__ 时，可以将实例上分配的属性名称限制为指定的名称，否则将引发 AttributeError 异常。这种限制可以阻止其他人向现有实例添加新属性，即便用户将属性名称写错，也不会创建出新的属性来。 在实际使用中， __slots__ 从未被当作一种安全的特性来实现。它实际上是对内存和执行速度的一种性能优化。 使用 __slots__ 的类的实例不再使用字典来存储实例数据，转而采用一种基于数组的更加紧凑的数据结构。在会创建大量对象的程序中，使用 __slots__ 可以显著减少减少内存占用和执行时间。 注意， __slots__ 与继承的配合使用需要一定的技巧。如果类继承自使用 __slots__ 的基类，那么它也需要定义 __slots__ 来存储自己的属性（即使它不会添加任何属性也是如此），这样才能利用 __slots__ 提供的优势。如果忘记了这一点，派生类的运行速度将更慢，占用的内存也更多，比完全不使用 __slots__ 时情况更糟。 __slots__ 的使用还会破坏期望实例具有底层 __dict__ 属性的代码。尽管这一点通常不适用于用户代码，但对于支持对象的实用库和其他工具，其代码可能要依靠 __dict__ 来调试、序列化对象以及执行其他操作。 最后，如果类中重新定义了 __getattribute__() 、 __getattr__() 和 __setattr__() 等方法， __slots__ 的存在不会对它们的调用产生任何影响。但是，这些方法的默认行为将考虑到 __slots__ 。此外应该强调一点，没有必要向 __slots__ 添加方法或特性名称，因为它们存储在类中，而不是存储在每个实例中。 参考 difference between staticmethod and classmethod in python","text_tokens":["done","很多","类中","该类","系统","对应","重","意图","出现","不足之处","然后","问题","!","mday","大多数","分配","父类","对于","该值","叫声","bases","ik3","不可","name","替代","前导","了","紧凑","占用","存储","扩散","perimeter","不必","82fbcd62768a","##","天然","自定","优势","传入","]","但","这个","暗示","对比","一类","加上","dir","加利","假定","made","代表","之处","时候","而是","可能","year","仅","约定","并","编写","覆盖","这样","语言","继续","变为","相应","为","调试","独有","非常","分开","准确","截获","k","area","后面","应该","性能","connection","\"","上面","已知","考虑","typeerror","实际上","12","使用","-","程序员","只能","cesar","jackson","广度","保存","其他","甚至","__","新创","上","基于","该","smethod","其","没","生成",">","空间","程序","time","seema","models","、","名上","底层","老","根类","划线","出","大量","用户","即可","新创建","对","cannot","最好","来源","才能","像","默认","now","之一","只","setattr","单","报错","地","#","已经","has","位置","3","__.","静态方法","采用","面向","它们","还","ruby","method","与其","因为","多个","达到","头疼","结果","这里","松散","不利于","部分","第一个","+","多数","tomorrow","关联","另","共享","7","巧妙","即便","123456","冲突","a","mon","语法","或类","转发","既","不会","arun","创建","处","一下","人","data","4","接口","对类","dict","female","positional","状态","返回","区别","slots","继承","变量","’","支持","列出","superclass","命名","反映","期望","delf","如何","字母","正好","唯一","尽可","）","*","现在","结构","spam","接收","内","getattribute","更新","经常","attr","常常","其实","指向","过程","不再","数组","setter","圣","复杂","[","delname","people","然而","代码","开","性","知道","load","note","限制","模型","阻止","更慢","消息","新","到","ipython","db","发生","深奥","额外",",","华盛","one","线性化","权","时会","本身","集","拉蒙","do","c3","匹配","比如","imethod2","中显式","参与","显著","工具","高级","整洁","时间","californians","了解","首字","从","typing","位于","很难","请","每个","9","作为","之","且","相关联","避免","数据","module","特定","2","添加","尽管","拒绝","并会","用法","组合","recent","给定","确定","意味","集合","有关","guido","层次结构","向","字典","，","合法","一点","严格","定义","reset","产生","有","发生冲突","某个","a1a0cdcb1eb3","能够","一个","库中","简化","名","打印函数","优化","eurodate","getattrribute","否则","edwin","arguments","面向对象","无论","做","不错","失败","图片","维护","速度","想","看起","内部","arg","这些","4.0","子类","格式","修改","简单","平常","首先","关于","bound","d","一次","于","变形","把","包装","具体","或者","路径","必不可少","一定","加载","填入","“","是因为","call","派生类","解释","原样","order","影响","默认值","字符","字符串","：","?","consistent","而且","san","pi","must","形成","可见","过","但是","barrett","普通","52599b4ddcfc","不能","看","优先","twotimes","耦合","更","age","去","所以","放到","只不过","某些","管理","开销","也就是说","关键在于","即使","不适","resolution","导出","25","cmethod1","kls","信息","独立","情况","新类","之外","可以","时","将","只读","行为","doc","只是","标识符","most","create","property","@","%","显示","参数","不必要","variable","面向对象编程","可","原始","old","set","描述","恰当","提供","始终","隐藏","尼亚","写","超类","运算符","将会","所谓","直接","american","适用","环境","解释器","不过","account","福尼亚","给出","can","b978ca4ed4ad","删除","而言","inst","先","一般来讲","拥有","大多","内容","任何","依靠","例如","无","所示","有效","查看","一般","利于","不要","c","发给","步骤","并且","释器","执行","你","要","有时","排列","调用","等","私有","发现","属性","尚有","语句","staticmethod","还有","我们","非","elif","参考","以前","ik2","进行","增强","in","5","访问","linearization","内置","mauck","readonly","还会","绑定","所","除了","自己","如","male","隐式","转而","项","打印","中","查找","需要","人类","透明","引发","逗号","其他人","is","difference","包括","不","是","cmethod2","总是","得来","之间","起来","参数传递","”","具有","washington","ind","=","让","减少","last","为了","这","库","svm","宏","模块","一些","date","f","8","很少","4d","定位","认识","性别","希望","工作","算符","相关","times","str","关键","正在","混淆","统一","static","实例","self","1","x","自动","发表","期间","华盛顿","deleter","变得","各种","之后","忽略","attributeerror","常用","用以","单数","用","未定义","构造函数","有点","由","是否","不想","或","circle","未定","包含","自定义","得","解决方案","强调","附加","—","的话","由于","形式","供","示例","25.132741228718345","会","mul","无需","predict","def","全新","错误","直到","python","根据","安全","序列","on","解决","tm","6055e1d64eee","不是","以及","growing","为此","pass","区分","keys","指","基本","given","必要","降低","链接","更加","16","现有","都","种类","来讲","传给","完全","从未","顺序搜索","得到","构造","搜索","printd","main","运行","not","其中","也","介绍","组件","代理","最终","表示","方案","应用","静态","外面","处理","论文","类去","多重","up","非常复杂","smalltalk","init","被","略加","似乎","则","清晰","of","preimeter","13","建议","利用","就是说","的","走起","isinstance","直至","此外","可变","注意","遵循","grow","存在","类型","imethod1","按","往","顺序","环境变量","而","哪个","从而","初始化","背景","terri","这种","外观","容易","派生"," ","任意","15","new","无法访问","mixin","费力","何时","一步","使用者","更改","尝试","加利福","以","正常","配合","}","._","它会","意义","以双","dylan","加利福尼亚","他人","想重","delattr","input","instances","设置","来说","保持","机制","称为","来源于","定制","试图","s","如果","特性","为止","显式","线性","带来","raise","02d","便会","localtime","意味着","month","如此","0x00000215c1b91f28","规则","运算","obj","鼓励","return","一直","静默","delete","和","基础","层次","(","model","稍微","陈述","后台","14","<","10","当前","object","monotonic","不同","继续下去","深度","import","96","方法","下去","foo","就是","目的","booth","be","得出","获取",")","具体来讲","美国","bar","接着","不足","又","有些","动态",".","以便","例子","b","写错","不利","指定","来","时未","何种","在","操作","无法","print","捕获","。","所属","转发给","允许","初始","between","years","与","下面","列表","看到","走起路来","就","场景","factor","内存","给","大写","radius","hasattr","setf","名称","封装","h","当然","多态","单个","后","'","day","基类","6c60ffbe4e5a","很","效果","数","再","算法","功能","回","duck","传递","请求","浅层","中将","weakref","重新","del","关系","文件","下划","即","欧洲","通用","多","mro","跟类","元组","数量","器","下划线","来自","鸭子","实用","用于","value","微妙","ramon","was","破坏","比","gender","marcotte","0","开头","getattr","number","前面","这是","0x215c1ba3d30","技巧","抛出","按类","86400","37","对象","那么","方式","类","0dac39a0c579","按照","and","0x00000215c1bb43c8","看起来","装饰","getname","instance","一种","class","如下","一句","引起","编程","math","分隔","特别","最后","一组","no","涉及","局部","takes","t","环境变","{","通过","一般来说","构建","版本","classmethod","但类","类时","_","getf",".__","for","在于","1967","预测","地方","应用程序","解析","函数","/","12.566370614359172","实现","除非","setname","but","首字母","描述符","类似","if","同样","最","更糟",":","异常","公共","attribute","50.26548245743669","忘记","from","ik1","数据结构","源于","它","仍然","特殊","没有","不受","暴露","oopsla","一样","标识","检查","计算","组成","1100.0","尽可能","else","at","出新","暗示着","找到","第一","classname","数传","none","原则","因此","traceback","多态性","只要","序列化","混合","get","当作","标准","person","两个","本来","日期","点","california","值","常见","能","转换","必须","cls","导致","相同","单独","以下","已","string","段","死","用者","下","通常","自","所有","checkind","实际","super","balance","谚语","type","有用","（"],"title":"4.1.类","title_tokens":["4.1",".","类"]},{"location":"Python基础/4.1.类.html#_1","text":"类的实例是以函数形式调用类对象来创建的。这种方法将创建一个新实例，然后将该实例传递给类的 __init__() 方法。 __init__() 方法的参数包括新创建的实例 self 和在调用类对象时提供的参数。 在 __init__() 内，通过将属性分配给 self 来将其保存到实例中。例如， self.name = name 表示将 name 属性保存在实例中。其中，点 . 运算符用于属性绑定。在新创建的实例返回到用户之后，使用点 . 运算符即可访问这些属性以及类的属性。 访问属性时，结果值可能来自多个不同的地方。可能来自实例独有的属性，也可能来自类的属性。访问属性时，Python 首先会检查实例，如果不知道该属性的任何信息，则会对实例的类进行搜索。这是类与其所有实例共享其属性的底层机制。","text_tokens":["不同","包括","不","是","然后","方法","=",")","这","分配",".","name","来","在","算符","。","实例","self","之后","，","给","一个","可能","独有","形式","传递","会","这些","首先","使用","python","来自","用于","保存","__","新创","该","其","以及","底层","用户","即可","新创建","对","搜索","对象","其中","类","也","表示","与其","多个","结果","通过","init","信息","则","共享","地方","的","将","时","函数","参数","创建","提供","返回","运算符","这种"," ","检查","任何","内","例如","以","调用","点","机制","知道","属性","值","如果","新","进行","到","访问","运算","绑定","和","所有","(","中"],"title":"类实例","title_tokens":["实例","类"]},{"location":"Python基础/4.1.类.html#_2","text":"继承是一种创建新类的机制，目的是使用或修改现有类的行为。原始类称为 基类 或 超类 。新类称为 派生类 或 子类 。 通过继承创建类时，所创建的类将“继承”其基类定义的属性。==但是，==派生类可以重新定义任何这些属性并添加自己的新属性。 在class语句中用以逗号分隔的基类名称列表来指定继承。如果没有有效的基类，类将继承object。object是所有Python对象的根类，提供了一些常见方法（如 __str__() ，它可创建供打印函数使用的字符串）的默认实现。 继承通常用于重新定义现有方法的行为。 继承是用功能稍微增强的点 . 运算符实现的。具体来讲，如果搜索一个属性时未在实例或实例的类中找到匹配项，将会继续搜索基类。这个过程会一直继续下去，直到没有更多的基类可供搜索为止。 派生类重定义 __init__() 时，不会自动调用基类的 __init__() 方法。因此，如果派生类想重定义 __init__() ，还想调用基类的 __init__() 方法，那么要由派生类调用基类的 __init__() 方法来对它们进行恰当的初始化。如果基类未定义 __init__() ，就可以忽略这一步。如果不知道基类是否定义了 __init__() ，可在不提供任何参数的情况下调用它，因为始终存在一个不执行任何操作的默认 __init__() 实现。 # 定义一个人类 class Person : def __init__ ( self , name , age ): self . name = name self . age = age def get_name ( self ): return self . name def get_age ( self ): return self . age # 定义一个美国人类 ## 现在想给美国人在初始化的时候加上 性别 的属性 class American ( Person ): # 重新定义__init__()会覆盖Person的__init__()方法 def __init__ ( self , name , age , gender ): Person . __init__ ( self , name , age ) self . gender = gender def get_gender ( self ): return self . gender jackson = American ( name = \"Cesar T. Mauck\" , age = 14 , gender = \"male\" ) jackson . get_age () 14 jackson . get_gender () 'male' # 有时，派生类将重新实现方法，但是还想调用原始的实现。 为此，有一种方法可以显式地调用基类中的原始方法，将实例 self 作为第一个参数传递即可，如下所示： # 定义一个华盛顿人类 class Washington ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 age = American . get_age () age += 1 self . age = age print ( \"Washington people grow up one year old\" ) 这个例子的微妙之处在于，American这个类其实没有实现 get_age() 方法。该方法是在Person类中实现的。尽管这段代码能够运行，但它可能会引起一些混淆（例如，American是否应该实现 get_age() ? ）。因此，替代解决方案是用 super() 函数，如下所示： # 定义一个加利福尼亚人类 class California ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 ## 实际上，因为get_age()方法在Person中定义 ## 这里可以传入Person的任何一个派生类 age = super ( California , self ) . get_age () age += 1 self . age = age print ( \"Californians grow up one year old\" ) Terri = California ( \"Terri H. Booth\" , 25 , \"female\" ) Terri . growing_up () Californians grow up one year old super(cls, instance) 会返回一个特殊对象，该对象支持在基类上执行属性查找。如果使用该函数，Python将使用本来应该在基类上使用的正常搜索规则来搜索属性。有了这种方式，就无需写死方法位置，并且能更清晰地陈述你的意图（即你希望调用以前的实现，无论它是哪个基类定义的）。然而， super() 的语法尚有不足之处。如果使用Python 3，可以使用简化的语句 super().get_age() 来执行上面示例中的计算。","text_tokens":["类中","人类","匹配","继续下去","重","逗号","意图","不","不足之处","是","方法","下去","californians","”","目的","参数传递","booth","washington","=",")","具体来讲","这","美国","作为","之","不足","一些",".","f","例子","name","指定","替代","添加","来","了","时未","性别","在","算符","操作","print","str","尽管","死","混淆","。","实例","self","##","初始","自动","1","华盛顿","传入","years","但","这个","忽略","列表","，","用以","就","加上","给","加利","定义","名称","有","之处","用","h","时候","能够","一个","查找","可能","year","打印函数","未定义","简化","并","覆盖","'","基类","继续","段","由","是否","或","未定","无论","解决方案","功能","应该","供","传递","想","示例","\"","会","这些","上面","无需","子类","重新","修改","def","实际上","即","多","使用","直到","希望","python","cesar","用于","具体","jackson","微妙","__","解决","“","上","该","gender","其","growing","为此","派生类","根类","字符","one","现有","即可","字符串","来讲","对","：","?","instance","搜索","默认","对象","运行","那么","但是","方式","地","#","类","位置","3","更","一种","class","如下","age","引起","它们","方案","分隔","还","因为","object","这里","第一个","up","+","t","{","通过","25","init","类时","_","清晰","情况","新类","在于","的","将","可以","时","行为","函数","实现","语法","grow","不会","参数","创建","存在","处","原始","可","old","人",":","恰当","提供","始终","female","返回","尼亚","写","超类","运算符","将会","哪个","继承","初始化","terri","它","american","这种","派生"," ","福尼亚","没有","特殊","支持","一步","计算","）","现在","任何","加利福","例如","找到","所示","有效","正常","第一","其实","}","数传","过程","并且","因此","执行","加利福尼亚","想重","你","要","有时","get","调用","person","people","然而","代码","本来","机制","点","称为","属性","知道","california","语句","常见","能","尚有","如果","为止","cls","显式","以前","新","进行","增强","mauck","运算","规则","一直","return","所",",","下","自己","如","所有","(","通常","稍微","male","项","14","华盛","super","打印","中","实际","陈述","（"],"title":"继承","title_tokens":["继承"]},{"location":"Python基础/4.1.类.html#_3","text":"Python支持多重继承。通过让一个类列出多个基类即可指定多重继承。例如，下面给出了一个类集合： # 定义一个圣拉蒙人类 class San_Ramon ( American , California , Washington ): def growing_up ( self ): pass Edwin = San_Ramon ( \"Edwin A. Marcotte\" , 37 , \"male\" ) Edwin . get_age () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-6c60ffbe4e5a> in <module> 1 # 定义一个圣拉蒙人类 ----> 2 class San_Ramon(American, California, Washington): 3 def growing_up(self): 4 pass 5 TypeError: Cannot create a consistent method resolution order (MRO) for bases American, California, Washington 使用多重继承时，属性的解析会变得非常复杂，因为可以使用很多搜索路径来绑定属性。 在查找使用了多重继承的属性时，会将所有基类按从“最特殊”的类到“最不特殊”的类这种顺序进行排列。然后在搜索属性时，就会按这个顺序搜索，直至找到该属性的第一个定义。对于任何给定的类，通过打印它的 mro 属性即可查看基类的顺序，例如： 在大多数情况下，这个列表基于“有意义”的规则排列得出。也就是说，始终先检查派生类，然后再检查其基类，如果一个类具有多个父类，那么始终按类定义中列出的父类顺序检查这些父类。但是，基类的准确顺序实际上非常复杂，不是基于任何“简单的”算法，如深度优先或广度优先搜索。实际上，基类的顺序由 C3 线性化算法确定，可以在论文“A Monotonic Superclass Linearization for Dylan”（K. Barrett 等，发表于 OOPSLA’96）中找到该算法的介绍。该算法的一个需要注意的地方是，某些类层次结构将被 Python 拒绝并会抛出 TypeError 错误，例如： 一般来说，在大多数程序中最好避免使用多重继承。但是，多重继承有时可用于定义所谓的混合（mixin）类。混合类通常定义了要“混合到”其他类中的一组方法，目的是添加更多的功能（这与宏很类似）。通常，混合类中的方法将假定其他方法存在，并将以这些方法为基础构建。","text_tokens":["需要","很多","类中","人类","c3","深度","不","是","然后","96","方法","”","从","就是","具有","washington","得出","目的","=","让","大多数","last",")","这","父类","对于","宏","避免",".","bases","module","指定","2","了","来","拒绝","并会","添加","在","recent","。","self","1","给定","发表","确定","集合","变得","这个","层次结构","下面","与","列表","，","就","假定","定义","有","一个","并","基类","edwin","6c60ffbe4e5a","由","很","为","或","非常","再","算法","准确","最好","功能","k","\"","会","这些","简单","def","typeerror","实际上","mro","多","使用","错误","-","python","于","用于","广度","路径","其他","ramon","“","基于","该","其","growing","marcotte",">","pass","不是","程序","call","派生类","order","（","即可","抛出","：","cannot","consistent","按类","san","顺序搜索","37","搜索","中","那么","但是","barrett","#","类","介绍","3","优先","更","class","age","method","因为","多个","论文","一组","某些","也就是说","多重","up","非常复杂","第一个","多数","resolution","构建","通过","一般来说","被","_","for","情况","就是说","地方","的","时","可以","将","直至","解析","a","most","create","注意","存在","类似","可","按","最",":","4","始终","顺序","继承","所谓","american","这种","它","给出","支持"," ","特殊","列出","派生","superclass","’","oopsla","检查","mixin","先","大多","）","结构","任何","例如","找到","查看","以","一般","第一","意义","dylan","traceback","圣","复杂","有时","get","input","排列","等","混合","来说","要","california","属性","如果","线性","进行","ipython","in","5","到","linearization","规则","绑定",",","下","如","male","所有","(","线性化","层次","通常","实际","基础","<","打印","查找","拉蒙","monotonic"],"title":"多重继承","title_tokens":["继承","多重"]},{"location":"Python基础/4.1.类.html#_4","text":"动态绑定（在继承背景下使用时，有时也称为多态性）是指在不考虑实例类型的情况下使用实例只要以 obj.attr 的形式访问属性，就会按照一定的顺序搜索并定位 attr ： 首先是实例本身，接着是实例的类定义，然后是基类。 查找过程会返回第一个匹配项。 这种绑定过程的关键在于，它不受对象 obj 的类型影响。因此，如果执行像 obj.name 这样的查找，对所有拥有 name 属性的 obj 都是适用的。这种行为有时被称为“鸭子类型”（duck typing），这个名称来源于一句谚语：“如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子。” Python 程序员经常编写利用这种行为的程序。例如，如果想编写现有对象的自定义版本，可以继承该对象，也可以创建一个外观和行为像它但与它无任何关系的全新对象。后一种方法通常用于保持程序组件的松散耦合。例如，可以编写代码来处理任何种类的对象，只要该对象拥有特定的方法集。最常见的例子就是利用标准库中定义的各种“类似文件”的对象。尽管这些对象的工作方式像文件，但它们并不是继承自内置文件对象的。","text_tokens":["匹配","不","是","然后","方法","起来","”","typing","就是","接着","叫声","动态",".","特定","例子","name","定位","来","尽管","工作","在","关键","。","实例","自定","但","这个","与","各种","，","走起路来","就","定义","名称","多态","一个","库中","后","并","编写","这样","基类","自定义","形式","duck","想","看起","会","这些","考虑","关系","文件","首先","全新","使用","程序员","python","鸭子","用于","一定","“","该","不是","程序","指","、","影响","现有","都","而且","：","对","种类","来源","顺序搜索","搜索","像","对象","那么","方式","类","也","按照","组件","看起来","耦合","一种","一句","它们","处理","松散","关键在于","第一个","版本","被","情况","在于","利用","的","时","走起","可以","行为","创建","类型","类似","最","顺序","返回","继承","背景","源于","这种","它","外观","适用"," ","不受","拥有","）","任何","例如","以","无","经常","attr","第一","过程","因此","执行","多态性","只要","有时","标准","代码","保持","称为","属性","来源于","常见","如果","访问","内置","obj","绑定","下","和","通常","所有","自","项","本身","谚语","查找","集","（"],"title":"多态动态绑定和鸭子类型","title_tokens":["鸭子","绑定","和","类型","动态","多态"]},{"location":"Python基础/4.1.类.html#_5","text":"类中最常用的方法是实例方法，即 将实例作为第一个参数传递给该方法。 例如，基本的实例方法如下： class Kls ( object ): def __init__ ( self , data ): self . data = data def printd ( self ): print ( self . data ) ik1 = Kls ( 'arun' ) ik2 = Kls ( 'seema' ) ik1 . printd () ik2 . printd () arun seema 然后看一下代码和示例图片: 在1、2中，参数传递给方法。 在3中， self参数指向当前实例。 在4中，我们不需要给方法提供实例， Python解释器自己会做这些操作 。","text_tokens":["需要","'","类中","看","3","class","如下","不","是","然后","做","方法","参数传递","图片","传递","例如","第一","示例","第一个","=","数传","作为",")","指向","会","这些","init","kls","释器",".","def","即","的","将","代码","2","python","在","我们","操作","print","参数","__","arun","。","实例","该","self","一下","最","ik2","data",":","1","4","基本","seema","、","提供","解释","，","常用","ik1","给",",","和","：","自己","(","解释器","中","printd"," ","一个","当前","object"],"title":"实例方法","title_tokens":["实例","方法"]},{"location":"Python基础/4.1.类.html#_6","text":"Note 以下两个代码示例介绍了静态方法的两个应用场景： 不需要访问实例对象或类对象的方法和属性，但与类有关的功能 创建构造函数 经常有一些跟类有关系的功能，但在运行时又不需要实例和类参与（比如更改环境变量或者修改其他类的属性），当然可以在类定义之外写一个函数实现这些功能，但这样会扩散类内部的代码，不利于代码的维护。比如这样： IND = 'ON' def checkind (): return ( IND == 'ON' ) class Kls ( object ): def __init__ ( self , data ): self . data = data def do_reset ( self ): if checkind (): print ( 'Reset done for:' , self . data ) def set_db ( self ): if checkind (): self . db = 'new db connection' print ( 'DB connection made for:' , self . data ) ik1 = Kls ( 12 ) do_reset ( ik1 ) # Reset done for: 12 set_db ( ik1 ) # DB connection made for: 12 如果使用 @staticmethod 就能把相关的代码放到对应的位置了。 IND = 'ON' class Kls ( object ): def __init__ ( self , data ): self . data = data @staticmethod def checkind (): return ( IND == 'ON' ) def do_reset ( self ): if self . checkind (): print ( 'Reset done for:' , self . data ) def set_db ( self ): if self . checkind (): self . db = 'New db connection' print ( 'DB connection made for: ' , self . data ) ik1 = Kls ( 12 ) ik1 . do_reset () ik1 . set_db () Reset done for: 12 DB connection made for: 12 实际上，静态方法是一种普通函数，只不过它们正好位于类定义的命名空间中， 因为它不会对任何实例类型进行操作 。 如果在编写类时需要采用很多不同的方式来创建新实例，则常常使用静态方法。因为类中只能有一个 __init__() 函数，所以替代的创建函数通常按如下方式定义： import time class Date ( object ): def __init__ ( self , year , month , day ): self . year = year self . month = month self . day = day @staticmethod def now (): t = time . localtime () return Date ( t . tm_year , t . tm_mon , t . tm_mday ) @staticmethod def tomorrow (): t = time . localtime ( time . time () + 86400 ) return Date ( t . tm_year , t . tm_mon , t . tm_mday ) # 创建日期的示例 a = Date ( 1967 , 4 , 9 ) b = Date . now () # 调用静态方法now() c = Date . tomorrow () # 调用静态方法tomorrow()","text_tokens":["需要","done","很多","类中","不同","比如","对应","参与","不","import","是","方法","位于","ind","=","mday","9",")","又","一些","date",".","b","不利","替代","了","来","在","扩散","相关","print","操作","。","实例","self","但","与","有关","，","场景","就","made","定义","reset","有","当然","一个","year","构造函数","编写","'","这样","day","功能","维护","示例","connection","内部","会","这些","关系","修改","def","12","实际上","跟类","使用","把","只能","或者","其他","on","__","tm","空间","time","：","对","86400","构造","now","对象","运行","方式","普通","#","类","介绍","位置","静态方法","一种","class","如下","应用","静态","它们","采用","所以","放到","只不过","因为","object","不利于","+","环境变","t","tomorrow","init","kls","类时","_","则","for","1967","的","时","可以","之外","函数","mon","a","实现","或类","@","不会","创建","类型","set","if","按","data",":","4","环境变量","写","ik1","它","变量","环境","不过"," ","命名","new","正好","）","更改","任何","经常","常常","利于","c","调用","两个","代码","日期","属性","note","staticmethod","能","如果","localtime","进行","新","db","访问","以下","month","return",",","和","通常","(","checkind","实际","中","（","do"],"title":"静态方法","title_tokens":["静态方法","方法","静态"]},{"location":"Python基础/4.1.类.html#_7","text":"Note 以下两个代码示例介绍了类方法的两个应用场景： 创建构造函数 动态更新类 类方法是将类本身作为对象进行操作的方法。类方法使用 @classmethod 装饰器定义，与实例方法不同，Python解释器会将类本身传递给类方法的第一个参数（一般将该参数命名为 cls ）。例如： class Times ( object ): factor = 1 @classmethod def mul ( cls , x ): return cls . factor * x class TwoTimes ( Times ): factor = 2 x = TwoTimes . mul ( 4 ) # 调用Times.mul(TwoTimes, 4) -> 8 在这个例子中，请注意类 TwoTimes 是如何作为对象传递给 mul() 的。尽管这个例子有些深奥，但类方法还有一些实用且巧妙的用法。例如，你定义了一个类，它继承自前面给出的 Date 类并对其略加定制： class EuroDate ( Date ): # 修改字符串转换，以使用欧洲日期格式 def __str__ ( self ): return \" %02d / %02d / %4d \" % ( self . day , self . month , self . year ) 由于该类继承自 Date，所以它拥有 Date 的所有特性。但是 now() 和 tomorrow() 方法稍微有点不同。例如，如果调用 EuroDate.now()，则会返回 Date 对象，而不是 EuroDate 对象。类方法可以解决该问题： class Date ( object ): def __init__ ( self , year , month , day ): self . year = year self . month = month self . day = day @classmethod def now ( cls ): t = time . localtime () return cls ( t . tm_year , t . tm_mon , t . tm_mday ) @classmethod def tomorrow ( cls ): t = time . localtime ( time . time () + 86400 ) return cls ( t . tm_year , t . tm_mon , t . tm_mday ) class EuroDate ( Date ): # 修改字符串转换，以使用欧洲日期格式 def __str__ ( self ): return \" %02d / %02d / %4d \" % ( self . day , self . month , self . year ) a = Date . now () # 调用Date.now(Date)并返回Date b = EuroDate . now () # 调用Date.now(EuroDate)并返回EuroDate print ( type ( a )) print ( type ( b )) <class '__main__.Date'> <class '__main__.EuroDate'> 类方法除了用于创建构造函数，另一个例子是动态更新类。例如我们想动态更新一个类属性： class Kls ( object ): models = {} def __init__ ( self , model_name ): # 加载模型 pass @classmethod def load_model ( cls , model_name ): cls . models [ model_name ] = cls ( model_name ) @classmethod def get_model ( cls , model_name ): return cls . models . get ( model_name , None ) def predict ( self ): return \"预测结果为1\" model_name = \"svm\" Kls . load_model ( model_name ) model = Kls . get_model ( model_name ) model . predict () '预测结果为1' Kls . models {'svm': <__main__.Kls at 0x215c1ba3d30>} 当然，除了使用类方法，也可以在实例方法中显式调用类属性，达到动态更新类的效果，例如我们要获取实例数： class Kls ( object ): no_inst = 0 def __init__ ( self ): Kls . no_inst = Kls . no_inst + 1 @classmethod def get_no_of_instance ( cls_obj ): return cls_obj . no_inst ik1 = Kls () ik2 = Kls () print ( ik1 . get_no_of_instance ()) print ( Kls . get_no_of_instance ()) 2 2 但是如果要用实例方法实现的话，就得创建一个实例对象，这意味着我们必须要给这个实例对象命名。在编程中，给过多的变量命名，有时是一个头疼的问题。 在类外面写一个函数也可以实现这样的效果，但不利于代码的维护。 def get_no_of_instances ( cls_obj ): return cls_obj . no_inst class Kls ( object ): no_inst = 0 def __init__ ( self ): Kls . no_inst = Kls . no_inst + 1 ik1 = Kls () ik2 = Kls () print ( get_no_of_instances ( Kls )) 2","text_tokens":["该类","不同","中显式","是","方法","问题","请","=","mday","获取","作为",")","这","svm","有些","且","8","一些","date","动态",".","例子","b","4d","name","2","不利","了","尽管","用法","times","操作","在","print","str","。","实例","self","1","x","意味","]","但","与","这个","，","场景","factor","就","给","定义","用","当然","一个","year","构造函数","eurodate","并","有点","day","'","这样","为","效果","数","得","的话","由于","传递","维护","想","示例","\"","会","mul","格式","修改","predict","def","欧洲","多","使用","器","-","python","实用","用于","加载","__","解决","tm","该","其","不是",">","time","models","pass","0","解释","前面","0x215c1ba3d30","字符","（","字符串","：","对","86400","构造","now","对象","main","过","但是","#","类","也","介绍","__.","装饰","twotimes","instance","class","应用","编程","所以","外面","达到","头疼","结果","no","不利于","第一个","+","tomorrow","t","{","init","classmethod","但类","略加","则","_","另","kls","of","巧妙","预测","的","将","可以","/","函数","mon","a","%","实现","@","注意","参数","创建",":","4","而","返回","写","ik1","继承","它","变量","解释器","给出"," ","命名","inst","如何","拥有","）","*","at","例如","以","更新","一般","第一","利于","}","none","释器","你","[","要","get","有时","调用","instances","两个","代码","日期","属性","load","必须","note","还有","定制","转换","如果","特性","cls","我们","模型","02d","localtime","意味着","ik2","进行","month","以下","深奥","obj","return",",","自","和","除了","所有","(","model","稍微","本身","<","中","type","object"],"title":"类方法","title_tokens":["方法","类"]},{"location":"Python基础/4.1.类.html#_8","text":"在实例方法和类方法中，Python默认将当前实例或者类对象传给方法的第一个参数（非指定默认值的参数），如果方法不设置参数，便会报错： class Kls ( object ): def __init__ ( self , data ): self . data = data def imethod1 (): print ( \"不接收实例\" ) def imethod2 ( * arg ): print ( 'Instance:' , arg ) @staticmethod def smethod ( * arg ): print ( 'Static:' , arg ) @classmethod def cmethod1 (): print ( \"不接收类对象\" ) @classmethod def cmethod2 ( * arg ): print ( 'Class:' , arg ) ik3 = Kls ( 'arun' ) ik3 . imethod1 () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-82fbcd62768a> in <module> 1 ik3 = Kls('arun') ----> 2 ik3.imethod1() TypeError: imethod1() takes 0 positional arguments but 1 was given ik3 . cmethod1 () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-6055e1d64eee> in <module> ----> 1 ik3.cmethod1() TypeError: cmethod1() takes 0 positional arguments but 1 was given 实例方法、类方法必须设置参数接收类对象： ik3 . imethod2 () ik3 . cmethod2 () Instance: (<__main__.Kls object at 0x00000215C1B91F28>,) Class: (<class '__main__.Kls'>,) 静态方法则不会传入实例或类对象： ik3 . smethod () Static: () 如果方法不设置参数，只能通过类去调用，应该避免这种用法，没参数的方法应该加上 @staticmethod 装饰器： Kls . imethod1 () 不接收实例 关于静态方法和类方法需要注意的一点是，Python 不会在与实例方法独立的命名空间中管理它们。因此，可以通过实例或类调用它们。例如： Kls . cmethod2 () Kls ( 'arun' ) . cmethod2 () Kls . smethod () Kls ( 'arun' ) . smethod () Class: (<class '__main__.Kls'>,) Class: (<class '__main__.Kls'>,) Static: () Static: () 这可能很容易引起混淆，因为对 Kls('arun').cmethod2() 的调用与实例 Kls('arun') 没有任何关系。 这种行为是 Python 对象系统与其他面向对象语言（如 Smalltalk 和 Ruby）对象系统的区别之一。在这些语言中，类方法与实例方法是严格分开的。 而实例方法必须通过实例调用，因为需要传入实例。","text_tokens":["需要","系统","imethod2","不","cmethod2","是","方法","=","last",")","这","避免",".","module","ik3","指定","2","用法","在","print","recent","混淆","static","实例","self","1","82fbcd62768a","。","传入","与","，","加上","一点","严格","一个","可能","'","语言","很","arguments","面向对象","分开","应该","\"","arg","这些","关系","def","typeerror","关于","器","-","python","只能","或者","其他","was","__","没","6055e1d64eee","smethod",">","0","空间","call","given","、","默认值","（","传给","：","对","默认","对象","main","之一","报错","类","__.","静态方法","装饰","instance","class","静态","它们","引起","面向","ruby","因为","类去","管理","第一个","takes","smalltalk","通过","cmethod1","init","kls","classmethod","则","独立","的","将","可以","行为","most","或类","@","but","注意","参数","arun","不会","imethod1","data",":","positional","区别","而","这种","容易"," ","没有","命名","）","*","接收","任何","at","例如","第一","因此","traceback","input","调用","设置","非","staticmethod","必须","如果","便会","ipython","in","0x00000215c1b91f28",",","和","如","(","<","中","当前","object"],"title":"实例方法、静态方法、类方法对比","title_tokens":["静态方法","静态","实例","方法","对比","、","类"]},{"location":"Python基础/4.1.类.html#_9","text":"@property ——把方法变为属性 通常，访问实例或类的属性时，返回的会是所存储的相关值。特性（property）是一种特殊的属性，访问它时会计算它的值。下面是一个简单的例子： import math class Circle ( object ): def __init__ ( self , radius ): self . radius = radius # Circle的一些附加特性 @property def area ( self ): return math . pi * self . radius ** 2 @property def preimeter ( self ): return 2 * math . pi * self . radius 得到的Circle对象的行为如下： c = Circle ( 4.0 ) c . radius 4.0 c . area 50.26548245743669 c . preimeter 25.132741228718345 c . area = 2 ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-0dac39a0c579> in <module> ----> 1 c.area = 2 AttributeError: can't set attribute 在这个例子中，Circle 实例存储了一个实例变量 c.radius 。 c.area 和 c.perimeter 是根据该值计算得来的。 @property 装饰器支持以简单属性的形式访问后面的方法，无需像平常一样添加额外的 () 来调用该方法。对象的使用者很难发现正在计算一个属性，除非在试图重新定义该属性时生成了错误消息（如上面的 AttributeError 异常所示）。 这种特性使用方式遵循所谓的统一访问原则。 实际上，如果定义一个类，尽可能保持编程接口的统一总是不错的。如果没有特性，将会以简单属性（如 c.radius ）的形式访问对象的某些属性，而其他属性将以方法（如 c.area() ）的形式访问。费力去了解何时添加额外的 () 会带来不必要的混淆。特性可以解决该问题。 Python 程序员很少认识到， 方法本身是被隐式地作为一类特性处理的。 考虑下面这个类： class Foo ( object ): def __init__ ( self , name ): self . name = name def spam ( self , x ): print ( \" %s , %s \" % ( self . name , x )) Foo ( \"d\" ) . spam <bound method Foo.spam of <__main__.Foo object at 0x00000215C1BB43C8>> 用户创建 f = Foo(\"Guido\") 这样的实例然后访问 f.spam 时，不会返回原始函数对象 spam ，而是会得到所谓的绑定方法（bound method），绑定方法是一个对象，代表将在对象上调用 () 运算符时执行的方法调用。绑定方法有点类似于已部分计算的函数，其中的self参数已经填入，但其他参数仍然需要在使用 () 调用该函数时提供。这种绑定方法对象是由在后台执行的特性函数静默地创建的。 使用 @staticmethod 和 @classmethod 定义静态方法和类方法时，实际上就指定了使用不同的特性函数，以不同的方式处理对这些方法的访问。 例如， @staticmethod 仅“按原样”返回方法函数，不会进行任何特殊的包装或处理。 特性还可以截获操作权，以设置和删除属性。这是通过向特性附加其他 setter 和 deleter 方法来实现的，如下所示： class Foo ( object ): def __init__ ( self , name ): self . __name = name @property def name ( self ): return self . __name @name . setter def name ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value @name . deleter def name ( self ): raise TypeError ( \"Can't delete name\" ) 在这个例子中，首先使用 @property 装饰器和相关方法将属性 name 定义为只读特性。后面的 @name.setter 和 @name.deleter 装饰器将其他方法与 name 属性上的设置和删除操作相关联。这些方法的名称必须与原始特性的名称完全匹配。在这些方法中，请注意实际的名称值存储在属性 __name 中。所存储属性的名称无需遵循任何约定，但它必须与特性名称不同，以便将它与特性的名称区分开。 在以前的代码中，通常会看到用 property(getf=None, setf=None, delf=None, doc=None) 函数来定义特性，往其中传入一组名称不同的方法，用于执行相关操作。例如： class Foo ( object ): def getname ( self ): return self . __name def setname ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value def delname ( self ): raise TypeError ( \"Can't delete name\" ) name = property ( getname , setname , delname ) 这种老方法仍然可以使用，但装饰器版本会让类看起来更整洁。 例如，如果使用装饰器，get、 set 和 delete 函数将不会显示为方法。","text_tokens":["然后","问题","!","该值","name","了","存储","perimeter","不必","传入","但","这个","一类","代表","而是","可能","仅","约定","这样","变为","为","截获","area","后面","\"","上面","考虑","typeerror","实际上","使用","-","程序员","其他","__","生成","上","该","完全",">","程序","、","老","用户","对","像","地","#","已经","__.","静态方法","还","method","部分","关联","a","或类","不会","创建","接口","返回","变量","支持","delf","尽可","）","*","spam","setter","delname","代码","消息","ipython","到","额外",",","权","时会","本身","匹配","整洁","了解","很难","请","作为","相关联","module","2","添加","recent","向","guido","，","定义","一个","不错","看起","这些","4.0","简单","平常","首先","bound","d","于","把","包装","填入","“","call","原样","：","must","pi","更","去","某些","doc","时","将","可以","只读","行为","most","%","property","@","显示","参数","不必要","set","原始","提供","将会","运算符","所谓","can","删除","任何","例如","所示","c","执行","调用","发现","属性","staticmethod","以前","进行","in","访问","绑定","所","如","隐式","中","需要","总是","是","得来","起来","”","=","让","last","一些","f","很少","认识","相关","统一","正在","区分","str","算符","混淆","实例","self","1","x","deleter","attributeerror","用","有点","由","或","circle","附加","—","形式","25.132741228718345","会","无需","def","错误","python","根据","解决","必要","得到","main","not","其中","静态","处理","init","被","preimeter","of","的","isinstance","注意","遵循","按","往","而","这种"," ","费力","何时","使用者","以","input","设置","保持","试图","s","如果","特性","带来","raise","运算","return","delete","静默","和","(","后台","<","object","不同","import","方法","foo","be",")",".","以便","例子","指定","来","在","操作","print","。","与","下面","看到","就","radius","setf","名称","'","重新","器","用于","value","这是","对象","方式","类","0dac39a0c579","0x00000215c1bb43c8","getname","装饰","看起来","math","一种","class","如下","编程","一组","t","开","版本","通过","classmethod","getf","函数","setname","除非","实现","类似","if",":","异常","attribute","50.26548245743669","它","仍然","特殊","没有","一样","计算","尽可能","at","none","原则","traceback","get","值","必须","已","string","用者","通常","实际","（"],"title":"特性","title_tokens":["特性"]},{"location":"Python基础/4.1.类.html#_10","text":"默认情况下，类的所有属性和方法都是“公共的”。这意味着对它们的访问没有任何限制。这还暗示着，在基类中定义的所有内容都会被派生类继承，并可从派生类内进行访问。在面向对象的应用程序中，通常我们不希望发生这种行为，因为它会暴露对象的内部实现，可能导致在派生类中定义的对象与在基类中定义的对象之间发生命名空间冲突。 Note 这意味着派生类可以覆盖基类的定义。 为了解决该问题， 类中所有以双下划线开头的名称（如 __Foo ）都会自动变形，形成具有 _Classname__Foo 形式的新名称。 这提供了一种在类中添加私有属性和方法的有效方式，因为派生类中使用的私有名称不会与基类中使用的相同私有名称发生冲突，如下所示： class A ( object ): def __init__ ( self ): self . __X = 3 # 变形为self._A__X def __spam ( self ): # 变形为_A__spam() print ( \"A\" ) def bar ( self ): self . __spam () # 只调用A.__spam() class B ( A ): def __init__ ( self ): A . __init__ ( self ) self . __X = 37 # 变形为self._B__X def __spam ( self ): # 变形为_B__spam() print ( \"B\" ) b = B () # 派生类的定义没有覆盖基类的定义 b . bar () A 尽管这种方案似乎隐藏了数据，但并没有严格的机制来实际阻止对类的“私有”属性进行访问。特别是如果已知类名称和相应私有属性的名称，则可以使用变形后的名称来访问它们。通过重定义 dir() 方法，类可以降低这些属性的可见性， dir() 方法提供了检查对象的 dir() 函数所返回的名称列表。 尽管这种名称变形似乎是一个额外的处理步骤，但变形过程实际上只在定义类时发生一次。它不会在方法执行期间发生，也不会为程序的执行添加额外的开销。而且要知道，名称变形不会在 getattr() 、 hasattr() 、 setattr() 或 delattr() 等函数中发生，在这些函数中，属性名被指定为字符串。对于这些函数，需要显式使用变形名称（如 __Classname__name ）来访问属性。 建议在定义可变属性时，通过特性来使用私有属性。这样，就可鼓励用户使用特性名称，而无需直接访问底层实例数据（如果你在实例开头添加了一个特性，可能不想采用这种访问方式）。 通过为方法提供私有名称，超类可以阻止派生类重新定义和更改方法的实现。 例如，示例中的 A.bar() 方法只调用 A.__spam() ，无论 self 具有何种类型，或者派生类中是否存在不同的 __spam() 方法都是如此。 最后，不要混淆私有类属性的命名和模块中“私有”定义的命名。一个常见的错误是，在定义类时，在属性名上使用单个前导下划线来隐藏属性值（如 _name ）。 在模块中，这种命名约定可以阻止通过 from module import * 语句导出名称。 这意味着单下划线开头的定义只能被类本身和其派生类访问。但是在类中，这种命名约定既不能隐藏属性，在某个类继承该类并使用相同名称定义一个新属性或方法时，也不能阻止出现名称冲突。","text_tokens":["需要","类中","该类","不同","重","不","import","是","出现","方法","foo","之间","”","从","问题","具有","=","bar","为了","这",")","对于","模块",".","数据","module","b","name","指定","前导","了","添加","尽管","希望","来","在","何种","print","开销","期间","混淆","。","self","实例","x","自动","意味","但","与","暗示","列表","，","就","dir","严格","hasattr","定义","名称","发生冲突","某个","一个","名","可能","单个","后","并","约定","覆盖","相应","基类","这样","是否","为","不想","或","面向对象","无论","形式","示例","内部","\"","会","这些","已知","无需","重新","下划","def","实际上","使用","错误","一次","下划线","变形","只能","或者","解决","__","“","公共","该","其","空间","开头","程序","getattr","派生类","、","名上","底层","划线","字符","都","而且","对","：","可见","字符串","用户","37","形成","默认","对象","只","方式","setattr","单","但是","#","类","不能","也","3","降低","一种","class","如下","应用","方案","它们","面向","还","特别","采用","处理","因为","object","最后","通过","导出","init","被",".__","似乎","_","则","类时","情况","建议","的","可以","时","应用程序","冲突","行为","函数","a","实现","可变","既","不会","存在","类型","可","对类",":","提供","隐藏","返回","而","超类","from","继承","直接","这种","它","派生"," ","暴露","没有","命名","检查","）","更改","spam","*","内容","任何","内","暗示着","例如","所示","有效","不要","classname","._","它会","以双","步骤","过程","执行","你","要","delattr","私有","调用","等","机制","性","知道","属性","值","note","常见","限制","我们","如果","特性","语句","显式","导致","阻止","意味着","进行","新","相同","发生","访问","如此","鼓励","额外","所","下","和","通常","所有","如","(","实际","本身","中","（"],"title":"数据封装和私有属性","title_tokens":["属性","和","封装","数据","私有"]},{"location":"Python基础/4.1.类.html#_11","text":"从内部实现上看，实例是使用字典来实现的，可以通过实例的 __dict__ 属性访问该字典。这个字典包含的数据对每个实例而言都是唯一的，如下所示： class Account ( object ): def __init__ ( self , name , balance ): self . name = name self . balance = balance a = Account ( \"Guido\" , 1100.0 ) a . __dict__ {'name': 'Guido', 'balance': 1100.0} 可以在任何时候向实例添加新属性，例如： a . number = 123456 # 将属性'number'添加到 a.__dict__ 对实例的修改始终会反映到局部 __dict__ 属性中。同样，如果直接对 __dict__ 进行修改，所做的修改也会反映在实例的属性中。 实例通过特殊属性 __class__ 链接回它们的类。类本身也只是对字典的浅层包装，你可以在实例的 __dict__ 属性中找到这个字典。可以在类字典中找到各种方法。例如： a . __class__ __main__.Account Account . __dict__ . keys () dict_keys(['__module__', '__init__', '__dict__', '__weakref__', '__doc__']) 最后，通过特殊属性 __bases__ 中将类链接到它们的基类，该属性是一个基类元组。这种底层结构是获取、设置和删除对象属性的所有操作的基础。 只要使用 obj.name = value 设置了属性，特殊方法 obj.__setattr__(\"name\", value) 就会被调用。如果使用 del obj.name 删除了一个属性，就会调用特殊方法 obj.__delattr__(\"name\") 。 这些方法的默认行为是修改或删除 obj 的局部 __dict__ 的值，除非请求的属性正好是一个特性或描述符。在这种情况下，设置和删除操作将由与该特性相关联的设置和删除函数执行。 在查找属性（如 obj.name ）时，将调用特殊方法 obj.__getattrribute__(\"name\") 。该方法执行搜索来查找该属性，这通常涉及检查特性、查找局部 __dict__ 属性、检查类字典以及搜索基类。如果搜索过程失败，最终会尝试调用类的 __getattr__() 方法（如果已定义）来查找该属性。如果这也失败，就会抛出 AttributeError 异常。 如果有必要，用户定义的类可以实现其自己的属性访问函数。例如： import math class Circle ( object ): def __init__ ( self , radius ): self . radius = radius def __getattr__ ( self , name ): if name == 'area' : return math . pi * self . radius ** 2 elif name == 'perimeter' : return 2 * math . pi * self . radius else : return object . __getattr__ ( self , name ) def __setattr__ ( self , name , value ): if name in [ 'area' , 'perimeter' ]: raise TypeError ( \" %s is readonly\" % name ) from None object . __setattr__ ( self , name , value ) c = Circle ( 2 ) c . area 12.566370614359172 c . area = 10 ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-52599b4ddcfc> in <module> ----> 1 c.area = 10 <ipython-input-1-a1a0cdcb1eb3> in __setattr__(self, name, value) 13 def __setattr__(self,name,value): 14 if name in ['area','perimeter']: ---> 15 raise TypeError(\"%s is readonly\" % name) from None 16 object.__setattr__(self,name,value) TypeError: area is readonly 重新实现这些方法的类应该可以依靠 object 中的默认实现来执行实际的工作。这是因为默认实现能够处理类的更高级特性，如描述符和特性。 一般来讲，类很少重新定义属性访问运算符。但是，在编写通用的包装器和现有对象的代理时，通常会使用属性访问运算符。通过重新定义 __getattr__() 、 __setattr__() 和 __delattr__() ，代理可以捕获属性访问操作，并透明地将这些操作转发给另一个对象。","text_tokens":["透明","is","import","是","方法","高级","从","每个","=","获取",")","这","last","相关联","数据",".","module","bases","很少","name","2","来","添加","了","工作","在","操作","相关","perimeter","算符","捕获","recent","。","实例","self","1","转发给","字典","向","guido","]","这个","与","各种","attributeerror","，","就","radius","定义","有","a1a0cdcb1eb3","查找","时候","能够","一个","并","编写","'","getattrribute","基类","由","或","circle","包含","做","失败","area","回","应该","请求","浅层","中将","内部","\"","会","weakref","这些","del","重新","修改","def","typeerror","通用","元组","使用","器","-","包装","value","__","上","该","以及","keys","其",">","getattr","number","call","链接","、","必要","底层","是因为","16","（","现有","都","抛出","对","：","用户","pi","来讲","搜索","main","对象","默认","setattr","52599b4ddcfc","但是","地","#","类","也","看","__.","代理","最终","math","class","如下","更","它们","处理","因为","最后","涉及","局部","关联","{","通过","init",".__","被","13","_","另","情况","的","可以","123456","将","doc","行为","函数","a","只是","时","实现","除非","%","12.566370614359172","most","转发","描述符","描述","同样","if","dict",":","异常","始终","from","运算符","直接","这种","account"," ","特殊","删除","反映","而言","15","检查","正好","一般来讲","唯一","1100.0","）","*","结构","尝试","任何","依靠","例如","找到","所示","一般","}","c","发给","过程","none","你","执行","只要","traceback","[","delattr","input","调用","设置","属性","值","elif","else","raise","如果","特性","s","进行","新","到","in","ipython","访问","readonly","已","obj","运算","return","所",",","和","下","基础","所有","(","如","通常","自己","实际","14","本身","balance","10","中","<","object"],"title":"对象表示和属性绑定","title_tokens":["属性","绑定","和","表示","对象"]},{"location":"Python基础/4.1.类.html#__slots__","text":"通过定义特殊变量 slots ，类可以限制对合法实例属性名称的设置，如下所示： class Account ( object ): def __init__ ( self , name , balance ): self . name = name self . balance = balance __slots__ = ( 'name' , 'balance' ) a = Account ( \"Guido\" , 1100.0 ) a . date = \"12-12\" ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-b978ca4ed4ad> in <module> 7 8 a = Account(\"Guido\", 1100.0) ----> 9 a.date = \"12-12\" AttributeError: 'Account' object has no attribute 'date' 定义 __slots__ 时，可以将实例上分配的属性名称限制为指定的名称，否则将引发 AttributeError 异常。这种限制可以阻止其他人向现有实例添加新属性，即便用户将属性名称写错，也不会创建出新的属性来。 在实际使用中， __slots__ 从未被当作一种安全的特性来实现。它实际上是对内存和执行速度的一种性能优化。 使用 __slots__ 的类的实例不再使用字典来存储实例数据，转而采用一种基于数组的更加紧凑的数据结构。在会创建大量对象的程序中，使用 __slots__ 可以显著减少减少内存占用和执行时间。 注意， __slots__ 与继承的配合使用需要一定的技巧。如果类继承自使用 __slots__ 的基类，那么它也需要定义 __slots__ 来存储自己的属性（即使它不会添加任何属性也是如此），这样才能利用 __slots__ 提供的优势。如果忘记了这一点，派生类的运行速度将更慢，占用的内存也更多，比完全不使用 __slots__ 时情况更糟。 __slots__ 的使用还会破坏期望实例具有底层 __dict__ 属性的代码。尽管这一点通常不适用于用户代码，但对于支持对象的实用库和其他工具，其代码可能要依靠 __dict__ 来调试、序列化对象以及执行其他操作。 最后，如果类中重新定义了 __getattribute__() 、 __getattr__() 和 __setattr__() 等方法， __slots__ 的存在不会对它们的调用产生任何影响。但是，这些方法的默认行为将考虑到 __slots__ 。此外应该强调一点，没有必要向 __slots__ 添加方法或特性名称，因为它们存储在类中，而不是存储在每个实例中。","text_tokens":["需要","类中","引发","其他人","不","是","显著","工具","方法","时间","具有","每个","=","减少","9","last",")","这","库","分配","对于","date","8",".","数据","module","写错","name","指定","紧凑","添加","来","占用","了","尽管","在","存储","操作","recent","。","实例","self","1","优势","字典","向","guido","但","与","attributeerror","，","合法","内存","一点","定义","产生","名称","可能","优化","'","否则","基类","这样","调试","为","或","强调","应该","速度","性能","\"","会","这些","重新","考虑","def","12","实际上","多","使用","-","序列","安全","实用","用于","其他","一定","破坏","__","上","基于","比","完全","其","以及","不是",">","getattr","程序","call","大量","派生类","、","底层","更加","影响","必要","（","现有","用户","技巧","对","：","才能","从未","默认","对象","运行","那么","setattr","但是","类","has","也","slots","更","一种","class","如下","采用","它们","因为","最后","no","不适","即使","通过","init","被","7","情况","利用","即便","的","可以","时","将","此外","行为","a","most","实现","注意","不会","创建","存在","更糟",":","异常","dict","attribute","提供","而","忘记","数据结构","继承","这种","它","变量","account","派生"," ","特殊","支持","没有","b978ca4ed4ad","期望","1100.0","）","结构","任何","依靠","出新","getattribute","所示","配合","不再","数组","traceback","他人","执行","序列化","要","input","当作","等","设置","调用","代码","属性","限制","如果","特性","阻止","更慢","新","ipython","in","到","如此","还会",",","和","自","自己","转而","(","通常","实际","<","balance","中","object"],"title":"__slots__","title_tokens":["slots","__"]},{"location":"Python基础/4.1.类.html#_12","text":"difference between staticmethod and classmethod in python","text_tokens":["and","python","staticmethod","difference","classmethod","between"," ","in"],"title":"参考","title_tokens":["参考"]},{"location":"Python基础/4.2.模块.html","text":"为什么需要模块 如果你想要编写一些更大的程序，肯定不想定义重复的函数、类，想让代码可以重复使用。随着程序变得越来越大，你可能想要将它分割成几个更易于维护的文件。为了满足这些需要，Python 提供了一个方法可以从文件中获取定义，在脚本或者解释器的一个交互式实例中使用。这样的文件被称为模块。 模块搜索路径 Python 怎样知道从何处找到模块文件？ 如果你熟悉命令行，那么这个问题对你来说就不难理解。在命令行中执行的任何命令，实际上背后都对应了一个可执行文件。命令行解释器（比如 cmd, bash）会从一个全局的环境变量 PATH 中读取一个有序的列表。这个列表包含了一系列的路径，而命令行解释器，会依次在这些路径里，搜索需要的可执行文件。 Python 搜寻模块文件，也遵循了类似的思路。比如，用户在 Python 中尝试导入 import foobar，那么 首先，Python 会在内建模块中搜寻 foobar； 若未找到，则 Python 会在当前工作路径（当前脚本所在路径，或者执行 Python 解释器的路径）中搜寻 foobar； 若仍未找到，则 Python 会在环境变量 PYTHONPATH 中指示的路径中搜寻 foobar； 若依旧未能找到，则 Python 会在安装时指定的路径中搜寻 foobar； 若仍旧失败，则 Python 会报错，提示找不到 foobar 这个模块。 添加搜索路径 当我们使用import加载自己编写的py代码时，必须放在python的默认路径下才可以import。 添加临时路径—— sys.path.append 在python中引入 sys ， sys 中的 path 是一个列表类型的对象，内容就是路径的列表，我们将sys引入后查看就可以清楚的知道了： import sys print ( type ( sys . path )) [ path for path in sys . path if \"Wiki\" not in path ] <class 'list'> ['C:\\\\Users\\\\Android\\\\Desktop', 'G:\\\\Installed\\\\Anaconda3\\\\python37.zip', 'G:\\\\Installed\\\\Anaconda3\\\\DLLs', 'G:\\\\Installed\\\\Anaconda3\\\\lib', 'G:\\\\Installed\\\\Anaconda3', 'C:\\\\Users\\\\Android\\\\AppData\\\\Roaming\\\\Python\\\\Python37\\\\site- packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site- packages\\\\xgboost-1.0.0_snapshot-py3.7.egg', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32\\\\lib', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\Pythonwin', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\IPython\\\\extensions', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop'] 既然是list对象，那么使用append可以向列表添加新的元素，假设我们要添加的路径是 \"C:\\Users\\Android\\Desktop\" ： import sys sys . path . append ( r \"C:\\Users\\Android\\Desktop\" ) 但这只是临时添加路径，如果重启编译器，添加的路径就会消失。 修改环境变量 在Windows10中，选择 ->控制面板\\系统和安全\\系统->高级系统设置->环境变量 ， # 找到path后选择编辑，添加新的路径。 但这种方法不能适用所有python的功能，因为这种方法并未将要查找的路径添加到python的Path系统环境中，在sys.path的列表中找不到相关路径的元素。也就是说这样做并没有将路径添加到python的搜索路径中。 添加永久搜索路径——增加.pth文件 在site-packages文件夹添加path文件，可以实现搜索路径的永久添加。方法如下： 先编辑一个扩展名为 .pth 的文本文件，在这个文本文件里面写上要添加的path就可以了，例如： 文本文件的文件名是：test.pth test.pth 文件的内容是： C:\\Users\\Android\\Desktop 接着获取python的site-packages文件夹的路径： import site site . getsitepackages () ['G:\\\\Installed\\\\Anaconda3', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site- packages'] 然后将 test.pth 文件放进 G:\\Installed\\Anaconda3\\lib\\site-packages 里面即可。 模块的导入 在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块(module)导入: 例如，我们要使用使用 sys 模块，那么首先要导入该模块： import sys 导入 sys 模块后，我们就有了 变量 sys 指向该模块，利用 sys 这个变量，就可以访问 sys 模块的所有功能。 也就是说导入整个模块的做法会导致命名空间的修改。 也可以一次性导入多个module： import os , sys , time 通过 as 关键字，可以在导入module的时候，给module定义别名： import sys as system 从某个模块中导入函数： 从某个模块中导入某个函数 from somemodule import somefunction 从某个模块中导入多个函数 from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入 from somemodule import * 一般而言，除了实验、排查，不推荐导入模块内的所有公开符号（没有前缀 _ 的那些）。因为导入模块会修改namespace，而通常你不知道模块定义了哪些符号、是否与当前的namespace有重名的符号。一旦有重名，那么，就会覆盖掉当前namespace的值。从而造成难以排查的错误 模块重载 出于性能考虑， 每个模块在每个解释器会话中只导入一遍。 因此，如果修改了的模块，需要重启解释器；如果想交互式地测试一个模块，则需要使用以下方法重新导入模块： 注意 只能重载模块，不能单独重载模块中的某个函数、类、变量。 Python 2.x： reload ( modulename ) Python 2.x 至 Python3.3： import imp imp . reload ( modulename ) Python3.4+： import importlib importlib . reload ( modulename ) 另外，spyder 的UMR(user module reloader)提供了自动重载模块的功能。 模块的识别 和 Python 中的其它对象一样，Python 也为模块定义了一些形如 __foo__ 的变量。对于模块来说，最重要的就是它的名字 __name__ 了。每当 Python 执行脚本，它就会为该脚本赋予一个名字： 对于「主程序」来说，这一脚本的 __name__ 被定义为 \"__main__\" 对于被 import 进主程序的模块来说，这一脚本的 __name__ 被定义为脚本的文件名（base filename） 因此，我们可以用如下的形式，在模块代码中定义一些测试代码： if __name__ == \"__main__\" : ··· 当脚本被直接运行时，测试代码就会被运行；当脚本作为模块被导入，测试代码不会被运行。 以下是一个完整的代码示例： 参考：(Python 中的黑暗角落（三）：模块与包)[https://liam0205.me/2017/07/23/modules-and-packages-of-python/] #!/usr/bin/env python3 # -*- coding: utf-8 -*- ' a test module ' __author__ = 'Michael Liao' import sys def test (): args = sys . argv if len ( args ) == 1 : print ( 'Hello, world!' ) elif len ( args ) == 2 : print ( 'Hello, %s !' % args [ 1 ]) else : print ( 'Too many arguments!' ) if __name__ == '__main__' : test () Hello, world! 作用域 在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用，在Python中，是通过 _ 前缀来实现的。 正常的函数和变量名是公开的（public），可以被直接引用，比如： abc ， x123 ， PI 等； 类似 __xxx__ 这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的 __author__ ， __name__ 就是特殊变量， hello 模块定义的文档注释也可以用特殊变量 __doc__ 访问，我们自己的变量一般不要用这种变量名； 类似 _xxx 和 __xxx 这样的函数或变量就是非公开的（private），不应该被直接引用，比如 _abc ， __abc 等； 之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。 private函数或变量不应该被别人引用，那它们有什么用呢？请看例子 def _private_1 ( name ): return 'Hello, %s ' % name def _private_2 ( name ): return 'Hi, %s ' % name def greeting ( name ): if len ( name ) > 3 : return _private_1 ( name ) else : return _private_2 ( name ) 我们在模块里公开 greeting() 函数，而把内部逻辑用private函数隐藏起来了，这样，调用 greeting() 函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即： 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。 作为脚本来执行模块 当你使用以下方式运行 Python 模块时，模块中的代码便会被执行: python fibo.py <arguments> 模块中的代码会被执行，就像导入它一样，不过 此时 __name__ 被设置为 \"__main__\" 。 这相当于，如果你在模块后加入如下代码: if __name__ == \"__main__\" : import sys fib ( int ( sys . argv [ 1 ])) 就可以让此文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为 “main” 文件执行时才被调用: $ python fibo . py 50 1 1 2 3 5 8 13 21 34 如果模块被导入，不会执行这段代码: >>> import fibo >>> 这通常用来为模块提供一个便于测试的用户接口（将模块作为脚本执行测试需求）。 “编译的” Python 文件—— pyc 文件 和 LaTeX 中遇到的问题一样：装载大量文本文件（ .py 文件）是很慢的。因此 Python 也采用了类似 LaTeX 的解决方案：将模块编译成容易装载的文件，并在 __pycache__ 目录下以 module.*version*.pyc 名字缓存这些文件。（相当于 LaTeX 中的 dump 格式文件 .fmt ）。 这里的版本编制了编译后文件的格式。它通常会包含 Python 的版本号。例如，在 CPython 3.3 版中，spam.py 编译后的版本将缓存为 __pycache__/spam.cpython-33.pyc 。这种命名约定允许由不同发布和不同版本的 Python 编译的模块同时存在。 当 Python 编译好模块之后，下次载入时，Python 就会读取相应的 .pyc 文件，而不是 .py 文件。而装载 .pyc 文件会比装载 .py 文件更快。 Python 会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。 这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。 Python 不检查在两个不同环境中的缓存。首先，它会永远重新编译而且不会存储直接从命令行加载的模块。其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源文件的模块。 部分高级技巧: 为了减少一个编译模块的大小，你可以在 Python 命令行中使用 -O 或者 -OO 。 -O 参数删除了断言语句， -OO 参数删除了断言语句和 doc 字符串。 因为某些程序依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。“优化的” 模块有一个 .pyo 后缀而不是 .pyc 后缀。未来的版本可能会改变优化的效果。 来自 .pyc 文件或 .pyo 文件中的程序不会比来自 .py 文件的运行更快； .pyc 或 .pyo 文件只是在它们加载的时候更快一些。 compileall 模块可以为指定目录中的所有模块创建 .pyc 文件（或者使用 -O 参数创建 .pyo 文件）。 在 PEP 3147 中有很多关这一部分内容的细节，并且包含了一个决策流程。","text_tokens":["系统","重启","一系列","很多","场合","对应","foobar","然后","问题","!","args","对于","所在","断言","形","name","了","依赖","win32","中有","存储","相当于","py3.7","]","但","何处","这个","公开","many","argv","hello","整个","时候","可能","并","约定","编写","相应","这样","覆盖","为","包","非常","同一","应该","更大","append","性能","提示","\"","上面","编译器","里","考虑","实际上","me","使用","android","后缀","-","x123","文本文件","只能","env","有序","__","上","该","完全",">","空间","程序","time","大量","、","pth","随着","译成","编译","越来越","用户","对","即可","usr","21","sys","像","默认","只","一部","报错","地","建","#","3","别人","下以","xxx","永久","采用","它们","因为","多个","这里","pep","部分","只有","+","识别","共享","在内","pycache","系列","既然","latex","文件名","a","modulename","文本","不会","找","创建","肯定","author","接口","变量","完整","支持","python37","命名","元素","）","fib","*","spam","内","2017","指向","快","过程","背后","[","path","排查","代码","需求","知道","限制","实验","greeting","将要","extensions","fmt","永远","cmd","新","ipython","到","慢","版中","依旧",",","导入","此时","utf","交互式","比如","下才","pyc","liao","源","高级","从","若","importlib","跨平台","请","每个","作为","制面","架构","module","不难理解","编译成","这一","2","添加","dlls","os","遇到","确定","向","，","平台","时才","理解","定义","07","便于","有","某个","一个","习惯","优化","全局","当于","xgboost","oo","arguments","说","做","bin","失败","编制","umr","维护","想","外部","py","「","未能","内部","这些","spyder","格式","修改","前缀","关","首先","依赖于","一次","version","把","或者","路径","加载","别名","fibo","“","roaming","python3.4","全部","base","解释","符号","michael","是因为","成","字符","用途","源文件","而且","：","字符串","pi","脚本","snapshot","system","abc","int","但是","版本号","不能","看","流程","更","一次性","扩展","所以","desktop","secondfunc","pyo","细节","缓存","某些","也就是说","件夹","list","改变","关键字","面板","什么","doc","可以","将","时","主程序","只是","引入","%","test","另外","从文件","满足","python3","参数","compileall","可用","提供","隐藏","写","直接","filename","适用","环境","解释器","不过","推荐","怎样","造成","名为","删除","而言","coding","本文","先","那些","重要","大","somemodule","内容","任何","一遍","？","文档","可用性","例如","查看","不要","一般","23","那","重复","c","里面","并且","释器","你","执行","消失","要","用来","o","等","调用","python3.3","载入","参考","elif","我们","语句","len","命令行","public","5","in","访问","文件夹","除了","自己","如","选择","查找","中","需要","不","是","其它","之间","起来","”","bash","pythonwin","=","让","好","才","为了","这","库","减少","模块","一些","8","r","namespace","工作","希望","相关","未找到","关键","zip","实例","egg","x","自动","1","易于","当前工作","变得","之后","思路","用","格式文件","是否","由","不想","或","包含","解决方案","—","形式","示例","源目录","会","def","错误","仍旧","python","安全","之所以","解决","安装","不是","难以","liam0205","reloader","都","行文","搜索","appdata","main","运行","not","as","也","方案","too","reload","重名","大小","注释","被","黑暗","13","越来","则","of","清楚","利用","就是说","的","1.0","33","注意","遵循","存在","类型","环境变量","而","不用","装载","从而","这种","熟悉","容易"," ","分割","modules","想要","无误","交互","somefunction","增加","进","尝试","正常","以","控制","引用","dump","它会","为什么","测试代码","；","设置","来说","」","称为","else","s","如果","变量名","便会","自动化","34","thirdfunc","·","几个","return","和","(","windows10","目录","<","出于","当前","呢","临时","private","不同","做法","import","一般而言","方法","foo","https","就是","cpython","赋予","不到","掉","获取","一系",")","3147","三","接着",".","同一个","getsitepackages","例子","关心","指定","来","g","当","版","在","放进","print","。","允许","命令","与","列表","wiki","imp","就","其次","给","仅仅","封装","后","放在","'","不难","编辑","很","下次","效果","功能","...","赖于","一旦","\\","相当","firstfunc","重新","文件","world","即","来自","hi","此","比","每当","0","$","这是","（","技巧","发布","对象","那么","方式","类","and","名字","读取","同时","一种","class","如下","编程","一部分","环境变","重载","会话","通过","版本","user","_","假设","for","lib","/","函数","实现","测试","仍","类似","if","最",":","anaconda3","指示","from","它","依次","特殊","没有","哪些","一样","检查","过期","至","50","site","选项","找到","加入","并未","3.3","控制面板","因此","pythonpath","packages","逻辑","installed","两个","日期","作用域","必须","可执行文件","值","决策","搜寻","角落","抽象","作用","导致","单独","是非","以下","段","未来","下","通常","所有","实际","重复使用","type","有用","users"],"title":"4.2.模块","title_tokens":[".","4.2","模块"]},{"location":"Python基础/4.2.模块.html#_1","text":"如果你想要编写一些更大的程序，肯定不想定义重复的函数、类，想让代码可以重复使用。随着程序变得越来越大，你可能想要将它分割成几个更易于维护的文件。为了满足这些需要，Python 提供了一个方法可以从文件中获取定义，在脚本或者解释器的一个交互式实例中使用。这样的文件被称为模块。","text_tokens":["编写","需要","这样","交互","交互式","不想","大","更","方法","更大","维护","想","重复","让","获取","为了","这些","释器","被","你","一些","越来","文件","模块","的","代码","可以","使用","将","函数","python","了","称为","在","或者","如果","从文件","满足","。","实例","肯定","易于","程序","变得","提供","、","解释","，","成","随着","几个","越来越","定义","它","脚本","解释器","重复使用","中","分割"," ","可能","一个","想要","类"],"title":"为什么需要模块","title_tokens":["为什么","需要","模块","什么"]},{"location":"Python基础/4.2.模块.html#_2","text":"Python 怎样知道从何处找到模块文件？ 如果你熟悉命令行，那么这个问题对你来说就不难理解。在命令行中执行的任何命令，实际上背后都对应了一个可执行文件。命令行解释器（比如 cmd, bash）会从一个全局的环境变量 PATH 中读取一个有序的列表。这个列表包含了一系列的路径，而命令行解释器，会依次在这些路径里，搜索需要的可执行文件。 Python 搜寻模块文件，也遵循了类似的思路。比如，用户在 Python 中尝试导入 import foobar，那么 首先，Python 会在内建模块中搜寻 foobar； 若未找到，则 Python 会在当前工作路径（当前脚本所在路径，或者执行 Python 解释器的路径）中搜寻 foobar； 若仍未找到，则 Python 会在环境变量 PYTHONPATH 中指示的路径中搜寻 foobar； 若依旧未能找到，则 Python 会在安装时指定的路径中搜寻 foobar； 若仍旧失败，则 Python 会报错，提示找不到 foobar 这个模块。","text_tokens":["需要","一系列","对应","比如","foobar","import","从","问题","bash","若","不到","一系","模块","不难理解","所在","指定","了","工作","在","未找到","。","命令","当前工作","这个","何处","列表","，","就","理解","思路","一个","全局","不难","包含","失败","未能","提示","会","这些","里","文件","实际上","首先","仍旧","python","或者","路径","有序","安装","解释","都","用户","对","行文","脚本","搜索","那么","报错","建","也","读取","环境变","则","在内","的","时","系列","遵循","找","仍","类似","环境变量","而","指示","熟悉","变量","环境","解释器","依次"," ","怎样","）","尝试","任何","？","找到","背后","释器","你","执行","pythonpath","path","；","来说","知道","可执行文件","搜寻","如果","命令行","cmd","依旧",",","导入","实际","中","当前","（"],"title":"模块搜索路径","title_tokens":["路径","搜索","模块"]},{"location":"Python基础/4.2.模块.html#_3","text":"当我们使用import加载自己编写的py代码时，必须放在python的默认路径下才可以import。","text_tokens":["编写","下才","import","py","的","时","可以","使用","代码","python","当","必须","我们","路径","加载","。","，","自己","默认","放在"],"title":"添加搜索路径","title_tokens":["路径","搜索","添加"]},{"location":"Python基础/4.2.模块.html#syspathappend","text":"在python中引入 sys ， sys 中的 path 是一个列表类型的对象，内容就是路径的列表，我们将sys引入后查看就可以清楚的知道了： import sys print ( type ( sys . path )) [ path for path in sys . path if \"Wiki\" not in path ] <class 'list'> ['C:\\\\Users\\\\Android\\\\Desktop', 'G:\\\\Installed\\\\Anaconda3\\\\python37.zip', 'G:\\\\Installed\\\\Anaconda3\\\\DLLs', 'G:\\\\Installed\\\\Anaconda3\\\\lib', 'G:\\\\Installed\\\\Anaconda3', 'C:\\\\Users\\\\Android\\\\AppData\\\\Roaming\\\\Python\\\\Python37\\\\site- packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site- packages\\\\xgboost-1.0.0_snapshot-py3.7.egg', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32\\\\lib', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\Pythonwin', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\IPython\\\\extensions', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop'] 既然是list对象，那么使用append可以向列表添加新的元素，假设我们要添加的路径是 \"C:\\Users\\Android\\Desktop\" ： import sys sys . path . append ( r \"C:\\Users\\Android\\Desktop\" ) 但这只是临时添加路径，如果重启编译器，添加的路径就会消失。","text_tokens":["重启","import","是","就是","pythonwin",")","这",".","r","了","g","win32","添加","在","dlls","print","zip","。","py3.7","egg","向","]","但","列表","，","wiki","就","一个","后","'","xgboost","append","\"","\\","编译器","会","android","使用","-","python","路径","roaming",">","0","编译","：","sys","snapshot","appdata","对象","那么","not","class","desktop","list","_","假设","for","清楚","lib","的","将","可以","1.0","既然","只是","引入","类型","if",":","anaconda3"," ","python37","元素","内容","site","查看","c","消失","[","要","packages","path","installed","知道","我们","如果","extensions","新","ipython","in",",","(","<","中","type","users","临时"],"title":"添加临时路径——sys.path.append","title_tokens":["添加","路径","sys",".","—","path","append","临时"]},{"location":"Python基础/4.2.模块.html#_4","text":"在Windows10中，选择 ->控制面板\\系统和安全\\系统->高级系统设置->环境变量 ， # 找到path后选择编辑，添加新的路径。 但这种方法不能适用所有python的功能，因为这种方法并未将要查找的路径添加到python的Path系统环境中，在sys.path的列表中找不到相关路径的元素。也就是说这样做并没有将路径添加到python的搜索路径中。","text_tokens":["系统","这样","编辑","元素","不能","做","方法","高级","功能","因为","就是","找到","控制","也就是说","不到","并未","控制面板","环境变","\\","制面",".","面板","path","设置","就是说","的","将","-","添加","python","安全","在","相关","路径","找","。","将要",">","新","到","但","环境变量","列表","，","和","这种","所有","选择","windows10","变量","环境","适用","查找","sys","搜索"," ","中","没有","并","后","#"],"title":"修改环境变量","title_tokens":["环境变","变量","修改","环境","环境变量"]},{"location":"Python基础/4.2.模块.html#pth","text":"在site-packages文件夹添加path文件，可以实现搜索路径的永久添加。方法如下： 先编辑一个扩展名为 .pth 的文本文件，在这个文本文件里面写上要添加的path就可以了，例如： 文本文件的文件名是：test.pth test.pth 文件的内容是： C:\\Users\\Android\\Desktop 接着获取python的site-packages文件夹的路径： import site site . getsitepackages () ['G:\\\\Installed\\\\Anaconda3', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site- packages'] 然后将 test.pth 文件放进 G:\\Installed\\Anaconda3\\lib\\site-packages 里面即可。","text_tokens":["'","编辑","先","本文","永久","如下","import","是","扩展","然后","内容","方法","desktop","site","例如","件夹","c","获取",")","里面","\\","接着","文件",".","要","[","packages","path","getsitepackages","lib","installed","的","可以","android","将","-","添加","了","文本文件","实现","文件名","在","test","路径","文本","python","g","放进","。","上",":","anaconda3","]","这个","，","pth","写","就","文件夹",",","：","即可","(","搜索"," ","一个","users","名为"],"title":"添加永久搜索路径——增加.pth文件","title_tokens":["pth","添加","增加","路径","永久","搜索",".","文件","—"]},{"location":"Python基础/4.2.模块.html#_5","text":"在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块(module)导入: 例如，我们要使用使用 sys 模块，那么首先要导入该模块： import sys 导入 sys 模块后，我们就有了 变量 sys 指向该模块，利用 sys 这个变量，就可以访问 sys 模块的所有功能。 也就是说导入整个模块的做法会导致命名空间的修改。 也可以一次性导入多个module： import os , sys , time 通过 as 关键字，可以在导入module的时候，给module定义别名： import sys as system 从某个模块中导入函数： 从某个模块中导入某个函数 from somemodule import somefunction 从某个模块中导入多个函数 from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入 from somemodule import * 一般而言，除了实验、排查，不推荐导入模块内的所有公开符号（没有前缀 _ 的那些）。因为导入模块会修改namespace，而通常你不知道模块定义了哪些符号、是否与当前的namespace有重名的符号。一旦有重名，那么，就会覆盖掉当前namespace的值。从而造成难以排查的错误","text_tokens":["做法","不","import","一般而言","就是","从","掉",")","模块","module","namespace","来","了","在","os","关键","。","这个","公开","与","，","就","给","整个","定义","有","某个","用","时候","后","相应","覆盖","是否","功能","...","一旦","会","firstfunc","修改","前缀","首先","使用","错误","一次","python","或者","别名","该","空间","time","难以","全部","、","符号","：","sys","system","那么","as","也","一次性","重名","secondfunc","因为","多个","也就是说","通过","关键字","_","利用","就是说","的","将","可以","函数",":","而","from","从而","变量","推荐"," ","造成","没有","哪些","命名","而言","somefunction","那些","）","*","somemodule","内","例如","一般","指向","你","要","排查","知道","值","我们","实验","导致","thirdfunc","访问",",","除了","导入","通常","所有","(","中","当前","（"],"title":"模块的导入","title_tokens":["导入","的","模块"]},{"location":"Python基础/4.2.模块.html#_6","text":"出于性能考虑， 每个模块在每个解释器会话中只导入一遍。 因此，如果修改了的模块，需要重启解释器；如果想交互式地测试一个模块，则需要使用以下方法重新导入模块： 注意 只能重载模块，不能单独重载模块中的某个函数、类、变量。 Python 2.x： reload ( modulename ) Python 2.x 至 Python3.3： import imp imp . reload ( modulename ) Python3.4+： import importlib importlib . reload ( modulename ) 另外，spyder 的UMR(user module reloader)提供了自动重载模块的功能。","text_tokens":["需要","重启","交互","交互式","import","reload","方法","一遍","功能","至","importlib","umr","想","每个","+","性能",")","重载","会话","释器","模块","考虑","因此","修改","则","重新",".","spyder","user","；","module","的","使用","python3.3","2","函数","了","python","只能","modulename","在","测试","如果","注意","另外","。","x","自动","单独","python3.4","提供","解释","以下","、","，","imp","reloader","导入","：","变量","(","某个","解释器","出于"," ","中","只","一个","地","不能","类"],"title":"模块重载","title_tokens":["重载","模块"]},{"location":"Python基础/4.2.模块.html#_7","text":"和 Python 中的其它对象一样，Python 也为模块定义了一些形如 __foo__ 的变量。对于模块来说，最重要的就是它的名字 __name__ 了。每当 Python 执行脚本，它就会为该脚本赋予一个名字： 对于「主程序」来说，这一脚本的 __name__ 被定义为 \"__main__\" 对于被 import 进主程序的模块来说，这一脚本的 __name__ 被定义为脚本的文件名（base filename） 因此，我们可以用如下的形式，在模块代码中定义一些测试代码： if __name__ == \"__main__\" : ··· 当脚本被直接运行时，测试代码就会被运行；当脚本作为模块被导入，测试代码不会被运行。 以下是一个完整的代码示例： 参考：(Python 中的黑暗角落（三）：模块与包)[https://liam0205.me/2017/07/23/modules-and-packages-of-python/] #!/usr/bin/env python3 # -*- coding: utf-8 -*- ' a test module ' __author__ = 'Michael Liao' import sys def test (): args = sys . argv if len ( args ) == 1 : print ( 'Hello, world!' ) elif len ( args ) == 2 : print ( 'Hello, %s !' % args [ 1 ]) else : print ( 'Too many arguments!' ) if __name__ == '__main__' : test () Hello, world!","text_tokens":["utf","liao","import","是","其它","foo","https","就是","!","赋予","=","args","作为",")","三","对于","模块","一些","8",".","module","形","name","这一","2","了","当","在","print","。","1","]","与","many","，","就","argv","hello","定义","07","用","一个","'","为","arguments","包","bin","形式","示例","「","\"","会","文件","def","world","me","-","python","env","__","该","每当","程序","base","liam0205","michael","usr","：","脚本","sys","main","对象","运行","#","and","也","名字","如下","too","被","黑暗","of","的","时","可以","主程序","/","文件名","a","%","test","测试","python3","不会","if","最","author",":","直接","它","filename","变量","完整"," ","modules","一样","coding","重要","）","进","*","23","2017","因此","执行","[","测试代码","packages","；","来说","代码","」","参考","elif","我们","s","else","len","角落","·","以下",",","和","如","导入","(","中","（"],"title":"模块的识别","title_tokens":["的","识别","模块"]},{"location":"Python基础/4.2.模块.html#_8","text":"在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用，在Python中，是通过 _ 前缀来实现的。 正常的函数和变量名是公开的（public），可以被直接引用，比如： abc ， x123 ， PI 等； 类似 __xxx__ 这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的 __author__ ， __name__ 就是特殊变量， hello 模块定义的文档注释也可以用特殊变量 __doc__ 访问，我们自己的变量一般不要用这种变量名； 类似 _xxx 和 __xxx 这样的函数或变量就是非公开的（private），不应该被直接引用，比如 _abc ， __abc 等； 之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。 private函数或变量不应该被别人引用，那它们有什么用呢？请看例子 def _private_1 ( name ): return 'Hello, %s ' % name def _private_2 ( name ): return 'Hi, %s ' % name def greeting ( name ): if len ( name ) > 3 : return _private_1 ( name ) else : return _private_2 ( name ) 我们在模块里公开 greeting() 函数，而把内部逻辑用private函数隐藏起来了，这样，调用 greeting() 函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即： 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。","text_tokens":["需要","很多","private","比如","不","是","方法","起来","就是","”","从","请","才",")","这","模块","例子","关心","name","2","来","了","希望","在","。","1","但","公开","，","就","hello","给","定义","仅仅","封装","有","用","一个","习惯","可能","并","'","这样","为","或","说","非常","应该","外部","内部","会","上面","里","前缀","def","即","使用","python","x123","把","之所以","hi","__","“","上","完全","不是",">","是因为","全部","成","用途","：","pi","abc","但是","不能","也","看","3","别人","xxx","一种","编程","它们","所以","因为","细节","只有","通过","注释","被","_","什么","的","可以","doc","函数","实现","%","类似","if","author",":","而","隐藏","不用","直接","这种","变量"," ","特殊","没有","）","？","文档","正常","那","不要","一般","引用","逻辑","等","；","调用","代码","else","我们","限制","s","len","greeting","变量名","抽象","public","是非","访问","return",",","和","自己","(","中","呢","有用","（"],"title":"作用域","title_tokens":["作用","作用域"]},{"location":"Python基础/4.2.模块.html#_9","text":"当你使用以下方式运行 Python 模块时，模块中的代码便会被执行: python fibo.py <arguments> 模块中的代码会被执行，就像导入它一样，不过 此时 __name__ 被设置为 \"__main__\" 。 这相当于，如果你在模块后加入如下代码: if __name__ == \"__main__\" : import sys fib ( int ( sys . argv [ 1 ])) 就可以让此文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为 “main” 文件执行时才被调用: $ python fibo . py 50 1 1 2 3 5 8 13 21 34 如果模块被导入，不会执行这段代码: >>> import fibo >>> 这通常用来为模块提供一个便于测试的用户接口（将模块作为脚本执行测试需求）。","text_tokens":["import","”","=","让",")","这","作为","模块","8",".","name","2","当","在","相当于","。","1","]","，","就","argv","时才","便于","一个","后","当于","为","arguments","py","\"","会","相当","文件","使用","python","此","__","fibo","“",">","$","用户","脚本","sys","像","21","int","main","运行","方式","3","如下","只有","被","13","的","时","可以","将","测试","不会","if",":","接口","提供","它","不过"," ","一样","）","fib","50","加入","你","执行","[","用来","调用","设置","代码","需求","如果","便会","34","5","以下","段","导入","此时","通常","(","<","中","（"],"title":"作为脚本来执行模块","title_tokens":["来","作为","模块","脚本","执行"]},{"location":"Python基础/4.2.模块.html#python-pyc","text":"和 LaTeX 中遇到的问题一样：装载大量文本文件（ .py 文件）是很慢的。因此 Python 也采用了类似 LaTeX 的解决方案：将模块编译成容易装载的文件，并在 __pycache__ 目录下以 module.*version*.pyc 名字缓存这些文件。（相当于 LaTeX 中的 dump 格式文件 .fmt ）。 这里的版本编制了编译后文件的格式。它通常会包含 Python 的版本号。例如，在 CPython 3.3 版中，spam.py 编译后的版本将缓存为 __pycache__/spam.cpython-33.pyc 。这种命名约定允许由不同发布和不同版本的 Python 编译的模块同时存在。 当 Python 编译好模块之后，下次载入时，Python 就会读取相应的 .pyc 文件，而不是 .py 文件。而装载 .pyc 文件会比装载 .py 文件更快。 Python 会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。 这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。 Python 不检查在两个不同环境中的缓存。首先，它会永远重新编译而且不会存储直接从命令行加载的模块。其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源文件的模块。 部分高级技巧: 为了减少一个编译模块的大小，你可以在 Python 命令行中使用 -O 或者 -OO 。 -O 参数删除了断言语句， -OO 参数删除了断言语句和 doc 字符串。 因为某些程序依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。“优化的” 模块有一个 .pyo 后缀而不是 .pyc 后缀。未来的版本可能会改变优化的效果。 来自 .pyc 文件或 .pyo 文件中的程序不会比来自 .py 文件的运行更快； .pyc 或 .pyo 文件只是在它们加载的时候更快一些。 compileall 模块可以为指定目录中的所有模块创建 .pyc 文件（或者使用 -O 参数创建 .pyo 文件）。 在 PEP 3147 中有很多关这一部分内容的细节，并且包含了一个决策流程。","text_tokens":["需要","系统","很多","场合","不同","pyc","不","是","源","高级","之间","”","从","问题","若","cpython","跨平台","减少","库","好","3147","为了","这","模块","一些",".","架构","module","同一个","断言","编译成","这一","指定","了","版","当","依赖","中有","在","存储","相当于","。","遇到","允许","自动","确定","命令","与","之后","，","平台","就","其次","有","时候","一个","可能","优化","后","并","约定","相应","当于","格式文件","很","为","由","下次","是否","oo","效果","或","包含","解决方案","同一","编制","应该","赖于","py","源目录","会","这些","相当","格式","重新","修改","文件","关","首先","依赖于","使用","后缀","-","python","version","文本文件","来自","或者","加载","解决","__","比","“","完全","不是","程序","大量","这是","字符","译成","编译","源文件","而且","：","技巧","字符串","发布","只","运行","一部","版本号","也","下以","名字","同时","读取","更","流程","方案","采用","它们","所以","pyo","因为","一部分","缓存","这里","大小","部分","某些","只有","pep","细节","版本","改变","共享","pycache","的","将","latex","时","33","/","可以","doc","只是","文本","不会","参数","存在","创建","类似","compileall",":","可用","而","装载","直接","它","这种","容易","变量","环境"," ","支持","没有","命名","删除","一样","检查","无误","本文","过期","）","*","spam","内容","可用性","例如","以","选项","3.3","dump","快","过程","它会","并且","因此","你","要","o","；","两个","日期","载入","必须","语句","决策","如果","命令行","永远","fmt","自动化","慢","版中","未来","和","通常","下","所有","目录","中","（"],"title":"“编译的” Python 文件——pyc 文件","title_tokens":["python","pyc","编译","“","文件"," ","—","”","的"]},{"location":"Python基础/4.3.魔术方法.html","text":"构造和初始化 每个人都知道一个最基本的魔术方法， __init__ 。通过此方法我们可以定义一个对象的初始操作。但很多博客和个别书籍中都把 __init__ 当作类似于C++的构造方法，其实是错误的。 __init__ 并不是第一个被调用的方法。实际上，还有一个叫做 __new__ 的方法，来构造这个实例。然后给在开始创建时候的初始化函数来传递参数。在对象生命周期的另一端，也有一个 __del__ 方法。 __new__(cls, [...) __new__ 是在一个对象实例化的时候所调用的第一个方法。它的第一个参数是这个类，其他的参数是用来直接传递给 __init__ 方法。 __new__ 方法相当不常用，也不是很有用处，但是它有自己的特性，特别是当继承一个不可变的类型（比如一个tuple或者string）： class inch ( float ): \"Convert from inch to meter\" def __new__ ( cls , arg = 0.0 ): return float . __new__ ( cls , arg * 0.0254 ) print ( inch ( 12 )) 0.30479999999999996 这个类可能不是很有用，但是它显示了如何扩展不可变类型的构造函数。如果我们尝试替代 __init__ 而不是 __new__ ，那么它将不起作用： class inch ( float ): \"THIS DOESN'T WORK!!!\" def __init__ ( self , arg = 0.0 ): float . __init__ ( self , arg * 0.0254 ) try : print ( inch ( 12 )) except TypeError as e : print ( e ) object.__init__() takes exactly one argument (the instance to initialize) 重写初始值的版本不起作用，因为浮点类型的初始值是一个不可变对象。另一个 __new__ 的例子是单例模式。 class A : pass new1 = A () new2 = A () print ( new1 ) print ( new2 ) <__main__.A object at 0x0000021AA9651AC8> <__main__.A object at 0x0000021AA9651B00> class A ( object ): _singleton = None def __new__ ( cls , * args , ** kwargs ): if not cls . _singleton : cls . _singleton = object . __new__ ( cls , * args , ** kwargs ) return cls . _singleton new1 = A () new2 = A () print ( new1 ) print ( new2 ) <__main__.A object at 0x0000021AA86752E8> <__main__.A object at 0x0000021AA86752E8> 关于 __new__ 的一些规则： __new__ 是一个静态方法，但在重定义 __new__ 时，不需要加上 @staticmethod ，因为它的名字已经暗示了这一点。 __new__ 的第一个参数必须是一个类；其余参数是构造函数调用所看到的参数。 __new__ 方法必须返回一个实例，如果返回None，则不会调用 __init__ 方法。 __init__(self, […) 此方法为类的初始化方法。当构造函数被调用的时候的任何参数都将会传给它。(比如如果我们调用 x = SomeClass(10, 'foo') )，那么 __init__ 将会得到两个参数10和foo。 __init__ 在Python的类定义中被广泛用到。 __del__(self) 如果 __new__ 和 __init__ 是对象的构造器的话，那么 __del__ 就是析构器。它不实现语句 del x (以上代码将不会翻译为 x.__del__() )。它定义的是当一个对象进行垃圾回收时候的行为。当一个对象在删除的时需要更多的清洁工作的时候此方法会很有用，比如套接字对象或者是文件对象。注意，如果解释器退出的时候对象还存存在，就不能保证 __del__ 能够被执行。 class A : def __del__ ( self ): print ( \"我被删除了\" ) a = A () del a 我被删除了 用于比较的魔术方法 魔术方法 调用方式 描述 __eq__(self, other) self == other __nq__(self, other) self != other __le__(self, other) self <= other __ge__(self, other) self >= other __lt__(self, other) self < other __gt__(self, other) self > other class A : def __init__ ( self , num = 2 ): self . num = num def __repr__ ( self ): return str ( self . num ) def __eq__ ( self , other ): return self . num == other def __ne__ ( self , other ): return self . num != other def __le__ ( self , other ): return self . num <= other def __ge__ ( self , other ): return self . num >= other def __lt__ ( self , other ): return self . num < other def __gt__ ( self , other ): return self . num > other a = A ( 5 ) print ( a == 5 ) print ( a != 5 ) print ( a > 4 ) print ( a < 6 ) print ( a >= 5 ) print ( a <= 6 ) True False True True True True 数值处理的魔术方法 一元运算符和内置函数 魔术方法 调用方式 描述 __pos__(self) +self __neg__(self) -self __abs__(self) abs(self) __invert__(self) ~self class A : def __init__ ( self , num = 2 ): self . num = num def __repr__ ( self ): return str ( self . num ) def __pos__ ( self ): new_num = 0 + self . num return A ( new_num ) def __neg__ ( self ): new_num = 0 - self . num return A ( new_num ) def __abs__ ( self ): new_num = abs ( self . num ) return A ( new_num ) a = A ( - 5 ) print ( + a ) print ( - a ) print ( abs ( a )) -5 5 5 算术运算符 魔术方法 调用方式 描述 __add__(self, other) self + other __sub_(self, other) self - other __mul__(self, other) self * other __truediv__(self, other) self / other __pow__(self, other) self ** other __floordiv__(self, other) self // other __mod__(self, other) self % other class A : def __init__ ( self , num = 2 ): self . num = num def __repr__ ( self ): return str ( self . num ) def __add__ ( self , other ): new_num = self . num + other return A ( new_num ) def __sub__ ( self , other ): new_num = self . num - other return A ( new_num ) def __mul__ ( self , other ): new_num = self . num * other return A ( new_num ) def __truediv__ ( self , other ): new_num = self . num / other return A ( new_num ) def __pow__ ( self , other ): new_num = self . num ** other return A ( new_num ) def __floordiv__ ( self , other ): new_num = self . num // other return A ( new_num ) def __mod__ ( self , other ): new_num = self . num % other return A ( new_num ) a = A ( 5 ) print ( \"a + 2 =\" , a + 2 ) print ( \"a - 2 =\" , a - 2 ) print ( \"a * 2 =\" , a * 2 ) print ( \"a / 2 =\" , a / 2 ) print ( \"a ** 2 =\" , a ** 2 ) print ( \"a // 2 =\" , a // 2 ) print ( \"a % 2 =\" , a % 2 ) a + 2 = 7 a - 2 = 3 a * 2 = 10 a / 2 = 2.5 a ** 2 = 25 a // 2 = 2 a % 2 = 1 反运算 以下是一个普通的加法运算的例子: # __add__ some_object + other 反运算是相同的，只是把操作数调换了位置: # __radd__ other + some_object 所以，除了当与其他对象操作的时候自己会成为第二个操作数之外，所有的这些魔术方法都与普通的操作是相同的。大多数情况下，反运算的结果是与普通运算相同的。所以你可以你可以将 __radd__ 与 __add__ 等价。 魔术方法 调用方式 描述 __radd__(self, other) other + self __rsub_(self, other) other - self __rmul__(self, other) other * self __rtruediv__(self, other) other / self __rpow__(self, other) other ** self __rfloordiv__(self, other) other // self __rmod__(self, other) other % self 增强赋值 魔术方法 调用方式 描述 __iadd__(self, other) self += other __isub_(self, other) self -= other __imul__(self, other) self *= other __itruediv__(self, other) self /= other __ipow__(self, other) self **= other __ifloordiv__(self, other) self //= other __imod__(self, other) self %= other 表现你的类 如果有一个字符串来表示一个类将会非常有用，例如： a = [ 1 , 2 , 3 ] a [1, 2, 3] 在Python中，有很多方法可以实现类定义内置的一些函数的返回值。 __str__(self) 定义当 str() 调用的时候的返回值。 __repr__(self) 定义 repr() 被调用的时候的返回值。 str() 和 repr() 的主要区别在于 repr() 返回的是机器可读的输出，而 str() 返回的是人类可读的。 __unicode__(self) 定义当 unicode() 调用的时候的返回值。 unicode() 和 str() 很相似，但是返回的是unicode字符串。注意，如果对你的类调用 str() 然而你只定义了 __unicode__() ，那么将不会工作。你应该定义 __str__() 来确保调用时能返回正确的值。 __hash__(self) 定义当 hash() 调用的时候的返回值，它返回一个整数值，用来在字典中进行快速比较 __nonzero__(self) 定义当 bool() 调用的时候的返回值。本方法应该返回True或者False，取决于你想让它返回的值。 创建定制的序列 有很多方法让你的Python类行为可以像内置的序列(dict, tuple,list, string等等)。 现在我们开始讲如何在Python中创建定制的序列，这个时候该讲一讲协议。协议(Protocols)与其他语言中的接口很相似。它给你很多你必须定义的方法。然而在Python中的协议是很不正式的，不需要明确声明实现。事实上，他们更像一种指南。 我们为什么现在讨论协议？因为如果要定制容器类型的话需要用到这些协议： 实现不变容器的话有一个协议：实现不可变容器，你只能定义 __len__ 和 __getitem__ (一会会讲更多)。 可变容器协议则需要所有不可变容器的所有另外还需要 __setitem__ 和 __delitem__ 。 最终，如果你希望你的对象是可迭代的话，你需要定义 __iter__ 会返回一个迭代器。迭代器必须遵循迭代器协议，需要有 __iter__ (返回它本身) 和 next 。 容器的魔法 魔法方法 调用方法 描述 __len__(self) len(self) __index__(self) x[self] 对象被作为索引使用的时候 __getitem__(self, key) self[key] 使用索引访问元素时 __setitem__(self, key, val) self[key] = val 对某个索引值赋值时 __delitem__(self, key) del self[key] 删除某个索引值时 __iter__(self) for x in self 迭代时 __contains__(self, value) value in self, value not in self 使用 in 操作测试关系时 __concat__(self, value) self + other 连接两个对象时 __reversed__(self) reversed(self) 实现当 reversed() 被调用时的行为 可以调用的对象 在Python中，方法也是一种高等的对象。这意味着他们也可以被传递到方法中就像其他对象一样。这是一个非常惊人的特性。 在Python中，一个特殊的魔术方法可以让类的实例的行为表现的像函数一样，你可以调用他们，将一个函数当做一个参数传到另外一个函数中等等。这是一个非常强大的特性让Python编程更加舒适甜美。 __call__(self, [args...]) 允许一个类的实例像函数一样被调用。实质上说，这意味着 x() 与 x.__call__() 是相同的。注意 __call__ 参数可变。这意味着你可以定义 __call__ 为其他你想要的函数，无论有多少个参数。 __call__ 在那些类的实例经常改变状态的时候会非常有效。调用这个实例是一种改变这个对象状态的直接和优雅的做法。用一个实例来表达最好不过了。 会话管理 在Python 2.5中，为了代码利用定义了一个新的关键词 with 语句。会话控制在Python中不罕见(之前是作为库的一部分被实现)，直到 PEP343 被添加后。它被成为一级语言结构。你也许之前看到这样的语句: with open('foo.txt') as bar: # perform some action with bar 回话控制器通过包装一个 with 语句来设置和清理行为。回话控制器的行为通过两个魔术方法来定义: __enter__(self) 定义当使用 with 语句的时候会话管理器应该初始块被创建的时候的行为。注意 __enter__ 的返回值被 with 语句的目标或者 as 后的名字绑定。 __exit__(self, exception_type,exception_value, traceback) 定义当一个代码块被执行或者终止后会话管理器应该做什么。它可以被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作。如果代码块执行成功， exception_type , exception_value , 和 traceback 将会是 None 。否则的话你可以选择处理这个异常或者是直接交给用户处理。如果你想处理这个异常的话，确认 __exit__ 在所有结束之后会返回 True 。如果你想让异常被会话管理器处理的话，那么就这样处理。 __enter 和 __exit__ 对于明确有定义好的和日常行为的设置和清洁工作的类很有帮助。你也可以使用这些方法来创建一般的可以包装其他对象的会话管理器。以下是一个例子： class Closer : '''通过with语句和一个close方法来关闭一个对象的会话管理器''' def __init__ ( self , obj ): self . obj = obj def __enter__ ( self ): return self . obj # bound to target def __exit__ ( self , exception_type , exception_val , trace ): try : self . obj . close () except AttributeError : # obj isn't closable print ( 'Not closable.' ) return True # exception handled successfully with Closer ( int ( 5 )) as i : i += 1 Not closable. 参考 文章","text_tokens":["很多","重","强大","然后","清除","try","!","ne","the","concat","args","大多数","算术","some","对于","0.0254","作数","不可","替代","了","不起作用","open","话","]","但","这个","暗示","日常","加上","时候","可能","他们","并","这样","语言","e","为","trace","非常","等等","iadd","isub","应该","\"","管理器","12","实际上","typeerror","0x0000021aa9651ac8","使用","明确","-","pep343","只能","tuple","其他","6","__","之前","上","该","目标",">","nq","bool","0x0000021aa86752e8","成为","函数调用","最好","对","用户","像","只","当做","一部","#","已经","except","变","3","位置","repr","__.","静态方法","传到","new2","还","因为","结果","meter","部分","第一个","+","多数","to","一会","另","7","itruediv","机器","exit","清理","a","不会","创建","一端","人","4","dict","协议","接口","索引","区别","返回","状态","pow","继承","值时","isn","如何","元素","成功","）","key","*","现在","结构","单例","with","经常","指南","表现","其实","不变","[","然而","代码","知道","0.30479999999999996","取决","控制器","新","关闭","到","个","本","清洁","rmul",",","one","本身","终止","rpow","比如","close","文章","add","魔术","closable","每个","floordiv","表达","作为","事实上","还存","target","2","正确","添加","一元","实质","字典","意味","行为表现","invert","，","舒适","书籍","一点","定义","someclass","有","某个","能够","完毕","一个","回收","叫做","delitem","否则","exception","说","比较","无论","一级","做","想","arg","这些","unicode","浮点","关于","exactly","bound","于","把","包装","或者","call","解释","字符","用到","字符串","：","rmod","日常行为","int","i","但是","普通","不能","可读","连接","更","声明","结束","扩展","所以","nonzero","甜美","enter","管理","rfloordiv","0x0000021aa9651b00","接字","list","25","赋值","改变","情况","0.0","我","什么","之外","可以","将","时","事实","行为","只是","%","@","gt","另外","显示","参数","val","描述","可","优雅","将会","运算符","直接","交给","解释器","不过","理器","删除","那些","大多","任何","返回值","？","主要","例如","有效","一般","neg","perform","释器","执行","你","work","要","用来","lt","handled","调用","化","翻译","语句","还有","staticmethod","我们","参考","也许","len","进行","5","增强","in","访问","内置","绑定","所","除了","自己","选择","中","套","需要","人类","不","是","生命","ipow","=","让","库","好","为了","这","一些","…","工作","希望","算符","str","关键","实例","self","1","x","pos","之后","attributeerror","常用","反","用","构造函数","生命周期","容器","closer","c++","的话","会","mul","convert","true","def","惊人","contains","action","错误","直到","python","高等","序列","一个整","等价","rsub","le","不是","pass","基本","输出","更加","都","传给","得到","构造","main","not","as","也","最终","表示","doesn","静态","处理","ge","init","被","2.5","则","利用","的","setitem","可变","注意","遵循","存在","类型","时能","析","而","hash","初始化","float","为类"," ","想要","迭代","new","尝试","初始值","控制","next","模式","为什么","确保","；","加法","设置","false","二个","快速","确认","定制","多少","如果","特性","退出","相似","意味着","num","讨论","规则","运算","obj","以上","return","和","(","取决于","<","10","object","保证","做法","abs","操作数","方法","个别","foo","sub","就是","iter","bar",")","讲","protocols",".","new1","例子","后会话","其余","来","当","操作","在","用处","print","。","初始","允许","successfully","与","看到","就","给","reversed","后","'","很","调换","index","第二","...","周期","传递","正式","相当","inch","构造方法","del","argument","文件","关系","多","魔法","器","重写","txt","用于","value","此","构器","getitem","0","块","这是","imul","另一端","数值","imod","博客","other","对象","那么","方式","ifloordiv","类","名字","instance","一种","class","编程","特别","第二个","initialize","singleton","一部分","~","takes","回话","t","版本","通过","会话",".__","_","for","this","在于","radd","帮助","/","函数","实现","测试","类似","if","最",":","异常","from","它","后会","特殊","一样","关键词","at","第一","kwargs","none","开始","一","traceback","当作","两个","eq","必须","值","罕见","mod","cls","广泛","作用","truediv","rtruediv","相同","以下","string","下","所有","垃圾","实际","type","有用","（"],"title":"4.3.魔术方法","title_tokens":["方法","4.3",".","魔术"]},{"location":"Python基础/4.3.魔术方法.html#_1","text":"每个人都知道一个最基本的魔术方法， __init__ 。通过此方法我们可以定义一个对象的初始操作。但很多博客和个别书籍中都把 __init__ 当作类似于C++的构造方法，其实是错误的。 __init__ 并不是第一个被调用的方法。实际上，还有一个叫做 __new__ 的方法，来构造这个实例。然后给在开始创建时候的初始化函数来传递参数。在对象生命周期的另一端，也有一个 __del__ 方法。 __new__(cls, [...) __new__ 是在一个对象实例化的时候所调用的第一个方法。它的第一个参数是这个类，其他的参数是用来直接传递给 __init__ 方法。 __new__ 方法相当不常用，也不是很有用处，但是它有自己的特性，特别是当继承一个不可变的类型（比如一个tuple或者string）： class inch ( float ): \"Convert from inch to meter\" def __new__ ( cls , arg = 0.0 ): return float . __new__ ( cls , arg * 0.0254 ) print ( inch ( 12 )) 0.30479999999999996 这个类可能不是很有用，但是它显示了如何扩展不可变类型的构造函数。如果我们尝试替代 __init__ 而不是 __new__ ，那么它将不起作用： class inch ( float ): \"THIS DOESN'T WORK!!!\" def __init__ ( self , arg = 0.0 ): float . __init__ ( self , arg * 0.0254 ) try : print ( inch ( 12 )) except TypeError as e : print ( e ) object.__init__() takes exactly one argument (the instance to initialize) 重写初始值的版本不起作用，因为浮点类型的初始值是一个不可变对象。另一个 __new__ 的例子是单例模式。 class A : pass new1 = A () new2 = A () print ( new1 ) print ( new2 ) <__main__.A object at 0x0000021AA9651AC8> <__main__.A object at 0x0000021AA9651B00> class A ( object ): _singleton = None def __new__ ( cls , * args , ** kwargs ): if not cls . _singleton : cls . _singleton = object . __new__ ( cls , * args , ** kwargs ) return cls . _singleton new1 = A () new2 = A () print ( new1 ) print ( new2 ) <__main__.A object at 0x0000021AA86752E8> <__main__.A object at 0x0000021AA86752E8> 关于 __new__ 的一些规则： __new__ 是一个静态方法，但在重定义 __new__ 时，不需要加上 @staticmethod ，因为它的名字已经暗示了这一点。 __new__ 的第一个参数必须是一个类；其余参数是构造函数调用所看到的参数。 __new__ 方法必须返回一个实例，如果返回None，则不会调用 __init__ 方法。 __init__(self, […) 此方法为类的初始化方法。当构造函数被调用的时候的任何参数都将会传给它。(比如如果我们调用 x = SomeClass(10, 'foo') )，那么 __init__ 将会得到两个参数10和foo。 __init__ 在Python的类定义中被广泛用到。 __del__(self) 如果 __new__ 和 __init__ 是对象的构造器的话，那么 __del__ 就是析构器。它不实现语句 del x (以上代码将不会翻译为 x.__del__() )。它定义的是当一个对象进行垃圾回收时候的行为。当一个对象在删除的时需要更多的清洁工作的时候此方法会很有用，比如套接字对象或者是文件对象。注意，如果解释器退出的时候对象还存存在，就不能保证 __del__ 能够被执行。 class A : def __del__ ( self ): print ( \"我被删除了\" ) a = A () del a 我被删除了","text_tokens":["需要","很多","保证","比如","重","不","是","然后","方法","个别","foo","就是","魔术","!","生命","try","the","每个","=","args",")","这","一些","还存",".","0.0254","new1","例子","…","不可","替代","其余","来","了","当","不起作用","工作","操作","在","用处","print","。","实例","self","初始","x","但","这个","暗示","看到","，","常用","加上","就","书籍","给","一点","定义","someclass","有","时候","能够","一个","可能","构造函数","生命周期","并","回收","叫做","'","e","很","为","c++","的话","...","周期","传递","\"","arg","相当","会","convert","inch","构造方法","del","argument","文件","def","浮点","12","实际上","typeerror","exactly","0x0000021aa9651ac8","关于","多","错误","器","于","重写","把","python","tuple","或者","其他","此","__","构器","不是",">","pass","基本","解释","0x0000021aa86752e8","另一端","用到","都","函数调用","：","传给","得到","构造","博客","main","对象","那么","但是","not","as","不能","类","已经","也","except","变","__.","静态方法","名字","instance","new2","class","更","doesn","静态","扩展","特别","因为","object","initialize","singleton","meter","第一个","takes","t","版本","通过","to","0x0000021aa9651b00","init","被",".__","接字","另","_","则","this","0.0","我","的","可以","将","时","行为","函数","a","套","实现","@","注意","显示","参数","不会","创建","类型","一端","类似","if","存在","最","人",":","析","而","返回","将会","from","初始化","继承","直接","它","float","为类","解释器"," ","删除","new","如何","）","*","尝试","任何","初始值","单例","at","第一","kwargs","其实","模式","none","开始","释器","执行","work","[","用来","当作","调用","化","；","两个","代码","知道","翻译","0.30479999999999996","还有","staticmethod","我们","必须","如果","特性","cls","语句","退出","广泛","作用","进行","清洁","规则","string","以上","return","所",",","和","自己","one","(","垃圾","实际","<","10","中","有用","（"],"title":"构造和初始化","title_tokens":["初始化","构造","和","初始"]},{"location":"Python基础/4.3.魔术方法.html#_2","text":"魔术方法 调用方式 描述 __eq__(self, other) self == other __nq__(self, other) self != other __le__(self, other) self <= other __ge__(self, other) self >= other __lt__(self, other) self < other __gt__(self, other) self > other class A : def __init__ ( self , num = 2 ): self . num = num def __repr__ ( self ): return str ( self . num ) def __eq__ ( self , other ): return self . num == other def __ne__ ( self , other ): return self . num != other def __le__ ( self , other ): return self . num <= other def __ge__ ( self , other ): return self . num >= other def __lt__ ( self , other ): return self . num < other def __gt__ ( self , other ): return self . num > other a = A ( 5 ) print ( a == 5 ) print ( a != 5 ) print ( a > 4 ) print ( a < 6 ) print ( a >= 5 ) print ( a <= 6 ) True False True True True True","text_tokens":["repr","class","方法","魔术","!","ne","ge","=",")","init",".","def","true","lt","调用","eq","false","2","a","gt","print","str","6","__","self","描述","le","nq",">",":","5","4","num","return",",","(","<","other"," ","方式"],"title":"用于比较的魔术方法","title_tokens":["用于","比较","方法","魔术","的"]},{"location":"Python基础/4.3.魔术方法.html#_3","text":"","text_tokens":[],"title":"数值处理的魔术方法","title_tokens":["数值","方法","处理","魔术","的"]},{"location":"Python基础/4.3.魔术方法.html#_4","text":"魔术方法 调用方式 描述 __pos__(self) +self __neg__(self) -self __abs__(self) abs(self) __invert__(self) ~self class A : def __init__ ( self , num = 2 ): self . num = num def __repr__ ( self ): return str ( self . num ) def __pos__ ( self ): new_num = 0 + self . num return A ( new_num ) def __neg__ ( self ): new_num = 0 - self . num return A ( new_num ) def __abs__ ( self ): new_num = abs ( self . num ) return A ( new_num ) a = A ( - 5 ) print ( + a ) print ( - a ) print ( abs ( a )) -5 5 5","text_tokens":["new","repr","class","abs","方法","魔术","~","+","=",")","neg","init","_",".","def","调用","2","-","a","print","str","__","self","描述","0",":","5","num","invert","pos","return",",","("," ","方式"],"title":"一元运算符和内置函数","title_tokens":["运算","函数","运算符","一元","算符","和","内置"]},{"location":"Python基础/4.3.魔术方法.html#_5","text":"魔术方法 调用方式 描述 __add__(self, other) self + other __sub_(self, other) self - other __mul__(self, other) self * other __truediv__(self, other) self / other __pow__(self, other) self ** other __floordiv__(self, other) self // other __mod__(self, other) self % other class A : def __init__ ( self , num = 2 ): self . num = num def __repr__ ( self ): return str ( self . num ) def __add__ ( self , other ): new_num = self . num + other return A ( new_num ) def __sub__ ( self , other ): new_num = self . num - other return A ( new_num ) def __mul__ ( self , other ): new_num = self . num * other return A ( new_num ) def __truediv__ ( self , other ): new_num = self . num / other return A ( new_num ) def __pow__ ( self , other ): new_num = self . num ** other return A ( new_num ) def __floordiv__ ( self , other ): new_num = self . num // other return A ( new_num ) def __mod__ ( self , other ): new_num = self . num % other return A ( new_num ) a = A ( 5 ) print ( \"a + 2 =\" , a + 2 ) print ( \"a - 2 =\" , a - 2 ) print ( \"a * 2 =\" , a * 2 ) print ( \"a / 2 =\" , a / 2 ) print ( \"a ** 2 =\" , a ** 2 ) print ( \"a // 2 =\" , a // 2 ) print ( \"a % 2 =\" , a % 2 ) a + 2 = 7 a - 2 = 3 a * 2 = 10 a / 2 = 2.5 a ** 2 = 25 a // 2 = 2 a % 2 = 1","text_tokens":["new","3","repr","class","*","方法","sub","add","魔术","+","floordiv","=",")","\"","mul","init","25","2.5","_",".","def","7","调用","/","-","a","2","%","mod","str","print","__","self","描述","truediv","1",":","5","num","pow","return",",","(","other"," ","10","方式"],"title":"算术运算符","title_tokens":["算符","运算","运算符","算术"]},{"location":"Python基础/4.3.魔术方法.html#_6","text":"以下是一个普通的加法运算的例子: # __add__ some_object + other 反运算是相同的，只是把操作数调换了位置: # __radd__ other + some_object 所以，除了当与其他对象操作的时候自己会成为第二个操作数之外，所有的这些魔术方法都与普通的操作是相同的。大多数情况下，反运算的结果是与普通运算相同的。所以你可以你可以将 __radd__ 与 __add__ 等价。 魔术方法 调用方式 描述 __radd__(self, other) other + self __rsub_(self, other) other - self __rmul__(self, other) other * self __rtruediv__(self, other) other / self __rpow__(self, other) other ** self __rfloordiv__(self, other) other // self __rmod__(self, other) other % self","text_tokens":["rpow","是","操作数","方法","add","魔术","大多数",")","some","例子","作数","了","当","操作","。","self","与","，","反","时候","一个","调换","第二","会","这些","-","把","其他","等价","rsub","__","成为","都","rmod","other","对象","方式","普通","#","位置","所以","第二个","结果","+","rfloordiv","多数","_","情况","radd","的","之外","可以","将","/","只是","%","描述",":"," ","大多","*","你","加法","调用","二个","rtruediv","相同","以下","rmul","运算","除了","下","自己",",","所有","(","object"],"title":"反运算","title_tokens":["反","运算"]},{"location":"Python基础/4.3.魔术方法.html#_7","text":"魔术方法 调用方式 描述 __iadd__(self, other) self += other __isub_(self, other) self -= other __imul__(self, other) self *= other __itruediv__(self, other) self /= other __ipow__(self, other) self **= other __ifloordiv__(self, other) self //= other __imod__(self, other) self %= other","text_tokens":["*","方法","iadd","isub","魔术","ipow","+","=",")","_","itruediv","调用","/","-","%","__","self","描述","imul",",","imod","(","other"," ","方式","ifloordiv"],"title":"增强赋值","title_tokens":["增强","赋值"]},{"location":"Python基础/4.3.魔术方法.html#_8","text":"如果有一个字符串来表示一个类将会非常有用，例如： a = [ 1 , 2 , 3 ] a [1, 2, 3] 在Python中，有很多方法可以实现类定义内置的一些函数的返回值。 __str__(self) 定义当 str() 调用的时候的返回值。 __repr__(self) 定义 repr() 被调用的时候的返回值。 str() 和 repr() 的主要区别在于 repr() 返回的是机器可读的输出，而 str() 返回的是人类可读的。 __unicode__(self) 定义当 unicode() 调用的时候的返回值。 unicode() 和 str() 很相似，但是返回的是unicode字符串。注意，如果对你的类调用 str() 然而你只定义了 __unicode__() ，那么将不会工作。你应该定义 __str__() 来确保调用时能返回正确的值。 __hash__(self) 定义当 hash() 调用的时候的返回值，它返回一个整数值，用来在字典中进行快速比较 __nonzero__(self) 定义当 bool() 调用的时候的返回值。本方法应该返回True或者False，取决于你想让它返回的值。","text_tokens":["很多","人类","是","方法","=","让",")","一些","正确","2","来","了","当","工作","在","str","。","self","1","字典","]","，","定义","有","时候","一个","很","比较","非常","应该","想","会","unicode","true","python","一个整","或者","__","bool","输出","字符","数值","字符串","：","对","只","那么","但是","类","3","repr","可读","表示","nonzero","被","机器","在于","的","将","可以","函数","a","实现","注意","不会","时能","区别","返回","而","hash","它"," ","返回值","主要","例如","你","[","用来","确保","调用","然而","false","快速","值","如果","取决","相似","进行","本","内置",",","和","(","取决于","中","有用"],"title":"表现你的类","title_tokens":["你","表现","的","类"]},{"location":"Python基础/4.3.魔术方法.html#_9","text":"有很多方法让你的Python类行为可以像内置的序列(dict, tuple,list, string等等)。 现在我们开始讲如何在Python中创建定制的序列，这个时候该讲一讲协议。协议(Protocols)与其他语言中的接口很相似。它给你很多你必须定义的方法。然而在Python中的协议是很不正式的，不需要明确声明实现。事实上，他们更像一种指南。 我们为什么现在讨论协议？因为如果要定制容器类型的话需要用到这些协议： 实现不变容器的话有一个协议：实现不可变容器，你只能定义 __len__ 和 __getitem__ (一会会讲更多)。 可变容器协议则需要所有不可变容器的所有另外还需要 __setitem__ 和 __delitem__ 。 最终，如果你希望你的对象是可迭代的话，你需要定义 __iter__ 会返回一个迭代器。迭代器必须遵循迭代器协议，需要有 __iter__ (返回它本身) 和 next 。","text_tokens":["需要","很多","不","是","方法","让","iter",")","讲","protocols","事实上","不可","希望","在","。","这个","与","，","给","定义","有","时候","一个","他们","容器","delitem","语言","很","等等","的话","正式","会","这些","多","明确","器","python","序列","只能","tuple","其他","__","该","getitem","用到","：","像","对象","类","变","更","声明","一种","最终","还","因为","list","一会","则","什么","的","可以","事实","setitem","行为","实现","可变","另外","遵循","创建","类型","可","dict","协议","接口","返回","它"," ","迭代","如何","现在","？","指南","next","开始","一","你","为什么","不变","要","然而","必须","定制","我们","如果","len","相似","内置","讨论","string",",","和","所有","(","本身","中"],"title":"创建定制的序列","title_tokens":["创建","的","序列","定制"]},{"location":"Python基础/4.3.魔术方法.html#_10","text":"魔法方法 调用方法 描述 __len__(self) len(self) __index__(self) x[self] 对象被作为索引使用的时候 __getitem__(self, key) self[key] 使用索引访问元素时 __setitem__(self, key, val) self[key] = val 对某个索引值赋值时 __delitem__(self, key) del self[key] 删除某个索引值时 __iter__(self) for x in self 迭代时 __contains__(self, value) value in self, value not in self 使用 in 操作测试关系时 __concat__(self, value) self + other 连接两个对象时 __reversed__(self) reversed(self) 实现当 reversed() 被调用时的行为","text_tokens":["delitem","元素","连接","index","key","方法","concat","=","+","iter",")","作为","被","赋值","del","关系","[","for","调用","contains","两个","的","使用","魔法","时","setitem","行为","当","值","实现","操作","value","测试","len","__","self","描述","getitem","x","val","]","in","访问","索引",",","值时","对","(","某个","reversed","时候","other"," ","对象","not","删除","迭代"],"title":"容器的魔法","title_tokens":["的","魔法","容器"]},{"location":"Python基础/4.3.魔术方法.html#_11","text":"在Python中，方法也是一种高等的对象。这意味着他们也可以被传递到方法中就像其他对象一样。这是一个非常惊人的特性。 在Python中，一个特殊的魔术方法可以让类的实例的行为表现的像函数一样，你可以调用他们，将一个函数当做一个参数传到另外一个函数中等等。这是一个非常强大的特性让Python编程更加舒适甜美。 __call__(self, [args...]) 允许一个类的实例像函数一样被调用。实质上说，这意味着 x() 与 x.__call__() 是相同的。注意 __call__ 参数可变。这意味着你可以定义 __call__ 为其他你想要的函数，无论有多少个参数。 __call__ 在那些类的实例经常改变状态的时候会非常有效。调用这个实例是一种改变这个对象状态的直接和优雅的做法。用一个实例来表达最好不过了。","text_tokens":["做法","强大","是","方法","魔术","表达","让","args",")","这","来","了","在","实质","。","实例","self","允许","x","意味","]","行为表现","与","这个","，","就","舒适","定义","有","用","时候","一个","他们","为","说","无论","非常","等等","...","传递","会","惊人","python","高等","其他","__","上","call","这是","更加","最好","像","对象","当做","类","也","传到","一种","编程","甜美","被",".__","改变","的","可以","将","行为","函数","可变","另外","注意","参数","优雅","状态","直接","不过"," ","特殊","想要","一样","那些","经常","有效","表现","你","[","调用","多少","特性","意味着","到","相同","个",",","和","(","中"],"title":"可以调用的对象","title_tokens":["调用","的","可以","对象"]},{"location":"Python基础/4.3.魔术方法.html#_12","text":"在Python 2.5中，为了代码利用定义了一个新的关键词 with 语句。会话控制在Python中不罕见(之前是作为库的一部分被实现)，直到 PEP343 被添加后。它被成为一级语言结构。你也许之前看到这样的语句: with open('foo.txt') as bar: # perform some action with bar 回话控制器通过包装一个 with 语句来设置和清理行为。回话控制器的行为通过两个魔术方法来定义: __enter__(self) 定义当使用 with 语句的时候会话管理器应该初始块被创建的时候的行为。注意 __enter__ 的返回值被 with 语句的目标或者 as 后的名字绑定。 __exit__(self, exception_type,exception_value, traceback) 定义当一个代码块被执行或者终止后会话管理器应该做什么。它可以被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作。如果代码块执行成功， exception_type , exception_value , 和 traceback 将会是 None 。否则的话你可以选择处理这个异常或者是直接交给用户处理。如果你想处理这个异常的话，确认 __exit__ 在所有结束之后会返回 True 。如果你想让异常被会话管理器处理的话，那么就这样处理。 __enter 和 __exit__ 对于明确有定义好的和日常行为的设置和清洁工作的类很有帮助。你也可以使用这些方法来创建一般的可以包装其他对象的会话管理器。以下是一个例子： class Closer : '''通过with语句和一个close方法来关闭一个对象的会话管理器''' def __init__ ( self , obj ): self . obj = obj def __enter__ ( self ): return self . obj # bound to target def __exit__ ( self , exception_type , exception_val , trace ): try : self . obj . close () except AttributeError : # obj isn't closable print ( 'Not closable.' ) return True # exception handled successfully with Closer ( int ( 5 )) as i : i += 1 Not closable.","text_tokens":["close","不","是","清除","方法","foo","魔术","try","closable","=","库","让","bar","为了","作为",")","some","好","对于","一些",".","target","例子","后会话","来","了","添加","当","工作","在","open","print","关键","话","。","self","1","初始","successfully","这个","attributeerror","之后","看到","，","日常","就","定义","有","时候","完毕","一个","后","'","这样","语言","否则","很","exception","closer","trace","一级","做","的话","应该","想","会","这些","管理器","true","def","bound","action","使用","直到","明确","python","pep343","txt","包装","或者","value","其他","之前","__","目标","块","成为","用户","：","日常行为","int","i","对象","一部","那么","not","as","#","类","也","except","名字","结束","class","处理","一部分","enter","管理","部分","+","回话","t","会话","通过","to","init","被","2.5","_","exit","什么","利用","清理","的","可以","帮助","行为","实现","注意","创建","val",":","异常","返回","将会","直接","它","交给","理器","后会"," ","isn","成功","关键词","结构","返回值","with","控制","一般","perform","none","你","traceback","执行","用来","handled","设置","两个","代码","确认","语句","罕见","也许","如果","控制器","新","关闭","5","以下","清洁","obj","return","绑定",",","和","所有","(","选择","终止","中","type"],"title":"会话管理","title_tokens":["会话","管理"]},{"location":"Python基础/4.3.魔术方法.html#_13","text":"文章","text_tokens":["文章"],"title":"参考","title_tokens":["参考"]},{"location":"numpy笔记/6.1.创建数组.html","text":"import numpy as np 共同的参数 这里有几个共同的参数： a ：一个 array-like 类型的实例，它不一定是数组，可以为 list 、 tuple 、 list of tuple 、 list of list 、 tuple of list 、 tuple of tuple 等等。 dtype ：数组的值类型，默认为 float 。你可以指定Python的标准数值类型，也可以使用 numpy 的数值类型如： numpy.int32 或者 numpy.float64 等等。 order ：指定存储多维数据的方式。 - 'C' ，表示按行优先存储（C风格）； - 'F' ，表示按列优先存储（Fortran风格）。 - 对于 **_like() 函数， order 可以为： 'C' ， 'F' ， 'A' （表示结果的order与a相同）， 'K' （表示结果的 order 与 a 尽可能相似） subok ： bool 值。如果为 True 则：如果 a 为 ndarray 的子类（如 matrix 类），则结果类型与 a 类型相同。如果为 False 则：结果类型始终为 ndarray 。默认为True。 从现有的数据创建 1 np.array(object[, dtype, copy, order, subok, ndmin]) :从 object 创建。 - object 可以是一个 ndarray ，也可以是一个 array_like 的对象，也可以是一个含有返回一个序列或者 ndarray 的 __array__ 方法的对象，或者一个序列。 - `copy` ：默认为 `True` ，表示拷贝对象 - `order` 可以为 `'C'、'F'、'A'` 。默认为 `'K'` 。 - `subok` 默认为 `False` - `ndmin` ：指定结果 `ndarray` 最少有多少个维度。 2 np.asarray(a[, dtype, order]) ：将 a 转换成一个 ndarray 。其中 a 是 array_like 的对象， 可以是 list 、 list of tuple 、 tuple 、 tuple of list 、 ndarray 类型。 order 默认为 C 。 3 np.asanyarray(a[, dtype, order]) ：将 a 转换成 ndarray 。 4 np.ascontiguousarray(a[, dtype]) ：返回C风格的连续 ndarray 。 5 np.copy(a[, order]) ：返回 ndarray 的一份深拷贝。 以上5个方法实际上都是调用了 array() 的接口。 np . asarray () # array(a, dtype, copy=False, order=order) np . asanyarray () # array(a, dtype, copy=False, order=order, subok=True) np . ascontiguousarray () # array(a, dtype, copy=False, order='C', ndmin=1) np . copy () # array(a, order=order, copy=True) 6 np.asmatrix(data[, dtype]) ：返回 matrix 。 7 np.frombuffer(buffer[, dtype, count, offset]) ：从输入数据中返回一维 ndarray 。 count 指定读取的数量， -1 表示全部读取； offset 指定从哪里开始读取，默认为0。 创建的数组与 buffer 共享内存。 buffer 是一个提供了 buffer 接口的对象（ 内置的 bytes/bytearray/array.array 类型提供了该接口 ）。 from array import array # array.array 提供了类似list对象的内存机制 a = array ( \"d\" , [ 1 , 2 , 3 , 4 ]) # 创建一个array数组 na = np . frombuffer ( a , dtype = np . float ) # 通过np.frombuffer()创建一个和a共享内存的NumPy数组 print ( \"a:\" , a ) print ( \"na:\" , na ) na [ 1 ] = 20 # 修改NumPy数组中的第一个元素 a # array数组中的第一个元素也同时改变 a : array ( 'd' , [ 1.0 , 2.0 , 3.0 , 4.0 ]) na : [ 1 . 2 . 3 . 4 .] array('d', [1.0, 20.0, 3.0, 4.0]) 8 np.fromfile(file[, dtype, count, sep]) ：从二进制文件或者文本文件中读取数据返回 ndarray 。 sep ：当从文本文件中读取时，数值之间的分隔字符串，如果 sep 是空字符串则表示文件应该作为二进制文件读取；如果 sep 为 \" \" 表示可以匹配0个或者多个空白字符。 9 np.fromfunction(function, shape, \\**kwargs) ：返回一个 ndarray 。function会获取每一个坐标点的数据，作为输入参数。假设 shape 的维度为N，那么 function 带有 N 个参数， fn(x1,x2,...x_N) ，其返回值就是该坐标点的值。 def fun ( x , y ): return x + y np . fromfunction ( fun , shape = ( 3 , 3 )) array([[0., 1., 2.], [1., 2., 3.], [2., 3., 4.]]) 10 np.fromiter(iterable, dtype[, count]) ：从可迭代对象中迭代获取数据创建一维 ndarray 。 np . fromiter ( \"123\" , dtype = \"int64\" ) array([1, 2, 3], dtype=int64) 11 np.fromstring(string[, dtype, count, sep]) ：从字符串或者 raw binary 中创建一维 ndarray 。如果 sep 为空字符串则 string 将按照二进制数据解释（即每个字符作为 ASCII 码值对待）。创建的数组有自己的数据存储区。 a = \"abcdefg\" a = np . fromstring ( a , dtype = np . int8 ) # 将每个字符的ASCII编码解释为整数 print ( a ) a = \"1;2;3;4;5\" a = np . fromstring ( a , dtype = np . int8 , sep = \";\" ) print ( a ) [ 97 98 99 100 101 102 103] [1 2 3 4 5] .\\setup_m.py:2: DeprecationWarning: The binary mode of fromstring is deprecated, as it behaves surprisingly on unicode inputs. Use frombuffer instead from datetime import datetime 12 np.loadtxt(fname[, dtype, comments, delimiter, ...]) :从文本文件中加载数据创建 ndarray ，要求文本文件每一行都有相同数量的数值。 comments ：指示注释行的起始字符，可以为单个字符或者字符列表（默认为 # ）。 delimiter :指定数值之间的分隔字符串，默认为空白符。 converters ：将指定列号(0,1,2...)的列数据执行转换，是一个 map ，如 {0:func1} 表示对第一列数据执行 func1(val_0) 。 skiprows ：指定跳过开头的多少行。 usecols ：指定读取那些列（0表示第一列）。 从数值区间创建 1 np.arange([start,] stop[, step,][, dtype]) :返回均匀间隔的值组成的一维 ndarray 。区间是半闭半开的 [start,stop) ，其采样行为类似Python的 range 函数。 start 为开始点， stop 为终止点， step 为步长，默认为1。这几个数可以为整数可以为浮点数。 注意如果 step 为浮点数，则结果可能有误差，因为浮点数相等比较不准确（计算机精度有限）。 2 np.linspace(start, stop[, num, endpoint, ...]) ：返回 num 个均匀采样的数值组成的一维 ndarray （默认为50）。区间是闭区间 [start,stop] 。 endpoint 为布尔值，如果为真则表示 stop 是最后采样的值（默认为 True ），否则结果不包含 stop 。 retstep 如果为 True 则返回结果包含采样步长 step ，默认为 True 。 3 np.logspace(start, stop[, num, endpoint, base, ...]) ：返回对数级别上均匀采样的数值组成的一维 ndarray 。采样点开始于 base^start ，结束于 base^stop 。 base 为对数的基，默认为 10。 它逻辑上相当于先执行 arange 获取数组 array ，然后再执行 base^array[i] 获取采样点 - 它没有 retstep 关键字参数 以填充的方式创建 1 np.empty(shape[,dtype,order]) ：返回一个新的 ndarray ，指定了 shape 和 dtype ，但是没有初始化元素。因此其内容是随机的。 2 np.empty_like(a[,dtype,order,subok]) ：返回一个新的 ndarray ， shape 与 a 相同，但是没有初始化元素。因此其内容是随机的。 # 内存未初始化 a = np . empty (( 3 , 2 ), order = \"C\" ) # 内存未初始化 np . empty_like ( a ) array([[0., 0.], [0., 0.], [0., 0.]]) 3 np.eye(N[, M, k, dtype]) ：返回一个==二维数组==，对角线元素为1，其余元素为0。 M 默认等于 N 。 k 默认为0表示对角线元素为1，如为正数则表示对角线上方一格的元素为1，如为负数表示对角线下方一格的元素为1。 4 np.identity(n[, dtype]) ：返回一个单位矩阵。 np . eye ( N = 2 , M = 3 ) np . eye ( N = 2 , M = 3 , k = 0 ) # 参数k是可以超出范围的 np . eye ( N = 2 , M = 3 , k = 1 ) # 返回n阶单位矩阵 np . identity ( n = 4 ) array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) 5 np.ones(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为1. 6 np.ones_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为1。 7 np.zeros(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为0. 8 np.zeros_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a （另一个数组）相同，每个元素初始化为0。 9 np.full(shape, fill_value[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为 fill_value 。 10 np.full_like(a, fill_value[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为 fill_value 。 np . full (( 2 , 3 ), fill_value = 2 ) array([[2, 2, 2], [2, 2, 2]])","text_tokens":["然后","fromfile","the","区间","103","对于","超出","跳过","等于","了","存储","ones","相当于","点数","buffer","]","fromiter","可能","起始","为","空白","等等","准确","k","behaves","应该","fn","正数","\"","asmatrix","12","实际上","使用","-","文本文件","tuple","6","__","linspace","上","该","matrix","其","换成","bool","、","function","对角线","offset","对","默认","like","含有","#","3","因为","多个","结果","这里","第一个","+","n","7","共享","另","计算机","有限","a","文本","创建","data","4","接口","返回","读取数据","每","区","精度","it","fortran","元素","尽可","）","*","func1","数组","[",";","码值","use","共同","新","个","单位矩阵","拷贝","ascontiguousarray","arange","布尔",",","datetime","终止","3.0","相等","匹配","m","full","对待","从","每个","9","作为","数据","单位","2","97","闭","ndarray","，","级别","有","一个","否则","当于","fun","100","比较","subok","py","进制","输入","4.0","unicode","子类","修改","浮点","维度","x1","d","于","转换成","或者","一定","加载","全部","base","解释","order","负数","字符","字符串","：","i","但是","优先","结束","setup","int8","abcdefg","未","list","改变","关键字","deprecationwarning","列","instead","可以","将","时","均匀","行为","asanyarray","采样","参数","val","可","始终","提供","98","获取数据","deprecated","asarray","本文","先","那些","范围","误差","内容","返回值","y","c","你","执行","skiprows","空白符","调用","按行","5","numpy","内置","如","自己","编码","binary","中","空","is","不","fname","是","之间","surprisingly","=","这","8","`","f","二进制","关键","实例","1","x","bytes","下方","endpoint","map","按列","mode","包含","copy","x2","102","真则","int64","会","true","def","python","序列","on","11","comments","123","连续","现有","都","随机","range","as","其中","loadtxt","填充","也","float64","多维","identity","表示","带有","注释","则","of","iterable","的","超出范围","1.0","注意","类型","初始化","float","基","shape","start"," ","bytearray","共享内存","迭代","stop","坐标","一维","以","}","zeros","na","为空","；","false","机制","inputs","步长","最少","多少","如果","一列","相似","行","num","间隔","step","以上","几个","sep","return","和","(","一行","empty","10","object","2.0","上方","import","方法","就是","101","列号","logspace","获取",")","对数",".","指定","其余","当","print","。","初始","深","与","列表","内存","单个","第一列","dtype","'","数","file","再","converters","...","一格","retstep","\\","相当","ascii","对角","文件","即","半开","eye","数量","20","fill","count","一份","value","二维","0","开头","布尔值","数值","20.0","对象","方式","那么","半闭","类","按照","同时","读取","array","fromstring","要求","分隔","风格","99","最后","^","{","通过","哪里","_","假设","np","/","函数","类似",":","frombuffer","浮点数","指示","from","它","矩阵","没有","delimiter","如为","算机","计算","组成","尽可能","阶","raw","50","第一","kwargs","开始","因此","int32","逻辑","标准","fromfunction","点","值","转换","相同","string","ndmin","usecols","实际","整数","type","（"],"title":"6.1.创建数组","title_tokens":["创建","数组","6.1","."]},{"location":"numpy笔记/6.1.创建数组.html#_1","text":"这里有几个共同的参数： a ：一个 array-like 类型的实例，它不一定是数组，可以为 list 、 tuple 、 list of tuple 、 list of list 、 tuple of list 、 tuple of tuple 等等。 dtype ：数组的值类型，默认为 float 。你可以指定Python的标准数值类型，也可以使用 numpy 的数值类型如： numpy.int32 或者 numpy.float64 等等。 order ：指定存储多维数据的方式。 - 'C' ，表示按行优先存储（C风格）； - 'F' ，表示按列优先存储（Fortran风格）。 - 对于 **_like() 函数， order 可以为： 'C' ， 'F' ， 'A' （表示结果的order与a相同）， 'K' （表示结果的 order 与 a 尽可能相似） subok ： bool 值。如果为 True 则：如果 a 为 ndarray 的子类（如 matrix 类），则结果类型与 a 类型相同。如果为 False 则：结果类型始终为 ndarray 。默认为True。","text_tokens":["不","是",")","对于",".","数据","f","指定","存储","。","实例","ndarray","与","，","有","一个","可能","按列","dtype","'","为","等等","subok","k","子类","true","使用","-","python","tuple","或者","一定","matrix","bool","、","order","数值","：","默认","like","方式","类","也","float64","多维","优先","表示","array","风格","结果","这里","list","_","of","则","的","可以","函数","a","参数","类型","始终","它","float"," ","fortran","尽可","）","*","尽可能","c","数组","你","int32","；","标准","false","值","如果","共同","相似","按行","相同","numpy","几个","如","(","（"],"title":"共同的参数","title_tokens":["的","共同","参数"]},{"location":"numpy笔记/6.1.创建数组.html#_2","text":"1 np.array(object[, dtype, copy, order, subok, ndmin]) :从 object 创建。 - object 可以是一个 ndarray ，也可以是一个 array_like 的对象，也可以是一个含有返回一个序列或者 ndarray 的 __array__ 方法的对象，或者一个序列。 - `copy` ：默认为 `True` ，表示拷贝对象 - `order` 可以为 `'C'、'F'、'A'` 。默认为 `'K'` 。 - `subok` 默认为 `False` - `ndmin` ：指定结果 `ndarray` 最少有多少个维度。 2 np.asarray(a[, dtype, order]) ：将 a 转换成一个 ndarray 。其中 a 是 array_like 的对象， 可以是 list 、 list of tuple 、 tuple 、 tuple of list 、 ndarray 类型。 order 默认为 C 。 3 np.asanyarray(a[, dtype, order]) ：将 a 转换成 ndarray 。 4 np.ascontiguousarray(a[, dtype]) ：返回C风格的连续 ndarray 。 5 np.copy(a[, order]) ：返回 ndarray 的一份深拷贝。 以上5个方法实际上都是调用了 array() 的接口。 np . asarray () # array(a, dtype, copy=False, order=order) np . asanyarray () # array(a, dtype, copy=False, order=order, subok=True) np . ascontiguousarray () # array(a, dtype, copy=False, order='C', ndmin=1) np . copy () # array(a, order=order, copy=True) 6 np.asmatrix(data[, dtype]) ：返回 matrix 。 7 np.frombuffer(buffer[, dtype, count, offset]) ：从输入数据中返回一维 ndarray 。 count 指定读取的数量， -1 表示全部读取； offset 指定从哪里开始读取，默认为0。 创建的数组与 buffer 共享内存。 buffer 是一个提供了 buffer 接口的对象（ 内置的 bytes/bytearray/array.array 类型提供了该接口 ）。 from array import array # array.array 提供了类似list对象的内存机制 a = array ( \"d\" , [ 1 , 2 , 3 , 4 ]) # 创建一个array数组 na = np . frombuffer ( a , dtype = np . float ) # 通过np.frombuffer()创建一个和a共享内存的NumPy数组 print ( \"a:\" , a ) print ( \"na:\" , na ) na [ 1 ] = 20 # 修改NumPy数组中的第一个元素 a # array数组中的第一个元素也同时改变 a : array ( 'd' , [ 1.0 , 2.0 , 3.0 , 4.0 ]) na : [ 1 . 2 . 3 . 4 .] array('d', [1.0, 20.0, 3.0, 4.0]) 8 np.fromfile(file[, dtype, count, sep]) ：从二进制文件或者文本文件中读取数据返回 ndarray 。 sep ：当从文本文件中读取时，数值之间的分隔字符串，如果 sep 是空字符串则表示文件应该作为二进制文件读取；如果 sep 为 \" \" 表示可以匹配0个或者多个空白字符。 9 np.fromfunction(function, shape, \\**kwargs) ：返回一个 ndarray 。function会获取每一个坐标点的数据，作为输入参数。假设 shape 的维度为N，那么 function 带有 N 个参数， fn(x1,x2,...x_N) ，其返回值就是该坐标点的值。 def fun ( x , y ): return x + y np . fromfunction ( fun , shape = ( 3 , 3 )) array([[0., 1., 2.], [1., 2., 3.], [2., 3., 4.]]) 10 np.fromiter(iterable, dtype[, count]) ：从可迭代对象中迭代获取数据创建一维 ndarray 。 np . fromiter ( \"123\" , dtype = \"int64\" ) array([1, 2, 3], dtype=int64) 11 np.fromstring(string[, dtype, count, sep]) ：从字符串或者 raw binary 中创建一维 ndarray 。如果 sep 为空字符串则 string 将按照二进制数据解释（即每个字符作为 ASCII 码值对待）。创建的数组有自己的数据存储区。 a = \"abcdefg\" a = np . fromstring ( a , dtype = np . int8 ) # 将每个字符的ASCII编码解释为整数 print ( a ) a = \"1;2;3;4;5\" a = np . fromstring ( a , dtype = np . int8 , sep = \";\" ) print ( a ) [ 97 98 99 100 101 102 103] [1 2 3 4 5] .\\setup_m.py:2: DeprecationWarning: The binary mode of fromstring is deprecated, as it behaves surprisingly on unicode inputs. Use frombuffer instead from datetime import datetime 12 np.loadtxt(fname[, dtype, comments, delimiter, ...]) :从文本文件中加载数据创建 ndarray ，要求文本文件每一行都有相同数量的数值。 comments ：指示注释行的起始字符，可以为单个字符或者字符列表（默认为 # ）。 delimiter :指定数值之间的分隔字符串，默认为空白符。 converters ：将指定列号(0,1,2...)的列数据执行转换，是一个 map ，如 {0:func1} 表示对第一列数据执行 func1(val_0) 。 skiprows ：指定跳过开头的多少行。 usecols ：指定读取那些列（0表示第一列）。","text_tokens":["空","匹配","m","is","import","是","对待","fname","方法","之间","fromfile","从","就是","surprisingly","the","101","列号","每个","=","9","获取",")","作为","103","8","`",".","f","数据","跳过","指定","2","了","二进制","当","存储","print","97","buffer","。","1","x","ndarray","深","bytes","]","与","列表","，","内存","有","fromiter","一个","单个","map","第一列","dtype","起始","'","mode","为","空白","fun","100","file","copy","x2","subok","k","102","...","应该","fn","behaves","converters","int64","py","\"","进制","\\","输入","4.0","会","ascii","unicode","修改","true","asmatrix","文件","def","实际上","维度","x1","即","12","d","数量","20","-","转换成","序列","count","文本文件","tuple","或者","一份","6","on","__","11","加载","该","matrix","其","换成","0","comments","123","全部","开头","、","function","order","解释","连续","字符","（","offset","都","20.0","：","数值","字符串","对","默认","对象","like","那么","含有","其中","#","as","loadtxt","也","按照","3","同时","读取","表示","array","fromstring","setup","要求","分隔","风格","int8","99","多个","带有","结果","第一个","+","abcdefg","list","通过","哪里","n","注释","改变","{","_","of","7","共享","则","假设","iterable","deprecationwarning","列","instead","np","可以","的","将","1.0","/","时","a","asanyarray","文本","参数","创建","类型","val","类似","可","data",":","4","接口","frombuffer","提供","返回","读取数据","指示","from","每","区","98","float","it","shape"," ","bytearray","获取数据","deprecated","delimiter","共享内存","迭代","asarray","本文","元素","那些","）","*","func1","坐标","返回值","raw","一维","第一","kwargs","y","}","c","数组","开始","执行","na","[","skiprows","空白符","为空","调用","；","fromfunction",";","false","机制","点","inputs","码值","值","最少","多少","转换","如果","use","一列","行","5","个","numpy","相同","内置","拷贝","string","ascontiguousarray","ndmin","以上","sep","return","usecols",",","和","自己","如","编码","(","实际","整数","一行","10","中","3.0","binary","datetime","object","2.0"],"title":"从现有的数据创建","title_tokens":["现有","创建","数据","从","的"]},{"location":"numpy笔记/6.1.创建数组.html#_3","text":"1 np.arange([start,] stop[, step,][, dtype]) :返回均匀间隔的值组成的一维 ndarray 。区间是半闭半开的 [start,stop) ，其采样行为类似Python的 range 函数。 start 为开始点， stop 为终止点， step 为步长，默认为1。这几个数可以为整数可以为浮点数。 注意如果 step 为浮点数，则结果可能有误差，因为浮点数相等比较不准确（计算机精度有限）。 2 np.linspace(start, stop[, num, endpoint, ...]) ：返回 num 个均匀采样的数值组成的一维 ndarray （默认为50）。区间是闭区间 [start,stop] 。 endpoint 为布尔值，如果为真则表示 stop 是最后采样的值（默认为 True ），否则结果不包含 stop 。 retstep 如果为 True 则返回结果包含采样步长 step ，默认为 True 。 3 np.logspace(start, stop[, num, endpoint, base, ...]) ：返回对数级别上均匀采样的数值组成的一维 ndarray 。采样点开始于 base^start ，结束于 base^stop 。 base 为对数的基，默认为 10。 它逻辑上相当于先执行 arange 获取数组 array ，然后再执行 base^array[i] 获取采样点 - 它没有 retstep 关键字参数","text_tokens":["相等","不","是","然后","区间","logspace","获取",")","这","对数",".","2","闭","相当于","点数","关键","。","1","ndarray","]","，","级别","endpoint","有","可能","dtype","否则","当于","为","比较","数","包含","再","准确","...","真则","retstep","相当","true","浮点","半开","于","python","-","linspace","上","其","布尔值","base","数值","：","i","range","默认","半闭","3","结束","表示","array","因为","最后","结果","^","则","关键字","计算机","有限","的","np","均匀","可以","行为","函数","注意","采样","参数","类似",":","返回","浮点数","精度","它","基","start"," ","没有","先","算机","计算","组成","）","stop","误差","50","一维","数组","开始","执行","[","逻辑","点","步长","值","如果","个","num","间隔","step","arange","几个","布尔",",","(","整数","终止","10","（"],"title":"从数值区间创建","title_tokens":["创建","从","区间","数值"]},{"location":"numpy笔记/6.1.创建数组.html#_4","text":"1 np.empty(shape[,dtype,order]) ：返回一个新的 ndarray ，指定了 shape 和 dtype ，但是没有初始化元素。因此其内容是随机的。 2 np.empty_like(a[,dtype,order,subok]) ：返回一个新的 ndarray ， shape 与 a 相同，但是没有初始化元素。因此其内容是随机的。 # 内存未初始化 a = np . empty (( 3 , 2 ), order = \"C\" ) # 内存未初始化 np . empty_like ( a ) array([[0., 0.], [0., 0.], [0., 0.]]) 3 np.eye(N[, M, k, dtype]) ：返回一个==二维数组==，对角线元素为1，其余元素为0。 M 默认等于 N 。 k 默认为0表示对角线元素为1，如为正数则表示对角线上方一格的元素为1，如为负数表示对角线下方一格的元素为1。 4 np.identity(n[, dtype]) ：返回一个单位矩阵。 np . eye ( N = 2 , M = 3 ) np . eye ( N = 2 , M = 3 , k = 0 ) # 参数k是可以超出范围的 np . eye ( N = 2 , M = 3 , k = 1 ) # 返回n阶单位矩阵 np . identity ( n = 4 ) array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) 5 np.ones(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为1. 6 np.ones_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为1。 7 np.zeros(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为0. 8 np.zeros_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a （另一个数组）相同，每个元素初始化为0。 9 np.full(shape, fill_value[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为 fill_value 。 10 np.full_like(a, fill_value[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为 fill_value 。 np . full (( 2 , 3 ), fill_value = 2 ) array([[2, 2, 2], [2, 2, 2]])","text_tokens":["上方","m","full","是","每个","=","9",")","超出","8",".","等于","单位","指定","2","了","其余","ones","。","1","初始","ndarray","]","与","，","下方","内存","一个","dtype","为","subok","k","正数","一格","\"","对角","eye","fill","value","6","二维","其","0","order","负数","对角线","：","随机","默认","like","但是","#","3","identity","表示","array","未","n","_","则","7","另","的","np","可以","超出范围","a","参数","4","返回","初始化","shape","矩阵"," ","没有","如为","元素","范围","）","内容","阶","c","数组","zeros","因此","[","新","相同","5","单位矩阵",",","和","(","empty","10","type","（"],"title":"以填充的方式创建","title_tokens":["创建","方式","的","以","填充"]},{"location":"numpy笔记/6.10.函数库.html","text":"import numpy as np 随机数库","text_tokens":["库","机数","import","随机","随机数"," ","numpy","np","as"],"title":"6.10.函数库","title_tokens":[".","6.10","函数","函数库"]},{"location":"numpy笔记/6.10.函数库.html#_1","text":"","text_tokens":[],"title":"随机数库","title_tokens":["随机","随机数","库","机数"]},{"location":"numpy笔记/6.12.结构化数组.html","text":"结构化数组常用操作 import numpy as np import pprint x = np . array ([( 'Rex' , 9 , 81.0 ), ( 'Fido' , 3 , 27.0 )], dtype = [( 'name' , 'U10' ), ( 'age' , 'i4' ), ( 'weight' , 'f4' )]) pprint . pprint ( x ) array([('Rex', 9, 81.), ('Fido', 3, 27.)], dtype=[('name', '<U10'), ('age', '<i4'), ('weight', '<f4')]) 通过索引，可以获得一个结构 pprint . pprint ( x [ 0 ]) # 可以通过使用 字段名称 建立索引来访问和修改结构化数组的各个 字段： pprint . pprint ( x [ \"name\" ]) pprint . pprint ( x [[ \"age\" , \"name\" ]]) # 根据 字段名称 做过滤 pprint . pprint ( x [ x [ \"age\" ] > 5 ][ \"name\" ]) # 修改全部数组的age字段 x [ \"age\" ] = 20 pprint . pprint ( x ) ('Rex', 9, 81.) array(['Rex', 'Fido'], dtype='<U10') array([(9, 'Rex'), (3, 'Fido')], dtype={'names':['age','name'], 'formats':['<i4','<U10'], 'offsets':[40,0], 'itemsize':48}) array(['Rex'], dtype='<U10') array([('Rex', 20, 81.), ('Fido', 20, 27.)], dtype=[('name', '<U10'), ('age', '<i4'), ('weight', '<f4')]) 创建结构化数组 可以通过 a list of tuple 的形式创建结构化数组。 \"\"\" # the tupe is (fieldname, datatype, Shape) # fieldname、Shape可以省略 # fieldname 是字符串，如果使用 title，则为元组 # 如果fieldname省略，则用 f# 的默认名称代替 # shape 如果省略，则默认为(1,) \"\"\" np . dtype ([( 'x' , 'f4' ), ( 'y' , np . float32 ), ( 'z' , 'f4' , ( 2 , 2 ))]) \"\"\" 如果 fieldname 是空字符串 '' ，则将为字段指定格式为 f# 的默认名称， 其中 # 是字段的整数索引，从左侧开始从0开始计数： \"\"\" np . dtype ([( 'x' , 'f4' ), ( '' , 'i4' ), ( 'z' , 'i8' )]) dtype([('x', '<f4'), ('f1', '<i4'), ('z', '<i8')]) 可以通过“逗号分割的字符串”创建结构化数组。字符串要符合规范。 np . dtype ( 'i8, f4, S3' ) np . dtype ( '3int8, float32, (2, 3)float64' ) dtype([('f0', 'i1', (3,)), ('f1', '<f4'), ('f2', '<f8', (2, 3))]) 通过“字段参数组字典”创建结构化数组。 这是最灵活的规范形式，因为它允许控制字段的字节偏移和结构的项目大小。 dict有两个必需键 names 和 format ，以及四个可选键 offsets 、 itemsize 、 Aligned 和 title ： names 和 format 的值应该分别是相同长度的字段名列表和dtype规范列表。 可选的 offsets 值应该是整数字节偏移量的列表，结构中的每个字段都有一个偏移量。如果未给出 offsets ，则自动确定偏移量。 可选的 itemsize 值应该是一个整数， 描述 dtype 的总大小（以字节为单位），它必须足够大以包含所有字段。 可选的 Aligned 值可以设置为True，以使自动偏移计算使用对齐的偏移量（ 请参阅自动字节偏移量和对齐 ）。 可选的 titles 值应该是长度与 names 相同的标题列表。 np . dtype ({ 'names' : [ 'col1' , 'col2' ], 'formats' : [ 'i4' , 'f4' ]}) np . dtype ({ 'names' : [ 'col1' , 'col2' ], 'formats' : [ 'i4' , 'f4' ], 'offsets' : [ 0 , 4 ], 'itemsize' : 12 }) dtype({'names':['col1','col2'], 'formats':['<i4','<f4'], 'offsets':[0,4], 'itemsize':12}) 通过 dict of fieldname 创建结构化数组。不鼓励使用这种形式，因为Python字典在Python 3.6之前的Python版本中不保留顺序，但结构化dtype中字段的顺序有意义。 字典的关键字是字段名称，值是指定类型和偏移量的元组： np . dtype ({ 'col1' : ( 'i1' , 0 ), 'col2' : ( 'f4' , 1 )}) dtype([('col1', 'i1'), ('col2', '<f4')]) 操作和显示结构化数据类型 d = np . dtype ([( 'x' , 'i8' ), ( 'y' , 'f4' )]) d . names d . fields mappingproxy({'x': (dtype('int64'), 0), 'y': (dtype('float32'), 8)}) 为什么需要结构化数组 numpy结构化数组中的用法好像类似于Python的dict of list，那为什么还要用numpy结构化数组呢？ 因为numpy的结构化数组底层是类似C语言的结构，占用一块连续的内存区域，并且numpy底层是C实现，numpy数组中的类型都是静态类型的，性能好于Python的的字典列表。 可以来做一下性能比较。 import time ### 定义计时器 def timer ( func ): def wrapper ( self , * args , ** kwargs ): start = time . process_time () something = func ( self , * args , ** kwargs ) end = time . process_time () type_str = func . __repr__ () print ( \"当前函数：\" , type_str , \" \\n \" , \"用时：\" , end - start , \"秒\" , sep = \"\" ) return something return wrapper # numpy版本长一岁 @timer def addage_numpy ( data , loop ): for i in range ( loop ): data [ 'age' ] += 1 # python循环长一岁 @timer def addage_python ( data , loop ): for j in range ( loop ): for i in range ( 4 ): data [ i ][ \"age\" ] += 1 # 创建结构化数组 names = [ 'Lin' , 'Pan' , 'Shen' , 'Zhou' ] ages = [ 28 , 33 , 34 , 29 ] grades = [ 25 , 26 , 27 , 24 ] data_np = np . zeros ( 4 , dtype = { 'names' :( 'name' , 'age' , 'grade' ), 'formats' :( 'U10' , 'i4' , 'i4' ) }) data_np [ 'name' ] = names data_np [ 'age' ] = ages data_np [ 'grade' ] = grades data_py = [] for i in range ( 4 ): person = { \"name\" : names [ i ], \"age\" : ages [ i ], \"grade\" : grades [ i ]} data_py . append ( person ) addage_numpy ( data_np , loop = 1000000 ) addage_python ( data_py , loop = 1000000 ) 当前函数：<function addage_numpy at 0x000001198F1ECC80> 用时：5.53125秒 当前函数：<function addage_python at 0x000001198F1ECD90> 用时：1.796875秒 记录数组 记录数组和结构数组没有太大区别，它们所使用的场景也是类似的，只不过记录数组可以通过属性的方式访问数据。 创建记录数组的最简单方法是 numpy.rec.array 。 recordarr = np . rec . array ([( 1 , 2. , 'Hello' ), ( 2 , 3. , \"World\" )], dtype = [( 'foo' , 'i4' ),( 'bar' , 'f4' ), ( 'baz' , 'S10' )]) print ( type ( recordarr )) # 通过属性访问数据 recordarr . foo <class 'numpy.recarray'> array([1, 2]) numpy.rec.array 可以将各种参数转换为记录数组，包括结构化数组： arr = np . array ([( 1 , 2. , 'Hello' ), ( 2 , 3. , \"World\" )], dtype = [( 'foo' , 'i4' ), ( 'bar' , 'f4' ), ( 'baz' , 'S10' )]) recordarr = np . rec . array ( arr ) pprint . pprint ( recordarr ) rec.array([(1, 2., b'Hello'), (2, 3., b'World')], dtype=[('foo', '<i4'), ('bar', '<f4'), ('baz', 'S10')]) numpy.rec 模块提供了多个便利的函数来创建记录数组，请参阅 记录数组创建方法列表 。 注意： numpy.rec 是 numpy.core.records 的首选别名。 core.records.array(obj[, dtype, shape, …]) ：从各种各样的对象构造一个记录数组。 core.records.fromarrays(arrayList[, dtype, …]) ：从一维的list或array创建记录数组。 core.records.fromrecords(recList[, dtype, …]) ：从文本格式的list创建一个记录数组。 core.records.fromstring(datastring[, dtype, …]) ：从二进制字符串数据创建（只读）记录数组。 core.records.fromfile(fd[, dtype, shape, …]) ：从二进制文件数据创建记录数组。 参考 一文彻底搞懂numpy的结构化数组——structured array Numpy的结构化数组 结构化数组","text_tokens":["40","fromfile","the","args","便利","可选","c语言","name","用时","pan","占用","了","shen","计时器","]","但","fromarrays","hello","###","27","字段","语言","为","0x000001198f1ecc80","应该","append","循环","性能","\"","长","12","使用","-","tuple","各种各样","之前","__","f2",">","time","、","function","底层","3int8","col1","aligned","默认","structured","#","fromrecords","3","repr","col2","它们","因为","多个","区域","+","27.0","n","各个","各样","a","偏移","使","文本","创建","一下","data","dict","4","j","索引","区别","3.6","组","）","*","结构","长度","字","标题","数组","lin","[","pprint","fields","end","灵活",",","81.0","rec","从","每个","9","baz","26","1.796875","数据","float32","单位","规范","2","用法","字典","确定","，","定义","有","records","一个","省略","记录","24","文本格式","ages","比较","做","formats","i1","py","进制","数据类型","格式","修改","简单","d","彻底","于","符合","别名","title","“","全部","太","i4","字符","字符串","：","arr","搞懂","i","offsets","48","tupe","age","只不过","29","未","list","25","关键字","什么","可以","将","只读","@","显示","参数","描述","提供","core","不过","给出","四个","zhou","recordarr","大","func","reclist","？","那","f4","y","c","并且","要","fido","属性","参考","datastring","5","numpy","in","访问","所","符合规范","计时","中","需要","空","逗号","something","addage","is","不","包括","是","”","结构化","=","这","8","模块","f","1000000","参阅","…","二进制","建立","str","关键","self","1","x","自动","分别","各种","常用","81","总","用","i8","z","或","包含","—","形式","int64","true","def","rex","python","根据","还要","timer","以及","wrapper","连续","都","fieldname","构造","range","names","as","其中","float64","也","recarray","静态","大小","fd","则","of","的","33","合规","过滤","process","注意","一文","类型","必需","顺序","首选","0x000001198f1ecd90","这种","好像","对齐","shape","start"," ","分割","键","arraylist","一维","以","控制","}","意义","zeros","好于","为什么","设置","如果","34","obj","鼓励","sep","return","和","(","<","当前","呢","import","方法","foo","mappingproxy","bar",")",".","28","b","指定","u10","来","操作","在","print","。","允许","与","列表","场景","一块","内存","itemsize","名称","dtype","'","字节","秒","\\","文件","world","s3","grades","元组","字段名","20","称","0","请参阅","datatype","获得","对象","方式","array","f0","class","fromstring","保留","一岁","{","通过","版本","偏移量","_","for","np","format","计数","函数","实现","左侧","f8","titles","grade","类似","最",":","可选键","它","足够","没有","计算","at","s10","f1","loop","kwargs","开始","person","两个","代替","值","必须","转换","weight","相同","大以","段","项目","所有","5.53125","整数","type","（","中字"],"title":"6.12.结构化数组","title_tokens":["结构化","数组","结构",".","6.12"]},{"location":"numpy笔记/6.12.结构化数组.html#_1","text":"import numpy as np import pprint x = np . array ([( 'Rex' , 9 , 81.0 ), ( 'Fido' , 3 , 27.0 )], dtype = [( 'name' , 'U10' ), ( 'age' , 'i4' ), ( 'weight' , 'f4' )]) pprint . pprint ( x ) array([('Rex', 9, 81.), ('Fido', 3, 27.)], dtype=[('name', '<U10'), ('age', '<i4'), ('weight', '<f4')]) 通过索引，可以获得一个结构 pprint . pprint ( x [ 0 ]) # 可以通过使用 字段名称 建立索引来访问和修改结构化数组的各个 字段： pprint . pprint ( x [ \"name\" ]) pprint . pprint ( x [[ \"age\" , \"name\" ]]) # 根据 字段名称 做过滤 pprint . pprint ( x [ x [ \"age\" ] > 5 ][ \"name\" ]) # 修改全部数组的age字段 x [ \"age\" ] = 20 pprint . pprint ( x ) ('Rex', 9, 81.) array(['Rex', 'Fido'], dtype='<U10') array([(9, 'Rex'), (3, 'Fido')], dtype={'names':['age','name'], 'formats':['<i4','<U10'], 'offsets':[40,0], 'itemsize':48}) array(['Rex'], dtype='<U10') array([('Rex', 20, 81.), ('Fido', 20, 27.)], dtype=[('name', '<U10'), ('age', '<i4'), ('weight', '<f4')])","text_tokens":["'","81.0","48","3","40","offsets","array","import","age","结构","做","formats","#","字","f4","结构化","=","}","9",")","数组","通过","27.0","\"","{","各个","修改",".","[","pprint","fido","names","np","可以","使用","字段名","rex","name","的","u10","来","根据","20","建立","过滤","称","x","0",">","weight","numpy","]","访问","索引","5","全部",":","，","i4","获得","段",",","27","和","81","：","(","itemsize","<","字段"," ","一个","as","dtype"],"title":"结构化数组常用操作","title_tokens":["结构化","常用","操作","数组","结构"]},{"location":"numpy笔记/6.12.结构化数组.html#_2","text":"可以通过 a list of tuple 的形式创建结构化数组。 \"\"\" # the tupe is (fieldname, datatype, Shape) # fieldname、Shape可以省略 # fieldname 是字符串，如果使用 title，则为元组 # 如果fieldname省略，则用 f# 的默认名称代替 # shape 如果省略，则默认为(1,) \"\"\" np . dtype ([( 'x' , 'f4' ), ( 'y' , np . float32 ), ( 'z' , 'f4' , ( 2 , 2 ))]) \"\"\" 如果 fieldname 是空字符串 '' ，则将为字段指定格式为 f# 的默认名称， 其中 # 是字段的整数索引，从左侧开始从0开始计数： \"\"\" np . dtype ([( 'x' , 'f4' ), ( '' , 'i4' ), ( 'z' , 'i8' )]) dtype([('x', '<f4'), ('f1', '<i4'), ('z', '<i8')]) 可以通过“逗号分割的字符串”创建结构化数组。字符串要符合规范。 np . dtype ( 'i8, f4, S3' ) np . dtype ( '3int8, float32, (2, 3)float64' ) dtype([('f0', 'i1', (3,)), ('f1', '<f4'), ('f2', '<f8', (2, 3))]) 通过“字段参数组字典”创建结构化数组。 这是最灵活的规范形式，因为它允许控制字段的字节偏移和结构的项目大小。 dict有两个必需键 names 和 format ，以及四个可选键 offsets 、 itemsize 、 Aligned 和 title ： names 和 format 的值应该分别是相同长度的字段名列表和dtype规范列表。 可选的 offsets 值应该是整数字节偏移量的列表，结构中的每个字段都有一个偏移量。如果未给出 offsets ，则自动确定偏移量。 可选的 itemsize 值应该是一个整数， 描述 dtype 的总大小（以字节为单位），它必须足够大以包含所有字段。 可选的 Aligned 值可以设置为True，以使自动偏移计算使用对齐的偏移量（ 请参阅自动字节偏移量和对齐 ）。 可选的 titles 值应该是长度与 names 相同的标题列表。 np . dtype ({ 'names' : [ 'col1' , 'col2' ], 'formats' : [ 'i4' , 'f4' ]}) np . dtype ({ 'names' : [ 'col1' , 'col2' ], 'formats' : [ 'i4' , 'f4' ], 'offsets' : [ 0 , 4 ], 'itemsize' : 12 }) dtype({'names':['col1','col2'], 'formats':['<i4','<f4'], 'offsets':[0,4], 'itemsize':12}) 通过 dict of fieldname 创建结构化数组。不鼓励使用这种形式，因为Python字典在Python 3.6之前的Python版本中不保留顺序，但结构化dtype中字段的顺序有意义。 字典的关键字是字段名称，值是指定类型和偏移量的元组： np . dtype ({ 'col1' : ( 'i1' , 0 ), 'col2' : ( 'f4' , 1 )}) dtype([('col1', 'i1'), ('col2', '<f4')])","text_tokens":["空","逗号","is","不","是","”","从","the","结构化","每个",")","这","可选","f",".","float32","单位","规范","参阅","2","指定","在","关键","。","1","x","允许","自动","字典","确定","]","但","与","分别","列表","，","itemsize","总","名称","有","用","字段","一个","省略","dtype","i8","'","z","为","字节","包含","formats","形式","应该","i1","\"","格式","true","12","s3","元组","使用","字段名","符合","python","tuple","称","之前","title","“","f2","以及","0","请参阅","、","datatype","3int8","i4","col1","字符","都","字符串","fieldname","：","aligned","默认","names","其中","#","offsets","float64","3","tupe","f0","col2","保留","因为","大小","未","list","通过","{","版本","偏移量","则","of","关键字","的","可以","np","将","format","计数","a","偏移","左侧","合规","f8","使","titles","参数","创建","类型","描述","最","dict",":","可选键","4","必需","索引","顺序","它","这种","对齐","shape","3.6","给出"," ","分割","足够","四个","组","键","计算","）","结构","长度","字","以","f1","f4","控制","y","标题","}","意义","数组","开始","[","要","设置","两个","代替","值","必须","如果","灵活","相同","大以","鼓励","段","项目",",","和","符合规范","所有","(","整数","<","中","（","中字"],"title":"创建结构化数组","title_tokens":["创建","数组","结构化","结构"]},{"location":"numpy笔记/6.12.结构化数组.html#_3","text":"d = np . dtype ([( 'x' , 'i8' ), ( 'y' , 'f4' )]) d . names d . fields mappingproxy({'x': (dtype('int64'), 0), 'y': (dtype('float32'), 8)})","text_tokens":["i8","'","mappingproxy","f4","int64","y","=","}",")","{","8",".","[","float32","np","d","fields","x","0",":","]",",","("," ","names","dtype"],"title":"操作和显示结构化数据类型","title_tokens":["结构化","操作","和","显示","数据类型","结构","类型","数据"]},{"location":"numpy笔记/6.12.结构化数组.html#_4","text":"numpy结构化数组中的用法好像类似于Python的dict of list，那为什么还要用numpy结构化数组呢？ 因为numpy的结构化数组底层是类似C语言的结构，占用一块连续的内存区域，并且numpy底层是C实现，numpy数组中的类型都是静态类型的，性能好于Python的的字典列表。 可以来做一下性能比较。 import time ### 定义计时器 def timer ( func ): def wrapper ( self , * args , ** kwargs ): start = time . process_time () something = func ( self , * args , ** kwargs ) end = time . process_time () type_str = func . __repr__ () print ( \"当前函数：\" , type_str , \" \\n \" , \"用时：\" , end - start , \"秒\" , sep = \"\" ) return something return wrapper # numpy版本长一岁 @timer def addage_numpy ( data , loop ): for i in range ( loop ): data [ 'age' ] += 1 # python循环长一岁 @timer def addage_python ( data , loop ): for j in range ( loop ): for i in range ( 4 ): data [ i ][ \"age\" ] += 1 # 创建结构化数组 names = [ 'Lin' , 'Pan' , 'Shen' , 'Zhou' ] ages = [ 28 , 33 , 34 , 29 ] grades = [ 25 , 26 , 27 , 24 ] data_np = np . zeros ( 4 , dtype = { 'names' :( 'name' , 'age' , 'grade' ), 'formats' :( 'U10' , 'i4' , 'i4' ) }) data_np [ 'name' ] = names data_np [ 'age' ] = ages data_np [ 'grade' ] = grades data_py = [] for i in range ( 4 ): person = { \"name\" : names [ i ], \"age\" : ages [ i ], \"grade\" : grades [ i ]} data_py . append ( person ) addage_numpy ( data_np , loop = 1000000 ) addage_python ( data_py , loop = 1000000 ) 当前函数：<function addage_numpy at 0x000001198F1ECC80> 用时：5.53125秒 当前函数：<function addage_python at 0x000001198F1ECD90> 用时：1.796875秒","text_tokens":["something","addage","import","是","结构化","=","args",")","c语言","26","1.796875",".","28","1000000","name","用时","pan","占用","用法","来","u10","print","str","shen","。","self","计时器","1","字典","]","列表","，","一块","内存","###","27","定义","用","dtype","'","24","语言","ages","秒","比较","0x000001198f1ecc80","做","formats","append","循环","性能","py","\"","\\","长","def","grades","于","python","-","当前","还要","__","timer",">","time","function","底层","wrapper","i4","连续","都","：","i","range","names","#","repr","age","静态","因为","29","区域","一岁","+","list","版本","n","25","{","_","of","for","什么","的","可以","np","33","函数","实现","@","grade","process","创建","类型","类似","一下","data","dict",":","4","j","0x000001198f1ecd90","好像","start"," ","zhou","func","*","结构","？","at","那","loop","kwargs","}","c","数组","lin","zeros","并且","好于","为什么","[","person","end","34","numpy","in","sep","return",",","(","计时","5.53125","<","中","type","呢"],"title":"为什么需要结构化数组","title_tokens":["需要","结构化","数组","为什么","结构","什么"]},{"location":"numpy笔记/6.12.结构化数组.html#_5","text":"记录数组和结构数组没有太大区别，它们所使用的场景也是类似的，只不过记录数组可以通过属性的方式访问数据。 创建记录数组的最简单方法是 numpy.rec.array 。 recordarr = np . rec . array ([( 1 , 2. , 'Hello' ), ( 2 , 3. , \"World\" )], dtype = [( 'foo' , 'i4' ),( 'bar' , 'f4' ), ( 'baz' , 'S10' )]) print ( type ( recordarr )) # 通过属性访问数据 recordarr . foo <class 'numpy.recarray'> array([1, 2]) numpy.rec.array 可以将各种参数转换为记录数组，包括结构化数组： arr = np . array ([( 1 , 2. , 'Hello' ), ( 2 , 3. , \"World\" )], dtype = [( 'foo' , 'i4' ), ( 'bar' , 'f4' ), ( 'baz' , 'S10' )]) recordarr = np . rec . array ( arr ) pprint . pprint ( recordarr ) rec.array([(1, 2., b'Hello'), (2, 3., b'World')], dtype=[('foo', '<i4'), ('bar', '<f4'), ('baz', 'S10')]) numpy.rec 模块提供了多个便利的函数来创建记录数组，请参阅 记录数组创建方法列表 。 注意： numpy.rec 是 numpy.core.records 的首选别名。 core.records.array(obj[, dtype, shape, …]) ：从各种各样的对象构造一个记录数组。 core.records.fromarrays(arrayList[, dtype, …]) ：从一维的list或array创建记录数组。 core.records.fromrecords(recList[, dtype, …]) ：从文本格式的list创建一个记录数组。 core.records.fromstring(datastring[, dtype, …]) ：从二进制字符串数据创建（只读）记录数组。 core.records.fromfile(fd[, dtype, shape, …]) ：从二进制文件数据创建记录数组。","text_tokens":["rec","包括","是","方法","foo","fromfile","从","结构化","=","便利","bar",")","baz","模块","数据",".","参阅","b","…","2","了","来","二进制","print","。","1","]","fromarrays","各种","列表","，","场景","hello","records","一个","记录","dtype","'","文本格式","为","或","\"","进制","格式","简单","文件","world","使用","别名","各种各样",">","请参阅","太","i4","字符","字符串","：","arr","构造","对象","方式","#","fromrecords","也","recarray","3","array","class","fromstring","它们","只不过","多个","list","通过","fd","各样","的","可以","np","将","只读","函数","注意","文本","参数","创建","类似","最","提供","区别","首选","core","shape","不过"," ","没有","recordarr","大","arraylist","）","结构","reclist","s10","一维","f4","数组","[","pprint","属性","转换","datastring","numpy","访问","obj","所",",","和","(","<","type","（"],"title":"记录数组","title_tokens":["数组","记录"]},{"location":"numpy笔记/6.12.结构化数组.html#_6","text":"一文彻底搞懂numpy的结构化数组——structured array Numpy的结构化数组 结构化数组","text_tokens":["结构化","数组","一文","array","搞懂","结构","structured"," ","—","numpy","的","彻底"],"title":"参考","title_tokens":["参考"]},{"location":"numpy笔记/6.2.索引.html","text":"import numpy as np import copy ndarrays 可以使用标准 Python x[obj] 语法对其进行索引 ，其中 x 是数组， obj 是索引。有三种可用的索引：字段访问，基本切片，高级索引。哪一个发生取决于 obj 。 在 Python 中， x[(exp1，exp2，.，EXPN)] 等同于 x[exp1，exp2，.，EXPN] 。后者只是前者的语法糖。 # 创建一个一维数组 a = np . arange ( 100 ) # 创建一个二维数组 b = copy . deepcopy ( np . reshape ( a , ( 20 , 5 ))) # 创建一个三维数组 c = copy . deepcopy ( np . arange ( 90 ) . reshape (( 10 , 3 , 3 ))) 一维数组的索引 一维数组的索引和列表相同。假设 a1 是一维数组，那么有以下5种使用索引的情况： 可以指定一个 整数 i 作为索引下标，如 a1[i] 。 可以指定一个 切片 作为索引下标，如 a1[i:j] ，等价于 a1[slice(j,j)] 。 可以指定一个 整数list 对数组进行存取，如 a1[[i1,i2,i3]] 。此时会将列表中的每个整数作为下标 (i1/i2/i3) ，使用列表作为下标得到的数组为 np.array([a1[i1],a1[i2],a1[i3]]) ，它不和原始数组共享内存。 可以指定一个 整数数组 作为数组下标，如 a1[a2] 此时会得到一个形状和下标数组 a2 相同的新数组。新数组的每个元素都是下标数组中对应位置的值作为下标从原始数组中获得的值。新数组不和原始数组共享数据。 可以指定一个 布尔数组 作为数组下标，如a1[b]。此时将获得数组a1中与数组b中的True对应的元素。新数组不和原始数组共享数据。 # 指定一个整数 a [ 1 ] # OWNDATA : True ## 等价于 a [( 1 )] # OWNDATA : True # 指定切片 a [ 0 : 20 : 2 ] # 返回视图 a [ slice ( 0 , 20 , 2 )] # 返回视图 # 指定一个整数列表 a [[ 1 , 2 , 3 , 4 ]] # OWNDATA : True # 指定一个整数数组 ## index是一维数组 index = np . array ([ 0 , 1 , 2 , 3 , 4 ]) a [ index ] # OWNDATA : True ## index是二维数组 index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) a [ index ] # OWNDATA : True # 指定一个布尔数组 ## 布尔数组的ndim需要和原数组相同 bool_a = a > 50 bool_a = list ( bool_a ) 多维数组的索引 多维数组使用 元组 作为数组的下标，如 a[1,2] ，当然你也可以添加圆括号为 a[(1,2)] 。实际上，一维数组也是如此，只是一维数组只有第 0 轴。 下标元组 中每个元素和数组的每个轴对应。下标元组的第 0 个元素对应数组第 0 轴，第 1 个元素对应数组第 1 轴，第 2 个元素对应数组第 2 轴··· 多维数组的下标必须是一个长度和数组的维度ndim相等的元组。 如果下标元组的长度大于数组的维度ndim，则IndexError 如果下标元组的长度小于数组的维度ndim，则自动在元组的后面补 : ，使得下标元组的长度等于数组维度ndim。 如果下标对象不是元组，则Numpy会首先将其转换为元组。 有以下7种使用索引的情况： 整数元组 切片 整数元组搭配切片 整数list 整数数组 布尔数组 整数数组、切片、整数元组混搭 # 指定一个整数元组 b [( 1 , 2 )] # OWNDATA : Trues ## 等价于 b [ 1 , 2 ] # OWNDATA : Trues ## 元组的维度超过多维数组的维度:IndexError ''' b[(1,2,3)] ''' ## 元组的维度超少于维数组的维度 b [ 1 ] # 返回视图 等价于 b[1,:] # 切片 b [ 0 , 0 : 5 : 2 ] # 返回视图 b [ 0 , 0 :: 2 ] # 返回视图 b [ 0 , slice ( 0 , None , 2 )] # 返回视图 ## SyntaxError b[0,slice(0,,2)] b [ 0 : 10 : 2 , 0 : 5 : 2 ] # 返回视图 ## 第二列 b [:, 1 ] # 返回视图 b [ ... , 1 ] # 返回视图 ## IndexError: an index can only have a single ellipsis ('...') ''' b[...,...] IndexError ''' b [ ... ,:] # 返回视图 b [:,:] # 返回视图 # 整数数组 ## arrays used as indices must be of integer (or boolean) type index = np . array ([ 0 , 1 , 2 , 3 ]) b [ index ] # OWNDATA : True index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) b [ index ] # OWNDATA : True ## 如果下标整数数组的维度不一致，会进行广播 rows = np . array ([[ 0 , 1 , 2 ]]) columns = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 4 ]]) index = ( rows , columns ) b [ index ] array([[ 0, 6, 12], [ 3, 9, 14]]) 多维数组的下标是布尔数组或者下标元组中包含了布尔数组，则相当于将布尔数组通过 np.nonzero() 将布尔数组转换成一个整数数组的元组，然后使用整数数组进行下标运行。 np.nonzero(a) 返回数组 a 中，值非零的元素的 下标 。它返回值是一个长度为 a.ndim 的元组，元组的每个元素都是一个一维的整数数组，其值为非零元素的下标在对应轴上的值。如：第 0 个元素为a中的非零值元素在0轴的下标、第 1 个元素为a中的非零值元素在1轴的下标... np . nonzero ( bool_a ) (array([51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], dtype=int64),) 进阶说明 使用切片返回视图的原因： 当下标使用切片时，所取得的数据在数据存储区域中是等间隔分布的。因为只需要修改数组的ndim/shape/strides等属性以及指向数据存储区域的data指针就能够实现整数和切片下标的索引。所以新数组和原始数组能够共享数据存储区域。 当使用整数数组（整数元组，整数列表页转换成整数数组），布尔数组时，不能保证所取得的数据在数据存储区中是等间隔的，因此无法和原始数组共享数据，只能对数据进行复制。 通过整数元组获取的数组元素的类型为数组的dtype类型 。如果你想获取标准python类型，可以使用数组的item()方法。 索引的维度变换 索引的下标元组中： 如果下标元组都是切片，则索引结果的数组与原始数组的维度相同（轴的数量相等） 每多一个整数下标，则索引结果的数组就少一个维度（少一个轴） 如果所有的下标都是整数，则索引结果的维度为 0 如果下标元组中存在数组，则还需要考虑该下标数组广播后的维度 多维数组的下标必须是一个长度和数组的维度 ndim 相等的元组。但是如果下标中包含None，则可以突破这一限制。每多一个None，则索引结构维度升 1 。 当数组的下标元组的长度小于等于数组的维度ndim时，元组中出现的None等价于切片: 当数组的下标元组的长度大于数组的维度ndim时，元组中哪里出现None，索引结果就在哪里创建一个新轴，该轴长度为 1。 b [ 1 , 2 ] b [ 1 , 2 , None ] b [ 1 , 2 , np . newaxis ] array([7])","text_tokens":["分布","74","对应","出现","然后","原","57","92","等于","88","了","存储","相当于","indexerror","##","]","boolean","轴上","搭","为","86","63","前者","后面","考虑","single","12","实际上","使用","只能","6","reshape","该","其",">","换成","bool","owndata","、","等同于","视图","对","只","#","位置","3","还","因为","结果","只有","区域","91","圆括号","7","共享","item","93","79","a","语法","创建","指针","data","4","j","索引","76","一个三维","返回","syntaxerror","70","新轴","66","ellipsis","元素","77","）","长度","结构","87","arrays","字","标的","页","进阶","73","指向","数组","[","80","85","ndarrays","标","84","限制","取决","i2","新","发生","个","arange","布尔",",","此时","广播","相等","一个二维","高级","从","每个","9","作为","deepcopy","哪","存取","数据","每多","这一","2","添加","97","65","，","有","等同","能够","一个","当于","使得","100","56","i1","想","修改","首先","维度","非零值","于","转换成","或者","78","an","83","：","must","integer","i","但是","61","不能","所以","nonzero","list","小于","情况","时","可以","将","只是","原始","可用","种","58","98","中是","can","68","newaxis","94","返回值","c","slice","a1","你","等","90","糖","属性","非","60","used","进行","5","numpy","访问","所","如","轴","中","大于","需要","不","是","形状","=","其值","二列","1","x","自动","95","切片","81","一致","包含","copy","a2","int64","会","true","exp2","后者","python","等价","不是","以及","基本","都","得到","运行","其中","as","89","也","多维","补","区中","则","of","的","维","82","存在","类型","have","shape"," ","indices","共享内存","突破","69","括号","一维","下标","strides","升","如果","搭配","·","如此","间隔","obj","i3","和","说明","(","取决于","14","零","10","51","保证","import","96","方法","52","be","获取",")","当下",".","b","三种","少于","指定","当","在","无法","。","复制","三维","与","列表","就","内存","当然","columns","后","dtype","'","55","trues","index","第二","...","相当","元组","rows","59","数量","20","53","变换","67","exp1","二维","0","71","同于","获得","only","72","对象","那么","array","99","取得","75","expn","超","少","通过","哪里","_","假设","np","原因","/","实现","超过","第二列",":","它","50","none","第","因此","标准","混","54","值非","值","必须","转换","相同","以下","ndim","or","62","段","下","所有","64","整数","实际","type","（"],"title":"6.2.索引","title_tokens":["6.2",".","索引"]},{"location":"numpy笔记/6.2.索引.html#_1","text":"一维数组的索引和列表相同。假设 a1 是一维数组，那么有以下5种使用索引的情况： 可以指定一个 整数 i 作为索引下标，如 a1[i] 。 可以指定一个 切片 作为索引下标，如 a1[i:j] ，等价于 a1[slice(j,j)] 。 可以指定一个 整数list 对数组进行存取，如 a1[[i1,i2,i3]] 。此时会将列表中的每个整数作为下标 (i1/i2/i3) ，使用列表作为下标得到的数组为 np.array([a1[i1],a1[i2],a1[i3]]) ，它不和原始数组共享内存。 可以指定一个 整数数组 作为数组下标，如 a1[a2] 此时会得到一个形状和下标数组 a2 相同的新数组。新数组的每个元素都是下标数组中对应位置的值作为下标从原始数组中获得的值。新数组不和原始数组共享数据。 可以指定一个 布尔数组 作为数组下标，如a1[b]。此时将获得数组a1中与数组b中的True对应的元素。新数组不和原始数组共享数据。 # 指定一个整数 a [ 1 ] # OWNDATA : True ## 等价于 a [( 1 )] # OWNDATA : True # 指定切片 a [ 0 : 20 : 2 ] # 返回视图 a [ slice ( 0 , 20 , 2 )] # 返回视图 # 指定一个整数列表 a [[ 1 , 2 , 3 , 4 ]] # OWNDATA : True # 指定一个整数数组 ## index是一维数组 index = np . array ([ 0 , 1 , 2 , 3 , 4 ]) a [ index ] # OWNDATA : True ## index是二维数组 index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) a [ index ] # OWNDATA : True # 指定一个布尔数组 ## 布尔数组的ndim需要和原数组相同 bool_a = a > 50 bool_a = list ( bool_a )","text_tokens":["需要","对应","不","是","原","形状","从","每个","=","作为",")","存取",".","数据","b","指定","2","。","1","##","]","与","列表","，","切片","内存","有","一个","为","index","a2","i1","会","true","使用","20","于","等价","二维","0",">","bool","owndata","获得","视图","都","：","对","得到","i","那么","#","位置","3","array","list","_","共享","假设","情况","的","可以","将","np","/","a","原始",":","4","j","索引","返回","种","它"," ","共享内存","元素","50","一维","下标","slice","a1","数组","[","值","i2","进行","新","5","相同","以下","ndim","i3","布尔",",","和","如","此时","(","整数","中"],"title":"一维数组的索引","title_tokens":["数组","索引","一维","的"]},{"location":"numpy笔记/6.2.索引.html#_2","text":"多维数组使用 元组 作为数组的下标，如 a[1,2] ，当然你也可以添加圆括号为 a[(1,2)] 。实际上，一维数组也是如此，只是一维数组只有第 0 轴。 下标元组 中每个元素和数组的每个轴对应。下标元组的第 0 个元素对应数组第 0 轴，第 1 个元素对应数组第 1 轴，第 2 个元素对应数组第 2 轴··· 多维数组的下标必须是一个长度和数组的维度ndim相等的元组。 如果下标元组的长度大于数组的维度ndim，则IndexError 如果下标元组的长度小于数组的维度ndim，则自动在元组的后面补 : ，使得下标元组的长度等于数组维度ndim。 如果下标对象不是元组，则Numpy会首先将其转换为元组。 有以下7种使用索引的情况： 整数元组 切片 整数元组搭配切片 整数list 整数数组 布尔数组 整数数组、切片、整数元组混搭 # 指定一个整数元组 b [( 1 , 2 )] # OWNDATA : Trues ## 等价于 b [ 1 , 2 ] # OWNDATA : Trues ## 元组的维度超过多维数组的维度:IndexError ''' b[(1,2,3)] ''' ## 元组的维度超少于维数组的维度 b [ 1 ] # 返回视图 等价于 b[1,:] # 切片 b [ 0 , 0 : 5 : 2 ] # 返回视图 b [ 0 , 0 :: 2 ] # 返回视图 b [ 0 , slice ( 0 , None , 2 )] # 返回视图 ## SyntaxError b[0,slice(0,,2)] b [ 0 : 10 : 2 , 0 : 5 : 2 ] # 返回视图 ## 第二列 b [:, 1 ] # 返回视图 b [ ... , 1 ] # 返回视图 ## IndexError: an index can only have a single ellipsis ('...') ''' b[...,...] IndexError ''' b [ ... ,:] # 返回视图 b [:,:] # 返回视图 # 整数数组 ## arrays used as indices must be of integer (or boolean) type index = np . array ([ 0 , 1 , 2 , 3 ]) b [ index ] # OWNDATA : True index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) b [ index ] # OWNDATA : True ## 如果下标整数数组的维度不一致，会进行广播 rows = np . array ([[ 0 , 1 , 2 ]]) columns = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 4 ]]) index = ( rows , columns ) b [ index ] array([[ 0, 6, 12], [ 3, 9, 14]]) 多维数组的下标是布尔数组或者下标元组中包含了布尔数组，则相当于将布尔数组通过 np.nonzero() 将布尔数组转换成一个整数数组的元组，然后使用整数数组进行下标运行。 np.nonzero(a) 返回数组 a 中，值非零的元素的 下标 。它返回值是一个长度为 a.ndim 的元组，元组的每个元素都是一个一维的整数数组，其值为非零元素的下标在对应轴上的值。如：第 0 个元素为a中的非零值元素在0轴的下标、第 1 个元素为a中的非零值元素在1轴的下标... np . nonzero ( bool_a ) (array([51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], dtype=int64),)","text_tokens":["相等","51","74","对应","不","是","然后","96","52","be","每个","=","9","作为",")","57","其值","92",".","等于","b","少于","88","2","指定","添加","了","在","相当于","indexerror","二列","97","。","1","##","自动","95","]","boolean","轴上","65","切片","，","81","有","当然","一致","一个","columns","搭","dtype","'","当于","55","为","trues","使得","index","包含","86","第二","63","后面","...","56","int64","会","相当","true","single","12","实际上","维度","首先","元组","使用","rows","非零值","59","于","转换成","53","或者","等价","67","78","6","不是","其","0","换成","bool","owndata","、","71","an","视图","only","都","：","must","integer","72","83","对象","运行","as","#","61","89","也","3","多维","补","array","99","nonzero","75","超","只有","91","圆括号","小于","list","通过","则","7","of","情况","_","的","可以","将","维","np","79","93","a","只是","超过","82","第二列",":","4","索引","76","返回","syntaxerror","70","种","58","98","66","它","ellipsis","have","can"," ","indices","68","94","元素","77","长度","69","括号","返回值","87","arrays","一维","下标","slice","73","数组","none","第","你","[","80","混","54","90","值非","85","必须","非","值","转换","84","如果","60","搭配","used","进行","5","个","·","如此","ndim","numpy","以下","or","62","布尔",",","和","如","(","64","实际","轴","整数","14","10","中","type","零","大于","广播"],"title":"多维数组的索引","title_tokens":["数组","的","多维","索引"]},{"location":"numpy笔记/6.2.索引.html#_3","text":"使用切片返回视图的原因： 当下标使用切片时，所取得的数据在数据存储区域中是等间隔分布的。因为只需要修改数组的ndim/shape/strides等属性以及指向数据存储区域的data指针就能够实现整数和切片下标的索引。所以新数组和原始数组能够共享数据存储区域。 当使用整数数组（整数元组，整数列表页转换成整数数组），布尔数组时，不能保证所取得的数据在数据存储区中是等间隔的，因此无法和原始数组共享数据，只能对数据进行复制。 通过整数元组获取的数组元素的类型为数组的dtype类型 。如果你想获取标准python类型，可以使用数组的item()方法。","text_tokens":["需要","分布","保证","是","方法","获取",")","当下","数据","当","在","存储","无法","。","复制","切片","，","列表","就","能够","dtype","为","想","修改","元组","使用","python","转换成","只能","以及","换成","视图","：","对","只","不能","所以","因为","取得","区中","区域","通过","共享","的","原因","时","可以","item","/","实现","类型","原始","指针","data","索引","返回","中是","shape"," ","元素","）","标的","strides","页","指向","数组","因此","你","等","标准","属性","标","转换","如果","新","进行","ndim","间隔","所","布尔","和","下","(","整数","（"],"title":"进阶说明","title_tokens":["说明","进阶"]},{"location":"numpy笔记/6.2.索引.html#_4","text":"索引的下标元组中： 如果下标元组都是切片，则索引结果的数组与原始数组的维度相同（轴的数量相等） 每多一个整数下标，则索引结果的数组就少一个维度（少一个轴） 如果所有的下标都是整数，则索引结果的维度为 0 如果下标元组中存在数组，则还需要考虑该下标数组广播后的维度 多维数组的下标必须是一个长度和数组的维度 ndim 相等的元组。但是如果下标中包含None，则可以突破这一限制。每多一个None，则索引结构维度升 1 。 当数组的下标元组的长度小于等于数组的维度ndim时，元组中出现的None等价于切片: 当数组的下标元组的长度大于数组的维度ndim时，元组中哪里出现None，索引结果就在哪里创建一个新轴，该轴长度为 1。 b [ 1 , 2 ] b [ 1 , 2 , None ] b [ 1 , 2 , np . newaxis ] array([7])","text_tokens":["相等","需要","出现","是",")",".","每多","等于","b","这一","2","当","在","。","1","]","与","切片","，","就","一个","后","为","包含","考虑","维度","元组","数量","于","等价","该","0","（","都","：","中","但是","多维","array","还","结果","少","小于","哪里","则","7","的","可以","时","np","存在","创建","原始",":","索引","新轴"," ","newaxis","突破","）","长度","结构","下标","数组","none","升","[","必须","限制","如果","相同","ndim",",","和","所有","(","整数","轴","大于","广播"],"title":"索引的维度变换","title_tokens":["的","变换","索引","维度"]},{"location":"numpy笔记/6.3.内存布局.html","text":"import numpy as np import pprint import copy ndarray对象 NumPy提供了一个N维数组对象ndarray，它描述了同一类型的元素的集合。可以使用N个整数对元素进行索引。 ndarray中所有元素都是 同质的 ：每个元素占用相同大小的内存块，并且所有内存块的解释方式完全相同。数组中各元素的解释方式由一个的 data-type 对象（dtype）指定。 图中显示了用于描述数组中数据的三个基本对象之间的关系： ndarray本身 描述数组中单个固定大小元素的内存布局的data-type对象 访问数组的单个元素时返回的数组标量（Python对象） ndarray类的实例由一个 连续的 一维计算机内存块（由数组或其他对象拥有）和一个索引方案组合而成，该索引方案将N个整数分别映射到内存块中N个元素的位置。索引可以变化的范围被数组的shape限制。 ndarray看上去似乎可以是多维的，但在内存中，ndarray是一维储存的。有许多方案将N维数组以一维数组的形式储存在内存中。其中numpy有两种储存方式： 元素按行顺序储存（C语言风格） 或者按列顺序储存（Fortran语言风格） 因此，如果要对一个ndarray以行为单位进行操作，最好以C-type的方式创建ndarray；如果要对一个ndarray以列为单位进行操作，则用Fortran方式。 内存布局 A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) pprint . pprint ( A ) array([[0, 1, 2], [3, 4, 5], [6, 7, 8]], dtype=int16) 属性（与数组内存布局有关） A的属性值 描述 A.dtype dtype('int16') 元素数据类型。A的每个元素是16bit大小的int型数据。 A.ndim 2 轴（维度）的个数。A有两个轴：0轴、1轴。 A.shape (3, 3) 各个轴的大小。0轴有3个元素，1轴有3个元素。 A.size 9 数组的大小，有多少个元素。 A.data <memory at 0x000001B17A238A68> 指向数组的数据的存储区。 A.itemsize 2 一个元素的长度，以字节为单位。16bit等于2字节。 A.nbytes 18 数组元素占据的总字节数。 A.base None 如果内存来自其他对象，则以此为基础对象。 A.flags 有关数组内存布局的信息。 A.strides (6, 2) 一个整数元组，每个元素保存着每个轴上相邻两个元素的地址差。 即当某个轴的下标增加1 时，数据存储区中的指针增加的字节数。 可以从不同的角度(即布局)观察该array： shape [ 1 ] ( = 3 ) ┌───────────┐ ┌ ┌───┬───┬───┐ ┐ │ │ 0 │ 1 │ 2 │ │ │ ├───┼───┼───┤ │ shape [ 0 ] │ │ 3 │ 4 │ 5 │ │ len ( Z ) ( = 3 ) │ ├───┼───┼───┤ │ ( = 3 ) │ │ 6 │ 7 │ 8 │ │ └ └───┴───┴───┘ ┘ 展开的item layout ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ └───┴───┴───┴───┴───┴───┴───┴───┴───┘ └───────────────────────────────────┘ A . size ( = 9 ) 内存布局(C顺序) strides [ 1 ] ( = 2 ) ┌─────────────────────┐ ┌ ┌──────────┬──────────┐ ┐ │ p + 00 : │ 00000000 │ 00000000 │ │ │ ├──────────┼──────────┤ │ │ p + 02 : │ 00000000 │ 00000001 │ │ strides [ 0 ] │ ├──────────┼──────────┤ │ ( = 2 x3 ) │ p + 04 │ 00000000 │ 00000010 │ │ │ ├──────────┼──────────┤ ┘ │ p + 06 │ 00000000 │ 00000011 │ │ ├──────────┼──────────┤ A . nbytes │ p + 08 : │ 00000000 │ 00000100 │ ( = 3 x3x2 ) │ ├──────────┼──────────┤ │ p + 10 : │ 00000000 │ 00000101 │ │ ├──────────┼──────────┤ │ p + 12 : │ 00000000 │ 00000110 │ │ ├──────────┼──────────┤ │ p + 14 : │ 00000000 │ 00000111 │ │ ├──────────┼──────────┤ │ p + 16 : │ 00000000 │ 00001000 │ └ └──────────┴──────────┘ └─────────────────────┘ A . itemsize A . dtype . itemsize ( = 2 ) 如果我们现在取一A的切片，结果是A的基本数组的一个视图： V = A[::2,::2] 这样的视图是由shape，dtype 和 strides 指定的，因为仅凭dtype和shape不能推断出strides: 如果我们现在取一A的切片，结果是A的基本数组的一个视图： V = A[::2,::2] 这样的视图是由shape，dtype 和 strides 指定的，因为仅凭dtype和shape不能推断出strides: Item layout shape [ 1 ] ( = 2 ) ┌───────────┐ ┌ ┌───┬───┬───┐ ┐ │ │ 0 │ │ 2 │ │ ┌───┬───┐ │ ├───┼───┼───┤ │ | 0 │ 2 │ shape [ 0 ] │ │ │ │ │ │ len ( A ) → ├───┼───┤ ( = 2 ) │ ├───┼───┼───┤ │ ( = 2 ) | 6 │ 8 │ │ │ 6 │ │ 8 │ │ └───┴───┘ └ └───┴───┴───┘ ┘ 展开的item layout ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐ ┌───┬───┬───┬───┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ → │ 0 │ 2 │ 6 │ 8 │ └───┴───┴───┴───┴───┴───┴───┴───┴───┘ └───┴───┴───┴───┘ └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘ └───┬───┘ └───┬───┘ └───────────┬───────────┘ A.size (=4) 内存布局(C顺序，大端序) ┌ ┌──────────┬──────────┐ ┐ ┐ ┌─┤ p + 00 : │ 00000000 │ 00000000 │ │ │ │ └ ├──────────┼──────────┤ │ strides [ 1 ] │ ┌─┤ p + 02 : │ │ │ │ ( = 4 ) │ │ │ ┌ ├──────────┼──────────┤ ┘ │ │ └─┤ p + 04 │ 00000000 │ 00000010 │ │ │ └ ├──────────┼──────────┤ │ strides [ 0 ] │ p + 06 : │ │ │ │ ( = 12 ) │ ├──────────┼──────────┤ │ A . nbytes ─┤ p + 08 : │ │ │ │ ( = 8 ) │ ├──────────┼──────────┤ │ │ p + 10 : │ │ │ │ │ ┌ ├──────────┼──────────┤ ┘ │ ┌─┤ p + 12 : │ 00000000 │ 00000110 │ │ │ └ ├──────────┼──────────┤ └─┤ p + 14 : │ │ │ │ ┌ ├──────────┼──────────┤ └─┤ p + 16 : │ 00000000 │ 00001000 │ └ └──────────┴──────────┘ └─────────────────────┘ A . itemsize A . dtype . itemsize ( = 2 ) 可以直接修改 ndarray 对象的 strides 属性，改变 ndarray 的内存布局，但此时会修改原数组。 A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) A . strides = ( 2 , 4 ) pprint . pprint ( A ) array([[0, 2, 4], [1, 3, 5], [2, 4, 6]], dtype=int16) 视图和副本 视图和副本是优化数值计算的重要概念。 在numpy中，可以用切片和 花式索引 （整数数组索引）来索引数据。切片将始终返回视图，而整数数组索引将返回一个副本。这种差异很重要，因为在切片情况下，修改视图会修改原数组，而在整数数组索引情况下则不是这样： Z = np . zeros ( 9 ) Z_view = Z [: 3 ] Z_view [ ... ] = 1 print ( Z ) [1. 1. 1. 0. 0. 0. 0. 0. 0.] Z = np . zeros ( 9 ) Z_copy = Z [[ 0 , 1 , 2 ]] Z_copy [ ... ] = 1 print ( Z ) [0. 0. 0. 0. 0. 0. 0. 0. 0.] 因此，如果你需要反复用到某个花式索引，最好保留它的副本（特别是如果计算它很复杂）。如果您不确定索引的结果是视图还是副本，则可以检查base的结果。如果是None，那么结果就是副本： Z = np . random . uniform ( 0 , 1 ,( 5 , 5 )) Z1 = Z [: 3 ,:] Z2 = Z [[ 0 , 1 , 2 ], :] print ( np . allclose ( Z1 , Z2 )) True print ( Z1 . base is Z ) True print ( Z2 . base is Z ) False print ( Z2 . base is None ) True 请注意，一些numpy函数在可能的情况下返回视图(例如， ravel )，而另一些函数总是返回副本(例如， flatten ): Z = np . zeros (( 5 , 5 )) print ( Z . ravel () . base is Z ) True print ( Z [:: 2 ,:: 2 ] . ravel () . base is Z ) False print ( Z . flatten () . base is Z ) False 可以通过 ndarray.view() 方法，从同一块内存区（储存着numpy数组的内存区）创建不同的dtype数组。 即用不同的数值类型查看同一段内存中的二进制数据。 它们使用的是同一块内存。 实际上， ndarray.view() 方法是创建了一个视图。 A = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ],[ 6 , 7 , 8 ]]) A_view = A . view ( np . int32 ) # A_view 是视图 A_view . flags C_CONTIGUOUS : True F_CONTIGUOUS : False OWNDATA : False WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False 如果我们直接修改原始数组的 dtype ，会达到同样的效果， 但此时直接修改原始数组。 A . dtype = np . float32 Caution 通常应避免改变由切片、transposes、fortran排序等定义的数组的 dtype 的大小，如下： A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) A_view = A . view ( np . int32 ) ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-7b8b7375e3ff> in <module> 1 A = copy.deepcopy(np.arange(9, dtype=np.int16).reshape(3,3)) ----> 2 A_view = A.view(np.int32) ValueError: When changing to a larger dtype, its size must be a divisor of the total size in bytes of the last axis of the array.","text_tokens":["06","原","┤","the","c语言","等于","00000100","了","占用","三个","存储","]","但","轴上","larger","可能","这样","语言","为","同一","12","实际上","使用","-","其他","保存","6","reshape","该","完全",">","owndata","、","视图","最好","对","aligned","许多","您","着","#","位置","还是","3","它们","00000111","达到","因为","04","观察","结果","+","两种","n","to","各个","7","另","计算机","块内存","item","a","创建","占据","同质","指针","data","4","→","索引","返回","size","区","同","fortran","元素","00000110","）","现在","长度","00000001","axis","看上","固定","指向","数组","花式","[","复杂","pprint","下则","限制","ravel","00000011","到","个","ipython","以此","arange",",","此时","本身","推断出","列为","仅凭","从","请","每个","9","deepcopy","避免","数据","module","单位","float32","00","2","z2","排序","组合","recent","ndarray","确定","集合","有关","，","看上去","型","定义","相邻","有","某个","一个","优化","节数","─","18","进制","数据类型","修改","view","维度","7b8b7375e3ff","或者","base","call","解释","uniform","用到","：","must","p","x3x2","int","不能","改变","信息","情况","时","可以","将","memory","行为","│","大端","most","显示","描述","原始","提供","始终","直接","allclose","00000000","重要","valueerror","拥有","范围","┐","例如","查看","c","int16","并且","你","要","等","属性","我们","len","储存","nbytes","按行","进行","5","numpy","contiguous","访问","in","16bit","轴","0x000001b17a238a68","中","需要","is","不","总是","是","|","之间","差异","=","last","差","8","一些","f","┬","二进制","个数","实例","1","bytes","分别","┴","切片","总","用","按列","一段","由","z","或","copy","推断","形式","映射","会","writeable","图中","true","┌","组合而成","python","不是","基本","16","连续","都","00000010","as","其中","多维","方案","区中","变化","大小","writebackifcopy","00001000","divisor","被","似乎","则","of","的","维","注意","展开","类型","顺序","而","flags","这种","shape"," ","布局","轴有","增加","字节数","一维","以","下标","strides","zeros","└","input","；","false","┘","各","即用","多少","如果","角度","和","基础","(","大端序","14","<","10","08","不同","import","方法","标量","就是","be",")",".","指定","来","updateifcopy","在","操作","print","random","。","z1","与","layout","内存","itemsize","单个","dtype","'","字节","很","效果","副本","...","关系","即","元组","取一","来自","用于","0","块","反复","上去","数值","对象","方式","那么","类","地址","array","如下","保留","风格","特别","v","transposes","通过","_","when","changing","x3","np","函数","flatten","同样","its",":","00000101","完全相同","它","├","即当","检查","算机","计算","概念","at","┼","none","因此","traceback","int32","应","两个","值","02","相同","ndim","下","通常","所有","整数","实际","caution","type","（","total"],"title":"6.3.内存布局","title_tokens":[".","布局","6.3","内存"]},{"location":"numpy笔记/6.3.内存布局.html#ndarray","text":"NumPy提供了一个N维数组对象ndarray，它描述了同一类型的元素的集合。可以使用N个整数对元素进行索引。 ndarray中所有元素都是 同质的 ：每个元素占用相同大小的内存块，并且所有内存块的解释方式完全相同。数组中各元素的解释方式由一个的 data-type 对象（dtype）指定。 图中显示了用于描述数组中数据的三个基本对象之间的关系： ndarray本身 描述数组中单个固定大小元素的内存布局的data-type对象 访问数组的单个元素时返回的数组标量（Python对象） ndarray类的实例由一个 连续的 一维计算机内存块（由数组或其他对象拥有）和一个索引方案组合而成，该索引方案将N个整数分别映射到内存块中N个元素的位置。索引可以变化的范围被数组的shape限制。 ndarray看上去似乎可以是多维的，但在内存中，ndarray是一维储存的。有许多方案将N维数组以一维数组的形式储存在内存中。其中numpy有两种储存方式： 元素按行顺序储存（C语言风格） 或者按列顺序储存（Fortran语言风格） 因此，如果要对一个ndarray以行为单位进行操作，最好以C-type的方式创建ndarray；如果要对一个ndarray以列为单位进行操作，则用Fortran方式。","text_tokens":["列为","是","之间","标量","每个","c语言","数据","单位","指定","了","占用","三个","在","操作","组合","。","实例","ndarray","集合","但","分别","，","看上去","内存","有","用","一个","单个","按列","dtype","语言","由","或","同一","形式","映射","图中","关系","使用","组合而成","-","python","用于","或者","其他","该","完全","块","基本","解释","上去","连续","都","最好","对","：","对象","方式","许多","其中","类","位置","多维","方案","风格","变化","大小","两种","n","被","似乎","则","计算机","的","可以","时","维","将","行为","显示","创建","类型","描述","同质","data","提供","索引","顺序","返回","完全相同","它","shape"," ","fortran","布局","元素","算机","拥有","计算","范围","）","一维","以","看上","固定","c","数组","并且","因此","要","；","各","限制","如果","储存","按行","进行","相同","numpy","个","访问","到","和","所有","整数","本身","中","type","（"],"title":"ndarray对象","title_tokens":["对象","ndarray"]},{"location":"numpy笔记/6.3.内存布局.html#_1","text":"A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) pprint . pprint ( A ) array([[0, 1, 2], [3, 4, 5], [6, 7, 8]], dtype=int16) 属性（与数组内存布局有关） A的属性值 描述 A.dtype dtype('int16') 元素数据类型。A的每个元素是16bit大小的int型数据。 A.ndim 2 轴（维度）的个数。A有两个轴：0轴、1轴。 A.shape (3, 3) 各个轴的大小。0轴有3个元素，1轴有3个元素。 A.size 9 数组的大小，有多少个元素。 A.data <memory at 0x000001B17A238A68> 指向数组的数据的存储区。 A.itemsize 2 一个元素的长度，以字节为单位。16bit等于2字节。 A.nbytes 18 数组元素占据的总字节数。 A.base None 如果内存来自其他对象，则以此为基础对象。 A.flags 有关数组内存布局的信息。 A.strides (6, 2) 一个整数元组，每个元素保存着每个轴上相邻两个元素的地址差。 即当某个轴的下标增加1 时，数据存储区中的指针增加的字节数。 可以从不同的角度(即布局)观察该array： shape [ 1 ] ( = 3 ) ┌───────────┐ ┌ ┌───┬───┬───┐ ┐ │ │ 0 │ 1 │ 2 │ │ │ ├───┼───┼───┤ │ shape [ 0 ] │ │ 3 │ 4 │ 5 │ │ len ( Z ) ( = 3 ) │ ├───┼───┼───┤ │ ( = 3 ) │ │ 6 │ 7 │ 8 │ │ └ └───┴───┴───┘ ┘ 展开的item layout ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ └───┴───┴───┴───┴───┴───┴───┴───┴───┘ └───────────────────────────────────┘ A . size ( = 9 ) 内存布局(C顺序) strides [ 1 ] ( = 2 ) ┌─────────────────────┐ ┌ ┌──────────┬──────────┐ ┐ │ p + 00 : │ 00000000 │ 00000000 │ │ │ ├──────────┼──────────┤ │ │ p + 02 : │ 00000000 │ 00000001 │ │ strides [ 0 ] │ ├──────────┼──────────┤ │ ( = 2 x3 ) │ p + 04 │ 00000000 │ 00000010 │ │ │ ├──────────┼──────────┤ ┘ │ p + 06 │ 00000000 │ 00000011 │ │ ├──────────┼──────────┤ A . nbytes │ p + 08 : │ 00000000 │ 00000100 │ ( = 3 x3x2 ) │ ├──────────┼──────────┤ │ p + 10 : │ 00000000 │ 00000101 │ │ ├──────────┼──────────┤ │ p + 12 : │ 00000000 │ 00000110 │ │ ├──────────┼──────────┤ │ p + 14 : │ 00000000 │ 00000111 │ │ ├──────────┼──────────┤ │ p + 16 : │ 00000000 │ 00001000 │ └ └──────────┴──────────┘ └─────────────────────┘ A . itemsize A . dtype . itemsize ( = 2 ) 如果我们现在取一A的切片，结果是A的基本数组的一个视图： V = A[::2,::2] 这样的视图是由shape，dtype 和 strides 指定的，因为仅凭dtype和shape不能推断出strides: 如果我们现在取一A的切片，结果是A的基本数组的一个视图： V = A[::2,::2] 这样的视图是由shape，dtype 和 strides 指定的，因为仅凭dtype和shape不能推断出strides: Item layout shape [ 1 ] ( = 2 ) ┌───────────┐ ┌ ┌───┬───┬───┐ ┐ │ │ 0 │ │ 2 │ │ ┌───┬───┐ │ ├───┼───┼───┤ │ | 0 │ 2 │ shape [ 0 ] │ │ │ │ │ │ len ( A ) → ├───┼───┤ ( = 2 ) │ ├───┼───┼───┤ │ ( = 2 ) | 6 │ 8 │ │ │ 6 │ │ 8 │ │ └───┴───┘ └ └───┴───┴───┘ ┘ 展开的item layout ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐ ┌───┬───┬───┬───┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ → │ 0 │ 2 │ 6 │ 8 │ └───┴───┴───┴───┴───┴───┴───┴───┴───┘ └───┴───┴───┴───┘ └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘ └───┬───┘ └───┬───┘ └───────────┬───────────┘ A.size (=4) 内存布局(C顺序，大端序) ┌ ┌──────────┬──────────┐ ┐ ┐ ┌─┤ p + 00 : │ 00000000 │ 00000000 │ │ │ │ └ ├──────────┼──────────┤ │ strides [ 1 ] │ ┌─┤ p + 02 : │ │ │ │ ( = 4 ) │ │ │ ┌ ├──────────┼──────────┤ ┘ │ │ └─┤ p + 04 │ 00000000 │ 00000010 │ │ │ └ ├──────────┼──────────┤ │ strides [ 0 ] │ p + 06 : │ │ │ │ ( = 12 ) │ ├──────────┼──────────┤ │ A . nbytes ─┤ p + 08 : │ │ │ │ ( = 8 ) │ ├──────────┼──────────┤ │ │ p + 10 : │ │ │ │ │ ┌ ├──────────┼──────────┤ ┘ │ ┌─┤ p + 12 : │ 00000000 │ 00000110 │ │ │ └ ├──────────┼──────────┤ └─┤ p + 14 : │ │ │ │ ┌ ├──────────┼──────────┤ └─┤ p + 16 : │ 00000000 │ 00001000 │ └ └──────────┴──────────┘ └─────────────────────┘ A . itemsize A . dtype . itemsize ( = 2 ) 可以直接修改 ndarray 对象的 strides 属性，改变 ndarray 的内存布局，但此时会修改原数组。 A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) A . strides = ( 2 , 4 ) pprint . pprint ( A ) array([[0, 2, 4], [1, 3, 5], [2, 4, 6]], dtype=int16)","text_tokens":["08","不同","仅凭","06","是","|","原","┤","从","每个","=","9",")","差","deepcopy","8",".","数据","单位","等于","00000100","00","2","指定","┬","个数","存储","。","1","ndarray","]","有关","与","但","轴上","┴","layout","，","切片","型","内存","itemsize","总","相邻","有","某个","一个","dtype","'","这样","字节","为","z","由","copy","节数","推断","─","18","会","数据类型","修改","12","维度","即","元组","┌","取一","来自","其他","保存","6","reshape","该",">","0","base","基本","、","16","视图","00000010","：","p","x3x2","int","对象","着","不能","3","地址","array","00000111","因为","04","区中","v","观察","结果","大小","+","00001000","改变","各个","7","则","信息","x3","np","的","时","可以","memory","│","item","a","大端","展开","类型","占据","描述","指针","data","4",":","→","顺序","00000101","size","区","flags","直接","├","shape","即当"," ","00000000","布局","元素","轴有","00000110","增加","）","现在","长度","┐","00000001","字节数","at","┼","以","下标","strides","c","指向","int16","数组","none","└","[","pprint","两个","┘","属性","值","我们","多少","如果","len","00000011","02","nbytes","5","个","角度","ndim","以此","arange",",","和","基础","此时","(","大端序","整数","14","<","16bit","10","轴","0x000001b17a238a68","推断出","（"],"title":"内存布局","title_tokens":["布局","内存"]},{"location":"numpy笔记/6.3.内存布局.html#_2","text":"视图和副本是优化数值计算的重要概念。 在numpy中，可以用切片和 花式索引 （整数数组索引）来索引数据。切片将始终返回视图，而整数数组索引将返回一个副本。这种差异很重要，因为在切片情况下，修改视图会修改原数组，而在整数数组索引情况下则不是这样： Z = np . zeros ( 9 ) Z_view = Z [: 3 ] Z_view [ ... ] = 1 print ( Z ) [1. 1. 1. 0. 0. 0. 0. 0. 0.] Z = np . zeros ( 9 ) Z_copy = Z [[ 0 , 1 , 2 ]] Z_copy [ ... ] = 1 print ( Z ) [0. 0. 0. 0. 0. 0. 0. 0. 0.] 因此，如果你需要反复用到某个花式索引，最好保留它的副本（特别是如果计算它很复杂）。如果您不确定索引的结果是视图还是副本，则可以检查base的结果。如果是None，那么结果就是副本： Z = np . random . uniform ( 0 , 1 ,( 5 , 5 )) Z1 = Z [: 3 ,:] Z2 = Z [[ 0 , 1 , 2 ], :] print ( np . allclose ( Z1 , Z2 )) True print ( Z1 . base is Z ) True print ( Z2 . base is Z ) False print ( Z2 . base is None ) True 请注意，一些numpy函数在可能的情况下返回视图(例如， ravel )，而另一些函数总是返回副本(例如， flatten ): Z = np . zeros (( 5 , 5 )) print ( Z . ravel () . base is Z ) True print ( Z [:: 2 ,:: 2 ] . ravel () . base is Z ) False print ( Z . flatten () . base is Z ) False 可以通过 ndarray.view() 方法，从同一块内存区（储存着numpy数组的内存区）创建不同的dtype数组。 即用不同的数值类型查看同一段内存中的二进制数据。 它们使用的是同一块内存。 实际上， ndarray.view() 方法是创建了一个视图。 A = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ],[ 6 , 7 , 8 ]]) A_view = A . view ( np . int32 ) # A_view 是视图 A_view . flags C_CONTIGUOUS : True F_CONTIGUOUS : False OWNDATA : False WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False 如果我们直接修改原始数组的 dtype ，会达到同样的效果， 但此时直接修改原始数组。 A . dtype = np . float32 Caution 通常应避免改变由切片、transposes、fortran排序等定义的数组的 dtype 的大小，如下： A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) A_view = A . view ( np . int32 ) ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-7b8b7375e3ff> in <module> 1 A = copy.deepcopy(np.arange(9, dtype=np.int16).reshape(3,3)) ----> 2 A_view = A.view(np.int32) ValueError: When changing to a larger dtype, its size must be a divisor of the total size in bytes of the last axis of the array.","text_tokens":["需要","不同","is","不","总是","是","方法","原","caution","就是","从","be","差异","the","请","=","9","last",")","deepcopy","8","一些","避免","数据",".","f","module","float32","2","来","z2","二进制","了","updateifcopy","在","排序","print","recent","random","。","1","ndarray","bytes","确定","]","z1","但","切片","，","内存","larger","定义","某个","用","一个","可能","优化","dtype","这样","一段","很","z","由","效果","copy","同一","副本","...","writeable","会","进制","修改","view","true","实际上","使用","-","7b8b7375e3ff","6","reshape","不是","0",">","反复","base","owndata","、","call","uniform","数值","视图","用到","最好","：","must","aligned","那么","您","着","#","还是","3","array","如下","它们","保留","特别","达到","因为","结果","writebackifcopy","大小","divisor","transposes","通过","to","改变","_","则","另","情况","7","块内存","when","of","changing","的","可以","将","np","函数","a","most","flatten","注意","创建","类型","原始","同样","its",":","4","始终","索引","而","返回","区","flags","size","allclose","直接","这种","它","同"," ","fortran","检查","重要","valueerror","计算","）","概念","axis","例如","查看","c","数组","zeros","none","花式","int16","因此","你","traceback","int32","[","复杂","应","input","等","false","下则","即用","我们","如果","ravel","储存","5","numpy","contiguous","ipython","in","arange",",","和","下","此时","通常","(","整数","实际","<","中","（","total"],"title":"视图和副本","title_tokens":["视图","副本","和"]},{"location":"numpy笔记/6.4.广播.html","text":"广播 当使用ufunc函数对两个数组进行计算时，ufunc函数会对这两个数组的对应元素进行计算。这要求这两个数组的形状相同。如果这两个数组的形状不同，就通过广播broadcasting进行处理： 首先让所有输入数组都向其中维度最高的数组看齐。看齐方式为：在shape属性的左侧插入数字1 最后输出数组的shape属性是输入数组的shape属性的各轴上的最大值 如果输入数组的某个轴的长度为 1，或者与输出数组的各对应轴的长度相同，该数组能正确广播。否则计算出错 当输入数组的某个轴的长度为 1时，沿着此轴运算时都用此轴上的第一组值。 \"\"\" numpy.broadcast_arrays() 查看广播之后的数组 np.broadcast_to(array, shape, subok=False) 将array广播为指定的shape，如果指定的shape不满足广播要求，则报错 ndarray.repeat(repeats, axis=None) 重复某个轴上的值. repeats为重复次数 axis指定被重复的轴，即沿着哪一轴重复。如果未指定，则将数组展平然后重复。返回的也是一个展平的数组 \"\"\" a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = np . arange ( 5 ) c = b [:, None ] d = np . ones (( 5 , 3 )) np . broadcast_arrays ( d , c ) [array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]), array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]])] np . broadcast_to ( b [:, None ], ( 5 , 2 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) a . repeat ( 3 , axis = 1 ) array([[0, 0, 0, 1, 1, 1], [2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5], [6, 6, 6, 7, 7, 7], [8, 8, 8, 9, 9, 9]]) 广播示意图 The code to produce the figures is part of the AstroML book","text_tokens":["不同","对应","最大值","意图","is","不","是","然后","大值","形状","the","此轴","=","让","9",")","这","deepcopy","8",".","b","正确","指定","2","当","哪一轴","在","示意图","ones","。","1","ndarray","向","]","数字","与","轴上","之后","，","就","插入","某个","用","一个","否则","为","copy","part","subok","ufunc","produce","\"","会","输入","首先","维度","即","使用","d","或者","最大","沿着","6","reshape","该","0","code","输出","最高","都","对","：","示意","方式","报错","其中","也","3","array","要求","处理","最后","repeat","一组","book","出错","通过","to","被","各轴上","_","则","7","of","的","时","np","将","函数","a","左侧","看齐","满足","figures",":","4","返回","未指定","shape"," ","展平","元素","计算","broadcasting","长度","broadcast","arrays","axis","第一组","查看","第一","repeats","重复","c","数组","none","次数","[","两个","astroml","false","各","属性","值","能","如果","进行","相同","numpy","5","运算","arange",",","所有","(","此轴上","10","轴","广播"],"title":"6.4.广播","title_tokens":[".","广播","6.4"]},{"location":"numpy笔记/6.4.广播.html#_1","text":"当使用ufunc函数对两个数组进行计算时，ufunc函数会对这两个数组的对应元素进行计算。这要求这两个数组的形状相同。如果这两个数组的形状不同，就通过广播broadcasting进行处理： 首先让所有输入数组都向其中维度最高的数组看齐。看齐方式为：在shape属性的左侧插入数字1 最后输出数组的shape属性是输入数组的shape属性的各轴上的最大值 如果输入数组的某个轴的长度为 1，或者与输出数组的各对应轴的长度相同，该数组能正确广播。否则计算出错 当输入数组的某个轴的长度为 1时，沿着此轴运算时都用此轴上的第一组值。 \"\"\" numpy.broadcast_arrays() 查看广播之后的数组 np.broadcast_to(array, shape, subok=False) 将array广播为指定的shape，如果指定的shape不满足广播要求，则报错 ndarray.repeat(repeats, axis=None) 重复某个轴上的值. repeats为重复次数 axis指定被重复的轴，即沿着哪一轴重复。如果未指定，则将数组展平然后重复。返回的也是一个展平的数组 \"\"\" a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = np . arange ( 5 ) c = b [:, None ] d = np . ones (( 5 , 3 )) np . broadcast_arrays ( d , c ) [array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]), array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]])] np . broadcast_to ( b [:, None ], ( 5 , 2 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) a . repeat ( 3 , axis = 1 ) array([[0, 0, 0, 1, 1, 1], [2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5], [6, 6, 6, 7, 7, 7], [8, 8, 8, 9, 9, 9]])","text_tokens":["不同","对应","最大值","不","是","然后","大值","形状","此轴","=","让","9",")","这","deepcopy","8",".","b","正确","指定","2","当","哪一轴","在","ones","。","1","ndarray","向","]","数字","与","轴上","之后","，","就","插入","某个","用","一个","否则","为","copy","subok","ufunc","\"","会","输入","首先","维度","即","使用","d","或者","最大","沿着","6","reshape","该","0","输出","最高","都","对","：","方式","报错","其中","也","3","array","要求","处理","最后","repeat","一组","出错","通过","to","被","各轴上","_","则","7","的","时","np","将","函数","a","左侧","看齐","满足",":","4","返回","未指定","shape"," ","展平","元素","计算","broadcasting","长度","broadcast","arrays","axis","第一组","查看","第一","repeats","重复","c","数组","none","次数","[","两个","false","各","属性","值","能","如果","进行","相同","numpy","5","运算","arange",",","所有","(","此轴上","10","轴","广播"],"title":"广播","title_tokens":["广播"]},{"location":"numpy笔记/6.4.广播.html#_2","text":"The code to produce the figures is part of the AstroML book","text_tokens":["produce","book","to","is","of","figures"," ","part","code","astroml","the"],"title":"广播示意图","title_tokens":["意图","示意图","广播","示意"]},{"location":"numpy笔记/6.5.常量.html","text":"import numpy as np NumPy定义了几个常量（都是IEEE 754 浮点表示）： （正）无穷大 # 使用`inf`是因为`Inf`、`Infinity`、`PINF`和`infty`是`inf`的别名。 np . inf np . Infinity np . PINF np . Inf np . infty inf 负无穷大 np . NINF -inf 非数字 NaN # `NaN`和`NAN`是`nan`的等价定义。请使用`nan而不是`NAN`。 np . nan np . NAN np . NaN nan 负零 np . NZERO -0.0 正零 np . PZERO 0.0 自然对数的基础，纳皮尔的常数 np . e 2.718281828459045 欧拉常数 γ = 0.5772156649015328606065120900824024310421... 参考 np . euler_gamma 0.5772156649015329 None的便捷别名 对索引数组很有用 np . newaxis 圆周率 np . pi 3.141592653589793","text_tokens":["0.5772156649015329","import","是","gamma","请","无穷大","=","对数","`",".","正","了","。","自然对数","euler","nzero","数字","nan","圆周率","，","γ","定义","常量","e","很","...","浮点","pzero","使用","常数","-","等价","别名","不是","自然","负零","是因为","、","都","：","对","pi","as","#","2.718281828459045","表示","ieee","3.141592653589793","因为","pinf","纳皮尔","_","0.0","np","的","负","无穷","索引","而","0.5772156649015328606065120900824024310421","便捷"," ","newaxis","欧拉","infty","）","infinity","inf","正零","数组","none","非","参考","ninf","numpy","754","圆周","几个","和","基础","有用","（"],"title":"6.5.常量","title_tokens":[".","6.5","常量"]},{"location":"numpy笔记/6.6.打印数组.html","text":"import numpy import numpy as np 打印数组 当打印ndarray时，numpy按照Python的嵌套list的格式打印输出，但是按照以下顺序打印： 最底层的axis按照从左到右的顺序输出 次底层的axis按照从上到下的顺序输出 其他层的axis也是按照从上到下的顺序输出，但是每个slice中间间隔一条空行 如： 一维的ndarray按行打印；二维的ndarray按照矩阵打印；三维的ndarray按照矩阵的list打印 如果ndarray太大，那么numpy默认跳过中间部分的数据而只是输出四个角落的数据。 要想任何时候都打印全部数据，可以在print(array)之前设置选项 numpy . set_printoptions ( threshold = None ) 这样后续的打印ndarray就不会省略中间数据。 np . set_printoptions ( threshold = 5 ) np . arange ( 200 ) array([ 0, 1, 2, ..., 197, 198, 199])","text_tokens":["import","是","中间","上到","打印输出","每个","=",")","数据",".","跳过","2","从上到下","层","当","在","print","。","1","三维","ndarray","]","，","就","时候","省略","这样","198","...","嵌套","想","格式","次","200","python","其他","之前","二维","0","全部","输出","底层","都","：","默认","空行","那么","但是","197","as","按照","也","array","部分","list","后续","_","的","时","np","可以","printoptions","只是","不会","set","顺序","而","矩阵"," ","从左到右","四个","任何","axis","一维","选项","slice","数组","none","要","[","；","设置","最底层","如果","角落","按行","threshold","5","numpy","以下","间隔","199","arange",",","如","(","太大","一条","打印"],"title":"6.6.打印数组","title_tokens":["6.6",".","数组","打印"]},{"location":"numpy笔记/6.6.打印数组.html#_1","text":"当打印ndarray时，numpy按照Python的嵌套list的格式打印输出，但是按照以下顺序打印： 最底层的axis按照从左到右的顺序输出 次底层的axis按照从上到下的顺序输出 其他层的axis也是按照从上到下的顺序输出，但是每个slice中间间隔一条空行 如： 一维的ndarray按行打印；二维的ndarray按照矩阵打印；三维的ndarray按照矩阵的list打印 如果ndarray太大，那么numpy默认跳过中间部分的数据而只是输出四个角落的数据。 要想任何时候都打印全部数据，可以在print(array)之前设置选项 numpy . set_printoptions ( threshold = None ) 这样后续的打印ndarray就不会省略中间数据。 np . set_printoptions ( threshold = 5 ) np . arange ( 200 ) array([ 0, 1, 2, ..., 197, 198, 199])","text_tokens":["是","中间","上到","打印输出","每个","=",")","数据",".","跳过","2","从上到下","层","当","在","print","。","1","三维","ndarray","]","，","就","时候","省略","这样","198","...","嵌套","想","格式","次","200","python","其他","之前","二维","0","全部","输出","底层","都","：","默认","空行","那么","但是","197","按照","也","array","部分","list","后续","_","的","时","可以","printoptions","np","只是","不会","set","顺序","而","矩阵"," ","从左到右","四个","任何","axis","一维","选项","slice","none","要","[","；","设置","最底层","如果","角落","按行","threshold","5","numpy","以下","间隔","199","arange",",","如","(","太大","一条","打印"],"title":"打印数组","title_tokens":["数组","打印"]},{"location":"numpy笔记/6.7.添加和删除.html","text":"import numpy as np 添加和删除数组元素 方法 描述 delete (arr, obj[, axis]) 沿指定轴删除指定的元素，返回未删除的数组 insert (arr, obj, values[, axis]) 沿指定轴在指定索引之前插入值 append (arr, values[, axis]) 将值附加到数组的末尾 trim_zeros s(filt[, trim]) 修剪一维数组或序列中的前导、尾随的零 unique (ar[, return_index, return_inverse, …]) 返回没有重复元素的数组 # append a = np . arange ( 4 ) . reshape (( 2 , 2 )) np . append ( a , [[ 1 , 2 ],[ 3 , 4 ]], axis = 0 ) array([[0, 1], [2, 3], [1, 2], [3, 4]]) # insert a = np . arange ( 4 ) . reshape (( 2 , 2 )) # obj 是索引 np . insert ( a , obj = 1 , values = [ 10 , 11 ], axis = 0 ) array([[ 0, 1], [10, 11], [ 2, 3]]) # delete 删除指定数据，返回未删除的数据 a = np . arange ( 4 ) . reshape (( 2 , 2 )) np . delete ( a , 1 , axis = 0 ) array([[0, 1]]) # 默认返回一维数组 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = False , axis = None ) array([1, 2, 3]) # 设置axis参数 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = False , axis = 0 ) array([[1, 2], [2, 3]]) # 同时返回unique数组元素在原数组中的索引index a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = True , return_inverse = False , return_counts = False , axis = 0 ) (array([[1, 2], [2, 3]]), array([0, 2], dtype=int64)) # 同时返回原数组元素在unique数组中的索引index # 可用于重建原数组 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = True , return_counts = False , axis = 0 ) (array([[1, 2], [2, 3]]), array([0, 0, 1], dtype=int64)) # 同时返回 计数 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = True , axis = 0 ) (array([[1, 2], [2, 3]]), array([2, 1], dtype=int64)) a = np . array ([ 0 , 0 , 1 , 2 , 3 , 0 , 0 ]) # 删除一维数组开头和结尾的0元素 # trim='f' 从前面裁剪 # trim='b' 从后面裁剪 # 默认为 trim='fb' np . trim_zeros ( a , trim = 'fb' ) array([1, 2, 3])","text_tokens":["import","是","重建","方法","原","从","=",")",".","数据","f","b","…","指定","前导","添加","2","在","1","]","，","trim","插入","dtype","'","unique","为","或","index","末尾","附加","后面","append","int64","true","结尾","序列","用于","之前","reshape","11","0","开头","、","前面","沿","将值","arr","默认","as","#","3","同时","array","未","尾随","_","np","的","计数","a","参数","描述","可","4","索引","counts","返回"," ","没有","删除","修剪","元素","insert","axis","一维","重复","数组","zeros","none","ar","[","设置","false","值","裁剪","s","fb","到","numpy","filt","obj","return","arange","delete",",","和","(","values","零","轴","10","中","inverse"],"title":"6.7.添加和删除","title_tokens":["添加","6.7","和",".","删除"]},{"location":"numpy笔记/6.7.添加和删除.html#_1","text":"方法 描述 delete (arr, obj[, axis]) 沿指定轴删除指定的元素，返回未删除的数组 insert (arr, obj, values[, axis]) 沿指定轴在指定索引之前插入值 append (arr, values[, axis]) 将值附加到数组的末尾 trim_zeros s(filt[, trim]) 修剪一维数组或序列中的前导、尾随的零 unique (ar[, return_index, return_inverse, …]) 返回没有重复元素的数组 # append a = np . arange ( 4 ) . reshape (( 2 , 2 )) np . append ( a , [[ 1 , 2 ],[ 3 , 4 ]], axis = 0 ) array([[0, 1], [2, 3], [1, 2], [3, 4]]) # insert a = np . arange ( 4 ) . reshape (( 2 , 2 )) # obj 是索引 np . insert ( a , obj = 1 , values = [ 10 , 11 ], axis = 0 ) array([[ 0, 1], [10, 11], [ 2, 3]]) # delete 删除指定数据，返回未删除的数据 a = np . arange ( 4 ) . reshape (( 2 , 2 )) np . delete ( a , 1 , axis = 0 ) array([[0, 1]]) # 默认返回一维数组 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = False , axis = None ) array([1, 2, 3]) # 设置axis参数 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = False , axis = 0 ) array([[1, 2], [2, 3]]) # 同时返回unique数组元素在原数组中的索引index a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = True , return_inverse = False , return_counts = False , axis = 0 ) (array([[1, 2], [2, 3]]), array([0, 2], dtype=int64)) # 同时返回原数组元素在unique数组中的索引index # 可用于重建原数组 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = True , return_counts = False , axis = 0 ) (array([[1, 2], [2, 3]]), array([0, 0, 1], dtype=int64)) # 同时返回 计数 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = True , axis = 0 ) (array([[1, 2], [2, 3]]), array([2, 1], dtype=int64)) a = np . array ([ 0 , 0 , 1 , 2 , 3 , 0 , 0 ]) # 删除一维数组开头和结尾的0元素 # trim='f' 从前面裁剪 # trim='b' 从后面裁剪 # 默认为 trim='fb' np . trim_zeros ( a , trim = 'fb' ) array([1, 2, 3])","text_tokens":["重建","是","方法","原","从","=",")",".","数据","f","b","…","指定","前导","2","在","1","]","，","trim","插入","dtype","'","unique","为","或","index","末尾","附加","后面","append","int64","true","结尾","序列","用于","之前","reshape","11","0","开头","、","前面","沿","将值","arr","默认","#","3","同时","array","未","尾随","_","的","np","计数","a","参数","描述","可","4","索引","counts","返回"," ","没有","删除","修剪","元素","insert","axis","一维","重复","数组","zeros","none","ar","[","设置","false","值","裁剪","s","fb","到","filt","obj","return","arange","delete",",","和","(","values","零","轴","10","中","inverse"],"title":"添加和删除数组元素","title_tokens":["添加","元素","数组","和","删除"]},{"location":"numpy笔记/6.8.形状操纵.html","text":"import numpy as np import copy 形状操作( shape ) .shape .reshape() .resize() reshape resize 区别： reshape不会修改原数据 resize会修改原数据 # 创建示例数据 a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) # 会直接修改原始数组 a . shape = ( 5 , 10 ) a . flags # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . shape = ( 25 , - 1 ) # 不会直接修改原始数组 a . reshape ( 5 , 10 ) # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . reshape ( 5 , - 1 ) # 会直接修改原始数组 a . resize (( 25 , 2 )) 形状操作( ndim ) .flatten() ：多维数组转为一维数组 .reval() ：多维数组转为一维数组 .squeeze() ：将大小等于1的轴删除 .swapaxes(a, axis1, axis2)) ：交换指定的两个轴axis1/axis2。它获得是原数组的视图。 .transpose(a, axes=None) ：重置轴序。如果 axes=None ，则默认重置为逆序的轴序，如原来的 shape=(1,2,3) ，逆序之后为 (3,2,1） 如果 axes!=None ，则要给出重置后的轴序。它获得的是原数组的视图。 .atleast_1d(*arys) ：将输入转换为至少一维的数组 .atleast_2d(*arys) ：将输入转换为至少二维的数组 .atleast_3d(*arys) ：将输入转换为至少三维的数组 .expand_dims() ：在指定位置插入大小为1的新轴 .moveaxis(a, source, destination) ：将a中的source轴移动到位置destination，source、destination可以是int of list，一次性移动多个轴 # 多维数组转为一维数组 a . flatten () # 返回副本 a . ravel () # 一般返回视图 ## flatten ravel 区别 ## ravel()：如果没有必要，不会产生源数据的副本 ## flatten()：返回源数据的副本 b = np . arange ( 10 ) # 创建示例数据 b . flatten () . flags [ \"OWNDATA\" ] True b . ravel () . flags [ \"OWNDATA\" ] False a . ravel ( order = \"F\" ) . flags [ \"OWNDATA\" ] True # 对维数为1的维度降维,返回副本 b = copy . deepcopy ( np . arange ( 20 ) . reshape ( 20 , 1 )) b [: 6 ] array([[0], [1], [2], [3], [4], [5]]) b . squeeze ( 1 ) array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) # 返回数组的视图，其中axis1和axis2互换。 ## ndarray.swapaxes(axis1, axis2) a = copy . deepcopy ( np . arange ( 20 ) . reshape ( 10 , 2 )) a . swapaxes ( 0 , 1 ) # 视图 array([[ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18], [ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]]) # 返回轴转置的数组视图。 b = copy . deepcopy ( np . arange ( 60 ) . reshape ( 3 , 2 , 10 )) b . transpose () array ([[[ 0 , 20 , 40 ], [ 10 , 30 , 50 ]], [[ 1 , 21 , 41 ], [ 11 , 31 , 51 ]], [[ 2 , 22 , 42 ], [ 12 , 32 , 52 ]], [[ 3 , 23 , 43 ], [ 13 , 33 , 53 ]], [[ 4 , 24 , 44 ], [ 14 , 34 , 54 ]], [[ 5 , 25 , 45 ], [ 15 , 35 , 55 ]], [[ 6 , 26 , 46 ], [ 16 , 36 , 56 ]], [[ 7 , 27 , 47 ], [ 17 , 37 , 57 ]], [[ 8 , 28 , 48 ], [ 18 , 38 , 58 ]], [[ 9 , 29 , 49 ], [ 19 , 39 , 59 ]]]) # atleast_nd np . atleast_1d ( 1 ) array([1]) np . atleast_2d ([ 1 , 2 , 3 , 4 ]) array([[1, 2, 3, 4]]) np . atleast_3d ([[ 1 , 2 ],[ 3 , 4 ]]) array ([[[ 1 ], [ 2 ]], [[ 3 ], [ 4 ]]]) a = np . arange ( 4 ) . reshape ( 2 , 2 ) np . expand_dims ( a , 1 ) . shape (2, 1, 2) x = np . zeros (( 3 , 4 , 5 )) print ( np . moveaxis ( x , 0 , - 1 ) . shape ) print ( np . moveaxis ( x , - 1 , 0 ) . shape ) (4, 5, 3) (5, 3, 4) \"以下代码的效果一样\" x = np . zeros (( 3 , 4 , 5 )) np . transpose ( x ) . shape np . swapaxes ( x , 0 , - 1 ) . shape np . moveaxis ( x , [ 0 , 2 ], [ - 1 , - 2 ]) . shape np . moveaxis ( x , [ 0 , 1 , 2 ], [ - 1 , - 2 , - 3 ]) . shape 数组拼接 .concatenate((a1, a2, ...), axis=0) ：连接多个数组。其中 (a1,a2,...) 为数组的序列，给出了待连接的数组，它们沿着 axis 指定的已存在的轴连接。所有的这些数组的形状，除了 axis 轴之外都相同。 .vstack(tup) ：沿0轴拼接（垂直拼接），增加行。 .hstack(tup) ：沿1轴拼接（水平拼接），增加列。 .dstack(tup) ： numpy.concatenate((a1, a2, ...), axis=3) 。沿着3轴堆叠数组。 .column_stack(tup) ：类似于 hstack ，但是如果被拼接的数组是一维的，则将其形状修改为二维的$(N,1)$。 .c_ ： .c_ 对象的 [] 方法也可以用于按列连接数组。但是如果被拼接的数组是一维的，则将其形状修改为二维的$(N,1)$。沿列方向拼接，增加列。 a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) # 横向拼接、拼接 1 轴（第二个轴，即列） np . concatenate (( a , b ), axis = 1 ) np . hstack (( a , b )) np . c_ [ a , b ] array([[0, 1, 0, 1], [2, 3, 2, 3], [4, 5, 4, 5], [6, 7, 6, 7], [8, 9, 8, 9]]) # column_stack hstack np.c_区别 a1 = np . arange ( 5 ) np . column_stack (( a1 , a1 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) np . hstack (( a1 , a1 )) array([0, 1, 2, 3, 4, 0, 1, 2, 3, 4]) np . c_ [ a1 , a1 ] array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) 数组拆分 1. .split(ary, indices_or_sections, axis=0) ：用于沿着指定的轴拆分数组ary。 indices_or_sections指定了拆分点： 如果为整数N，则表示平均拆分成N份。如果不能平均拆分，则报错 如果为序列，则该序列指定了划分区间（无需指定最开始的0起点和终点）。如 [1,3] 指定了区间： [0,1],[1,3],[3:] 2. .array_split(ary, indices_or_sections, axis=0) ：作用与 .split() 类似。唯一的区别在于：当indices_or_sections为整数，且无法平均拆分时，并不报错，而是尽可能的维持平均拆分。 3. .dsplit(ary, indices_or_sections) ：沿第3轴将数组拆分为多个子数组。 4. .hsplit(ary, indices_or_sections) ：水平（按列）将一个数组拆分为多个子数组。 5. .vsplit(ary, indices_or_sections) ：垂直（行）将数组拆分为多个子数组。 a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) np . split ( a , 2 , axis = 0 ) [array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]]), array([[25, 26, 27, 28, 29], [30, 31, 32, 33, 34], [35, 36, 37, 38, 39], [40, 41, 42, 43, 44], [45, 46, 47, 48, 49]])] # [0,1) [1,3) [3:] np . split ( a ,[ 1 , 3 ], axis = 1 ) [array([[ 0], [ 5], [10], [15], [20], [25], [30], [35], [40], [45]]), array([[ 1, 2], [ 6, 7], [11, 12], [16, 17], [21, 22], [26, 27], [31, 32], [36, 37], [41, 42], [46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], [18, 19], [23, 24], [28, 29], [33, 34], [38, 39], [43, 44], [48, 49]])] np . array_split ( a , 2 , axis = 1 ) [array([[ 0, 1, 2], [ 5, 6, 7], [10, 11, 12], [15, 16, 17], [20, 21, 22], [25, 26, 27], [30, 31, 32], [35, 36, 37], [40, 41, 42], [45, 46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], [18, 19], [23, 24], [28, 29], [33, 34], [38, 39], [43, 44], [48, 49]])]","text_tokens":["40","dims","原","!","区间","沿第","57","等于","了","##","]","35","27","而是","可能","并","2d","为","arys","3d","份","\"","12","-","6","沿着","reshape","该","其","owndata","、","视图","21","46","默认","报错","#","位置","3","axis1","它们","多个","n","7","a","38","不会","创建","4","区别","返回","17","分为","唯一","49","尽可","）","*","长度","axis","1d","横向","数组","垂直","[","代码","ravel","互换","sections","新","到","arange",",","此时","至少","对维数","nd","源","9","axis2","deepcopy","26","且","数据","2","22","ndarray","，","产生","某个","插入","一个","24","axes","18","56","这些","输入","修改","44","维度","一次","于","交换","order","沿","：","19","int","47","但是","不能","48","连接","平均","一次性","29","list","25","列","之外","时","可以","将","原始","58","直接","给出","43","hsplit","删除","一般","23","方向","c","a1","column","要","降维","60","5","numpy","dstack","squeeze","除了","如","中","轴","ary","不","是","reval","transpose","形状","=","堆叠","8","f","dsplit","39","1","x","自动","之后","终点","按列","atleast","copy","a2","示例","source","会","无需","true","序列","11","必要","16","都","逆序","as","其中","也","多维","表示","大小","即列","被","13","则","of","转为","的","33","水平","拼接","存在","31","swapaxes","轴序","flags","分成","shape"," ","indices","15","重置","增加","一维","moveaxis","zeros","起点","设置","false","二个","如果","34","vstack","行","和","(","14","划分","10","51","子","import","hstack","方法","52","转置","expand",")",".","30","28","b","指定","当","操作","在","无法","print","。","42","三维","与","concatenate","后","55","效果","stack","第二","副本","...","59","20","53","用于","二维","拆分","0","$","获得","destination","37","维持","对象","array","41","第二个","split","32","_","在于","tup","np","/","flatten","沿列","类似","最",":","vsplit","它","没有","一样","计算","尽可能","resize","50","45","拆","none","开始","36","54","两个","点","待","转换","作用","相同","ndim","以下","or","已","所有","整数","移动","原来","（"],"title":"6.8.形状操纵","title_tokens":["操纵","形状",".","6.8"]},{"location":"numpy笔记/6.8.形状操纵.html#shape","text":".shape .reshape() .resize() reshape resize 区别： reshape不会修改原数据 resize会修改原数据 # 创建示例数据 a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) # 会直接修改原始数组 a . shape = ( 5 , 10 ) a . flags # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . shape = ( 25 , - 1 ) # 不会直接修改原始数组 a . reshape ( 5 , 10 ) # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . reshape ( 5 , - 1 ) # 会直接修改原始数组 a . resize (( 25 , 2 ))","text_tokens":["为","计算","长度","原","copy","resize","50","示例","=",")","数组","会","deepcopy","25","被","修改",".","数据","维度","设置","np","可以","的","2","-","a","在","不会","reshape","创建","原始","1","其","该","自动","5","区别","，","arange","flags",",","直接","：","此时","(","某个","shape"," ","10","#"],"title":"形状操作(shape)","title_tokens":[")","操作","(","shape","形状"]},{"location":"numpy笔记/6.8.形状操纵.html#ndim","text":".flatten() ：多维数组转为一维数组 .reval() ：多维数组转为一维数组 .squeeze() ：将大小等于1的轴删除 .swapaxes(a, axis1, axis2)) ：交换指定的两个轴axis1/axis2。它获得是原数组的视图。 .transpose(a, axes=None) ：重置轴序。如果 axes=None ，则默认重置为逆序的轴序，如原来的 shape=(1,2,3) ，逆序之后为 (3,2,1） 如果 axes!=None ，则要给出重置后的轴序。它获得的是原数组的视图。 .atleast_1d(*arys) ：将输入转换为至少一维的数组 .atleast_2d(*arys) ：将输入转换为至少二维的数组 .atleast_3d(*arys) ：将输入转换为至少三维的数组 .expand_dims() ：在指定位置插入大小为1的新轴 .moveaxis(a, source, destination) ：将a中的source轴移动到位置destination，source、destination可以是int of list，一次性移动多个轴 # 多维数组转为一维数组 a . flatten () # 返回副本 a . ravel () # 一般返回视图 ## flatten ravel 区别 ## ravel()：如果没有必要，不会产生源数据的副本 ## flatten()：返回源数据的副本 b = np . arange ( 10 ) # 创建示例数据 b . flatten () . flags [ \"OWNDATA\" ] True b . ravel () . flags [ \"OWNDATA\" ] False a . ravel ( order = \"F\" ) . flags [ \"OWNDATA\" ] True # 对维数为1的维度降维,返回副本 b = copy . deepcopy ( np . arange ( 20 ) . reshape ( 20 , 1 )) b [: 6 ] array([[0], [1], [2], [3], [4], [5]]) b . squeeze ( 1 ) array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) # 返回数组的视图，其中axis1和axis2互换。 ## ndarray.swapaxes(axis1, axis2) a = copy . deepcopy ( np . arange ( 20 ) . reshape ( 10 , 2 )) a . swapaxes ( 0 , 1 ) # 视图 array([[ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18], [ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]]) # 返回轴转置的数组视图。 b = copy . deepcopy ( np . arange ( 60 ) . reshape ( 3 , 2 , 10 )) b . transpose () array ([[[ 0 , 20 , 40 ], [ 10 , 30 , 50 ]], [[ 1 , 21 , 41 ], [ 11 , 31 , 51 ]], [[ 2 , 22 , 42 ], [ 12 , 32 , 52 ]], [[ 3 , 23 , 43 ], [ 13 , 33 , 53 ]], [[ 4 , 24 , 44 ], [ 14 , 34 , 54 ]], [[ 5 , 25 , 45 ], [ 15 , 35 , 55 ]], [[ 6 , 26 , 46 ], [ 16 , 36 , 56 ]], [[ 7 , 27 , 47 ], [ 17 , 37 , 57 ]], [[ 8 , 28 , 48 ], [ 18 , 38 , 58 ]], [[ 9 , 29 , 49 ], [ 19 , 39 , 59 ]]]) # atleast_nd np . atleast_1d ( 1 ) array([1]) np . atleast_2d ([ 1 , 2 , 3 , 4 ]) array([[1, 2, 3, 4]]) np . atleast_3d ([[ 1 , 2 ],[ 3 , 4 ]]) array ([[[ 1 ], [ 2 ]], [[ 3 ], [ 4 ]]]) a = np . arange ( 4 ) . reshape ( 2 , 2 ) np . expand_dims ( a , 1 ) . shape (2, 1, 2) x = np . zeros (( 3 , 4 , 5 )) print ( np . moveaxis ( x , 0 , - 1 ) . shape ) print ( np . moveaxis ( x , - 1 , 0 ) . shape ) (4, 5, 3) (5, 3, 4) \"以下代码的效果一样\" x = np . zeros (( 3 , 4 , 5 )) np . transpose ( x ) . shape np . swapaxes ( x , 0 , - 1 ) . shape np . moveaxis ( x , [ 0 , 2 ], [ - 1 , - 2 ]) . shape np . moveaxis ( x , [ 0 , 1 , 2 ], [ - 1 , - 2 , - 3 ]) . shape","text_tokens":["51","40","dims","是","源","reval","原","transpose","52","!","转置","expand","=","9",")","axis2","deepcopy","26","8","57",".","数据","f","30","等于","28","b","指定","2","在","print","39","22","。","42","1","三维","##","ndarray","x","]","35","之后","，","27","产生","插入","后","atleast","2d","24","55","为","效果","arys","3d","axes","copy","副本","18","56","示例","source","\"","输入","true","12","44","维度","59","一次","20","-","53","交换","6","reshape","11","二维","0","owndata","、","必要","order","16","获得","视图","：","19","21","destination","37","中","46","int","默认","47","逆序","其中","#","位置","48","3","多维","array","axis1","一次性","多个","41","29","大小","32","list","25","13","则","_","of","7","转为","的","将","可以","np","33","/","a","38","flatten","不会","创建","31","swapaxes","轴序",":","4","区别","返回","flags","58","它","17","shape","给出"," ","43","没有","删除","15","一样","重置","49","）","*","50","一维","一般","23","45","1d","moveaxis","数组","none","zeros","36","要","[","54","两个","代码","false","降维","转换","如果","ravel","互换","60","34","新","到","5","以下","squeeze","arange","nd",",","和","如","(","至少","对维数","移动","14","10","轴","原来"],"title":"形状操作(ndim)","title_tokens":[")","操作","(","形状","ndim"]},{"location":"numpy笔记/6.8.形状操纵.html#_1","text":".concatenate((a1, a2, ...), axis=0) ：连接多个数组。其中 (a1,a2,...) 为数组的序列，给出了待连接的数组，它们沿着 axis 指定的已存在的轴连接。所有的这些数组的形状，除了 axis 轴之外都相同。 .vstack(tup) ：沿0轴拼接（垂直拼接），增加行。 .hstack(tup) ：沿1轴拼接（水平拼接），增加列。 .dstack(tup) ： numpy.concatenate((a1, a2, ...), axis=3) 。沿着3轴堆叠数组。 .column_stack(tup) ：类似于 hstack ，但是如果被拼接的数组是一维的，则将其形状修改为二维的$(N,1)$。 .c_ ： .c_ 对象的 [] 方法也可以用于按列连接数组。但是如果被拼接的数组是一维的，则将其形状修改为二维的$(N,1)$。沿列方向拼接，增加列。 a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) # 横向拼接、拼接 1 轴（第二个轴，即列） np . concatenate (( a , b ), axis = 1 ) np . hstack (( a , b )) np . c_ [ a , b ] array([[0, 1, 0, 1], [2, 3, 2, 3], [4, 5, 4, 5], [6, 7, 6, 7], [8, 9, 8, 9]]) # column_stack hstack np.c_区别 a1 = np . arange ( 5 ) np . column_stack (( a1 , a1 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) np . hstack (( a1 , a1 )) array([0, 1, 2, 3, 4, 0, 1, 2, 3, 4]) np . c_ [ a1 , a1 ] array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]])","text_tokens":["是","hstack","方法","形状","=","9",")","deepcopy","堆叠","8",".","b","指定","2","了","。","1","]","，","concatenate","按列","为","stack","copy","第二","...","a2","这些","修改","于","序列","用于","沿着","6","reshape","二维","其","0","、","$","沿","都","：","对象","但是","其中","#","也","3","连接","array","它们","多个","第二个","即列","n","被","_","则","7","列","tup","的","之外","将","可以","np","a","水平","拼接","沿列","存在","类似","4","区别","给出"," ","增加","）","axis","一维","方向","c","a1","横向","数组","垂直","column","[","二个","待","如果","vstack","行","相同","numpy","dstack","5","已","arange",",","除了","所有","(","10","轴","（"],"title":"数组拼接","title_tokens":["拼接","数组"]},{"location":"numpy笔记/6.8.形状操纵.html#_2","text":"1. .split(ary, indices_or_sections, axis=0) ：用于沿着指定的轴拆分数组ary。 indices_or_sections指定了拆分点： 如果为整数N，则表示平均拆分成N份。如果不能平均拆分，则报错 如果为序列，则该序列指定了划分区间（无需指定最开始的0起点和终点）。如 [1,3] 指定了区间： [0,1],[1,3],[3:] 2. .array_split(ary, indices_or_sections, axis=0) ：作用与 .split() 类似。唯一的区别在于：当indices_or_sections为整数，且无法平均拆分时，并不报错，而是尽可能的维持平均拆分。 3. .dsplit(ary, indices_or_sections) ：沿第3轴将数组拆分为多个子数组。 4. .hsplit(ary, indices_or_sections) ：水平（按列）将一个数组拆分为多个子数组。 5. .vsplit(ary, indices_or_sections) ：垂直（行）将数组拆分为多个子数组。 a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) np . split ( a , 2 , axis = 0 ) [array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]]), array([[25, 26, 27, 28, 29], [30, 31, 32, 33, 34], [35, 36, 37, 38, 39], [40, 41, 42, 43, 44], [45, 46, 47, 48, 49]])] # [0,1) [1,3) [3:] np . split ( a ,[ 1 , 3 ], axis = 1 ) [array([[ 0], [ 5], [10], [15], [20], [25], [30], [35], [40], [45]]), array([[ 1, 2], [ 6, 7], [11, 12], [16, 17], [21, 22], [26, 27], [31, 32], [36, 37], [41, 42], [46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], [18, 19], [23, 24], [28, 29], [33, 34], [38, 39], [43, 44], [48, 49]])] np . array_split ( a , 2 , axis = 1 ) [array([[ 0, 1, 2], [ 5, 6, 7], [10, 11, 12], [15, 16, 17], [20, 21, 22], [25, 26, 27], [30, 31, 32], [35, 36, 37], [40, 41, 42], [45, 46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], [18, 19], [23, 24], [28, 29], [33, 34], [38, 39], [43, 44], [48, 49]])]","text_tokens":["ary","子","40","不","区间","=","9",")","沿第","deepcopy","26","且","8",".","30","28","指定","2","了","当","无法","dsplit","39","22","。","42","1","]","与","35","终点","，","27","而是","一个","可能","按列","并","24","为","copy","18","份","无需","12","44","20","序列","用于","沿着","6","reshape","11","该","拆分","0","16","：","19","21","37","46","47","维持","报错","不能","#","48","3","平均","表示","array","split","多个","41","29","32","n","25","13","_","则","7","在于","的","时","将","np","33","a","38","水平","类似","31","最",":","4","vsplit","区别","分成","17","hsplit"," ","indices","43","15","分为","唯一","49","尽可","）","尽可能","50","axis","23","45","数组","拆","垂直","开始","36","起点","[","点","如果","作用","sections","34","行","5","or","arange",",","和","如","(","整数","14","划分","10","轴","（"],"title":"数组拆分","title_tokens":["数组","拆分"]},{"location":"numpy笔记/6.9.ufunc函数.html","text":"import numpy as np np . set_printoptions ( threshold = 40 ) 四则运算 a = np . arange ( 1 , 6 ) # 表达式形式 a + a a - a a * a a / a # ufunc函数形式 np . add ( a , a ) np . subtract ( a , a ) np . multiply ( a , a ) np . true_divide ( a , a ) array([1., 1., 1., 1., 1.]) 比较运算 a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 表达式形式 a == b a != b a < b a <= b a > b a >= b # ufunc函数形式 np . equal ( a , b ) np . not_equal ( a , b ) np . less ( a , b ) np . less_equal ( a , b ) np . greater ( a , b ) np . greater_equal ( a , b ) array([[False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False]]) 逻辑运算 a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 与 np . logical_and ( a , b ) # 或 np . logical_or ( a , b ) # 非 np . logical_not ( a , b ) # 异或 np . logical_xor ( a , b ) # 任意一个元素 np . any ( a ) # 全部元素 np . all ( a ) False 位运算 a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) a & b a | b ~ a a ^ b # 按位与 np . bitwise_and ( a , b ) # 按位或 np . bitwise_or ( a , b ) # 按位取反 np . bitwise_not ( a ) # 按位异或 np . bitwise_xor ( a , b ) array([[10, 10, 14, 14, 10, 10, 22, 22, 26, 26], [30, 30, 26, 26, 22, 22, 10, 10, 14, 14]], dtype=int32) 自定义 ufunc 函数 可以通过 frompyfunc() 将计算单个元素的函数转换成ufunc函数。调用格式为如下： numpy . frompyfunc ( func , nin , nout ) # func：计算单个元素的函数 # nin：func的输入参数的个数 The number of input # nout：func返回值的个数 The number of output def my_add ( x , y ): z = x + y + 1 return z myufunc = np . frompyfunc ( my_add , 2 , 1 ) a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) myufunc ( a , b ) array([6, 8, 10, 12, 14], dtype=object) 也可以通过 vectorize() 函数来实现 frompyfunc() 的功能。 np . vectorize ( func , otypes = '' , doc = None , excluded = None ) 。 # func：计算单个元素的函数 # otypes：可以是一个表示结果数组元素类型的字符串，也可以是一个类型列表。如果使用类型列表，可以描述多个返回数组的元素类型 # doc：函数的描述字符串。若未给定，则使用func.__doc__ # excluded：指定func中哪些参数未被向量化。你可以指定一个字符串和整数的集合，其中字符串代表关键字参数，整数代表位置参数。 a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) def my_add ( x , num ): z = x + num return z myufunc = np . vectorize ( my_add , doc = \"每一个元素加上一个指定的数\" ) print ( myufunc . __doc__ ) myufunc ( a , 1 ) 每一个元素加上一个指定的数 array([1, 2, 3, 4, 5]) def my_add ( x , y , list_num ): z = x + y for i in list_num : z = z + i return z myufunc = np . vectorize ( my_add , excluded = [ 2 ]) myufunc ( a , b , [ 1 , 2 , 3 ]) # list_num 作为一个list，而不是向量化成一个个元素 array([11, 13, 15, 17, 19]) def my_add ( x , num ): z = x + num return z , z myufunc = np . vectorize ( my_add , otypes = [ np . float , int ]) myufunc ( a , 1 ) (array([1., 2., 3., 4., 5.]), array([1, 2, 3, 4, 5])) ufunc 对象的方法 ufunc函数对象本身还有一些方法。 这些方法只对于两个输入、一个输出的ufunc函数函数有效。对于其他的ufunc函数对象调用这些方法时，会抛出 ValueError 异常。 ufunc.reduce() ufunc.reduce 方法：类似于Python的 reduce 函数，它==沿着== axis 参数指定的轴，对数组进行操作。经过一次reduce，结果数组的维度降低一维。 假设 <op> 是一个ufunc函数， ufunc.reduce 用法如下： < op >. reduce ( array , axis = 0 , dtype = None ) a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . reduce ( a , axis = 1 ) # 沿着 列方向 array([ 6, 22, 38, 54, 70]) np . add . reduce ( a , axis = 0 ) # 沿着 行方向 array([40, 45, 50, 55]) 相当于将 运算符插入到沿着axis轴的所有元素之间： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) def fun ( a , b ): z = a + b + 1 return z fun2 = np . frompyfunc ( fun , 2 , 1 ) fun2 . reduce ( a , axis = 1 ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] array([9, 25, 41, 57, 73], dtype=object) ufunc.accumulate() ufunc.accumulate 方法：它类似于reduce()的计算过程，但是它会保存所有的中间计算结果，从而使得返回数组的形状和输入数组的形状相同： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . accumulate ( a , axis = 1 ) array([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38], [12, 25, 39, 54], [16, 33, 51, 70]], dtype=int32) ufunc.outer() ufunc.outer 方法：相当于将 运算符对输入数组A和输入数组B的每一对元素对(a,b)起作用。设A的shape=(4,5)，B的shape为(4,)，则结果数组的shape=(4,5,4) 一维数组和一维数组的outer操作为二维数组 a = np . arange ( 1 , 6 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array([[2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7], [5, 6, 7, 8], [6, 7, 8, 9]]) 多维数组的outer拆分成各自的一维操作 a = np . arange ( 1 , 7 ) . reshape ( 2 , 3 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array ([[[ 2 , 3 , 4 , 5 ], [ 3 , 4 , 5 , 6 ], [ 4 , 5 , 6 , 7 ]], [[ 5 , 6 , 7 , 8 ], [ 6 , 7 , 8 , 9 ], [ 7 , 8 , 9 , 10 ]]]) 数学函数 下面是一元的数学函数： abs/fabs ：计算整数、浮点数或者复数的绝对值。对于非复数值，可以使用更快的fabs sqrt ：计算平方根，相当于$a^{0.5}$ square ：计算平方，相当于$a^2$ exp ：计算指数$e^x$ log/log10/log2/log1p ：分别为$log_{e}(a), log_{10}(a), log_2(a), log_e(1+x)$ sign ：计算$sign(a)$ ceil ：计算各元素的ceiling值：大于等于该值的最小整数 floor ：计算个元素的floor值：小于等于该值的最大整数 rint ：将各元素四舍五入到最接近的整数，保留 dtype modf ：将数组的小数和整数部分以两个独立数组的形式返回 cos/cosh/sin/sinh/tan/tanh ：普通和双曲型三角函数 arccos/arcsosh/arcsin/arcsinh/arctan/arctanh :反三角函数 isnan ：返回一个布尔数组，该数组指示那些是 NaN isfinite/isinf ：返回一个布尔数组，该数组指示哪些是有限的/无限数","text_tokens":["40","!","the","该值","对于","57","等于","相当于","起","点数","自定","]","加上","27","代表","平方根","e","为","数学","sqrt","0.5","\"","subtract","12","使用","floor","-","其他","保存","6","沿着","reshape","__","该",">","换成","isfinite","、","对","square","只","reduce","#","小数","位置","3","ceiling","多个","最小","结果","部分","+","四则","7","有限","a","38","xor","4","返回","70","每","ceil","arctanh","17","arccos","元素","*","axis","73","过程","数组","rint","[","sign","threshold","到","方根","个","平方","greater","arange","myufunc",",","布尔","本身","中间","add","若","逻辑运算","表达","9","作为","26","divide","2","用法","一元","22","给定","向","集合","，","异或","型","定义","插入","output","equal","log1p","一个","当于","fun","使得","比较","表达式","18","无限","这些","输入","格式","浮点","维度","nin","一个个","一次","于","计算结果","转换成","或者","全部","字符","字符串","：","19","i","int","但是","普通","nout","复数","绝对值","未","list","小于","25","关键字","独立","列","doc","时","可以","将","printoptions","logical","参数","按位","set","描述","运算符","log2","otypes","那些","valueerror","func","返回值","有效","y","方向","你","调用","op","非","还有","取反","fun2","arcsinh","进行","5","numpy","in","指数","三角","中","轴","大于","是","|","之间","my","形状","less","=","8","一些","量化","个数","算符","39","关键","1","x","化成","分别","tanh","nan","accumulate","设","反","z","或","自定义","形式","ufunc","cosh","会","true","def","python","arcsin","11","arctan","不是","输出","16","not","as","其中","也","多维","表示","log","cos","被","13","则","of","的","四则运算","33","类型","而","arcsosh","非复","从而","分成","float","shape"," ","任意","15","接近","一维","以","}","它会","input","false","各","multiply","如果","行","num","运算","return","和","(","14","<","个个","10","双曲","object","51","all","import","tan","abs","方法",")","达式",".","30","b","指定","来","&","操作","print","。","vectorize","与","下面","列表","单个","dtype","'","sinh","55","数","经过","功能","相当","20","更快","log10","最大","二维","0","outer","一对","number","$","数值","抛出","exp","对象","and","降低","向量","array","如下","保留","41","~","^","{","通过","位",".__","_","假设","for","frompyfunc","np","/","函数","实现","类似","最",":","异常","浮点数","指示","它","bitwise","三角函数","哪些","计算","50","any","45","sin","拆","none","四舍五入","int32","逻辑","54","两个","excluded","isinf","值","绝对","转换","isnan","作用","相同","各自","or","modf","所有","整数","fabs"],"title":"6.9.ufunc函数","title_tokens":[".","ufunc","6.9","函数"]},{"location":"numpy笔记/6.9.ufunc函数.html#_1","text":"a = np . arange ( 1 , 6 ) # 表达式形式 a + a a - a a * a a / a # ufunc函数形式 np . add ( a , a ) np . subtract ( a , a ) np . multiply ( a , a ) np . true_divide ( a , a ) array([1., 1., 1., 1., 1.])","text_tokens":["array","*","表达式","add","形式","ufunc","=","表达","+",")","subtract","divide","达式","_",".","true","[","np","/","-","a","函数","multiply","6","1","]","arange",",","("," ","#"],"title":"四则运算","title_tokens":["四则运算","运算","四则"]},{"location":"numpy笔记/6.9.ufunc函数.html#_2","text":"a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 表达式形式 a == b a != b a < b a <= b a > b a >= b # ufunc函数形式 np . equal ( a , b ) np . not_equal ( a , b ) np . less ( a , b ) np . less_equal ( a , b ) np . greater ( a , b ) np . greater_equal ( a , b ) array([[False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False]])","text_tokens":["array","表达式","形式","!","ufunc","less","=","表达",")","达式","_",".","30","[","b","np","false","20","2","a","函数","reshape",">","]","greater","arange",",","(","equal","<"," ","10","not","#"],"title":"比较运算","title_tokens":["运算","比较"]},{"location":"numpy笔记/6.9.ufunc函数.html#_3","text":"a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 与 np . logical_and ( a , b ) # 或 np . logical_or ( a , b ) # 非 np . logical_not ( a , b ) # 异或 np . logical_xor ( a , b ) # 任意一个元素 np . any ( a ) # 全部元素 np . all ( a ) False","text_tokens":["and","元素","all","或","any","=",")","_",".","30","b","np","false","logical","20","2","a","非","xor","reshape","全部","与","or","异或","arange",",","("," ","10","任意","一个","not","#"],"title":"逻辑运算","title_tokens":["逻辑运算","运算","逻辑"]},{"location":"numpy笔记/6.9.ufunc函数.html#_4","text":"a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) a & b a | b ~ a a ^ b # 按位与 np . bitwise_and ( a , b ) # 按位或 np . bitwise_or ( a , b ) # 按位取反 np . bitwise_not ( a ) # 按位异或 np . bitwise_xor ( a , b ) array([[10, 10, 14, 14, 10, 10, 22, 22, 26, 26], [30, 30, 26, 26, 22, 22, 10, 10, 14, 14]], dtype=int32)","text_tokens":["and","或","array","|","~","=","^",")","dtype","26","_",".","30","[","int32","b","np","20","2","a","&","取反","xor","reshape","按位","22","]","与","or","异或","arange",",","(","14","bitwise"," ","10","not","#"],"title":"位运算","title_tokens":["运算","位"]},{"location":"numpy笔记/6.9.ufunc函数.html#ufunc","text":"可以通过 frompyfunc() 将计算单个元素的函数转换成ufunc函数。调用格式为如下： numpy . frompyfunc ( func , nin , nout ) # func：计算单个元素的函数 # nin：func的输入参数的个数 The number of input # nout：func返回值的个数 The number of output def my_add ( x , y ): z = x + y + 1 return z myufunc = np . frompyfunc ( my_add , 2 , 1 ) a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) myufunc ( a , b ) array([6, 8, 10, 12, 14], dtype=object) 也可以通过 vectorize() 函数来实现 frompyfunc() 的功能。 np . vectorize ( func , otypes = '' , doc = None , excluded = None ) 。 # func：计算单个元素的函数 # otypes：可以是一个表示结果数组元素类型的字符串，也可以是一个类型列表。如果使用类型列表，可以描述多个返回数组的元素类型 # doc：函数的描述字符串。若未给定，则使用func.__doc__ # excluded：指定func中哪些参数未被向量化。你可以指定一个字符串和整数的集合，其中字符串代表关键字参数，整数代表位置参数。 a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) def my_add ( x , num ): z = x + num return z myufunc = np . vectorize ( my_add , doc = \"每一个元素加上一个指定的数\" ) print ( myufunc . __doc__ ) myufunc ( a , 1 ) 每一个元素加上一个指定的数 array([1, 2, 3, 4, 5]) def my_add ( x , y , list_num ): z = x + y for i in list_num : z = z + i return z myufunc = np . vectorize ( my_add , excluded = [ 2 ]) myufunc ( a , b , [ 1 , 2 , 3 ]) # list_num 作为一个list，而不是向量化成一个个元素 array([11, 13, 15, 17, 19]) def my_add ( x , num ): z = x + num return z , z myufunc = np . vectorize ( my_add , otypes = [ np . float , int ]) myufunc ( a , 1 ) (array([1., 2., 3., 4., 5.]), array([1, 2, 3, 4, 5]))","text_tokens":["是","my","add","若","the","=",")","作为","8",".","量化","b","2","指定","来","个数","print","关键","。","vectorize","1","x","给定","向","]","集合","化成","列表","，","加上","代表","output","单个","一个","dtype","'","z","为","数","功能","ufunc","\"","输入","格式","def","12","nin","一个个","使用","转换成","6","__","11","不是","换成","number","字符","字符串","：","19","i","int","其中","#","也","位置","3","表示","array","如下","向量","nout","多个","结果","+","未","list","通过",".__","被","13","_","of","则","关键字","for","frompyfunc","doc","的","将","可以","np","函数","a","实现","参数","类型","描述",":","4","而","返回","每","float","otypes","17"," ","哪些","15","元素","计算","func","返回值","y","数组","none","你","[","input","调用","excluded","转换","如果","5","numpy","in","num","return","arange","myufunc",",","和","(","整数","14","个个","10","中","object"],"title":"自定义 ufunc 函数","title_tokens":["函数","定义","自定义","自定"," ","ufunc"]},{"location":"numpy笔记/6.9.ufunc函数.html#ufunc_1","text":"ufunc函数对象本身还有一些方法。 这些方法只对于两个输入、一个输出的ufunc函数函数有效。对于其他的ufunc函数对象调用这些方法时，会抛出 ValueError 异常。","text_tokens":["valueerror","方法","ufunc","有效","会","这些","输入","对于","一些","调用","两个","的","时","函数","还有","其他","。","异常","、","输出","，","抛出","本身"," ","对象","只","一个"],"title":"ufunc 对象的方法","title_tokens":["方法"," ","对象","ufunc","的"]},{"location":"numpy笔记/6.9.ufunc函数.html#ufuncreduce","text":"ufunc.reduce 方法：类似于Python的 reduce 函数，它==沿着== axis 参数指定的轴，对数组进行操作。经过一次reduce，结果数组的维度降低一维。 假设 <op> 是一个ufunc函数， ufunc.reduce 用法如下： < op >. reduce ( array , axis = 0 , dtype = None ) a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . reduce ( a , axis = 1 ) # 沿着 列方向 array([ 6, 22, 38, 54, 70]) np . add . reduce ( a , axis = 0 ) # 沿着 行方向 array([40, 45, 50, 55]) 相当于将 运算符插入到沿着axis轴的所有元素之间： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) def fun ( a , b ): z = a + b + 1 return z fun2 = np . frompyfunc ( fun , 2 , 1 ) fun2 . reduce ( a , axis = 1 ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] array([9, 25, 41, 57, 73], dtype=object)","text_tokens":["40","是","方法","之间","add","=","9",")","8","57",".","b","指定","2","用法","操作","算符","print","相当于","22","。","1","]","，","插入","一个","dtype","当于","55","z","fun","经过","18","ufunc","相当","def","12","维度","一次","20","于","python","沿着","6","reshape","11",">","0","16","：","对","19","reduce","#","3","降低","array","如下","41","结果","+","25","13","7","假设","frompyfunc","列","的","np","将","函数","a","38","参数","类似","4",":","70","运算符","它","17"," ","15","元素","50","axis","一维","方向","45","73","数组","none","[","54","op","fun2","行","进行","5","到","运算","arange","return",",","所有","(","14","<","10","轴","object"],"title":"ufunc.reduce()","title_tokens":[")","(",".","ufunc","reduce"]},{"location":"numpy笔记/6.9.ufunc函数.html#ufuncaccumulate","text":"ufunc.accumulate 方法：它类似于reduce()的计算过程，但是它会保存所有的中间计算结果，从而使得返回数组的形状和输入数组的形状相同： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . accumulate ( a , axis = 1 ) array([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38], [12, 25, 39, 54], [16, 33, 51, 70]], dtype=int32)","text_tokens":["51","3","计算","使得","array","中间","方法","形状","18","ufunc","add","结果","axis","=","9","它会",")","过程","数组","dtype","输入","25","13","8","7",".","int32","[","12","54","的","np","33","20","于","计算结果","a","2","38","保存","print","6","39","reshape","11","22","类似","1","0","4","相同","5","]","返回","，","70","accumulate","16","arange","从而",",","和","：","它","所有","(","19","27","17","14"," ","10","但是","reduce","15"],"title":"ufunc.accumulate()","title_tokens":["accumulate",")","(",".","ufunc"]},{"location":"numpy笔记/6.9.ufunc函数.html#ufuncouter","text":"ufunc.outer 方法：相当于将 运算符对输入数组A和输入数组B的每一对元素对(a,b)起作用。设A的shape=(4,5)，B的shape为(4,)，则结果数组的shape=(4,5,4) 一维数组和一维数组的outer操作为二维数组 a = np . arange ( 1 , 6 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array([[2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7], [5, 6, 7, 8], [6, 7, 8, 9]]) 多维数组的outer拆分成各自的一维操作 a = np . arange ( 1 , 7 ) . reshape ( 2 , 3 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array ([[[ 2 , 3 , 4 , 5 ], [ 3 , 4 , 5 , 6 ], [ 4 , 5 , 6 , 7 ]], [[ 5 , 6 , 7 , 8 ], [ 6 , 7 , 8 , 9 ], [ 7 , 8 , 9 , 10 ]]])","text_tokens":["当于","3","元素","多维","为","array","方法","add","ufunc","一维","结果","=","9",")","数组","拆","相当","输入","8","则",".","7","[","b","的","将","np","2","a","操作","算符","相当于","起","6","reshape","作用","。","二维","1","outer","一对","4","5","]","各自","运算","，","运算符","每","设","arange",",","和","：","对","分成","(","shape"," ","10"],"title":"ufunc.outer()","title_tokens":[")","(",".","outer","ufunc"]},{"location":"numpy笔记/6.9.ufunc函数.html#_5","text":"下面是一元的数学函数： abs/fabs ：计算整数、浮点数或者复数的绝对值。对于非复数值，可以使用更快的fabs sqrt ：计算平方根，相当于$a^{0.5}$ square ：计算平方，相当于$a^2$ exp ：计算指数$e^x$ log/log10/log2/log1p ：分别为$log_{e}(a), log_{10}(a), log_2(a), log_e(1+x)$ sign ：计算$sign(a)$ ceil ：计算各元素的ceiling值：大于等于该值的最小整数 floor ：计算个元素的floor值：小于等于该值的最大整数 rint ：将各元素四舍五入到最接近的整数，保留 dtype modf ：将数组的小数和整数部分以两个独立数组的形式返回 cos/cosh/sin/sinh/tan/tanh ：普通和双曲型三角函数 arccos/arcsosh/arcsin/arcsinh/arctan/arctanh :反三角函数 isnan ：返回一个布尔数组，该数组指示那些是 NaN isfinite/isinf ：返回一个布尔数组，该数组指示哪些是有限的/无限数","text_tokens":["是","tan","abs",")","该值","对于","等于","2","一元","相当于","点数","。","1","x","分别","下面","tanh","nan","，","型","平方根","反","log1p","一个","dtype","当于","sinh","e","为","数学","数","形式","sqrt","0.5","cosh","无限","相当","浮点","使用","floor","更快","log10","arcsin","或者","最大","arctan","该","isfinite","、","$","数值","：","square","exp","普通","小数","ceiling","保留","最小","log","复数","绝对值","部分","+","^","{","小于","cos","_","独立","有限","的","可以","将","/","函数","a","最",":","浮点数","返回","arcsosh","指示","非复","ceil","log2","arctanh"," ","三角函数","哪些","arccos","元素","那些","计算","接近","以","}","sin","数组","四舍五入","rint","sign","两个","各","isinf","值","绝对","isnan","arcsinh","到","方根","指数","个","平方","布尔",",","和","modf","(","三角","整数","10","双曲","大于","fabs"],"title":"数学函数","title_tokens":["数学","函数"]},{"location":"pandas笔记/7.1.Series.html","text":"import pandas as pd from pandas import Series Series是能够保存任何类型的数据的一维数组。 Series类似numpy的一维ndarray，但是和ndarray又不同，ndarray的所有元素的类型或结构必须相同 1 ，而Series能保存不同类型、结构的数据；另外Series的元素带有索引。Series像一个有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中。 可以通过以下方式创建Series数据结构： 字典 一维NumPy数组 单个标量：数值标量、字符串 list、tuple（可以是多层嵌套的list、tuple） Series类 class pandas.Series(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False) 参数： data ： dict 、 array-like 、 list 、 scalar 。如果是序列或数组，则必须是一维的 如果是字典，则字典的键指定了 label 。如果同时使用了 index ，则以 index 为准。 如果是标量，则结果为：该标量扩充为 index 长度相同的列表。 index ：一个 array-like 或者一个 Index 对象。它指定了 label 。其值要求 hashable ，但不要求惟一，长度与 data 一致。如果未提供，则使用 RangeIndex (0, 1, 2, ..., n) 。 name ： str ， Series 的名字。 dtype ：指定数据类型。如果为 None ，则数据类型被自动推断 copy ：一个布尔值。如果为 True ，则拷贝输入数据 data 还可以通过类方法创建 Series ： Series.from_array(arr, index=None, name=None, dtype=None, copy=False, fastpath=False) 但 from_array 类方法会在未来的版本中被移除。 从 dict 来创建 如果只传入一个字典，则结果Series中的索引就是原字典的键： sdata = { 'Ohio' : 35000 , 'Texas' : 71000 , 'Oregon' : 16000 , 'Utah' : 5000 } # dict的key是无序的，但series的index是有序的 Series ( sdata ) Ohio 35000 Texas 71000 Oregon 16000 Utah 5000 dtype: int64 也可以指定原字典的key的排列顺序： 注意 如果传入dict和并指定index，index需要和dict的键匹配，若index不在dict的key中，对应的series值则为NaN。 sdata = { 'Ohio' : 35000 , 'Texas' : 71000 , 'Oregon' : 16000 , 'Utah' : 5000 } states = [ 'California' , 'Ohio' , 'Oregon' , 'Texas' ] Series ( sdata , index = states ) California NaN Ohio 35000.0 Oregon 16000.0 Texas 71000.0 dtype: float64 从NumPy数组来创建 数组必须是一维的： import numpy as np a = np . array ([ 1 , 2 , 3 ]) Series ( a ) 0 1 1 2 2 3 dtype: int32 从标量创建 如果提供索引，将重复标量值以匹配索引的长度。 Series ( 5 , index = [ 0 , 1 , 2 , 3 ]) 0 5 1 5 2 5 3 5 dtype: int64 实际上numpy可以定义储存不同类型数据的结构数组。 ↩","text_tokens":["需要","不同","sdata","匹配","对应","值到","不","import","是","texas","方法","原","标量","从","就是","若","scalar","=",")","又","其值","数据",".","states","label","name","pd","指定","了","2","来","在","str","。","1","自动","ndarray","字典","传入","]","但","与","nan","列表","，","16000.0","定义","值则","用","utah","能够","一致","一个","单个","35000.0","dtype","并","'","为","71000.0","或","index","fastpath","copy","推断","...","嵌套","int64","映射","会","5000","输入","数据类型","true","实际上","使用","-","序列","tuple","或者","rangeindex","保存","有序","该","惟一","oregon","0","布尔值","、","字符","数值","字符串","：","arr","像","值以","只","对象","like","许多","方式","pandas","但是","as","#","类","↩","也","float64","3","同时","名字","class","array","要求","还","因为","带有","结果","未","list","通过","n","版本","hashable","被","为准","{","则","_","的","可以","np","将","函数","a","16000","另外","注意","参数","创建","类型","类似","data","dict",":","提供","索引","顺序","而","from","数据结构","它"," ","移除","键","元素","）","key","多层","结构","长度","任何","ohio","一维","series","以","35000","}","重复","数组","none","int32","[","排列","；","false","california","原本","必须","值","能","如果","储存","扩充","相同","numpy","5","以下","71000","拷贝","无序","未来","布尔",",","和","所有","(","实际","中","（"],"title":"7.1.Series","title_tokens":["7.1",".","series"]},{"location":"pandas笔记/7.1.Series.html#series","text":"class pandas.Series(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False) 参数： data ： dict 、 array-like 、 list 、 scalar 。如果是序列或数组，则必须是一维的 如果是字典，则字典的键指定了 label 。如果同时使用了 index ，则以 index 为准。 如果是标量，则结果为：该标量扩充为 index 长度相同的列表。 index ：一个 array-like 或者一个 Index 对象。它指定了 label 。其值要求 hashable ，但不要求惟一，长度与 data 一致。如果未提供，则使用 RangeIndex (0, 1, 2, ..., n) 。 name ： str ， Series 的名字。 dtype ：指定数据类型。如果为 None ，则数据类型被自动推断 copy ：一个布尔值。如果为 True ，则拷贝输入数据 data 还可以通过类方法创建 Series ： Series.from_array(arr, index=None, name=None, dtype=None, copy=False, fastpath=False) 但 from_array 类方法会在未来的版本中被移除。","text_tokens":["不","是","方法","标量","scalar","=",")","其值",".","数据","label","name","指定","2","了","在","str","。","1","自动","字典","但","与","列表","，","一致","一个","dtype","为","index","fastpath","或","copy","推断","...","会","输入","数据类型","true","使用","-","序列","或者","rangeindex","该","惟一","0","布尔值","、","：","arr","对象","like","pandas","类","同时","名字","class","array","要求","还","结果","未","list","通过","n","版本","hashable","被","为准","则","_","的","可以","参数","创建","类型","data","dict","提供","from","它"," ","移除","键","长度","一维","series","以","数组","none","false","必须","如果","扩充","相同","拷贝","未来","布尔",",","(","中"],"title":"Series类","title_tokens":["series","类"]},{"location":"pandas笔记/7.1.Series.html#dict","text":"如果只传入一个字典，则结果Series中的索引就是原字典的键： sdata = { 'Ohio' : 35000 , 'Texas' : 71000 , 'Oregon' : 16000 , 'Utah' : 5000 } # dict的key是无序的，但series的index是有序的 Series ( sdata ) Ohio 35000 Texas 71000 Oregon 16000 Utah 5000 dtype: int64 也可以指定原字典的key的排列顺序： 注意 如果传入dict和并指定index，index需要和dict的键匹配，若index不在dict的key中，对应的series值则为NaN。 sdata = { 'Ohio' : 35000 , 'Texas' : 71000 , 'Oregon' : 16000 , 'Utah' : 5000 } states = [ 'California' , 'Ohio' , 'Oregon' , 'Texas' ] Series ( sdata , index = states ) California NaN Ohio 35000.0 Oregon 16000.0 Texas 71000.0 dtype: float64","text_tokens":["需要","'","也","float64","匹配","sdata","对应","为","71000.0","index","key","不","是","texas","原","#","就是","ohio","若","结果","series","int64","35000","=","}",")","{","5000","dtype","则","[","排列","的","可以","states","指定","california","16000","在","如果","注意","有序","。","oregon","字典","传入",":","dict","但","索引","71000","顺序","无序","，","nan","]",",","和","：","16000.0","(","值则","utah","一个","中","只"," ","并","35000.0","键"],"title":"从dict来创建","title_tokens":["dict","从","创建","来"]},{"location":"pandas笔记/7.1.Series.html#numpy","text":"数组必须是一维的： import numpy as np a = np . array ([ 1 , 2 , 3 ]) Series ( a ) 0 1 1 2 2 3 dtype: int32","text_tokens":["3","array","import","是","一维","series","=",")","数组",".","int32","[","np","的","2","a","必须","1","0",":","numpy","]",",","：","("," ","as","dtype"],"title":"从NumPy数组来创建","title_tokens":["来","数组","创建","从","numpy"]},{"location":"pandas笔记/7.1.Series.html#_1","text":"如果提供索引，将重复标量值以匹配索引的长度。 Series ( 5 , index = [ 0 , 1 , 2 , 3 ]) 0 5 1 5 2 5 3 5 dtype: int64 实际上numpy可以定义储存不同类型数据的结构数组。 ↩","text_tokens":["3","匹配","不同","index","长度","结构","标量","series","int64","=","重复",")","↩","数组","数据","[","实际上","的","将","可以","2","如果","。","储存","类型","1","0",":","5","]","numpy","提供","索引","，",",","定义","(","实际","值以"," ","dtype"],"title":"从标量创建","title_tokens":["标量","从","创建"]},{"location":"pandas笔记/7.2.DataFrame.html","text":"from pandas import DataFrame from pandas import Series import numpy as np DataFrame类 DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型 1 （数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做是Series的容器。 pandas中的 DataFrame 可以使用以下构造函数创建 - pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) data ：数据可以是各种形式，如: ndarray ， series ， map ， lists ， dict ， constant 和另一个 DataFrame 。 index ：行标签。默认为 np.arrange(n) 。 columns ：列标签。默认为 np.arrange(n) 。 dtype ：数据类型。 copy ：是否复制数据。 可以输入给DataFrame构造器的数据： 类型 说明 二维ndarray 由数组、列表或元组组成的字典 每个序列作为DataFrame的一列。 所有序列的长度必须相同 。 NumPy的结构化/记录数组 类似于“由数组组成的字典” 由Series组成的字典 每个Series会成为一列。如果没有显式指定index，则 各Series的index会被合并成结果的行索引。 每个Series的长度不要求必须相同 ，DataFrame会以NaN填充。 由字典组成的字典 各内层字典会成为一列。键会被合并成结果的行索 弓丨，跟由“Series组成的字典”的情况一样 字典或Series的列表 各项将会成为DataFrame的一行。字典键或Series索引 的并集将会成为DataFrame的列标 由list或tuple组成的list 类似于“二维ndarray” 另—个DataFrame 该DataFrame的索引将会被沿用，除非显式指定了其他索引 NumPy 的 Masked Array 类似于“二维ndarray”的情况，只是掩码值在结果 DataFrame会变成NA/缺失值 总的来说，支持输入的数据类型是： dict 、 list 、 ndarray 、 DataFrame 。 从列表创建 可以使用 单个列表 或 列表内嵌列表 来创建DataFrame。 单个列表的例子： data = [ 1 , 2 , 3 , 4 , 5 ] DataFrame ( data ) 0 0 1 1 2 2 3 3 4 4 5 列表内嵌列表的例子： data = [[ 'Alex' , 10 ],[ 'Bob' , 12 ],[ 'Clarke' , 13 ]] DataFrame ( data , columns = [ 'Name' , 'Age' ]) Name Age 0 Alex 10 1 Bob 12 2 Clarke 13 从包含ndarrays/Lists的字典创建 传入一个由等长list或ndarray组成的字典： 结果DataFrame会自动加上索引（跟Series一样），且全部列 会被有序排列。 data = { 'state' : [ 'Ohio' , 'Ohio' , 'Ohio' , 'Nevada' , 'Nevada' ], 'year' : [ 2000 , 2001 , 2002 , 2001 , 2002 ], 'pop' : [ 1.5 , 1.7 , 3.6 , 2.4 , 2.9 ]} DataFrame ( data ) state year pop 0 Ohio 2000 1.5 1 Ohio 2001 1.7 2 Ohio 2002 3.6 3 Nevada 2001 2.4 4 Nevada 2002 2.9 如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列： DataFrame ( data , columns = [ 'year' , 'state' , 'pop' ]) year state pop 0 2000 Ohio 1.5 1 2001 Ohio 1.7 2 2002 Ohio 3.6 3 2001 Nevada 2.4 4 2002 Nevada 2.9 从字典列表创建 data = [{ 'a' : 1 , 'b' : 2 },{ 'a' : 5 , 'b' : 10 , 'c' : 20 }] DataFrame ( data , index = [ 'first' , 'second' ]) a b c first 1 2 NaN second 5 10 20.0 从Series的字典创建 d = { 'one' : Series ([ 1 , 2 , 3 ], index = [ 'a' , 'b' , 'c' ]), 'two' : Series ([ 1 , 2 , 3 , 4 ], index = [ 'a' , 'b' , 'c' , 'd' ])} df = DataFrame ( d ) df [[ \"two\" , \"two\" ]] two two a 1 1 b 2 2 c 3 3 d 4 4 替代构造函数 DataFrame.from_dict DataFrame.from_dict(data, orient=\"columns\", dtype=None, columns=None) DataFrame.from_dict 接受dict或类似数组的序列的dict并返回DataFrame。 DataFrame . from_dict ( dict ([( 'A' , [ 1 , 2 , 3 ]), ( 'B' , [ 4 , 5 , 6 ])])) DataFrame . from_dict ( dict ([( 'A' , [ 1 , 2 , 3 ]), ( 'B' , [ 4 , 5 , 6 ])]), orient = 'index' , columns = [ 'one' , 'two' , 'three' ]) one two three A 1 2 3 B 4 5 6 DataFrame.from_records DataFrame.from_records( data, index=None, exclude=None, columns=None, coerce_float=False, nrows=None, ) DataFrame.from_records 接受具有结构化dtype的元组或ndarray的列表。它与普通的 DataFrame 构造函数相似，除了所得的DataFrame索引可能是结构化dtype的特定字段。例如： data = np . array ([( 1 , 2. , b 'Hello' ), ( 2 , 3. , b 'World' )], dtype = [( 'A' , '<i4' ), ( 'B' , '<f4' ), ( 'C' , 'S10' )]) DataFrame . from_records ( data , index = 'C' ) A B C b'Hello' 1 2.0 b'World' 2 3.0 DataFrame.from_items DataFrame . from_items ( items , columns = None , orient = 'columns' ) # items ：为元组序列，元组格式为： ( key , value ) # 当 orient = 'index' 时必须传入（此时 key 指定的是行的 label ），且长度不能大于 DataFrame的列数 。 # 当 orient = ' columns时 ， key就是列的label ，此时 columns关键字参数指定的列label必须等于某个key ；否则抛出异常。 从元组序列中创建 DataFrame 。 实际上，DataFrame每一个值都可以是不同的数据类型。 ↩","text_tokens":["不同","不","import","是","”","从","具有","就是","接受","有列","结构化","每个","=","所得",")","作为","且","数据",".","等于","特定","表格","例子","clarke","b","label","name","指定","2","了","来","替代","当","在","关键","。","复制","1","自动","ndarray","字典","传入","]","与","各种","nan","列表","，","加上","就","型","hello","给","2.0","行索","看做","某个","2001","records","一个","map","单个","columns","state","year","构造函数","记录","dtype","容器","并","掩码","'","否则","是否","为","由","index","或","总的来说","包含","丨","copy","—","形式","全部列","弓","coerce","\"","会","长","输入","数据类型","three","格式","exclude","12","world","实际上","元组","使用","nevada","d","orient","器","-","于","20","序列","first","tuple","沿用","其他","value","6","有序","“","二维","该","布尔值","0","全部","、","bob","arrange","成为","字符","数值","成","20.0","字符串","：","i4","抛出","会以","变成","都","构造","默认","pandas","含有","普通","as","#","类","填充","也","按照","不能","3","1.7","↩","2000","array","age","每列","要求","nrows","items","可能","一组","结果","dataframe","list","n","{","被","内层","13","另","则","_","键会","情况","关键字","列","的","np","可以","将","时","/","函数","a","只是","除非","缺失","参数","创建","类型","df","类似","data",":","dict","4","异常","索引","顺序","跟","返回","将会","from","每","数据结构","second","它","float","3.6"," ","支持","没有","2002","two","键","一样","1.5","标签","pop","组成","）","key","结构","长度","constant","ohio","s10","masked","series","合并","字","例如","f4","alex","}","c","数组","none","列数","na","[","排列","等","既有","；","来说","false","ndarrays","各","2.4","值","必须","大于","如果","显式","2.9","一列","相似","lists","行","进行","相同","numpy","个","5","以下","段","布尔",",","和","如","说明","所有","(","列标","one","除了","此时","实际","一行","<","10","中","3.0","集","（","内嵌","各项"],"title":"7.2.DataFrame","title_tokens":["7.2",".","dataframe"]},{"location":"pandas笔记/7.2.DataFrame.html#dataframe","text":"DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型 1 （数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做是Series的容器。 pandas中的 DataFrame 可以使用以下构造函数创建 - pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) data ：数据可以是各种形式，如: ndarray ， series ， map ， lists ， dict ， constant 和另一个 DataFrame 。 index ：行标签。默认为 np.arrange(n) 。 columns ：列标签。默认为 np.arrange(n) 。 dtype ：数据类型。 copy ：是否复制数据。 可以输入给DataFrame构造器的数据： 类型 说明 二维ndarray 由数组、列表或元组组成的字典 每个序列作为DataFrame的一列。 所有序列的长度必须相同 。 NumPy的结构化/记录数组 类似于“由数组组成的字典” 由Series组成的字典 每个Series会成为一列。如果没有显式指定index，则 各Series的index会被合并成结果的行索引。 每个Series的长度不要求必须相同 ，DataFrame会以NaN填充。 由字典组成的字典 各内层字典会成为一列。键会被合并成结果的行索 弓丨，跟由“Series组成的字典”的情况一样 字典或Series的列表 各项将会成为DataFrame的一行。字典键或Series索引 的并集将会成为DataFrame的列标 由list或tuple组成的list 类似于“二维ndarray” 另—个DataFrame 该DataFrame的索引将会被沿用，除非显式指定了其他索引 NumPy 的 Masked Array 类似于“二维ndarray”的情况，只是掩码值在结果 DataFrame会变成NA/缺失值 总的来说，支持输入的数据类型是： dict 、 list 、 ndarray 、 DataFrame 。","text_tokens":["不同","不","是","”","有列","结构化","每个","=",")","作为","数据",".","表格","指定","了","在","。","复制","1","ndarray","字典","各种","nan","列表","，","型","给","行索","看做","一个","map","columns","构造函数","记录","dtype","容器","并","掩码","是否","为","由","index","或","总的来说","丨","copy","—","形式","弓","会","输入","数据类型","元组","使用","器","-","于","序列","tuple","沿用","其他","有序","“","二维","该","布尔值","、","arrange","成为","字符","数值","成","字符串","：","会以","变成","构造","默认","pandas","含有","填充","也","array","每列","要求","一组","结果","dataframe","list","n","被","内层","另","则","键会","情况","列","的","可以","np","将","/","函数","只是","除非","缺失","创建","类型","类似","data",":","dict","索引","跟","将会","数据结构","它"," ","支持","没有","键","一样","标签","组成","）","结构","长度","constant","masked","series","合并","数组","none","na","等","既有","来说","false","各","值","必须","如果","显式","一列","lists","行","相同","numpy","个","以下","布尔",",","和","如","说明","所有","(","列标","一行","中","集","（","各项"],"title":"DataFrame类","title_tokens":["dataframe","类"]},{"location":"pandas笔记/7.2.DataFrame.html#_1","text":"可以使用 单个列表 或 列表内嵌列表 来创建DataFrame。 单个列表的例子： data = [ 1 , 2 , 3 , 4 , 5 ] DataFrame ( data ) 0 0 1 1 2 2 3 3 4 4 5 列表内嵌列表的例子： data = [[ 'Alex' , 10 ],[ 'Bob' , 12 ],[ 'Clarke' , 13 ]] DataFrame ( data , columns = [ 'Name' , 'Age' ]) Name Age 0 Alex 10 1 Bob 12 2 Clarke 13","text_tokens":["'","3","或","age","=","alex",")","dataframe","13","[","12","例子","clarke","的","使用","可以","name","2","来","创建","。","1","data","4","5","]","0","列表","bob",",","：","(","单个"," ","10","columns","内嵌"],"title":"从列表创建","title_tokens":["创建","从","列表"]},{"location":"pandas笔记/7.2.DataFrame.html#ndarrayslists","text":"传入一个由等长list或ndarray组成的字典： 结果DataFrame会自动加上索引（跟Series一样），且全部列 会被有序排列。 data = { 'state' : [ 'Ohio' , 'Ohio' , 'Ohio' , 'Nevada' , 'Nevada' ], 'year' : [ 2000 , 2001 , 2002 , 2001 , 2002 ], 'pop' : [ 1.5 , 1.7 , 3.6 , 2.4 , 2.9 ]} DataFrame ( data ) state year pop 0 Ohio 2000 1.5 1 Ohio 2001 1.7 2 Ohio 2002 3.6 3 Nevada 2001 2.4 4 Nevada 2002 2.9 如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列： DataFrame ( data , columns = [ 'year' , 'state' , 'pop' ]) year state pop 0 2000 Ohio 1.5 1 2001 Ohio 1.7 2 2002 Ohio 3.6 3 2001 Nevada 2.4 4 2002 Nevada 2.9","text_tokens":["一样","'","1.5","按照","1.7","3","由","pop","组成","或","）","2000","columns","进行","ohio","结果","series","全部列","=","}",")","list","长","dataframe","会","{","且","被","则","[","排列","等","列","的","nevada","2","指定","2.4","了","序列","如果","有序","2.9","。","1","自动","ndarray","data","字典","传入",":","全部","]","索引","0","跟","4","，","顺序","加上","就",",","：","(","3.6","2001","一个"," ","year","state","（","2002"],"title":"从包含ndarrays/Lists的字典创建","title_tokens":["ndarrays","/","包含","字典","创建","lists","从","的"]},{"location":"pandas笔记/7.2.DataFrame.html#_2","text":"data = [{ 'a' : 1 , 'b' : 2 },{ 'a' : 5 , 'b' : 10 , 'c' : 20 }] DataFrame ( data , index = [ 'first' , 'second' ]) a b c first 1 2 NaN second 5 10 20.0","text_tokens":["'","index","=","}","c",")","{","dataframe","[","b","2","20","a","first","1","data",":","5","]","nan",",","20.0","second","("," ","10"],"title":"从字典列表创建","title_tokens":["字典","从","创建","列表"]},{"location":"pandas笔记/7.2.DataFrame.html#series","text":"d = { 'one' : Series ([ 1 , 2 , 3 ], index = [ 'a' , 'b' , 'c' ]), 'two' : Series ([ 1 , 2 , 3 , 4 ], index = [ 'a' , 'b' , 'c' , 'd' ])} df = DataFrame ( d ) df [[ \"two\" , \"two\" ]] two two a 1 1 b 2 2 c 3 3 d 4 4","text_tokens":["'","3","index","series","=","}","c",")","{","dataframe","\"","[","b","d","2","a","df","1",":","4","]",",","one","("," ","two"],"title":"从Series的字典创建","title_tokens":["从","创建","字典","的","series"]},{"location":"pandas笔记/7.2.DataFrame.html#_3","text":"","text_tokens":[],"title":"替代构造函数","title_tokens":["替代","函数","构造函数","构造"]},{"location":"pandas笔记/7.2.DataFrame.html#dataframefrom_dict","text":"DataFrame.from_dict(data, orient=\"columns\", dtype=None, columns=None) DataFrame.from_dict 接受dict或类似数组的序列的dict并返回DataFrame。 DataFrame . from_dict ( dict ([( 'A' , [ 1 , 2 , 3 ]), ( 'B' , [ 4 , 5 , 6 ])])) DataFrame . from_dict ( dict ([( 'A' , [ 1 , 2 , 3 ]), ( 'B' , [ 4 , 5 , 6 ])]), orient = 'index' , columns = [ 'one' , 'two' , 'three' ]) one two three A 1 2 3 B 4 5 6","text_tokens":["'","3","或","index","接受","=",")","dataframe","\"","none","数组","three","_",".","[","b","的","orient","2","a","序列","6","。","类似","1","data","dict","4","]","5","返回","from",",","one","("," ","columns","并","two","dtype"],"title":"DataFrame.from_dict","title_tokens":["from","dataframe","_",".","dict"]},{"location":"pandas笔记/7.2.DataFrame.html#dataframefrom_records","text":"DataFrame.from_records( data, index=None, exclude=None, columns=None, coerce_float=False, nrows=None, ) DataFrame.from_records 接受具有结构化dtype的元组或ndarray的列表。它与普通的 DataFrame 构造函数相似，除了所得的DataFrame索引可能是结构化dtype的特定字段。例如： data = np . array ([( 1 , 2. , b 'Hello' ), ( 2 , 3. , b 'World' )], dtype = [( 'A' , '<i4' ), ( 'B' , '<f4' ), ( 'C' , 'S10' )]) DataFrame . from_records ( data , index = 'C' ) A B C b'Hello' 1 2.0 b'World' 2 3.0","text_tokens":["'","3","index","或","array","是","结构","nrows","具有","s10","字","接受","例如","f4","结构化","所得","=","c","coerce",")","dataframe","none","_",".","exclude","[","world","特定","b","的","元组","false","np","2","函数","a","。","相似","1","ndarray","data","]","与","索引","列表","，","i4","from","段","hello",",","除了","：","float","它","(","3.0","构造","records","<"," ","可能","columns","普通","构造函数","dtype","2.0"],"title":"DataFrame.from_records","title_tokens":["from","dataframe","_",".","records"]},{"location":"pandas笔记/7.2.DataFrame.html#dataframefrom_items","text":"DataFrame . from_items ( items , columns = None , orient = 'columns' ) # items ：为元组序列，元组格式为： ( key , value ) # 当 orient = 'index' 时必须传入（此时 key 指定的是行的 label ），且长度不能大于 DataFrame的列数 。 # 当 orient = ' columns时 ， key就是列的label ，此时 columns关键字参数指定的列label必须等于某个key ；否则抛出异常。 从元组序列中创建 DataFrame 。 实际上，DataFrame每一个值都可以是不同的数据类型。 ↩","text_tokens":["'","否则","不同","为","index","key","）","不能","是","长度","items","就是","从","=",")","↩","dataframe","none","列数","数据类型","且","格式","_",".","关键字","数据","等于","实际上","列","；","元组","orient","时","的","label","指定","可以","序列","当","必须","大于","值","value","关键","参数","创建","。","类型","行","传入","异常","，","from","每",",","抛出","：","此时","都","(","某个","实际"," ","中","一个","columns","（","#"],"title":"DataFrame.from_items","title_tokens":["from","dataframe","_",".","items"]},{"location":"开发环境管理/5.1.conda笔记.html","text":"conda usage : conda - script . py [ - h ] [ - V ] command ... conda is a tool for managing and deploying applications , environments and packages . Options : positional arguments : command clean 删除未使用的包和缓存 。 config 修改 . condarc中的配置值 。 create Create a new conda environment from a list of specified packages . help Displays a list of available conda commands and their help strings . info 显示有关当前安装的conda的信息 。 init Initialize conda for shell interaction . [ Experimental ] install 把一个列表中包含的包安装到指定的conda环境 。 list 列出链接到某个conda环境的所有包名 。 remove 从指定的conda环境移除列表中包含的包 。 uninstall conda remove的别名 。 run 在 conda 环境中运行可执行文件 。 [ 实验 ] search Search for packages and display associated information . The input is a MatchSpec , a query language for conda packages . See examples below . update 将 conda 包更新为最新的兼容版本 。 upgrade conda update的别名 optional arguments : - h , -- help Show this help message and exit . - V , -- version Show the conda version number and exit . conda命令 conda info 该命令可以查看当前安装的 conda 的详细信息，包括 conda 版本、python 版本、软件包仓库地址、新建环境的存放路径等。 usage: conda-script.py info [ -h ] [ --json ] [ -v ] [ -q ] [ -a ] [ --base ] [ -e ] [ -s ] [ --unsafe-channels ] Display information about current conda install. Options: optional arguments: -h, --help Show this help message and exit. -a, --all 显示所有信息。 --base 基本显示 base 环境路径。 -e, --envs 列出所有已知的Conda环境。 -s, --system 列出环境变量。 --unsafe-channels Display list of channels with tokens exposed. Output, Prompt, and Flow Control Options: --json Report all output as json. Suitable for using conda programmatically. -v, --verbose Use once for info, twice for debug, three times for trace. -q, --quiet Do not display progress bar. conda create usage: conda-script.py create [ -h ] [ --clone ENV ] [ -n ENVIRONMENT | -p PATH ] [ -c CHANNEL ] [ --use-local ] [ --override-channels ] [ --repodata-fn REPODATA_FNS ] [ --strict-channel-priority ] [ --no-channel-priority ] [ --no-deps | --only-deps ] [ --no-pin ] [ --copy ] [ --no-shortcuts ] [ -C ] [ -k ] [ --offline ] [ -d ] [ --json ] [ -q ] [ -v ] [ -y ] [ --download-only ] [ --show-channel-urls ] [ --file FILE ] [ --no-default-packages ] [ --dev ] [ package_spec [ package_spec ... ]] Create a new conda environment from a list of specified packages. To use the created environment, use 'source activate envname' look in that directory first. This command requires either the -n NAME or -p PREFIX option. Options: positional arguments: package_spec Packages to install or update in the conda environment. optional arguments: -h, --help Show this help message and exit. --clone ENV 通过克隆其他环境来创建一个新环境， 'ENV' 可以是现有本地环境的路径（或名 称）。 --file FILE 从文件创建环境 ( 从给定的文件读入指定版本的包 ) 。可以传递重复的文件规范（例 如--file = file1 --file = file2）。 --dev Use ` sys.executable -m conda ` in wrapper scripts instead of CONDA_EXE This is mainly for use during tests where we test new conda source against old Python versions. Target Environment Specification: -n ENVIRONMENT, --name ENVIRONMENT Name of environment. -p PATH, --prefix PATH Full path to environment location ( i.e. prefix ) . Channel Customization: -c CHANNEL, --channel CHANNEL 用于搜索包的其他通道。这些 URL 按给定顺序搜索 ( 包括本地目录file:// ) 。然 后,搜索 .condarc 中的默认值或通道 ( 除非提供 --override-channels ) 。 您可以使用 \"defaults\" 获取 conda 的默认包。您还可以使用任何名称, .condarc的channel_alias值将预置。默认的channel_alias是 http://conda.anaconda.org/。 --use-local 使用本地构建的包。等同于 \"-c local\" 。 --override-channels 不在 default 或者 .condarc channels 中搜索. Requires --channel. --repodata-fn REPODATA_FNS Specify name of repodata on remote server. Conda will try whatever you specify, but will ultimately fall back to repodata.json if your specs are not satisfiable with what you specify here. This is used to employ repodata that is reduced in time scope. You may pass this flagmore than once. Leftmost entries are tried first, and the fallback torepodata.json is added for you automatically. Solver Mode Modifiers: --strict-channel-priority Packages in lower priority channels are not considered if a package with the same name appears in a higher priority channel. --no-channel-priority Package version takes precedence over channel priority. Overrides the value given by ` conda config --show channel_priority ` . --no-deps Do not install, update, remove, or change dependencies. This WILL lead to broken environments and inconsistent behavior. Use at your own risk. --only-deps Only install dependencies. --no-pin Ignore pinned file. --no-default-packages Ignore create_default_packages in the .condarc file. Package Linking and Install-time Options: --copy Install all packages using copies instead of hard- or soft-linking. --no-shortcuts Don 't install start menu shortcuts Networking Options: -C, --use-index-cache Use cache of channel index files, even if it has expired. -k, --insecure Allow conda to perform \"insecure\" SSL connections and transfers. Equivalent to setting ' ssl_verify ' to ' false '. --offline Offline mode. Don' t connect to the Internet. Output, Prompt, and Flow Control Options: -d, --dry-run Only display what would have been done . --json Report all output as json. Suitable for using conda programmatically. -q, --quiet Do not display progress bar. -v, --verbose Can be used multiple times. Once for INFO, twice for DEBUG, three times for TRACE. -y, --yes Do not ask for confirmation. --download-only Solve an environment and ensure package caches are populated, but exit prior to unlinking and linking packages into the prefix. --show-channel-urls Show channel urls. Overrides the value given by ` conda config --show show_channel_urls ` . conda常用命令 查看信息 # 查看conda的信息 ## 该命令可以查看当前安装的 conda 的详细信息，包括 conda 版本、python 版本、软件包仓库地址、新建环境的存放路径等。 conda info # 查看conda版本信息 conda -V conda --version 环境管理 # 查看环境信息 ## 查看系统中安装的所有环境： ### 这两个命令都可以查看当前 conda 中已经创建的环境列表，处于激活状态的环境旁边会有一个*的字样。 conda env list conda info –-envs conda info -e ## 查看 Conda 环境系统信息： conda info –-system conda info –s ## 查看环境系统更加详细的信息： conda info –-all conda info –a # 进入指定环境 conda activate <env> # 推出环境 conda deactivate # 导出环境 ## 导出环境之前首先要进入该环境 conda list -e > package-list.txt conda list -e > package-list.yml ## 或者这样 ### 这会将当前环境中由 conda 管理的包和由 pip 安装的包同时导出到文件中，所以当根据文件创建环境时，无需重新安装 pip 的包。 conda env export –-name base –-file base_bunnies.yml # 创建环境 ## 新建一个名为 newenv 的环境，并指定新环境中的 python 版本为 3.6 创建出来的环境中只带有最基本的包 conda create --name newenv python = 3 .6 ## 也可以在创建环境时候，包含某些程序或者包 conda create --name newenv python = 3 .6 biopython ipython ## 通过克隆创建一个新环境 conda create –-name newenv –clone base ## 从文件创建环境 ### 如果是用 conda env export --name 导出的文件，则可用下列命令创建： conda env create -f package-list.yml ### 如果是用 conda list -e 导出的文件，则用如下方式创建： conda create –-name <env> –-file <deps file> # 更新环境 conda env update –-name <env> –file = <deps file> # 删除环境 ## 删除环境中指定的包： conda remove –-name <env> ipython biopython ## 彻底删除环境： conda env remove –name <env> 从指定路径安装环境 conda 创建出来的环境默认放在 /User/<yourname>/anaconda/env 目录下，你可以将其中的某个环境文件夹整体拷贝走，复制到另一台机器上，然后基于此文件夹创建环境。 包管理 conda list # 查看已经安装的包 conda update conda # 升级conda自身 conda search requests # 查询某个包 conda install requests # 安装新包 conda install -n base requests # 将包安装到指定环境 conda update --all # 更新所有包 conda update requests # 升级包 conda remove requests # 移除包 conda remove -n base requests # 从指定环境中移除包 conda 不提供检查可更新的包的命令，update 所有包时会有提示，列出所有可更新的包，并让用户确认是否全部更新。 为 anaconda 指定国内镜像源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes 使用 conda config --show channels 命令可以查看当前的源仓库地址。","text_tokens":["done","系统","tried","their","然后","try","networking","the","deactivate","ultimately","internet","自身","channels","重新安装","name","旁边","推出","##","]","最新","json","don","###","message","时候","help","并","ask","这样","e","为","upgrade","详细信息","you","包","trace","k","fn","requires","q","during","提示","\"","change","已知","we","newenv","caches","这会","使用","-","tool","env","其他","6","suitable","之前","上","基于","该",">","time","程序","进入","、","等同于","兼容","applications","用户","cache","here","sys","新包","usage","仓库","默认","只","您","#","已经","has","3","appears","还","debug","than","n","to","requests","programmatically","employ","机器","exit","pkgs","unsafe","a","创建","pinned","query","associated","positional","状态","dry","镜像","新安","变量","it","3.6","列出","文件创建","）","*","另一台","are","with","更新","exe","see","higher","deps","broken","satisfiable","[","automatically","path","copies","pin","unlinking","常用命令","实验","use","below","或名","新","到","ipython","even","拷贝","insecure",",","时会","files","populated","激活","do","directory","m","full","源","managing","激活状态","从","envs","prior","leftmost","add","remove","详细","location","own","connect","target","规范","fall","overrides","risk","would","给定","back","有关","specs","，","over","出来","有","某个","language","output","等同","一个","新建","verify","arguments","versions","allow","against","py","这些","修改","display","首先","d","彻底","version","把","或者","路径","别名","solver","behavior","升级包","base","全部","默认值","an","：","p","system","i","interaction","entries","读入","repodata","setting","available","所以","mirrors","offline","remote","缓存","–","管理","某些","件夹","edu","未","export","list","progress","导出","信息","instead","将","可以","时","that","create","report","test","显示","set","old","可","可用","提供","urls","multiple","环境","can","strict","配置","tests","删除","名为","either","ssl","复制到","任何","查看","y","重复","c","perform","exposed","执行","你","要","等","file2","executable","used","package","in","options","查询","文件夹","如","中","prefix","is","包括","不","是","|","connections","channel","equivalent","=","让","activate","这","`","f","priority","软件包","times","install","常用","yourname","用","fallback","lower","dev","specify","mode","由","是否","或","包含","升级","copy","http","optional","source","three","会","added","无需","whatever","uninstall","deploying","cn","free","python","版本信息","config","根据","on","安装","mainly","yml","control","pass","基本","链接","given","本地","wrapper","更加","transfers","现有","都","shortcuts","environments","行文","顺序搜索","override","搜索","main","运行","quiet","not","as","其中","走","也","ensure","about","带有","预置","inconsistent","init","则","of","的","created","once","confirmation","整体","may","按","scope","环境变量","顺序","current","by","considered","have","start"," ","new","option","软件","国内","local","clean","input","false","show","verbose","确认","通道","s","ignore","menu","如果","envname","处于","specification","一台","和","pip","(","目录","<","当前","twice","hard","all","command","url","condarc","https","download","be","spec","bar",")","获取",".","modifiers","指定","clone","来","into","当","在","look","。","复制","run","命令","字样","列表","default","名称","h","后","放在","biopython","'","包名","flagmore","experimental","index","been","file","...","customization","传递","然","tsinghua","重新","using","will","文件","strings","update","anaconda","例","txt","first","用于","value","称","此","specified","displays","克隆","环境中运行","commands","number","同于","only","dependencies","linking","方式","and","precedence","shell","search","同时","地址","scripts","如下","v","initialize","no","matchspec","what","takes","环境变","t","版本","通过","environment","构建","user","_","for","this","/","examples","除非","defaults","but","where","if","最",":","your","tokens","org","server","from","fns","solve","flow","移除","information","检查","conda","soft","存放","same","prompt","at","lead","expired","packages","torepodata","reduced","info","两个","bunnies","file1","值","可执行文件","下列","yes","alias","or","tuna","下","所有","script","（"],"title":"5.1.conda笔记","title_tokens":[".","conda","5.1","笔记"]},{"location":"开发环境管理/5.1.conda笔记.html#conda","text":"usage : conda - script . py [ - h ] [ - V ] command ... conda is a tool for managing and deploying applications , environments and packages . Options : positional arguments : command clean 删除未使用的包和缓存 。 config 修改 . condarc中的配置值 。 create Create a new conda environment from a list of specified packages . help Displays a list of available conda commands and their help strings . info 显示有关当前安装的conda的信息 。 init Initialize conda for shell interaction . [ Experimental ] install 把一个列表中包含的包安装到指定的conda环境 。 list 列出链接到某个conda环境的所有包名 。 remove 从指定的conda环境移除列表中包含的包 。 uninstall conda remove的别名 。 run 在 conda 环境中运行可执行文件 。 [ 实验 ] search Search for packages and display associated information . The input is a MatchSpec , a query language for conda packages . See examples below . update 将 conda 包更新为最新的兼容版本 。 upgrade conda update的别名 optional arguments : - h , -- help Show this help message and exit . - V , -- version Show the conda version number and exit .","text_tokens":["is","command","their","managing","condarc","从","the","remove",".","指定","install","在","。","run","]","有关","最新","列表","message","某个","h","language","一个","help","包名","为","arguments","experimental","upgrade","包","包含","...","optional","py","修改","文件","display","strings","update","uninstall","deploying","使用","-","version","把","config","tool","别名","specified","安装","displays","环境中运行","commands","number","链接","兼容","applications","environments","行文","usage","interaction","运行","and","shell","search","available","v","initialize","缓存","matchspec","未","list","environment","版本","init","信息","of","for","this","exit","的","将","a","examples","create","显示","query","associated",":","positional","from","环境"," ","列出","配置","移除","删除","information","new","conda","clean","更新","see","执行","[","packages","input","info","show","值","可执行文件","实验","below","到","options",",","和","所有","script","中","当前"],"title":"conda","title_tokens":["conda"]},{"location":"开发环境管理/5.1.conda笔记.html#conda_1","text":"","text_tokens":[],"title":"conda命令","title_tokens":["命令","conda"]},{"location":"开发环境管理/5.1.conda笔记.html#conda-info","text":"该命令可以查看当前安装的 conda 的详细信息，包括 conda 版本、python 版本、软件包仓库地址、新建环境的存放路径等。 usage: conda-script.py info [ -h ] [ --json ] [ -v ] [ -q ] [ -a ] [ --base ] [ -e ] [ -s ] [ --unsafe-channels ] Display information about current conda install. Options: optional arguments: -h, --help Show this help message and exit. -a, --all 显示所有信息。 --base 基本显示 base 环境路径。 -e, --envs 列出所有已知的Conda环境。 -s, --system 列出环境变量。 --unsafe-channels Display list of channels with tokens exposed. Output, Prompt, and Flow Control Options: --json Report all output as json. Suitable for using conda programmatically. -v, --verbose Use once for info, twice for debug, three times for trace. -q, --quiet Do not display progress bar.","text_tokens":["all","包括","envs","bar","详细",".","channels","软件包","times","install","。","命令","]","，","json","message","h","output","help","新建","e","arguments","详细信息","trace","optional","q","py","three","已知","using","display","-","python","路径","suitable","安装","该","control","base","基本","、","system","usage","仓库","quiet","not","as","and","地址","about","v","debug","环境变","版本","list","progress","programmatically","信息","of","for","this","exit","的","可以","once","unsafe","a","report","显示",":","tokens","环境变量","current","变量","环境"," ","flow","列出","information","conda","软件","存放","prompt","with","查看","exposed","[","等","info","show","verbose","s","use","options",",","所有","script","当前","twice","do"],"title":"conda info","title_tokens":["info","conda"," "]},{"location":"开发环境管理/5.1.conda笔记.html#conda-create","text":"usage: conda-script.py create [ -h ] [ --clone ENV ] [ -n ENVIRONMENT | -p PATH ] [ -c CHANNEL ] [ --use-local ] [ --override-channels ] [ --repodata-fn REPODATA_FNS ] [ --strict-channel-priority ] [ --no-channel-priority ] [ --no-deps | --only-deps ] [ --no-pin ] [ --copy ] [ --no-shortcuts ] [ -C ] [ -k ] [ --offline ] [ -d ] [ --json ] [ -q ] [ -v ] [ -y ] [ --download-only ] [ --show-channel-urls ] [ --file FILE ] [ --no-default-packages ] [ --dev ] [ package_spec [ package_spec ... ]] Create a new conda environment from a list of specified packages. To use the created environment, use 'source activate envname' look in that directory first. This command requires either the -n NAME or -p PREFIX option. Options: positional arguments: package_spec Packages to install or update in the conda environment. optional arguments: -h, --help Show this help message and exit. --clone ENV 通过克隆其他环境来创建一个新环境， 'ENV' 可以是现有本地环境的路径（或名 称）。 --file FILE 从文件创建环境 ( 从给定的文件读入指定版本的包 ) 。可以传递重复的文件规范（例 如--file = file1 --file = file2）。 --dev Use ` sys.executable -m conda ` in wrapper scripts instead of CONDA_EXE This is mainly for use during tests where we test new conda source against old Python versions. Target Environment Specification: -n ENVIRONMENT, --name ENVIRONMENT Name of environment. -p PATH, --prefix PATH Full path to environment location ( i.e. prefix ) . Channel Customization: -c CHANNEL, --channel CHANNEL 用于搜索包的其他通道。这些 URL 按给定顺序搜索 ( 包括本地目录file:// ) 。然 后,搜索 .condarc 中的默认值或通道 ( 除非提供 --override-channels ) 。 您可以使用 \"defaults\" 获取 conda 的默认包。您还可以使用任何名称, .condarc的channel_alias值将预置。默认的channel_alias是 http://conda.anaconda.org/。 --use-local 使用本地构建的包。等同于 \"-c local\" 。 --override-channels 不在 default 或者 .condarc channels 中搜索. Requires --channel. --repodata-fn REPODATA_FNS Specify name of repodata on remote server. Conda will try whatever you specify, but will ultimately fall back to repodata.json if your specs are not satisfiable with what you specify here. This is used to employ repodata that is reduced in time scope. You may pass this flagmore than once. Leftmost entries are tried first, and the fallback torepodata.json is added for you automatically. Solver Mode Modifiers: --strict-channel-priority Packages in lower priority channels are not considered if a package with the same name appears in a higher priority channel. --no-channel-priority Package version takes precedence over channel priority. Overrides the value given by ` conda config --show channel_priority ` . --no-deps Do not install, update, remove, or change dependencies. This WILL lead to broken environments and inconsistent behavior. Use at your own risk. --only-deps Only install dependencies. --no-pin Ignore pinned file. --no-default-packages Ignore create_default_packages in the .condarc file. Package Linking and Install-time Options: --copy Install all packages using copies instead of hard- or soft-linking. --no-shortcuts Don 't install start menu shortcuts Networking Options: -C, --use-index-cache Use cache of channel index files, even if it has expired. -k, --insecure Allow conda to perform \"insecure\" SSL connections and transfers. Equivalent to setting ' ssl_verify ' to ' false '. --offline Offline mode. Don' t connect to the Internet. Output, Prompt, and Flow Control Options: -d, --dry-run Only display what would have been done . --json Report all output as json. Suitable for using conda programmatically. -q, --quiet Do not display progress bar. -v, --verbose Can be used multiple times. Once for INFO, twice for DEBUG, three times for TRACE. -y, --yes Do not ask for confirmation. --download-only Solve an environment and ensure package caches are populated, but exit prior to unlinking and linking packages into the prefix. --show-channel-urls Show channel urls. Overrides the value given by ` conda config --show show_channel_urls ` .","text_tokens":["done","tried","try","networking","the","ultimately","internet","channels","name","]","json","don","message","help","ask","e","you","包","trace","k","fn","requires","q","during","\"","change","we","caches","使用","-","env","其他","suitable","time","等同于","cache","here","sys","usage","默认","您","has","appears","还","debug","than","n","to","employ","programmatically","exit","a","创建","pinned","positional","dry","it","文件创建","）","are","with","exe","higher","deps","broken","satisfiable","[","automatically","path","copies","pin","unlinking","use","或名","新","even","insecure",",","files","populated","do","directory","m","full","从","prior","leftmost","remove","location","own","connect","target","规范","fall","overrides","risk","would","给定","back","specs","，","over","output","等同","一个","verify","arguments","versions","allow","against","py","这些","display","d","version","或者","路径","solver","behavior","默认值","an","p","i","entries","读入","repodata","setting","offline","remote","list","progress","instead","可以","将","that","create","test","report","old","提供","urls","multiple","环境","can","strict","tests","either","ssl","任何","y","重复","c","perform","file2","executable","used","package","in","options","如","中","prefix","is","包括","不","是","|","connections","channel","equivalent","=","activate","`","priority","times","install","fallback","lower","dev","specify","mode","或","copy","http","optional","source","three","added","whatever","python","config","on","mainly","control","pass","given","本地","wrapper","transfers","现有","shortcuts","environments","顺序搜索","override","搜索","not","quiet","as","ensure","预置","inconsistent","of","的","created","once","confirmation","may","按","scope","顺序","by","considered","have","start"," ","new","option","local","false","show","verbose","通道","ignore","menu","envname","specification","(","目录","twice","hard","all","command","url","condarc","download","be","spec","获取",")","bar",".","modifiers","指定","clone","来","into","在","look","。","run","default","名称","h","后","'","flagmore","index","been","file","...","customization","传递","然","will","using","文件","update","anaconda","例","first","用于","value","称","specified","克隆","同于","only","dependencies","linking","and","precedence","scripts","v","no","what","takes","t","版本","environment","通过","构建","_","for","this","/","除非","defaults","but","where","if",":","your","org","server","from","fns","solve","flow","conda","soft","same","prompt","at","lead","expired","packages","torepodata","reduced","info","file1","值","yes","alias","or","script","（"],"title":"conda create","title_tokens":["conda"," ","create"]},{"location":"开发环境管理/5.1.conda笔记.html#conda_2","text":"","text_tokens":[],"title":"conda常用命令","title_tokens":["命令","conda","常用","常用命令"]},{"location":"开发环境管理/5.1.conda笔记.html#_1","text":"# 查看conda的信息 ## 该命令可以查看当前安装的 conda 的详细信息，包括 conda 版本、python 版本、软件包仓库地址、新建环境的存放路径等。 conda info # 查看conda版本信息 conda -V conda --version","text_tokens":["conda","地址","软件","详细信息","包括","存放","v","查看","版本","详细","信息","等","info","的","可以","-","python","软件包","版本信息","version","路径","安装","。","该","##","命令","、","，","环境"," ","仓库","当前","新建","#"],"title":"查看信息","title_tokens":["信息","查看"]},{"location":"开发环境管理/5.1.conda笔记.html#_2","text":"# 查看环境信息 ## 查看系统中安装的所有环境： ### 这两个命令都可以查看当前 conda 中已经创建的环境列表，处于激活状态的环境旁边会有一个*的字样。 conda env list conda info –-envs conda info -e ## 查看 Conda 环境系统信息： conda info –-system conda info –s ## 查看环境系统更加详细的信息： conda info –-all conda info –a # 进入指定环境 conda activate <env> # 推出环境 conda deactivate # 导出环境 ## 导出环境之前首先要进入该环境 conda list -e > package-list.txt conda list -e > package-list.yml ## 或者这样 ### 这会将当前环境中由 conda 管理的包和由 pip 安装的包同时导出到文件中，所以当根据文件创建环境时，无需重新安装 pip 的包。 conda env export –-name base –-file base_bunnies.yml # 创建环境 ## 新建一个名为 newenv 的环境，并指定新环境中的 python 版本为 3.6 创建出来的环境中只带有最基本的包 conda create --name newenv python = 3 .6 ## 也可以在创建环境时候，包含某些程序或者包 conda create --name newenv python = 3 .6 biopython ipython ## 通过克隆创建一个新环境 conda create –-name newenv –clone base ## 从文件创建环境 ### 如果是用 conda env export --name 导出的文件，则可用下列命令创建： conda env create -f package-list.yml ### 如果是用 conda list -e 导出的文件，则用如下方式创建： conda create –-name <env> –-file <deps file> # 更新环境 conda env update –-name <env> –file = <deps file> # 删除环境 ## 删除环境中指定的包： conda remove –-name <env> ipython biopython ## 彻底删除环境： conda env remove –name <env>","text_tokens":["系统","all","是","激活状态","从","envs","deactivate","=","activate","这","remove","详细",".","f","重新安装","name","指定","clone","当","在","旁边","推出","。","##","命令","字样","列表","，","出来","###","有","用","时候","一个","新建","并","biopython","这样","e","由","为","包","包含","file","会","无需","重新","newenv","文件","update","首先","这会","彻底","-","txt","python","根据","env","或者","6","之前","安装","该","克隆","yml",">","程序","base","进入","基本","更加","都","：","system","只","方式","#","已经","也","3","同时","如下","所以","带有","–","管理","某些","export","list","版本","导出","通过","信息","_","则","的","可以","将","时","a","create","创建","最","可用","状态","新安","环境","3.6"," ","名为","删除","文件创建","conda","*","查看","更新","deps","要","info","两个","bunnies","s","如果","下列","处于","package","新","到","ipython","和","pip","所有","<","中","当前","激活"],"title":"环境管理","title_tokens":["环境","管理"]},{"location":"开发环境管理/5.1.conda笔记.html#_3","text":"conda 创建出来的环境默认放在 /User/<yourname>/anaconda/env 目录下，你可以将其中的某个环境文件夹整体拷贝走，复制到另一台机器上，然后基于此文件夹创建环境。","text_tokens":["走","conda","然后","另一台","复制到","件夹","user","你","文件","anaconda","机器","的","可以","将","/","env","此","创建","整体","上","复制","基于","。",">","拷贝","，","一台","出来","yourname","文件夹","下","环境","某个","目录","<"," ","默认","其中","放在"],"title":"从指定路径安装环境","title_tokens":["指定","路径","环境","安装","从"]},{"location":"开发环境管理/5.1.conda笔记.html#_4","text":"conda list # 查看已经安装的包 conda update conda # 升级conda自身 conda search requests # 查询某个包 conda install requests # 安装新包 conda install -n base requests # 将包安装到指定环境 conda update --all # 更新所有包 conda update requests # 升级包 conda remove requests # 移除包 conda remove -n base requests # 从指定环境中移除包 conda 不提供检查可更新的包的命令，update 所有包时会有提示，列出所有可更新的包，并让用户确认是否全部更新。","text_tokens":["检查","conda","是否","all","search","不","包","升级","从","查看","更新","让","提示","list","remove","n","requests","update","自身","的","将","指定","-","确认","install","安装","。","升级包","可","命令","到","base","提供","全部","，","查询","用户","所有","新包","某个","环境","时会","有"," ","中","列出","并","移除","#","已经"],"title":"包管理","title_tokens":["管理","包"]},{"location":"开发环境管理/5.1.conda笔记.html#anaconda","text":"conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes 使用 conda config --show channels 命令可以查看当前的源仓库地址。","text_tokens":["conda","地址","源","mirrors","https","channel","add","查看","edu","tsinghua","_",".","anaconda","channels","cn","的","pkgs","使用","show","free","/","-","可以","config","yes","。","set",":","命令","urls","tuna"," ","main","当前","仓库"],"title":"为 anaconda 指定国内镜像源","title_tokens":["指定","镜像","为","国内","源","anaconda"," "]},{"location":"开发环境管理/5.3.pip对比conda.html","text":"了解conda and pip的异同 本文翻译自 Understanding Conda and Pip ( Jonathan Helmus )。 Conda和pip这两个工具有一些重叠的功能，因此它们常常被认为是没什么区别的，但实际上它们被设计用于不同的目的。 pip 是Python Packaging Authority 推荐的从 Python Package Index (PyPI)安装包的工具。 pip可以安装打包为wheels格式的包，或者直接从源代码编译安装。从源代码文件安装可能需要系统安装兼容的编译器和相应的库 1 。 Conda 是跨平台的包和环境管理器，可以安装和管理来自 Anaconda repository 和 Anaconda Cloud 的conda包。Conda包是二进制文件，不需要使用编译器来安装。另外，conda包不限于Python包，还可以包含C或C++ 库、R包或任何其他软件。 这是conda和pip的关键区别。pip只能安装Python包，而conda安装的包可以是用任何语言编写的。例如，在使用pip之前，必须通过”系统程序管理器“或”下载并运行安装程序“来安装Python解释器，而Conda可以直接安装Python包和Python解释器。 这两个工具的另一个显著区别是conda可以为不同版本的python或package创建隔离的环境。这在使用数据科学工具时非常有用，因为不同的工具可能包含冲突的依赖，这可能会导致它们不适合安装到相同的环境中。pip没有内置的环境管理功能，而是依赖于 virtualenv 或 venv 等其他工具来创建隔离环境。 pipenv、poetry、hatch wrap pip、virtualenv等工具提供了统一的方法来创建单独的环境。 pip和conda在如何实现环境中的依赖关系方面也有所不同。安装包时，pip会在递归的串行循环中安装依赖项，没有努力确保同时满足所有包的依赖性。如果较早安装的包与稍后安装的包具有不兼容的依赖，环境就会被破坏。相反的，conda使用一个satisfiability (SAT)的处理程序去检查环境中的所有包的依赖是否都得到满足。此检查可能需要额外的时间，但可以防止创建一个被破坏的环境。只要包含依赖关系的package metadata是正确的，conda就可以创建有效的环境。 考虑到conda和pip之间的相似性，有些人试图将这些工具结合起来创建数据科学环境也就不足为奇了。将pip与conda结合的主要原因是有些包只能通过pip安装。在Anaconda repository中有1500多个包可用，其中涵盖了最流行的数据科学、机器学习和AI框架。另外，在conda-forge和bioconda的channel还有数以千计的包可以使用conda安装。尽管Anaconda cloud有大量的包，但与PyPI上可提供的150,000多个包相比，数量仍然很少。有时候需要的包没有相应的conda包，但在PyPI上有安装文件，则可以用pip安装。 补充 conda 安装包路径是 \\Anaconda3\\pkgs pip 安装包路径在虚拟环境下是 \\Anaconda3\\envs\\Lib\\site-packages pip可能会生成存在冲突的环境，而conda不会 pip与conda不会重复安装已经安装的依赖 pip安装的包不会显示在anaconda navigation的环境中 conda 为多个环境安装包时，对于同一个包只安装一次，由conda集中管理 pip 为多个环境安装包时，因为每个环境安装包使用的pip在不同的路径下，因此会重复安装 关于Python包管理工具的发展历史可以参考 Python's New Package Landscape (andrew)，其中文翻译版本 在这 。插图来自https://www.xkcd.com/1987/。 编译器和库用于编译源代码。 ↩","text_tokens":["需要","系统","不同","隔离","不","是","显著","工具","方法","下载","时间","之间","了解","目的","从","”","具有","起来","跨平台","channel","envs","每个","库","000",")","这","navigation","补充","有些","不足","有时候","一些","对于","数据",".","同一个","较","很少","landscape","r","正确","来","二进制","依赖","了","中有","在","尽管","统一","\\","中文","关键","1987","venv","jonathan","。","1","但","与","虚拟环境","，","平台","就","科学","andrew","集中","有","插图","用","时候","一个","而是","可能","源代码","并","数以千计","编写","相应","'","语言","早","是否","为","框架","由","index","或","包","包含","非常","不足为奇","c++","www","pipenv","功能","forge","同一","1500","helmus","赖于","没什么","循环","管理工具","流行","进制","编译器","会","包是","poetry","格式","管理器","关系","文件","考虑","anaconda","重叠","实际上","依赖于","有所不同","关于","使用","一次","数量","-","python","来自","只能","认为","用于","或者","其他","ai","此","破坏","路径","之前","发展","安装","“","递归","上","生成","其","150","pypi","repository","程序","方面","、","解释","这是","兼容","metadata","大量","编译","都","hatch","得到","其他软件","打包","运行","安装程序","其中","virtualenv","已经","and","也","↩","集中管理","同时","理工","去","它们","还","处理","因为","多个","历史","管理","防止","版本","通过","结合","被","xkcd","另","则","understanding","机器","什么","依赖性","lib","的","可以","时","冲突","将","设计","sat","原因","串行","pkgs","实现","/","稍后","另外","bioconda","满足","不会","虚拟","创建","存在","显示","可","最","有所","人",":","可用","anaconda3","提供","区别","而","相反","直接","authority","这些","包不","仍然","环境","解释器","推荐","理器"," ","没有","适合","检查","conda","本文","如何","努力","new","软件","任何","主要","site","例如","satisfiability","有效","常常","重复","c","处理程序","包只","释器","因此","只要","有时","限于","确保","安装包","等","wrap","两个","学习","代码","安装文件","packages","com","翻译","cloud","必须","试图","还有","参考","如果","s","相似","导致","相似性","package","到","相同","单独","内置","https","额外",",","自","pip","和","所有","(","wheels","相比","下","实际","项","涵盖","中","中文翻译","有用","异同","packaging"],"title":"5.3.pip对比conda","title_tokens":["conda","pip","5.3",".","对比"]},{"location":"开发环境管理/5.3.pip对比conda.html#conda-and-pip","text":"本文翻译自 Understanding Conda and Pip ( Jonathan Helmus )。 Conda和pip这两个工具有一些重叠的功能，因此它们常常被认为是没什么区别的，但实际上它们被设计用于不同的目的。 pip 是Python Packaging Authority 推荐的从 Python Package Index (PyPI)安装包的工具。 pip可以安装打包为wheels格式的包，或者直接从源代码编译安装。从源代码文件安装可能需要系统安装兼容的编译器和相应的库 1 。 Conda 是跨平台的包和环境管理器，可以安装和管理来自 Anaconda repository 和 Anaconda Cloud 的conda包。Conda包是二进制文件，不需要使用编译器来安装。另外，conda包不限于Python包，还可以包含C或C++ 库、R包或任何其他软件。 这是conda和pip的关键区别。pip只能安装Python包，而conda安装的包可以是用任何语言编写的。例如，在使用pip之前，必须通过”系统程序管理器“或”下载并运行安装程序“来安装Python解释器，而Conda可以直接安装Python包和Python解释器。 这两个工具的另一个显著区别是conda可以为不同版本的python或package创建隔离的环境。这在使用数据科学工具时非常有用，因为不同的工具可能包含冲突的依赖，这可能会导致它们不适合安装到相同的环境中。pip没有内置的环境管理功能，而是依赖于 virtualenv 或 venv 等其他工具来创建隔离环境。 pipenv、poetry、hatch wrap pip、virtualenv等工具提供了统一的方法来创建单独的环境。 pip和conda在如何实现环境中的依赖关系方面也有所不同。安装包时，pip会在递归的串行循环中安装依赖项，没有努力确保同时满足所有包的依赖性。如果较早安装的包与稍后安装的包具有不兼容的依赖，环境就会被破坏。相反的，conda使用一个satisfiability (SAT)的处理程序去检查环境中的所有包的依赖是否都得到满足。此检查可能需要额外的时间，但可以防止创建一个被破坏的环境。只要包含依赖关系的package metadata是正确的，conda就可以创建有效的环境。 考虑到conda和pip之间的相似性，有些人试图将这些工具结合起来创建数据科学环境也就不足为奇了。将pip与conda结合的主要原因是有些包只能通过pip安装。在Anaconda repository中有1500多个包可用，其中涵盖了最流行的数据科学、机器学习和AI框架。另外，在conda-forge和bioconda的channel还有数以千计的包可以使用conda安装。尽管Anaconda cloud有大量的包，但与PyPI上可提供的150,000多个包相比，数量仍然很少。有时候需要的包没有相应的conda包，但在PyPI上有安装文件，则可以用pip安装。","text_tokens":["需要","系统","不同","隔离","不","是","显著","工具","方法","下载","时间","之间","”","目的","从","具有","起来","channel","跨平台","库","000",")","这","有些","不足","有时候","一些","数据","较","很少","r","正确","来","二进制","依赖","了","中有","在","尽管","统一","关键","venv","jonathan","。","1","但","与","，","平台","就","科学","有","用","时候","一个","而是","可能","源代码","并","数以千计","编写","相应","语言","早","是否","为","框架","index","或","包","包含","非常","不足为奇","c++","pipenv","功能","forge","1500","helmus","赖于","没什么","循环","流行","进制","编译器","会","包是","poetry","格式","管理器","关系","文件","考虑","anaconda","重叠","实际上","依赖于","有所不同","使用","数量","-","python","来自","只能","认为","用于","或者","其他","ai","此","破坏","之前","安装","“","递归","上","150","pypi","repository","程序","方面","、","解释","这是","兼容","metadata","大量","编译","都","hatch","得到","其他软件","打包","运行","安装程序","其中","virtualenv","and","也","同时","去","它们","还","处理","因为","多个","管理","防止","版本","通过","结合","被","另","则","understanding","机器","什么","依赖性","的","可以","时","冲突","将","设计","原因","串行","实现","稍后","另外","bioconda","满足","创建","可","最","有所","人","可用","提供","区别","而","相反","直接","authority","这些","包不","仍然","环境","解释器","推荐","理器"," ","没有","适合","检查","本文","conda","如何","努力","软件","任何","主要","例如","satisfiability","有效","常常","c","处理程序","释器","因此","只要","有时","限于","确保","安装包","等","wrap","两个","学习","代码","安装文件","翻译","cloud","必须","试图","还有","如果","相似","导致","相似性","package","到","相同","单独","内置","额外",",","自","pip","和","所有","(","wheels","相比","实际","项","涵盖","中","有用","sat","packaging"],"title":"了解conda and pip的异同","title_tokens":["and","conda","pip"," ","了解","的","异同"]},{"location":"开发环境管理/5.3.pip对比conda.html#_1","text":"conda 安装包路径是 \\Anaconda3\\pkgs pip 安装包路径在虚拟环境下是 \\Anaconda3\\envs\\Lib\\site-packages pip可能会生成存在冲突的环境，而conda不会 pip与conda不会重复安装已经安装的依赖 pip安装的包不会显示在anaconda navigation的环境中 conda 为多个环境安装包时，对于同一个包只安装一次，由conda集中管理 pip 为多个环境安装包时，因为每个环境安装包使用的pip在不同的路径下，因此会重复安装 关于Python包管理工具的发展历史可以参考 Python's New Package Landscape (andrew)，其中文翻译版本 在这 。插图来自https://www.xkcd.com/1987/。 编译器和库用于编译源代码。 ↩","text_tokens":["不同","是","工具","https","envs","每个","库","navigation",")","这","对于",".","同一个","landscape","依赖","中文","在","1987","。","与","虚拟环境","，","andrew","集中","插图","一个","可能","源代码","'","由","为","包","同一","\\","会","编译器","anaconda","关于","使用","一次","-","python","来自","用于","路径","发展","安装","生成","其","编译","↩","已经","集中管理","理工","因为","多个","历史","管理","版本","xkcd","lib","的","pkgs","时","冲突","可以","/","显示","不会","虚拟","存在",":","anaconda3","而","环境"," ","new","conda","site","重复","因此","packages","安装包","com","代码","翻译","参考","s","package","包只","下","pip","管理工具","和","(","中","中文翻译","www"],"title":"补充","title_tokens":["补充"]},{"location":"开发环境管理/5.4.anaconda.html","text":"Anaconda下各个文件夹作用 anacoda3/conda-meta/history ：记录用户使用conda命令安装、卸载、升级包的操作 anaconda3/pkgs/urls.txt ：记录用户使用conda命令下载包的地址，直接复制地址到浏览器中也可以下载 anaconda3/conda-meta/ ：文件夹里保存着与各个包同名的.json文件（有些包会有多个.json文件），这些json文件会记录对应的包的版本、存放位置、md5值等信息 anaconda3/pkgs/ ：这个文件夹里存放了每个包刚下载来的文件，格式是.tar.gz2，另外也会自动解压到这个文件夹里。比如你下载了six这个包，anaconda3/pkgs/这个文件夹里会多出如下2个文件。另外，当你卸载包的时候，这里的2个文件是不会被删除的 anaconda3/lib/python3.6/site-packages/ ：包的存放目录 anaconda3/bin ：安装一些包的时候会往里添加一些可执行文件 anaconda3/lib ：安装一些包的时候会往里添加一些.so文件 anaconda3/include ：安装一些包的时候会往里添加了一些文件 anaconda3/man ：安装一些包的时候会往里里添加了一些文件 anaconda3/share ：安装一些包的时候会往里里添加了一些文件","text_tokens":["对应","比如","是","下载","meta","每个","有些","一些",".","2","six","了","来","当","添加","操作","share","。","复制","自动","命令","与","这个","，","json","include","有","时候","anacoda3","记录","多出","包","升级","bin","会","这些","格式","里","文件","anaconda","浏览器","使用","-","txt","保存","安装","升级包","、","md5","用户","：","解压","行文","卸载","着","也","位置","地址","如下","多个","会往","这里","件夹","tar","版本","被","各个","信息","lib","的","pkgs","可以","/","so","另外","不会","浏览","anaconda3","urls","直接","同名"," ","删除","conda","）","存放","包会","site","你","执行","gz2","packages","等","里会","history","值","可执行文件","作用","man","到","个","文件夹","下","包刚","python3.6","目录","中","（"],"title":"5.4.anaconda","title_tokens":[".","anaconda","5.4"]},{"location":"开发环境管理/5.4.anaconda.html#anaconda","text":"anacoda3/conda-meta/history ：记录用户使用conda命令安装、卸载、升级包的操作 anaconda3/pkgs/urls.txt ：记录用户使用conda命令下载包的地址，直接复制地址到浏览器中也可以下载 anaconda3/conda-meta/ ：文件夹里保存着与各个包同名的.json文件（有些包会有多个.json文件），这些json文件会记录对应的包的版本、存放位置、md5值等信息 anaconda3/pkgs/ ：这个文件夹里存放了每个包刚下载来的文件，格式是.tar.gz2，另外也会自动解压到这个文件夹里。比如你下载了six这个包，anaconda3/pkgs/这个文件夹里会多出如下2个文件。另外，当你卸载包的时候，这里的2个文件是不会被删除的 anaconda3/lib/python3.6/site-packages/ ：包的存放目录 anaconda3/bin ：安装一些包的时候会往里添加一些可执行文件 anaconda3/lib ：安装一些包的时候会往里添加一些.so文件 anaconda3/include ：安装一些包的时候会往里添加了一些文件 anaconda3/man ：安装一些包的时候会往里里添加了一些文件 anaconda3/share ：安装一些包的时候会往里里添加了一些文件","text_tokens":["对应","比如","是","下载","meta","每个","有些","一些",".","2","six","了","来","当","添加","操作","share","。","复制","自动","命令","与","这个","，","json","include","有","时候","anacoda3","记录","多出","包","升级","bin","会","这些","格式","里","文件","浏览器","使用","-","txt","保存","安装","升级包","、","md5","用户","：","解压","行文","卸载","着","也","位置","地址","如下","多个","会往","这里","件夹","tar","版本","被","各个","信息","lib","的","pkgs","可以","/","so","另外","不会","浏览","anaconda3","urls","直接","同名"," ","删除","conda","）","存放","包会","site","你","执行","gz2","packages","等","里会","history","值","可执行文件","man","到","个","文件夹","包刚","python3.6","目录","中","（"],"title":"Anaconda下各个文件夹作用","title_tokens":["件夹","文件夹","下","各个","作用","文件","anaconda"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html","text":"让代码窗口输出全部结果 将此代码放置在jupyter单元中： from IPython.core.interactiveshell import InteractiveShell InteractiveShell . ast_node_interactivity = \"all\" 修改全局设置 在Windows中，以下步骤会使更改永久生效。应该适用于其他操作系统。您可能必须更改路径。 C:\\Users\\your_profile\\\\.ipython\\profile_default 做一个ipython_config.py文件与下面的代码profile_defaults： c = get_config () c . InteractiveShell . ast_node_interactivity = \"all\" 使用 print 函数 快捷键使用指南 Jupyter Notebook 有两种键盘输入模式。即命令模式和编辑模式，这与 Vim 有些类似。在编辑模式下，可以往cell中键入代码或文本，此时命令模式下的快捷键不生效。在命令模式下，可以用快捷键命令运行单元格，移动单元格，切换单元格编辑状态等等，此时编辑模式下的快捷键不生效。 从命令模式进入编辑模式需按 Enter 键，从编辑模式切换到命令模式需按 Esc 键。 以下两表分别是对命令和编辑两种模式下快捷键的简单说明： 命令模式快捷键（按 Esc 键开启）: 快捷键 作用 说明 Enter 转入编辑模式 Shift-Enter 运行本单元，选中下个单元 新单元默认为命令模式 Ctrl-Enter 运行本单元 Alt-Enter 运行本单元，在其下插入新单元 新单元默认为编辑模式 Y 单元转入代码状态 M 单元转入 markdown 状态 R 单元转入 raw 状态 1 设定 1 级标题 仅在 markdown 状态下时建议使用标题相关快捷键，如果单元处于其他状态，则会强制切换到 markdown 状态 2 设定 2 级标题 3 设定 3 级标题 4 设定 4 级标题 5 设定 5 级标题 6 设定 6 级标题 Up 选中上方单元 K 选中上方单元 Down 选中下方单元 J 选中下方单元 Shift-K 连续选择上方单元 Shift-J 连续选择下方单元 A 在上方插入新单元 B 在下方插入新单元 X 剪切选中的单元 C 复制选中的单元 Shift-V 粘贴到上方单元 V 粘贴到下方单元 Z 恢复删除的最后一个单元 D,D 删除选中的单元 连续按两个 D 键 Shift-M 合并选中的单元 Ctrl-S 保存当前 NoteBook S 保存当前 NoteBook L 开关行号 编辑框的行号是可以开启和关闭的 O 转换输出 Shift-O 转换输出滚动 Esc 关闭页面 Q 关闭页面 H 显示快捷键帮助 I,I 中断 NoteBook 内核 0,0 重启 NoteBook 内核 Shift 忽略 Shift-Space 向上滚动 Space 向下滚动 编辑模式快捷键（ 按 Enter 键启动）: 快捷键 作用 说明 Tab 代码补全或缩进 Shift-Tab 提示 输出帮助信息，部分函数、类、方法等会显示其定义原型，如果在其后加 ? 再运行会显示更加详细的帮助 Ctrl-] 缩进 向右缩进 Ctrl-[ 解除缩进 向左缩进 Ctrl-A 全选 Ctrl-Z 撤销 Ctrl-Shift-Z 重做 Ctrl-Y 重做 Ctrl-Home 跳到单元开头 Ctrl-Up 跳到单元开头 Ctrl-End 跳到单元末尾 Ctrl-Down 跳到单元末尾 Ctrl-Left 跳到左边一个字首 Ctrl-Right 跳到右边一个字首 Ctrl-Backspace 删除前面一个字 Ctrl-Delete 删除后面一个字 Esc 切换到命令模式 Ctrl-M 切换到命令模式 Shift-Enter 运行本单元，选中下一单元 新单元默认为命令模式 Ctrl-Enter 运行本单元 Alt-Enter 运行本单元，在下面插入一单元 新单元默认为编辑模式 Ctrl-Shift-- 分割单元 按光标所在行进行分割 Ctrl-Shift-Subtract 分割单元 Ctrl-S 保存当前 NoteBook Shift 忽略 Up 光标上移或转入上一单元 Down 光标下移或转入下一单元 Ctrl-/ 注释整行/撤销注释 仅代码状态有效 注： 如果快捷键被系统中的其它应用占用，则可能会失效 在任意目录下打开notebook 在该目录下：shift + 右键 👉 打开powershell，输入jupter notebook 自定义主题 通过 pip 安装 jupyterthemes package： # 安装 pip install jupyterthemes # 更新jupyterthemes pip install --upgrade jupyterthemes 安装好 jupyterthemes package之后，就可以在命令行输入 jupyterthemes 的命令： # 列出所有安装好的主题 jt -l # 使用帮助 jt -h 具体使用方法参见： jupyterthemes官方说明 安装扩展 安装 jupyter_contrib_nbextensions 包。该插件并不是jupyter notebook官方的插件。具体参考 Unofficial Jupyter Notebook Extensions 和 为Jupyter Notebook安装扩展并启用Configurator 。 # 安装 pip install jupyter_contrib_nbextensions # 或者通过conda安装 conda install -c conda-forge jupyter_contrib_nbextensions # 激活 jupyter contrib nbextension install --user # 启用 jupyter nbextensions_configurator enable --user 输出带有中文的pdf jupyter notebook本身不能输出pdf，输出pdf依赖于$\\LaTeX$引擎。目前，带有中文的ipynb文件输出为pdf会报错，主要原因是jupyter的$\\LaTeX$模板设置了$\\text{pdf}\\LaTeX$引擎，但是Pdf$\\LaTeX$不可以直接编译中文文档的。因此，需要把jupyter的$\\LaTeX$引擎改为$\\text{Xe}\\LaTeX$引擎。 修改模板，模板位置为：...\\site-packages\\nbconvert\\templates\\latex\\article.tplx，将latex模板类由article改为ctexart。 原来的代码： ((* block docclass *)) \\documentclass [11pt] { article } ((* endblock docclass *)) 修改后的代码： ((* block docclass *)) \\documentclass [13pt] { ctexart } ((* endblock docclass *)) 或者，依然使用PdfLatex引擎，但引入xeCJK宏包： \\documentclass [11pt] { article } \\usepackage { xeCJK } % 如果设置mainfont，必须设置为已安装的中文字体，例如微软雅黑。 %\\setCJKmainfont{SourceHanSansCN-Light} 想要修改输出pdf的排版，则需要修改其预定义的latex排版模板，即base.tplx文件。例如可以在base.tplx加入如下代码控制输出的pdf的页边距。 \\geometry { a4paper,left=2cm,right=2cm,top=1cm,bottom=1cm } 但是，可能改了jupyter的latex模板，jupyter notebook输出pdf依然报错。例如下面的报错信息： nbconvert failed: PDF creating failed, captured latex output: This is XeTeX, Version 3.14159265-2.6-0.99999 (TeX Live 2018/W32TeX) (preloaded format=xelatex) restricted \\write18 enabled. entering extended mode ! Undefined control sequence. <*> .\\notebook .tex ? ! Emergency stop. <*> .\\notebook .tex No pages of output. Transcript written on ?. 这是jupyter中控制调用latex引擎的脚本pdf.py有bug，位于66行。 原来的代码： writer = Instance ( \"nbconvert.writers.FilesWriter\" , args = (), kw = { 'build_directory' : '.' }) 正确的代码： writer = Instance ( \"nbconvert.writers.FilesWriter\" , args = (), kw = { 'build_directory' : '' }) 原来的代码给xelatex引擎发送了错误的文件路径： 错误的路径： xelatex .\\notebook.tex 正确的路径： xelatex notebook.tex 详细内容参考这里 Problem in Converting Jupyter notebook to pdf #144 。 版本控制 Save and CheckPoint 和 Revert to CheckPoint。","text_tokens":["系统","重启","键入","恢复","space","!","需","args","所在","preloaded","interactiveshell","占用","依赖","了","窗口","右边","converting","自定","]","但","预定","转入","可能","仅","并","为","upgrade","包","等等","bottom","k","后面","entering","应该","q","剪切","提示","\"","subtract","restricted","2018","使用","windows","-","pdf","其他","保存","6","fileswriter","上","该","其",">","中断","pdflatex","进入","、","光标","编译","对","解除","emergency","默认","profile","您","报错","#","位置","failed","3","整行","永久","单元格","结果","这里","部分","距","+","两种","to","xe","13pt","左边","latex","a","使","文本","4","j","状态","markdown","0.99999","启动","66","列出","tplx","geometry","）","*","written","两表","字","更新","指南","nbconvert","页","标题","undefined","notebook","right","[","开关","nbextension","代码","nbextensions","usepackage","end","extensions","新","关闭","ipython","到","本",",","此时","enabled","本身","1cm","light","激活","directory","m","build","home","从","位于","内核","详细","jupter","transcript","2","正确","向","，","定义","有","插入","output","一个","全局","目前","做","checkpoint","py","输入","problem","修改","简单","依赖于","powershell","contrib","d","操作系统","于","version","把","mainfont","具体","或者","路径","jupyterthemes","全部","base","字首","?","：","writers","alt","3.14159265","脚本","ctexart","i","jt","w32tex","但是","不能","依然","扩展","captured","tab","enter","l","改为","xetex","选中","信息","边","快捷键","jupyter","将","可以","引入","%","显示","编辑框","core","直接","适用","block","2cm","kw","删除","快捷","interactivity","revert","内容","版本控制","文档","主要","例如","有效","y","c","步骤","setcjkmainfont","级","开启","o","宏包","等","调用","参考","命令行","11pt","进行","package","5","in","users","选择","中","configurator","需要","is","不","切换","是","sequence","其它","=","让","好","这","失效","extended","r","enable","install","中文","相关","1","x","页面","分别","忽略","之后","下方","雅黑","左","ipynb","向上","单元","字体","粘贴","用","mode","z","article","由","或","自定义","中文字体","键盘","原型","插件","backspace","creating","会","参见","xelatex","esc","错误","config","打开","on","安装","不是","其后","control","down","输出","ast","更加","xecjk","连续","运行","👉","应用","带有","引擎","up","注释","被","则","缩进","of","建议","的","a4paper","全选","向下","unofficial","按","往","使用指南"," ","分割","任意","想要","键","cell","stop","更改","注","控制","}","右键","模式","启用","发送","设定","设置","放置","s","如果","shift","上移","处于","行","144","生效","delete","和","说明","pip","save","(","目录","<","当前","上方","all","import","官方","方法",")","write18","pages","下移","有些",".","跳","b","live","在","操作","print","。","复制","endblock","命令","与","下面","就","给","default","h","后","sourcehansanscn","'","编辑","末尾","再","forge","...","赖于","writer","\\","文件","tex","即","此","bug","重做","微软","0","开头","主题","$","前面","文字","这是","ctrl","类","and","强制","instance","如下","text","键盘输入","vim","v","最后","no","义","补全","{","通过","版本","user","_","node","改了","this","帮助","format","原因","/","函数","defaults","类似","撤销",":","your","templates","from","conda","raw","site","合并","加入","模板","加","其下","一","因此","docclass","get","packages","两个","documentclass","必须","下个","转换","作用","2.6","滚动","以下","右","排版","已","下","所有","移动","下时","行号","left","原来","（","top"],"title":"5.5.jupyter使用笔记","title_tokens":["5.5",".","jupyter","使用","笔记"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_1","text":"将此代码放置在jupyter单元中： from IPython.core.interactiveshell import InteractiveShell InteractiveShell . ast_node_interactivity = \"all\" 修改全局设置 在Windows中，以下步骤会使更改永久生效。应该适用于其他操作系统。您可能必须更改路径。 C:\\Users\\your_profile\\\\.ipython\\profile_default 做一个ipython_config.py文件与下面的代码profile_defaults： c = get_config () c . InteractiveShell . ast_node_interactivity = \"all\" 使用 print 函数","text_tokens":["系统","函数","all","永久","interactivity","import","更改","做","应该","=","c","py",")","步骤","\"","会","\\","_",".","node","修改","文件","jupyter","get","设置","的","将","代码","操作系统","windows","放置","于","interactiveshell","使用","config","必须","defaults","在","操作","其他","使","此","路径","print","。",":","ipython","your","与","以下","ast","下面","，","core","from","生效","users","单元","：","default","(","适用"," ","中","可能","一个","profile","您","全局"],"title":"让代码窗口输出全部结果","title_tokens":["让","窗口","结果","全部","代码","输出"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_2","text":"Jupyter Notebook 有两种键盘输入模式。即命令模式和编辑模式，这与 Vim 有些类似。在编辑模式下，可以往cell中键入代码或文本，此时命令模式下的快捷键不生效。在命令模式下，可以用快捷键命令运行单元格，移动单元格，切换单元格编辑状态等等，此时编辑模式下的快捷键不生效。 从命令模式进入编辑模式需按 Enter 键，从编辑模式切换到命令模式需按 Esc 键。 以下两表分别是对命令和编辑两种模式下快捷键的简单说明：","text_tokens":["编辑","cell","快捷","或","不","单元格","切换","键入","等等","是","键盘输入","两表","vim","键盘","从","enter","需","两种","模式","这","notebook","输入","有些","简单","快捷键","jupyter","即","esc","的","可以","代码","在","文本","。","类似","按","命令","到","与","往","进入","状态","以下","，","分别","生效","和","下","此时","单元","对","说明","有","：","用","移动"," ","中","运行","键"],"title":"快捷键使用指南","title_tokens":["指南","使用指南","快捷","快捷键","使用"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#esc","text":"快捷键 作用 说明 Enter 转入编辑模式 Shift-Enter 运行本单元，选中下个单元 新单元默认为命令模式 Ctrl-Enter 运行本单元 Alt-Enter 运行本单元，在其下插入新单元 新单元默认为编辑模式 Y 单元转入代码状态 M 单元转入 markdown 状态 R 单元转入 raw 状态 1 设定 1 级标题 仅在 markdown 状态下时建议使用标题相关快捷键，如果单元处于其他状态，则会强制切换到 markdown 状态 2 设定 2 级标题 3 设定 3 级标题 4 设定 4 级标题 5 设定 5 级标题 6 设定 6 级标题 Up 选中上方单元 K 选中上方单元 Down 选中下方单元 J 选中下方单元 Shift-K 连续选择上方单元 Shift-J 连续选择下方单元 A 在上方插入新单元 B 在下方插入新单元 X 剪切选中的单元 C 复制选中的单元 Shift-V 粘贴到上方单元 V 粘贴到下方单元 Z 恢复删除的最后一个单元 D,D 删除选中的单元 连续按两个 D 键 Shift-M 合并选中的单元 Ctrl-S 保存当前 NoteBook S 保存当前 NoteBook L 开关行号 编辑框的行号是可以开启和关闭的 O 转换输出 Shift-O 转换输出滚动 Esc 关闭页面 Q 关闭页面 H 显示快捷键帮助 I,I 中断 NoteBook 内核 0,0 重启 NoteBook 内核 Shift 忽略 Shift-Space 向上滚动 Space 向下滚动","text_tokens":["重启","上方","m","切换","是","恢复","space","内核","b","r","2","在","相关","复制","1","x","命令","页面","忽略","，","下方","向上","单元","粘贴","插入","转入","h","一个","仅","编辑","z","为","k","q","剪切","会","esc","使用","d","-","其他","保存","6","0","down","中断","输出","ctrl","连续","alt","i","默认","运行","3","强制","v","最后","enter","l","up","选中","则","快捷键","建议","帮助","的","可以","a","显示","向下","按","4","j","状态","编辑框","markdown"," ","删除","键","快捷","raw","合并","y","标题","c","模式","notebook","其下","级","开启","设定","o","两个","开关","代码","下个","转换","s","如果","作用","shift","滚动","处于","新","关闭","到","5","本",",","说明","和","选择","下时","行号","当前"],"title":"命令模式快捷键（按 Esc 键开启）:","title_tokens":["快捷","模式","）","esc","开启","快捷键","按"," ",":","命令","（","键"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#enter","text":"快捷键 作用 说明 Tab 代码补全或缩进 Shift-Tab 提示 输出帮助信息，部分函数、类、方法等会显示其定义原型，如果在其后加 ? 再运行会显示更加详细的帮助 Ctrl-] 缩进 向右缩进 Ctrl-[ 解除缩进 向左缩进 Ctrl-A 全选 Ctrl-Z 撤销 Ctrl-Shift-Z 重做 Ctrl-Y 重做 Ctrl-Home 跳到单元开头 Ctrl-Up 跳到单元开头 Ctrl-End 跳到单元末尾 Ctrl-Down 跳到单元末尾 Ctrl-Left 跳到左边一个字首 Ctrl-Right 跳到右边一个字首 Ctrl-Backspace 删除前面一个字 Ctrl-Delete 删除后面一个字 Esc 切换到命令模式 Ctrl-M 切换到命令模式 Shift-Enter 运行本单元，选中下一单元 新单元默认为命令模式 Ctrl-Enter 运行本单元 Alt-Enter 运行本单元，在下面插入一单元 新单元默认为编辑模式 Ctrl-Shift-- 分割单元 按光标所在行进行分割 Ctrl-Shift-Subtract 分割单元 Ctrl-S 保存当前 NoteBook Shift 忽略 Up 光标上移或转入上一单元 Down 光标下移或转入下一单元 Ctrl-/ 注释整行/撤销注释 仅代码状态有效 注： 如果快捷键被系统中的其它应用占用，则可能会失效","text_tokens":["系统","m","切换","home","方法","其它","详细","下移","失效","跳","所在","占用","在","右边","命令","向","]","下面","忽略","，","左","单元","定义","插入","转入","一个","仅","可能","编辑","z","为","或","末尾","再","后面","原型","提示","backspace","会","subtract","esc","-","保存","上","重做","其","其后","开头","down","、","输出","字首","更加","前面","光标","ctrl","?","：","解除","alt","默认","运行","类","整行","应用","tab","enter","部分","补全","up","注释","被","缩进","信息","选中","快捷键","则","帮助","的","左边","/","函数","a","全选","显示","按","撤销","状态"," ","分割","删除","快捷","字","有效","注","y","模式","notebook","加","right","一","[","等","代码","s","如果","作用","shift","end","上移","行","新","进行","到","本","右","delete","说明","下","left","中","当前"],"title":"编辑模式快捷键（ 按 Enter 键启动）:","title_tokens":["编辑","快捷","模式","启动","）","快捷键","按"," ",":","（","enter","键"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#notebook","text":"在该目录下：shift + 右键 👉 打开powershell，输入jupter notebook","text_tokens":["，","+","右键","在","notebook","下","：","打开","输入","jupter","shift","该","目录"," ","powershell","👉"],"title":"在任意目录下打开notebook","title_tokens":["在","notebook","打开","下","目录","任意"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_3","text":"通过 pip 安装 jupyterthemes package： # 安装 pip install jupyterthemes # 更新jupyterthemes pip install --upgrade jupyterthemes 安装好 jupyterthemes package之后，就可以在命令行输入 jupyterthemes 的命令： # 列出所有安装好的主题 jt -l # 使用帮助 jt -h 具体使用方法参见： jupyterthemes官方说明","text_tokens":["upgrade","官方","方法","l","更新","好","通过","输入","参见","帮助","的","可以","使用","-","install","在","具体","命令行","安装","jupyterthemes","package","命令","主题","之后","，","就","说明","pip","：","所有","h"," ","jt","列出","#"],"title":"自定义主题","title_tokens":["自定义","主题","定义","自定"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_4","text":"安装 jupyter_contrib_nbextensions 包。该插件并不是jupyter notebook官方的插件。具体参考 Unofficial Jupyter Notebook Extensions 和 为Jupyter Notebook安装扩展并启用Configurator 。 # 安装 pip install jupyter_contrib_nbextensions # 或者通过conda安装 conda install -c conda-forge jupyter_contrib_nbextensions # 激活 jupyter contrib nbextension install --user # 启用 jupyter nbextensions_configurator enable --user","text_tokens":["conda","为","官方","包","扩展","forge","#","插件","c","启用","notebook","通过","user","_","jupyter","contrib","的","nbextension","-","nbextensions","enable","参考","具体","install","或者","安装","。","该","unofficial","不是","extensions","和","pip"," ","configurator","激活","并"],"title":"安装扩展","title_tokens":["扩展","安装"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#pdf","text":"jupyter notebook本身不能输出pdf，输出pdf依赖于$\\LaTeX$引擎。目前，带有中文的ipynb文件输出为pdf会报错，主要原因是jupyter的$\\LaTeX$模板设置了$\\text{pdf}\\LaTeX$引擎，但是Pdf$\\LaTeX$不可以直接编译中文文档的。因此，需要把jupyter的$\\LaTeX$引擎改为$\\text{Xe}\\LaTeX$引擎。 修改模板，模板位置为：...\\site-packages\\nbconvert\\templates\\latex\\article.tplx，将latex模板类由article改为ctexart。 原来的代码： ((* block docclass *)) \\documentclass [11pt] { article } ((* endblock docclass *)) 修改后的代码： ((* block docclass *)) \\documentclass [13pt] { ctexart } ((* endblock docclass *)) 或者，依然使用PdfLatex引擎，但引入xeCJK宏包： \\documentclass [11pt] { article } \\usepackage { xeCJK } % 如果设置mainfont，必须设置为已安装的中文字体，例如微软雅黑。 %\\setCJKmainfont{SourceHanSansCN-Light} 想要修改输出pdf的排版，则需要修改其预定义的latex排版模板，即base.tplx文件。例如可以在base.tplx加入如下代码控制输出的pdf的页边距。 \\geometry { a4paper,left=2cm,right=2cm,top=1cm,bottom=1cm } 但是，可能改了jupyter的latex模板，jupyter notebook输出pdf依然报错。例如下面的报错信息： nbconvert failed: PDF creating failed, captured latex output: This is XeTeX, Version 3.14159265-2.6-0.99999 (TeX Live 2018/W32TeX) (preloaded format=xelatex) restricted \\write18 enabled. entering extended mode ! Undefined control sequence. <*> .\\notebook .tex ? ! Emergency stop. <*> .\\notebook .tex No pages of output. Transcript written on ?. 这是jupyter中控制调用latex引擎的脚本pdf.py有bug，位于66行。 原来的代码： writer = Instance ( \"nbconvert.writers.FilesWriter\" , args = (), kw = { 'build_directory' : '.' }) 正确的代码： writer = Instance ( \"nbconvert.writers.FilesWriter\" , args = (), kw = { 'build_directory' : '' }) 原来的代码给xelatex引擎发送了错误的文件路径： 错误的路径： xelatex .\\notebook.tex 正确的路径： xelatex notebook.tex 详细内容参考这里 Problem in Converting Jupyter notebook to pdf #144 。","text_tokens":["需要","directory","build","is","不","sequence","是","位于","!","=","args",")","write18","pages","详细",".","extended","transcript","preloaded","正确","了","依赖","live","中文","在","converting","。","endblock","]","但","下面","，","雅黑","ipynb","预定","给","字体","有","output","可能","后","sourcehansanscn","'","mode","article","为","由","目前","中文字体","bottom","entering","...","赖于","writer","py","creating","\"","\\","会","restricted","problem","修改","文件","tex","2018","即","依赖于","xelatex","使用","错误","-","pdf","把","version","mainfont","或者","路径","on","fileswriter","安装","bug","微软","其","control","pdflatex",">","base","$","输出","文字","xecjk","这是","编译","?","：","writers","脚本","3.14159265","中","ctexart","emergency","w32tex","但是","报错","不能","类","#","位置","failed","instance","如下","依然","text","captured","带有","xetex","引擎","改为","义","距","no","这里","{","to","xe","则","边","信息","of","jupyter","改了","13pt","this","_","的","原因","latex","可以","将","/","format","引入","%","a4paper",":","templates","0.99999","直接","66"," ","block","2cm","kw","想要","tplx","geometry","stop","*","written","内容","文档","主要","site","例如","加入","控制","nbconvert","页","}","undefined","模板","发送","notebook","right","setcjkmainfont","因此","[","docclass","宏包","packages","调用","设置","代码","documentclass","usepackage","必须","参考","如果","2.6","11pt","行","in","排版","已","144",",","enabled","(","本身","left","1cm","light","原来","<","top"],"title":"输出带有中文的pdf","title_tokens":["pdf","中文","带有","的","输出"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_5","text":"Save and CheckPoint 和 Revert to CheckPoint。","text_tokens":["and","checkpoint","和","to","save","revert","。"," "],"title":"版本控制","title_tokens":["版本","版本控制","控制"]},{"location":"计算机基础/1.1.计算机与程序结构.html","text":"CPU 计算机的工作过程就是计算机执行程序的过程。程序是一个指令序列，这个序列明确告诉计算机应该执行什么操作，在什么地方能够找到用来操作的数据。 一旦把程序装入主存储器，计算机就可以自动执行取出指令和执行指令的任务。 专门用来完成此项工作的计算机部件称为中央处理器（Central Processing Unit，CPU） ，做成单片集成电路的CPU通常又称为微处理器（Microprocessor），在一个集成电路中集成了两个 CPU 芯片，称之为双核（dual core）微处理器。现代的个人计算机一般都是使用微处理器作为CPU。 注意：CPU不是指一个特定的某一类东西，而是具有某种功能的部件的总称。所以，不管是何种形态、设计、原理的部件，只要它能具有取出指令、执行指令的功能，它就是CPU。 简而言之， CPU 是用来表示计算机内部元件功能的术语。 下图为陶瓷PGA封装的Intel 80486 DX2 CPU： 计算机工业从1960年代早期开始使用CPU这个术语。迄今为止，CPU从形态、设计到实现都已发生了巨大的变化，但是其基本工作原理却一直没有大的变化。 早期的CPU通常是为大型、特定的应用而定制的。目前，这种为特定应用而设计定制CPU的昂贵方法，在很大程度上已经让位于可大规模生产的通用处理器。这种标准化趋势，诞生于分立晶体管大型计算机（Mainframe）和小型计算机（Minicomputer）年代，并且随着集成电路（IC）的普及而大大加速。 现代的CPU使用集成电路制作，集成电路可以把日益复杂的CPU设计制造在很小的空间里。CPU的小型化和标准化，大大增加了这些数字器件在现代生活中的应用范围，远远超出了专用运算机器这一有限的应用。现代微处理器已经随处可见，从汽车到手机，甚至儿童玩具。 ​ ——参考于 英特尔文档：CPU的功能和组成 CPU和内存由数字集成电路（数字芯片）构成，集成电路通常称为IC（Integrated Circuit），它由晶体管组成，每一个晶体管具有ON/OFF两个状态。 从功能方面来看 ，CPU的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。 寄存器可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有20～100 个寄存器。 控制器负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。 运算器负责运算从内存读入寄存器的数据。 时钟负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。 寄存器的主要种类和功能 根据功能的不同，我们可以将寄存器大致划分为八类。可以看出，==寄存器中存储的内容既可以是指令也可以是数据。其中，数据分为“用于运算的数值”和“表示内存地址的数值”两种。==数据种类不同，存储该数值的寄存器也不同。CPU 中每个寄存器的功能都是不同的。 种类 功能 累加寄存器 accumulator 存储执行运算的数据和运算后的数据 标志寄存器 flag register 存储运算处理后的 CPU 的状态 程序计数器 program counter 存储下一条指令所在内存的地址 基址寄存器 base register 存储数据内存的起始地址 变址寄存器 index register 存储基址寄存器的相对地址 通用寄存器 general purpose register 存储任意数据 指令寄存器 instruction register 存储指令。CPU 内部使用，程序员无法通过程序对该寄存器进行读写操作 栈寄存器 stack register 存储栈区域的起始地址 寄存器对程序员来说比较特殊，因为寄存器是编程中的一个对象，例如在汇编语言中： # 汇编语言编写的程序示例 mov eax, dword ptr [ebp-8] …把数值从内存复制到 eax add eax, dword ptr [ebp-0Ch] …exa 的数值和内存的数值相加 mov dword ptr [ebp-4], eax …把 exa 的数值（上一步的相加结果）存储在内存中 eax 和 ebp 是 CPU 内部的寄存器的名称。内存的存储场所通过地址编号来区分，而寄存器的种类则通过名字来区分。 main memory 通常所说的内存指的是计算机的主存储器（main memory），简称主存。 主存通过控制芯片等与 CPU 相连， 主要负责存储指令和数据。 主存由可读写的元素构成，每个字节（1 Byte = 8 bit ）都带有一个地址编号。 CPU 可以通过该地址读取主存中的指令和数据，以及写入数据。 如何通过内存索引数据？ 内存的构成单位是一个字节（8位），每一个字节都有一个地址编号，这个地址编号是它的逻辑地址。 CPU中的寄存器（基址寄存器、变址寄存器）会储存中被运算的数据的编号地址。CPU寄存器的空间大小决定了CPU能识别多大的内存。 比如说，一个32位的寄存器，它能表示的最大数为$2^{32}-1=4294967295$（十进制数，从0开始；换成16进制数就是FFFFFFFF）。也就是说它能表示$2^{32}=4294967296$种状态。而4g的内存一共有$4\\times1024\\times1024\\times1024=4294967296$个byte，也就是说一个具有32位的寄存器的CPU最多能识别4g的内存。 通过基址寄存器和变址寄存器，我们可以对主内存上特定的内存区域进行划分。首先，我们用十六进制数 将计算机内存上 00000000～FFFFFFFF的地址划分出来。那么，凡是该范围的内存区域，只要有一个 32 位的 寄存器，即可查看全部的内存地址。 CPU所生成的地址通常称为逻辑地址(logical address)，而内存单元所看到的地址（即加载到内存地址寄存器(memory-address register)中的地址）通常称为物理地址(physical address) 。 逻辑地址与物理地址的对应关系并不是固定不变的，这取决于执行的地址绑定方案。因此，逻辑地址又称为虚拟地址。虚拟地址通过 映射 与物理地址对应起来。完成这种映射的硬件设备是 内存管理单元 (memory-management unit, MMU)，完成映射的方法有多种，也就是地址绑定方案有多种。程序无法访问物理地址，只能基于虚拟地址进行操作。","text_tokens":["对应","工业","小型","专门","超出","此项工作","所在","了","任务","存储","迄今","生产","指令","]","这个","一类","～","整个","而是","80486","并","起始","编写","语言","简称","4294967295","为","计数器","应该","随处","硬件","趋势","来看","晶体管","写入","里","使用","明确","程序员","-","最大数","只能","甚至","上","生成","该","基于","其","空间","换成","程序","、","随着","即可","对","minicomputer","#","已经","玩具","因为","大致","结果","部分","区域","两种","dword","识别","计算机","机器","有限","既","4","索引","状态","小型化","标志","每","pga","分为","如何","大规模","元素","）","完成","随处可见","mov","集成","ffffffff","固定","过程","eax","日益","变址","不变","复杂","算器","基址","[","儿童","取决","称之为","控制器","accumulator","到","发生","个",",","取出","此项","比如","单片","物理地址","从","位于","add","相互","每个","装入","作为","times1024","数据","单位","特定","相对","陶瓷","这一","负责","2","integrated","形态","程度","bit","，","某种","出来","诞生","有","能够","一个","栈","byte","目前","100","比较","management","构成","十进制","却","累加","外部","内部","进制","这些","之为","专用","首先","大大增加","主存","于","把","制作","汽车","加载","“","英特尔","base","方面","全部","：","可见","大增","远远","但是","4g","物理","读入","虚拟地址","所以","制造","管理","也就是说","告诉","processing","什么","可以","将","memory","设计","巨大","最多","东西","logical","虚拟","可","可用","加速","core","生活","种","不过","理器","四个","00000000","而言","大","范围","内容","复制到","？","文档","主要","例如","mmu","查看","一般","并且","决定","执行","用来","中央处理器","等","参考","我们","储存","进行","访问","purpose","大规","绑定","所","​","计时","中","address","大大","最多能","部件","是","不管","之间","起来","具有","”","集成电路","术语","dx2","让","暂存","=","flag","这","汇编语言","8","场所","…","工作","读写操作","主存储器","区分","1","自动","很大","原理","单元","circuit","指令和数据","用","器件","由","个人","汇编","—","示例","中央","映射","会","序列","信号","根据","运算器","unit","on","不是","以及","指","cpu","基本","大数","dual","16","都","种类","off","main","其中","也","微处理器","表示","方案","应用","register","处理","变化","分立","带有","大小","手机","被","则","编号","就是说","的","电路","注意","而","规模","这种","元件","十六进制"," ","某","任意","intel","无法访问","增加","一步","八类","program","存储器","控制","十六","}","1960","昂贵","；","来说","晶体","称为","各","定制","为止","处理器","通用寄存器","比如说","运算","一直","和","(","一条","取决于","划分","多大","不同","存储栈","行程","physical","做成","方法","就是","简而言之",")","central","有些","又","寄存","来","何种","设备","操作","在","寄存器","无法","指令寄存器","年代","。","复制","数字","与","看到","就","内存","general","封装","ic","名称","microprocessor","双核","普及","instruction","后","mainframe","字节","index","stack","数","电流","相加","功能","一旦","\\","看出","关系","即","通用","20","用于","最大","很小","英特","读写","时钟","0","$","看作","数值","对象","那么","ebp","名字","读取","一种","标准化","地址","编程","多种","总称","相连","芯片","4294967296","32","^","连通","通过","所说","{","位","地方","儿童玩具","/","计数","实现","内存地址","特尔","counter","它","凡是","特殊","没有","现代","大型","算机","计算","组成","一共","迄今为止","ptr","找到","下图","0ch","成电","开始","发出","因此","只要","exa","逻辑","标准","两个","早期","能","执行程序","已","对主","下","通常","（"],"title":"1.1.计算机与程序结构","title_tokens":["算机","计算","1.1","程序结构","结构",".","计算机","程序","与"]},{"location":"计算机基础/1.1.计算机与程序结构.html#cpu","text":"计算机的工作过程就是计算机执行程序的过程。程序是一个指令序列，这个序列明确告诉计算机应该执行什么操作，在什么地方能够找到用来操作的数据。 一旦把程序装入主存储器，计算机就可以自动执行取出指令和执行指令的任务。 专门用来完成此项工作的计算机部件称为中央处理器（Central Processing Unit，CPU） ，做成单片集成电路的CPU通常又称为微处理器（Microprocessor），在一个集成电路中集成了两个 CPU 芯片，称之为双核（dual core）微处理器。现代的个人计算机一般都是使用微处理器作为CPU。 注意：CPU不是指一个特定的某一类东西，而是具有某种功能的部件的总称。所以，不管是何种形态、设计、原理的部件，只要它能具有取出指令、执行指令的功能，它就是CPU。 简而言之， CPU 是用来表示计算机内部元件功能的术语。 下图为陶瓷PGA封装的Intel 80486 DX2 CPU： 计算机工业从1960年代早期开始使用CPU这个术语。迄今为止，CPU从形态、设计到实现都已发生了巨大的变化，但是其基本工作原理却一直没有大的变化。 早期的CPU通常是为大型、特定的应用而定制的。目前，这种为特定应用而设计定制CPU的昂贵方法，在很大程度上已经让位于可大规模生产的通用处理器。这种标准化趋势，诞生于分立晶体管大型计算机（Mainframe）和小型计算机（Minicomputer）年代，并且随着集成电路（IC）的普及而大大加速。 现代的CPU使用集成电路制作，集成电路可以把日益复杂的CPU设计制造在很小的空间里。CPU的小型化和标准化，大大增加了这些数字器件在现代生活中的应用范围，远远超出了专用运算机器这一有限的应用。现代微处理器已经随处可见，从汽车到手机，甚至儿童玩具。 ​ ——参考于 英特尔文档：CPU的功能和组成 CPU和内存由数字集成电路（数字芯片）构成，集成电路通常称为IC（Integrated Circuit），它由晶体管组成，每一个晶体管具有ON/OFF两个状态。 从功能方面来看 ，CPU的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。 寄存器可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有20～100 个寄存器。 控制器负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。 运算器负责运算从内存读入寄存器的数据。 时钟负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。","text_tokens":["来","不同","工业","部件","行程","是","小型","做成","方法","不管","之间","单片","就是","具有","从","位于","相互","简而言之","集成电路","术语","dx2","让","装入","作为","暂存","专门","central","有些","又","超出","数据","此项工作","特定","寄存","陶瓷","这一","负责","了","何种","integrated","工作","任务","操作","在","存储","主存储器","迄今","生产","指令","年代","寄存器","。","自动","很大","数字","这个","形态","程度","一类","，","某种","就","～","内存","原理","整个","诞生","封装","ic","circuit","microprocessor","双核","能够","有","一个","而是","80486","普及","器件","并","mainframe","为","由","目前","个人","100","电流","构成","功能","—","应该","随处","趋势","却","中央","来看","外部","一旦","内部","晶体管","这些","会","之为","里","专用","通用","大大增加","使用","明确","主存","于","把","序列","制作","汽车","信号","根据","20","运算器","unit","很小","甚至","on","上","英特","不是","其","时钟","空间","英特尔","程序","指","cpu","、","基本","方面","看作","dual","随着","都","种类","：","可见","minicomputer","off","大增","对象","远远","但是","已经","玩具","也","读入","微处理器","表示","标准化","一种","应用","所以","总称","处理","制造","芯片","变化","分立","结果","部分","手机","连通","告诉","计算机","processing","什么","机器","有限","地方","的","可以","儿童玩具","将","设计","巨大","/","电路","东西","实现","注意","可","可用","特尔","加速","而","小型化","状态","core","生活","每","规模","pga","它","这种","元件","不过","理器"," ","某","没有","四个","intel","现代","而言","大型","算机","大规模","计算","大","增加","）","范围","组成","完成","随处可见","存储器","迄今为止","文档","找到","集成","下图","一般","控制","过程","1960","成电","开始","并且","执行","日益","只要","发出","昂贵","用来","中央处理器","复杂","算器","标准","等","两个","儿童","早期","晶体","称为","各","参考","能","定制","为止","处理器","称之为","控制器","到","发生","个","执行程序","已","运算","大规","一直","和","通常","​","取出","计时","此项","中","（","大大"],"title":"CPU","title_tokens":["cpu"]},{"location":"计算机基础/1.1.计算机与程序结构.html#_1","text":"根据功能的不同，我们可以将寄存器大致划分为八类。可以看出，==寄存器中存储的内容既可以是指令也可以是数据。其中，数据分为“用于运算的数值”和“表示内存地址的数值”两种。==数据种类不同，存储该数值的寄存器也不同。CPU 中每个寄存器的功能都是不同的。 种类 功能 累加寄存器 accumulator 存储执行运算的数据和运算后的数据 标志寄存器 flag register 存储运算处理后的 CPU 的状态 程序计数器 program counter 存储下一条指令所在内存的地址 基址寄存器 base register 存储数据内存的起始地址 变址寄存器 index register 存储基址寄存器的相对地址 通用寄存器 general purpose register 存储任意数据 指令寄存器 instruction register 存储指令。CPU 内部使用，程序员无法通过程序对该寄存器进行读写操作 栈寄存器 stack register 存储栈区域的起始地址 寄存器对程序员来说比较特殊，因为寄存器是编程中的一个对象，例如在汇编语言中： # 汇编语言编写的程序示例 mov eax, dword ptr [ebp-8] …把数值从内存复制到 eax add eax, dword ptr [ebp-0Ch] …exa 的数值和内存的数值相加 mov dword ptr [ebp-4], eax …把 exa 的数值（上一步的相加结果）存储在内存中 eax 和 ebp 是 CPU 内部的寄存器的名称。内存的存储场所通过地址编号来区分，而寄存器的种类则通过名字来区分。","text_tokens":["不同","存储栈","是","”","从","add","每个","=","flag","汇编语言","8","数据","相对","所在","寄存","…","场所","来","存储","寄存器","无法","操作","读写操作","指令寄存器","指令","在","区分","。","复制","]","，","内存","general","名称","一个","栈","instruction","后","起始","编写","语言","为","index","比较","stack","计数器","相加","汇编","功能","示例","累加","内部","看出","通用","使用","程序员","-","把","根据","用于","“","读写","该","上","程序","base","cpu","数值","种类","都","对","：","对象","其中","#","也","ebp","名字","表示","地址","编程","register","处理","因为","大致","结果","区域","两种","dword","通过","则","编号","的","将","可以","计数","既","内存地址","4","标志","状态","而","counter"," ","特殊","任意","分为","一步","）","八类","program","内容","复制到","mov","ptr","例如","0ch","eax","变址","执行","[","基址","exa","来说","我们","accumulator","进行","通用寄存器","purpose","运算",",","和","下","一条","划分","中","（"],"title":"寄存器的主要种类和功能","title_tokens":["寄存器","种类","和","功能","主要","寄存","的"]},{"location":"计算机基础/1.1.计算机与程序结构.html#main-memory","text":"通常所说的内存指的是计算机的主存储器（main memory），简称主存。 主存通过控制芯片等与 CPU 相连， 主要负责存储指令和数据。 主存由可读写的元素构成，每个字节（1 Byte = 8 bit ）都带有一个地址编号。 CPU 可以通过该地址读取主存中的指令和数据，以及写入数据。","text_tokens":["简称","算机","由","元素","字节","计算","byte","地址","）","读取","是","存储器","构成","相连","芯片","主要","带有","控制","每个","=","通过","所说","写入","8","数据","计算机","等","编号","的","可以","memory","主存","负责","存储","主存储器","指令","。","读写","该","可","1","以及","指","与","cpu","bit","，","内存","都","通常","指令和数据","中","main"," ","一个","（"],"title":"main memory","title_tokens":["memory"," ","main"]},{"location":"计算机基础/1.1.计算机与程序结构.html#_2","text":"内存的构成单位是一个字节（8位），每一个字节都有一个地址编号，这个地址编号是它的逻辑地址。 CPU中的寄存器（基址寄存器、变址寄存器）会储存中被运算的数据的编号地址。CPU寄存器的空间大小决定了CPU能识别多大的内存。 比如说，一个32位的寄存器，它能表示的最大数为$2^{32}-1=4294967295$（十进制数，从0开始；换成16进制数就是FFFFFFFF）。也就是说它能表示$2^{32}=4294967296$种状态。而4g的内存一共有$4\\times1024\\times1024\\times1024=4294967296$个byte，也就是说一个具有32位的寄存器的CPU最多能识别4g的内存。 通过基址寄存器和变址寄存器，我们可以对主内存上特定的内存区域进行划分。首先，我们用十六进制数 将计算机内存上 00000000～FFFFFFFF的地址划分出来。那么，凡是该范围的内存区域，只要有一个 32 位的 寄存器，即可查看全部的内存地址。 CPU所生成的地址通常称为逻辑地址(logical address)，而内存单元所看到的地址（即加载到内存地址寄存器(memory-address register)中的地址）通常称为物理地址(physical address) 。 逻辑地址与物理地址的对应关系并不是固定不变的，这取决于执行的地址绑定方案。因此，逻辑地址又称为虚拟地址。虚拟地址通过 映射 与物理地址对应起来。完成这种映射的硬件设备是 内存管理单元 (memory-management unit, MMU)，完成映射的方法有多种，也就是地址绑定方案有多种。程序无法访问物理地址，只能基于虚拟地址进行操作。","text_tokens":["比如","最多能","对应","physical","是","方法","起来","就是","从","具有","物理地址","=",")","这","8","又","times1024","数据","单位","特定","寄存","2","了","设备","操作","寄存器","无法","。","1","这个","与","看到","，","～","出来","内存","单元","有","用","一个","并","4294967295","字节","为","byte","management","数","构成","十进制","硬件","映射","会","进制","\\","关系","首先","即","-","最大数","只能","最大","unit","加载","上","生成","该","基于","不是","空间","0","换成","程序","全部","cpu","、","$","大数","16","都","即可","那么","4g","也","物理","address","虚拟地址","地址","表示","方案","多种","register","4294967296","大小","管理","32","也就是说","区域","^","{","通过","位","被","识别","计算机","编号","就是说","的","可以","将","logical","memory","最多","虚拟","内存地址","4","而","状态","种","每","它","这种","凡是","十六进制"," ","00000000","无法访问","算机","计算","范围","）","完成","一共","mmu","查看","ffffffff","固定","十六","}","开始","决定","变址","不变","执行","只要","因此","基址","逻辑","；","称为","能","我们","取决","储存","进行","比如说","个","到","访问","运算","对主","绑定","所",",","和","通常","(","取决于","划分","多大","中","（"],"title":"如何通过内存索引数据？","title_tokens":["如何","内存","通过","数据","？","索引"]},{"location":"计算机基础/1.2.基本概念.html","text":"程序和编程语言 程序（Program） 告诉计算机应如何完成一个计算任务，这里的计算可以是数学运算，比如解方程，也可以是符号运算，比如查找和替换文档中的某个单词。从根本上说，==计算机是由数字电路组成的运算机器，只能对数字做运算，程序之所以能做符号运算，是因为符号在计算机内部也是用数字表示的。==此外，程序还可以处理声音和图像，声音和图像在计算机内部必然也是用数字表示的，这些数字经过专门的硬件设备转换成人可以听到、看到的声音和图像。 程序由一系列 指令（Instruction） 组成，指令是指示计算机做某种运算的命令，通常包括以下几类： 输入（Input）：从键盘、文件或者其它设备获取数据。 输出（Output）：把数据显示到屏幕，或者存入一个文件，或者发送到其它设备。 基本运算：执行最基本的数学运算（加减乘除）和数据存取。 测试和分支：测试某个条件，然后根据不同的测试结果执行不同的后续指令。 循环：重复执行一系列操作。 对于程序来说，有上面这几类指令就足够了。你曾用过的任何一个程序，不管它有多么复杂，都是由这几类指令组成的。程序是那么的复杂，而编写程序可以用的指令却只有这么简单的几种，这中间巨大的落差就要由程序员去填了，所以编写程序理应是一件相当复杂的工作。 编写程序可以说就是这样一个过程：把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。 编程语言 ：编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。 机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，==语句是计算机指令的抽象表示。==举个例子，同样一个语句用C语言、汇编语言和机器语言分别表示如下： 低级编程语言使用计算机指令编写程序； 高级编程语言使用语句编写程序。 计算机只能对数字做运算，符号、声音、图像在计算机内部都要用数字表示，指令也不例外，上表中的机器语言完全由十六进制数字组成。最早的程序员都是直接用机器语言编程，但是很麻烦，需要查大量的表格来确定每个数字表示什么意思，编写出来的程序很不直观，而且容易出错，于是有了==汇编语言，把机器语言中一组一组的数字用助记符（Mnemonic）表示，直接用这些助记符写出汇编程序，然后让汇编器（Assembler）去查表把助记符替换成数字，也就把汇编语言翻译成了机器语言。 从上面的例子可以看出，==汇编语言和机器语言的指令是一一对应的，汇编语言有三条指令，机器语言也有三条指令，汇编器就是做一个简单的替换工作 ，例如在第一条指令中，把 movl ?,%eax 这种格式的指令替换成机器码 a1 ? ，?表示一个地址，在汇编指令中是 0x804a01c ，转换成机器码之后是 1c a0 04 08 （这是指令中的十六进制数的小端表示，小端表示将在 第 5.1 节 “目标文件” 介绍）。 从上面的例子还可以看出，==高级语言的语句和低级语言的指令之间不是简单的一一对应关系，==一条 a=b+1; 语句要翻译成三条汇编或机器指令，这个过程称为 编译（Compile） ，由编译器（Compiler）来完成，显然编译器的功能比汇编器要复杂得多。用高级语言编写的程序必须经过编译转成机器指令才能被计算机执行，编译需要花一些时间，这是用高级语言编程的一个缺点，然而更多的是优点。首先，用高级语言编程更容易，写出来的代码更紧凑，可读性更强，出了错也更容易改正。其次，高级语言是可移植的（Portable）或者称为平台无关的（Platform Independent）。 平台 这个词有很多种解释，可以指计算机体系结构（Architecture），也可以指操作系统（Operating System），也可以指开发平台（编译器、链接器等）。不同的计算机体系结构有不同的指令集（Instruction Set），可以识别的机器指令格式是不同的，直接用某种体系结构的汇编或机器指令写出来的程序只能在这种体系结构的计算机上运行，然而各种体系结构的计算机都有各自的C编译器，可以把C程序编译成各种不同体系结构的机器指令，这意味着用C语言写的程序只需稍加修改甚至不用修改就可以在各种不同的计算机上编译运行。各种高级语言都具有C语言的这些优点，所以绝大部分程序是用高级语言编写的，只有和硬件关系密切的少数程序（例如驱动程序）才会用到低级语言。还要注意一点，即使在相同的体系结构和操作系统下，用不同的C编译器（或者同一个C编译器的不同版本）编译同一个程序得到的结果也有可能不同，C语言有些语法特性在C标准中并没有明确规定，各编译器有不同的实现，编译出来的指令的行为特性也会不同，应该尽量避免使用不可移植的语法特性。 总结一下编译执行的过程，首先你用文本编辑器写一个C程序，然后保存成一个文件，例如 program.c （通常C程序的文件名后缀是 .c ），这称为源代码（Source Code）或源文件，然后运行编译器对它进行编译，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，再加上一些描述信息，生成一个新的文件，例如 a.out ，这称为可执行文件，可执行文件可以被操作系统加载运行，计算机执行该文件中由编译器生成的指令，如下图所示： 有些高级语言以解释（Interpret）的方式执行，解释执行过程和C语言的编译执行过程很不一样。例如编写一个Shell脚本 script.sh ，内容如下： #! /bin/sh VAR = 1 VAR = $(( $VAR + 1 )) echo $VAR 定义Shell变量 VAR 的初始值是1，然后自增1，然后打印 VAR 的值。用Shell程序 /bin/sh 解释执行这个脚本，结果如下： $ / bin / sh script . sh 2 这里的 /bin/sh 称为解释器（Interpreter），它把脚本中的每一行当作一条命令解释执行，而不需要先生成包含机器指令的可执行文件再执行。如果把脚本中的这三行当作三条命令直接敲到Shell提示符下，也能得到同样的结果： $ VAR = 1 $ VAR = $ (( $ VAR + 1 )) $ echo $ VAR 2 编程语言仍在发展演化。以上介绍的机器语言称为第一代语言（1GL，1st Generation Programming Language），汇编语言称为第二代语言（2GL，2nd Generation Programming Language），C、C++、Java、Python等可以称为第三代语言（3GL，3rd Generation Programming Language）。目前已经有了4GL（4th Generation Programming Language）和5GL（5th Generation Programming Language）的概念。3GL的编程语言虽然是用语句编程而不直接用指令编程，但语句也分为输入、输出、基本运算、测试分支和循环等几种，和指令有直接的对应关系。而4GL以后的编程语言更多是描述要做什么（Declarative）而不描述具体一步一步怎么做（Imperative），具体一步一步怎么做完全由编译器或解释器决定，例如SQL语言（SQL，Structured Query Language，结构化查询语言）就是这样的例子。 解释执行的语言相比编译执行的语言有什么优缺点？ 这是我们的第一个思考题。本书的思考题通常要求读者系统地总结当前小节的知识，结合以前的知识，并经过一定的推理，然后作答。本书强调的是基本概念，读者应该抓住概念的定义和概念之间的关系来总结，比如本节介绍了很多概念：程序由语句或指令组成，计算机只能执行 低级语言 中的指令（汇编语言的指令要先转成机器码才能执行），高级语言要执行就必须先翻译成低级语言，翻译的方法有两种：编译和解释，虽然有这样的不便，但高级语言有一个好处是平台无关性。什么是平台？一种平台，就是一种体系结构，就是一种指令集，就是一种机器语言，这些都可看作是一一对应的，上文并没有用“一一对应”这个词，但读者应该能推理出这个结论，而高级语言和它们不是一一对应的，因此高级语言是平台无关的，概念之间像这样的数量对应关系尤其重要。那么编译和解释的过程有哪些不同？主要的不同在于什么时候翻译和什么时候执行。 现在回答这个思考题，根据编译和解释的不同原理，你能否在执行效率和平台无关性等方面做一下比较？ 程序的调试 编程是一件复杂的工作，因为是人做的事情，所以难免经常出错。据说有这样一个典故：早期的计算机体积都很大，有一次一台计算机不能正常工作，工程师们找了半天原因最后发现是一只臭虫钻进计算机中造成的。从此以后，程序中的错误被叫做臭虫（Bug），而找到这些Bug并加以纠正的过程就叫做调试（Debug）。有时候调试是一件非常复杂的工作，要求程序员概念明确、逻辑清晰、性格沉稳，还需要一点运气。调试的技能我们在后续的学习中慢慢培养，但首先我们要区分清楚程序中的Bug分为哪几类。 编译时错误 编译器只能翻译语法正确的程序，否则将导致编译失败，无法生成可执行文件。对于自然语言来说，一点语法错误不是很严重的问题，因为我们仍然可以读懂句子。而编译器就没那么宽容了，只要有哪怕一个很小的语法错误，编译器就会输出一条错误提示信息然后罢工，你就得不到你想要的结果。虽然大部分情况下编译器给出的错误提示信息就是你出错的代码行，但也有个别时候编译器给出的错误提示信息帮助不大，甚至会误导你。在开始学习编程的前几个星期，你可能会花大量的时间来纠正语法错误。等到有了一些经验之后，还是会犯这样的错误，不过会少得多，而且你能更快地发现错误原因。等到经验更丰富之后你就会觉得，语法错误是最简单最低级的错误，编译器的错误提示也就那么几种，即使错误提示是有误导的也能够立刻找出真正的错误原因是什么。相比下面两种错误，语法错误解决起来要容易得多。 运行时错误 编译器检查不出这类错误，仍然可以生成可执行文件，但在运行时会出错而导致程序崩溃。对于我们接下来的几章将编写的简单程序来说，运行时错误很少见，到了后面的章节你会遇到越来越多的运行时错误。读者在以后的学习中要时刻 注意区分编译时和运行时（Run-time）这两个概念 ，不仅在调试时需要区分这两个概念，在学习C语言的很多语法时都需要区分这两个概念，有些事情在编译时做，有些事情则在运行时做。 逻辑错误和语义错误 第三类错误是逻辑错误和语义错误。如果程序里有逻辑错误，编译和运行都会很顺利，看上去也不产生任何错误信息，但是程序没有干它该干的事情，而是干了别的事情。当然不管怎么样，计算机只会按你写的程序去做，问题在于你写的程序不是你真正想要的，这意味着程序的意思（即语义）是错的。找到逻辑错误在哪需要十分清醒的头脑，要通过观察程序的输出回过头来判断它到底在做什么。 调试的过程可能会让你感到一些沮丧，但调试也是编程中最需要动脑的、最有挑战和乐趣的部分。从某种角度看调试就像侦探工作，根据掌握的线索来推断是什么原因和过程导致了你所看到的结果。调试也像是一门实验科学，每次想到哪里可能有错，就修改程序然后再试一次。如果假设是对的，就能得到预期的正确结果，就可以接着调试下一个Bug，一步一步逼近正确的程序；如果假设错误，只好另外再找思路再做假设。“当你把不可能的全部剔除，剩下的——即使看起来再怎么不可能——就一定是事实。”（即使你没看过福尔摩斯也该看过柯南吧）。 也有一种观点认为，编程和调试是一回事，编程的过程就是逐步调试直到获得期望的结果为止。你应该总是从一个能正确运行的小规模程序开始，每做一步小的改动就立刻进行调试，这样的好处是总有一个正确的程序做参考：如果正确就继续编程，如果不正确，那么一定是刚才的小改动出了问题。例如，Linux操作系统包含了成千上万行代码，但它也不是一开始就规划好了内存管理、设备管理、文件系统、网络等等大的模块，一开始它仅仅是Linus Torvalds用来琢磨Intel 80386芯片而写的小程序。据Larry Greenfield 说，“Linus的早期工程之一是编写一个交替打印AAAA和BBBB的程序，这玩意儿后来进化成了Linux。”（引自The Linux User's Guide Beta1版）在后面的章节中会给出更多关于调试和编程实践的建议。 变量及其行为 变量（Variable）是编程语言最重要的概念之一。 变量是计算机存储器中的一块命名的空间，可以在里面存储一个值（Value），存储的值是可以随时变的，比如这次存个字符 'a' 下次存个字符 'b' ，正因为变量的值可以随时变所以才叫变量。 也就是说，变量有一个储存地址，该地址储存的值是可以改变的。或者说，变量是一种使用方便的占位符，用于引用计算机内存地址，变量创建后会占用一定的内存空间。 不要弄混变量和变量名，变量名是标识符的一种。 占位符 ：先占住一个固定的位置，等待值添加到该位置的符号。 变量的类型决定了它所占的存储空间的大小。 变量的行为一共有四种：声明、定义、初始化、赋值。 声明 ：告诉编译器/解析器有这个变量的存在，这个行为不分配内存空间。 定义 ：为变量分配内存空间。 实际上，从广义的角度来说，声明有两种： 引用性声明（defining declaration）：不需要建立储存空间的声明，例如 extern in a 中的变量 a 已经在别的文件中被定义。 定义性声明（referencing declaration）：需要建立储存空间的声明，例如 int a 在声明时就建立了 a 的储存空间。 可见从广义的角度来说，声明包含了定义，而并非所有的声明都是定义。一般的情况下我们常常这样叙述，把建立空间的声明称之为\"定义\"，而把不需要建立存储空间称之为\"声明\"。 定义和声明的本质区别就是：定义会给变量分配内存空间，而声明则不会。 初始化 ：在定义变量之后，系统为变量分配的内存空间内并没有值，此时值是不确定的。为保证程序的安全性和确定性，需要对这个内存空间进行初始化。初始化一般伴随着定义而产生。初始化是从无到有的过程。 如果变量的定义没有初始化，那这个最初分配的空间的值是随机的（空间上原来存储的值）。不经过初始化的变量可能会为程序带来不安全与不确定性。 赋值 ：赋值是变量值得刷新操作。赋值是从旧到新的过程。 基本术语解释 assignment ：Assignments do not copy data — they just bind names to objects. assignment操作不会拷贝，只是把名字和对象做一个绑定。也就是assignment语句是起一个绑定或重绑定的作用（bind or rebind）。函数调用的参数传递是传引用，不是拷贝。 引用（reference ） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。因此，引用亦常被称为==该资料==的 指标 或 位址 。 标识符（identifier，缩写为ID） ：又称为识别码，是一个用来识别不同对象的名称。 在编程语言中，标识符就是程序员自己规定的具有特定含义的词，比如函数名、方法名、类名，变量名、常量名等。 对象（object） ：是一个记忆体位址，其中拥有值，这个位址可能有标识符指向此处。台湾译作物件。对象是某个类的实例。我们将数据和对数据的操作融为一体，形成具有静态信息和动态行为的对象。 每个对象都具有一个ID、一个类型、一个值。对象一旦建立，ID便不会改变。这里所说的ID是是对象在内存中的地址，而不是identifier。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 标识符并不是对象的属性，一个对象可以指向不同的标识符。而管理这些名字（标识符）的事物就是“命名空间”。 命名空间（Namespace） ：名字（标识符）到对象的==映射==。 A namespace is a mapping from names to objects. 各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。 现今 Python 的大部分命名空间是通过字典来实现的，也即一个命名空间就是名字到对象的映射，标识符是键，对象则是值。 与命名空间相对的一个概念就是“作用域” 。 作用域（Scope） ：本质是一块文本区域，Python 通过该文本区域可以 直接访问 相应的命名空间。 直接访问 ：Python 中不加 . 的访问为直接访问，反之为属性访问。 命名空间与作用域的联系 ：作用域是 Python 的一块文本区域，即一块代码区域，需要代码区域引用名字（标识符）来访问变量，那么作用域与命名空间之间就有了联系。 名字作用域 ：名字可以影响到的代码文本区域。 命名空间的作用域 ：就是这个命名空间可以影响到的代码文本区域。 显然可以存在这样的一个代码文本区域，它可以被多个命名空间影响。 面向对象编程 ：基于对象概念来分析问题和设计解法，这就是面向对象编程（object-orientation programming，简称OOP）。通过OOP所得到的程序是一个由很多对象组成的系统，可以向对象发送消息来实现对数据的处理，全体对象通过相互协作来完成程序的数据处理功能。 面向过程编程 ：得到的程序是一组对数据进行操作的过程，通过按顺序执行这些过程来实现程序功能。 类的概念 类是类型概念的发展。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 用计算机解决问题时，首先需要明确问题中涉及哪些数据，并在程序中将这些数据用编程语言提供的数据类型表示出来，然后再去考虑需要对这些数据执行何种操作。 为了表示数据，编程语言一般提供若干 基本数据类型 （如Python的int、float、str和list等类型） ，并为这些基本类型提供相应的基本操作（如Python中对int、float、str和list都提供了+运算，尽管含义不同）。 然而，实际问题中往往涉及很复杂的数据，不能用基本数据类型直接表示。为了表示复杂数据，大体有两种办法： 一种是将复杂数据分解成若干个简单数据项，以便每个数据项可以用基本类型表示 另一种是由用户自定义新的数据类型，以便对复杂数据进行直接的、整体的表示。 例如，如果要表示一个学生的姓名，可以简单地用一个字符串数据表示；如果要表示一个学生的年龄，可以简单地用一个整数数据表示。但如果要整体表示一个“学生”，包括该学生的姓名、年龄、地址等信息，就没法用基本数据类型直接表示了。 一种解决办法是将整体的“学生”分解成姓名、年龄、地址等简单数据，并通过分别处理这些简单数据而达到处理“学生”数据的目的。但这不是好办法，因为这种表示法丢失了数据的整体性，在维护姓名、年龄、地址等数据间的联系时很麻烦。 另一种解决办法是将学生整体视为一个数据值，并为这种数据值定义新的数据类型（因为编程语言中没有现成的类型能够表示该数据）。 假设我们要为“学生“数据定义一个新的数据类型S，那么S应该是由若干更简单的数据项构成的（如学号、姓名等），我们称这些构成S的成员数据为S的属性。除了定义S类型数据的属性，还需要定义能对S数据执行什么操作（如修改姓名或年龄、读取地址等）。可以利用编程语言提供的基本类型和新类型定义机制来实现S，例如用str类型表示姓名和学号，用int类型表示年龄之类，用函数实现对S数据的操作。定义了S，就好像为编程语言添加了一个新的数据类型，应用程序就可以像使用整数、字符串等基本类型一样去使用S。 由此，我们从传统的数据类型概念发展出了“类”的概念。类（class）是广义的数据类型，能够定义复杂数据的特性，包括静态特性（即数据）和动态特性（即对数据的操作方法）。 类的值就是“对象”，也称为类的实例。 对象 vs 变量 python的入门者可能很容易把变量和对象混为一谈。在Python中，变量的准确说法应该name（名字）。 在python中，对象属于某一个类型，而名字是没有类型的。所有的名字都是内存中一个对象的“引用”，也就是说名字对应着对象的地址，而不是储存了对象本身。 例如： nfoo = 1 #一个指向int数据类型的nfoo（再次提醒，nfoo没有类型），在这里，具有类型的是1 lstFoo = [ 1 ] #一个指向list类型的lstFoo，这个list中包含一个整数1","text_tokens":["系统","很多","一系列","明确规定","对应","接下","然后","误信","成员","小端","问题","!","臭虫","the","举个","每次","单词","需","玩意儿","专门","c语言","只好","对于","分配","总有","正","考题","不仅","表格","不可","name","紧凑","了","占用","叙述","任务","存储","上文","low","起","指令","大体","到底","类型定义","汇编程序","定性","自定","填","]","但","这个","提示信息","机器指令","加上","一一对应","柯南","常量","时候","混为","而是","解法","查表","可能","源代码","并","规划","编写","相应","这样","语言","调试","继续","简称","为","数学","编写程序","非常","等等","准确","同一","后面","应该","硬件","顺利","基于","像是","循环","自增","基本概念","提示","成千","上面","编译器","占","\"","思考题","里","考虑","实际上","驱动程序","使用","后缀","一只","这次","明确","程序员","-","例外","只能","反之","认为","学号","其他","保存","甚至","这类","portable","上","尽量避免","生成","完全","目标","该","没","换成","time","程序","动脑","independent","大量","、","空间","占住","抓住","they","出","译成","属于","层层","0x804a01c","对","编译","才能","越来越","交替","函数调用","麻烦","像","如学","structured","只","之一","5th","地","#","已经","从此以后","着","位置","还是","敲到","变","相互协作","再次","它们","面向","还","于是","因为","04","多个","debug","观察","达到","结果","这里","部分","只有","+","第一个","两种","programming","出错","花","怎么样","区域","会花","结合","规定","to","识别","会犯","四种","各个","另","计算机","机器","误导","系列","判断","觉得","文件名","a","语法","文本","看过","体系结构","不会","找","创建","query","一下","广义","沉稳","本质区别","人","不确定性","data","移植","学生","知识","操作方法","declarative","sh","区别","第一代","低级","每","只会","变量","半天","章节","语义","分解","期望","命名","分为","如何","严重","条件","）","第一条","办法","现在","完成","结构","送到","回事","内","用户","定义新","orientation","自然语言","经常","看上","常常","固定","快","过程","指向","eax","复杂","[","学习","1c",";","转","然而","代码","4gl","性","剔除","占位","实验","叫","句子","称之为","错","消息","新","几种","到","本","拷贝","随时","aaaa","这么",",","此时","时会","本身","据说","立刻","一件","do","物件","比如","第三","assignment","伴随","等待","中间","培养","高级","时间","整体性","从","小","相互","每个","琢磨","系统地","小节","哪","避免","存取","数据","称","特定","相对","编译成","少数","2","正确","添加","三代","识别码","尽管","提醒","乐趣","转成","罢工","遇到","尽量","融为一体","确定","意味","字典","方程","向","bind","推理","，","某种","平台","看上去","出来","号","一点","亦","定义","角度看","体系","产生","有","某个","output","language","high","能够","一个","回过","沮丧","使用方便","上万","名","数据处理","叫做","否则","目前","说","比较","引自","多么","做","或者说","bin","工程师","失败","发现错误","构成","维护","却","看起","内部","进制","这些","输入","记忆","词","格式","前","简单","发送到","修改","改正","之为","首先","关于","确定性","操作系统","一次","于","把","转换成","具体","或者","一定","加载","“","code","是因为","全部","architecture","解释","符号","方面","影响","成","虽然","用到","源文件","字符","而且","：","?","符","可见","分析","缺点","脚本","机器语言","system","绝大","int","是从","过","数字电","实践","但是","形成","普通","体性","不能","vs","助记符","典故","稍加","linux","电脑","可读","若干个","更","声明","去","能否","所以","几类","台湾","现今","优点","侦探","即使","assembler","管理","也就是说","内存空间","list","字符串","基本操作","后续","改变","赋值","信息","编程语言","告诉","情况","独立","联系","什么","可以","将","时","事实","行为","巨大","设计","只是","标识符","%","另外","显示","参数","set","描述","可","刚才","variable","安全性","一体","面向对象编程","提供","协作","写","会少","常","直接","数据表","中是","解释器","不过","接下来","给出","造成","获取数据","把子","而言","先","重要","刷新","过头","大","拥有","传统","内容","真正","任何","？","文档","主要","例如","大部分","所示","不要","一般","那","重复","c","查询语言","a1","里面","释器","决定","执行","你","文件系统","据","要","有时","用来","别的","等","调用","发现","年龄","翻译","属性","效率","语句","参考","我们","greenfield","运气","以前","上表","储存","听到","进行","in","访问","图","查询","所","绑定","自己","二代","相比","如","关系密切","除了","sql","打印","中","查找","platform","linus","需要","入门者","is","var","包括","不","是","总是","经验","存入","其它","不管","读懂","之间","起来","”","java","具有","参数传递","屏幕","结构化","术语","=","让","好","才","为了","这","compiler","汇编语言","若干","模块","一些","beta1","很少","namespace","最初","再试一次","工作","建立","区分","绝大部分","str","之类","实例","1","从无到有","很大","优缺点","尤其","玩意","nfoo","分别","各种","之后","先生","逐步","defining","原理","中不加","movl","思路","用","无关","自定义","由","加以","地用","或","包含","得","强调","汇编","c++","推断","5.1","—","键盘","会为","copy","想到","间","source","映射","会","福尔","时刻","摩斯","程式","全体","错误","直到","python","根据","安全","之所以","还要","改动","解决","level","就要","解析器","不是","清醒","第二代","基本","指","链接","输出","值得","资料","难免","都","a0","行文","得到","本书","随机","names","运行","not","其中","一一","也","介绍","入门","干","表示","十分","没法","compile","静态","应用","重名","可移植","处理","查","逼近","大小","非常复杂","翻译成","被","越来","清晰","则","建议","清楚","译作","没法用","就是说","利用","的","最有","此外","替换","电路","注意","更强","个字符","存在","类型","整体","根本","福尔摩斯","按","scope","不便","小规模","顺序","而","不用","最早","初始化","中要","规模","钻进","这种","预期","容易","float","好像","由此","十六进制","identifier","实体"," ","并非","某","观点","intel","想要","星期","键","2gl","指令集","数据项","间接","一步","program","存储器","初始值","慢慢","以","正常","通过观察","或重","汇编器","十六","机器码","引用","发送","分配内存","见","machine","旧到","echo","input","；","来说","剩下","机制","各","称为","3rd","objects","s","如果","解方程","特性","为止","带来","变量名","说法","节","意味着","行","事物","角度","几章","运算","缩写","以上","一台","几个","和","后来","(","网络","指标","一条","一行","当前","提示符","object","08","不同","保证","子","传","行程","此处","及其","一般而言","方法","个别","声音","类名","密切","就是","目的","本质","助记","不到","获取","一系",")","下来","有些","有时候","generation","接着","进化",".","事情","同一个","存","id","又","加减乘除","动态","例子","b","以便","器写","来","版","当","设备","何种","在","操作","曾","无法","驱动","rebind","bbbb","。","lstfoo","技能","编程序","初始","run","命令","崩溃","回过头来","数字","imperative","与","下面","看到","3gl","成人","就","其次","三行","科学","纠正","内存","一块","给","仅仅","名称","开发","线索","加减","当然","从根本上","instruction","文本编辑","后","体积","不出","larry","编辑","'","很","下次","回答","中一","总结","数","大部","再","经过","第二","功能","5gl","传递","中将","作答","怎么","一旦","相当","演化","结论","现成","看出","文件","关系","guide","即","多","mnemonic","意思","数量","器","第三类","4th","用于","value","工程","分支","很小","发展","弄混","表示法","比","bug","语法错误","mapping","reference","理应","一对","自然","解决问题","分解成","$","这是","三条","上去","看作","extern","获得","直观","显然","低级语言","对象","等到","那么","方式","宽容","declaration","往往","存储空间","类","看起来","shell","名字","读取","地址","一种","如下","落差","哪怕","编程","多种","要求","class","一代","可读性","芯片","丰富","最后","statement","词有","一组","涉及","错误信息","1st","图像","版本","1gl","通过","哪里","assignments","torvalds","挑战","user","所说","丢失","假设","必然","在于","数字电路","帮助","含义","原因","应用程序","视为","/","解析","函数","找出","装置","实现","测试","解决办法","先占住","out","仍","内存地址","同样","最","不加","方便","指示","assembly","from","便","它","仍然","头脑","写出","足够","数据类型","没有","读者","哪些","成千上万","一样","检查","标识","替换成","算机","第三代","计算","组成","2nd","从此","吧","概念","一共","性格","数据表示","找到","千上万","referencing","第一","数传","三类","第","开始","因此","一","80386","只要","应","当作","逻辑","标准","以后","两个","感到","乘除","早期","掌握","一一对","作用域","interpreter","必须","可执行文件","能","转换","interpret","值","得不到","抽象","思考","作用","导致","相同","just","好处","各自","以下","一门","执行程序","or","oop","混为一谈","姓名","operating","下","通常","所有","们","实际","整数","script","记忆体","原来","（","位址","融为"],"title":"1.2.基本概念","title_tokens":["基本概念",".","概念","1.2","基本"]},{"location":"计算机基础/1.2.基本概念.html#_1","text":"程序（Program） 告诉计算机应如何完成一个计算任务，这里的计算可以是数学运算，比如解方程，也可以是符号运算，比如查找和替换文档中的某个单词。从根本上说，==计算机是由数字电路组成的运算机器，只能对数字做运算，程序之所以能做符号运算，是因为符号在计算机内部也是用数字表示的。==此外，程序还可以处理声音和图像，声音和图像在计算机内部必然也是用数字表示的，这些数字经过专门的硬件设备转换成人可以听到、看到的声音和图像。 程序由一系列 指令（Instruction） 组成，指令是指示计算机做某种运算的命令，通常包括以下几类： 输入（Input）：从键盘、文件或者其它设备获取数据。 输出（Output）：把数据显示到屏幕，或者存入一个文件，或者发送到其它设备。 基本运算：执行最基本的数学运算（加减乘除）和数据存取。 测试和分支：测试某个条件，然后根据不同的测试结果执行不同的后续指令。 循环：重复执行一系列操作。 对于程序来说，有上面这几类指令就足够了。你曾用过的任何一个程序，不管它有多么复杂，都是由这几类指令组成的。程序是那么的复杂，而编写程序可以用的指令却只有这么简单的几种，这中间巨大的落差就要由程序员去填了，所以编写程序理应是一件相当复杂的工作。 编写程序可以说就是这样一个过程：把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。 编程语言 ：编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。 机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，==语句是计算机指令的抽象表示。==举个例子，同样一个语句用C语言、汇编语言和机器语言分别表示如下： 低级编程语言使用计算机指令编写程序； 高级编程语言使用语句编写程序。 计算机只能对数字做运算，符号、声音、图像在计算机内部都要用数字表示，指令也不例外，上表中的机器语言完全由十六进制数字组成。最早的程序员都是直接用机器语言编程，但是很麻烦，需要查大量的表格来确定每个数字表示什么意思，编写出来的程序很不直观，而且容易出错，于是有了==汇编语言，把机器语言中一组一组的数字用助记符（Mnemonic）表示，直接用这些助记符写出汇编程序，然后让汇编器（Assembler）去查表把助记符替换成数字，也就把汇编语言翻译成了机器语言。 从上面的例子可以看出，==汇编语言和机器语言的指令是一一对应的，汇编语言有三条指令，机器语言也有三条指令，汇编器就是做一个简单的替换工作 ，例如在第一条指令中，把 movl ?,%eax 这种格式的指令替换成机器码 a1 ? ，?表示一个地址，在汇编指令中是 0x804a01c ，转换成机器码之后是 1c a0 04 08 （这是指令中的十六进制数的小端表示，小端表示将在 第 5.1 节 “目标文件” 介绍）。 从上面的例子还可以看出，==高级语言的语句和低级语言的指令之间不是简单的一一对应关系，==一条 a=b+1; 语句要翻译成三条汇编或机器指令，这个过程称为 编译（Compile） ，由编译器（Compiler）来完成，显然编译器的功能比汇编器要复杂得多。用高级语言编写的程序必须经过编译转成机器指令才能被计算机执行，编译需要花一些时间，这是用高级语言编程的一个缺点，然而更多的是优点。首先，用高级语言编程更容易，写出来的代码更紧凑，可读性更强，出了错也更容易改正。其次，高级语言是可移植的（Portable）或者称为平台无关的（Platform Independent）。 平台 这个词有很多种解释，可以指计算机体系结构（Architecture），也可以指操作系统（Operating System），也可以指开发平台（编译器、链接器等）。不同的计算机体系结构有不同的指令集（Instruction Set），可以识别的机器指令格式是不同的，直接用某种体系结构的汇编或机器指令写出来的程序只能在这种体系结构的计算机上运行，然而各种体系结构的计算机都有各自的C编译器，可以把C程序编译成各种不同体系结构的机器指令，这意味着用C语言写的程序只需稍加修改甚至不用修改就可以在各种不同的计算机上编译运行。各种高级语言都具有C语言的这些优点，所以绝大部分程序是用高级语言编写的，只有和硬件关系密切的少数程序（例如驱动程序）才会用到低级语言。还要注意一点，即使在相同的体系结构和操作系统下，用不同的C编译器（或者同一个C编译器的不同版本）编译同一个程序得到的结果也有可能不同，C语言有些语法特性在C标准中并没有明确规定，各编译器有不同的实现，编译出来的指令的行为特性也会不同，应该尽量避免使用不可移植的语法特性。 总结一下编译执行的过程，首先你用文本编辑器写一个C程序，然后保存成一个文件，例如 program.c （通常C程序的文件名后缀是 .c ），这称为源代码（Source Code）或源文件，然后运行编译器对它进行编译，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，再加上一些描述信息，生成一个新的文件，例如 a.out ，这称为可执行文件，可执行文件可以被操作系统加载运行，计算机执行该文件中由编译器生成的指令，如下图所示： 有些高级语言以解释（Interpret）的方式执行，解释执行过程和C语言的编译执行过程很不一样。例如编写一个Shell脚本 script.sh ，内容如下： #! /bin/sh VAR = 1 VAR = $(( $VAR + 1 )) echo $VAR 定义Shell变量 VAR 的初始值是1，然后自增1，然后打印 VAR 的值。用Shell程序 /bin/sh 解释执行这个脚本，结果如下： $ / bin / sh script . sh 2 这里的 /bin/sh 称为解释器（Interpreter），它把脚本中的每一行当作一条命令解释执行，而不需要先生成包含机器指令的可执行文件再执行。如果把脚本中的这三行当作三条命令直接敲到Shell提示符下，也能得到同样的结果： $ VAR = 1 $ VAR = $ (( $ VAR + 1 )) $ echo $ VAR 2 编程语言仍在发展演化。以上介绍的机器语言称为第一代语言（1GL，1st Generation Programming Language），汇编语言称为第二代语言（2GL，2nd Generation Programming Language），C、C++、Java、Python等可以称为第三代语言（3GL，3rd Generation Programming Language）。目前已经有了4GL（4th Generation Programming Language）和5GL（5th Generation Programming Language）的概念。3GL的编程语言虽然是用语句编程而不直接用指令编程，但语句也分为输入、输出、基本运算、测试分支和循环等几种，和指令有直接的对应关系。而4GL以后的编程语言更多是描述要做什么（Declarative）而不描述具体一步一步怎么做（Imperative），具体一步一步怎么做完全由编译器或解释器决定，例如SQL语言（SQL，Structured Query Language，结构化查询语言）就是这样的例子。","text_tokens":["系统","一系列","明确规定","对应","然后","小端","!","举个","单词","需","专门","c语言","对于","表格","不可","紧凑","了","任务","low","指令","汇编程序","填","但","这个","机器指令","加上","一一对应","而是","查表","可能","源代码","并","编写","这样","语言","数学","编写程序","同一","应该","硬件","循环","自增","提示","上面","编译器","驱动程序","使用","后缀","明确","程序员","-","例外","只能","保存","甚至","portable","上","尽量避免","生成","完全","目标","该","换成","程序","independent","大量","、","出","译成","属于","层层","0x804a01c","对","编译","才能","麻烦","structured","只","5th","#","已经","敲到","还","于是","因为","04","结果","这里","部分","只有","+","programming","出错","花","规定","识别","计算机","机器","系列","文件名","a","语法","文本","体系结构","query","一下","移植","declarative","sh","第一代","低级","每","变量","分解","分为","如何","条件","）","第一条","完成","结构","送到","过程","eax","复杂","1c",";","转","然而","代码","4gl","错","新","几种","到","这么",",","一件","比如","第三","中间","高级","时间","从","每个","避免","存取","数据","编译成","少数","2","三代","尽量","确定","意味","方程","，","某种","平台","出来","一点","定义","体系","有","某个","output","language","high","一个","目前","说","多么","做","bin","却","内部","进制","这些","输入","格式","简单","发送到","修改","改正","首先","操作系统","把","转换成","具体","或者","加载","“","code","是因为","全部","architecture","解释","符号","成","虽然","用到","源文件","而且","：","?","缺点","脚本","机器语言","system","绝大","过","数字电","但是","助记符","稍加","可读","更","去","所以","几类","优点","即使","assembler","后续","信息","编程语言","告诉","什么","可以","将","行为","巨大","%","显示","set","描述","写","直接","中是","解释器","获取数据","把子","内容","任何","文档","例如","大部分","所示","重复","c","查询语言","a1","释器","决定","执行","你","要","等","翻译","语句","上表","听到","进行","图","查询","二代","关系密切","sql","打印","中","查找","platform","需要","var","包括","不","是","存入","其它","不管","之间","”","java","具有","屏幕","结构化","=","让","才","这","compiler","汇编语言","一些","工作","绝大部分","1","分别","各种","之后","先生","movl","用","无关","由","或","包含","得","汇编","c++","5.1","键盘","source","会","直到","python","根据","之所以","还要","level","就要","不是","第二代","基本","指","链接","输出","都","a0","行文","得到","运行","一一","也","介绍","表示","compile","可移植","处理","查","翻译成","被","的","此外","替换","电路","注意","更强","根本","而","不用","最早","这种","容易","十六进制"," ","2gl","指令集","一步","program","初始值","以","汇编器","十六","机器码","发送","machine","echo","input","；","来说","各","称为","3rd","如果","解方程","特性","节","意味着","运算","以上","和","(","一条","一行","提示符","08","不同","子","行程","声音","密切","就是","助记","获取","一系",")","有些","generation",".","同一个","加减乘除","例子","b","器写","来","设备","在","操作","曾","驱动","。","编程序","初始","命令","数字","imperative","看到","3gl","成人","就","其次","三行","开发","加减","从根本上","instruction","文本编辑","编辑","很","总结","数","大部","再","经过","第二","功能","5gl","怎么","相当","演化","看出","文件","关系","多","mnemonic","意思","器","4th","分支","发展","比","理应","一对","分解成","$","这是","三条","直观","显然","低级语言","那么","方式","shell","地址","如下","落差","编程","多种","一代","可读性","最后","statement","词有","一组","1st","图像","版本","1gl","必然","数字电路","/","实现","测试","out","仍","同样","最","指示","assembly","它","写出","足够","没有","一样","替换成","算机","第三代","计算","组成","2nd","概念","第一","第","应","当作","标准","以后","乘除","一一对","interpreter","必须","可执行文件","能","转换","interpret","值","抽象","相同","各自","以下","执行程序","operating","下","通常","script","（"],"title":"程序和编程语言","title_tokens":["语言","和","编程","编程语言","程序"]},{"location":"计算机基础/1.2.基本概念.html#_2","text":"这是我们的第一个思考题。本书的思考题通常要求读者系统地总结当前小节的知识，结合以前的知识，并经过一定的推理，然后作答。本书强调的是基本概念，读者应该抓住概念的定义和概念之间的关系来总结，比如本节介绍了很多概念：程序由语句或指令组成，计算机只能执行 低级语言 中的指令（汇编语言的指令要先转成机器码才能执行），高级语言要执行就必须先翻译成低级语言，翻译的方法有两种：编译和解释，虽然有这样的不便，但高级语言有一个好处是平台无关性。什么是平台？一种平台，就是一种体系结构，就是一种指令集，就是一种机器语言，这些都可看作是一一对应的，上文并没有用“一一对应”这个词，但读者应该能推理出这个结论，而高级语言和它们不是一一对应的，因此高级语言是平台无关的，概念之间像这样的数量对应关系尤其重要。那么编译和解释的过程有哪些不同？主要的不同在于什么时候翻译和什么时候执行。 现在回答这个思考题，根据编译和解释的不同原理，你能否在执行效率和平台无关性等方面做一下比较？","text_tokens":["系统","很多","不同","比如","对应","是","然后","方法","高级","之间","就是","”","系统地","汇编语言","小节","考题","来","了","在","上文","指令","转成","。","尤其","但","这个","推理","，","平台","就","原理","定义","一一对应","体系","有","用","无关","时候","一个","并","这样","语言","由","回答","或","总结","比较","强调","经过","汇编","做","应该","作答","基本概念","这些","思考题","词","结论","关系","数量","只能","根据","一定","“","不是","一对","程序","基本","方面","解释","这是","抓住","看作","出","虽然","译成","编译","才能","都","：","本书","机器语言","低级语言","像","那么","一一","介绍","一种","它们","要求","能否","第一个","两种","翻译成","结合","计算机","机器","什么","在于","的","体系结构","一下","可","不便","知识","而","低级"," ","读者","没有","哪些","指令集","先","算机","重要","计算","组成","）","现在","结构","概念","？","主要","第一","机器码","过程","因此","执行","你","要","等","性","一一对","翻译","效率","语句","必须","能","我们","思考","以前","节","好处","本","和","通常","中","当前","（"],"title":"解释执行的语言相比编译执行的语言有什么优缺点？","title_tokens":["语言","编译","相比","执行","有","缺点","？","什么","优缺点","的","解释"]},{"location":"计算机基础/1.2.基本概念.html#_3","text":"编程是一件复杂的工作，因为是人做的事情，所以难免经常出错。据说有这样一个典故：早期的计算机体积都很大，有一次一台计算机不能正常工作，工程师们找了半天原因最后发现是一只臭虫钻进计算机中造成的。从此以后，程序中的错误被叫做臭虫（Bug），而找到这些Bug并加以纠正的过程就叫做调试（Debug）。有时候调试是一件非常复杂的工作，要求程序员概念明确、逻辑清晰、性格沉稳，还需要一点运气。调试的技能我们在后续的学习中慢慢培养，但首先我们要区分清楚程序中的Bug分为哪几类。 编译时错误 编译器只能翻译语法正确的程序，否则将导致编译失败，无法生成可执行文件。对于自然语言来说，一点语法错误不是很严重的问题，因为我们仍然可以读懂句子。而编译器就没那么宽容了，只要有哪怕一个很小的语法错误，编译器就会输出一条错误提示信息然后罢工，你就得不到你想要的结果。虽然大部分情况下编译器给出的错误提示信息就是你出错的代码行，但也有个别时候编译器给出的错误提示信息帮助不大，甚至会误导你。在开始学习编程的前几个星期，你可能会花大量的时间来纠正语法错误。等到有了一些经验之后，还是会犯这样的错误，不过会少得多，而且你能更快地发现错误原因。等到经验更丰富之后你就会觉得，语法错误是最简单最低级的错误，编译器的错误提示也就那么几种，即使错误提示是有误导的也能够立刻找出真正的错误原因是什么。相比下面两种错误，语法错误解决起来要容易得多。 运行时错误 编译器检查不出这类错误，仍然可以生成可执行文件，但在运行时会出错而导致程序崩溃。对于我们接下来的几章将编写的简单程序来说，运行时错误很少见，到了后面的章节你会遇到越来越多的运行时错误。读者在以后的学习中要时刻 注意区分编译时和运行时（Run-time）这两个概念 ，不仅在调试时需要区分这两个概念，在学习C语言的很多语法时都需要区分这两个概念，有些事情在编译时做，有些事情则在运行时做。 逻辑错误和语义错误 第三类错误是逻辑错误和语义错误。如果程序里有逻辑错误，编译和运行都会很顺利，看上去也不产生任何错误信息，但是程序没有干它该干的事情，而是干了别的事情。当然不管怎么样，计算机只会按你写的程序去做，问题在于你写的程序不是你真正想要的，这意味着程序的意思（即语义）是错的。找到逻辑错误在哪需要十分清醒的头脑，要通过观察程序的输出回过头来判断它到底在做什么。 调试的过程可能会让你感到一些沮丧，但调试也是编程中最需要动脑的、最有挑战和乐趣的部分。从某种角度看调试就像侦探工作，根据掌握的线索来推断是什么原因和过程导致了你所看到的结果。调试也像是一门实验科学，每次想到哪里可能有错，就修改程序然后再试一次。如果假设是对的，就能得到预期的正确结果，就可以接着调试下一个Bug，一步一步逼近正确的程序；如果假设错误，只好另外再找思路再做假设。“当你把不可能的全部剔除，剩下的——即使看起来再怎么不可能——就一定是事实。”（即使你没看过福尔摩斯也该看过柯南吧）。 也有一种观点认为，编程和调试是一回事，编程的过程就是逐步调试直到获得期望的结果为止。你应该总是从一个能正确运行的小规模程序开始，每做一步小的改动就立刻进行调试，这样的好处是总有一个正确的程序做参考：如果正确就继续编程，如果不正确，那么一定是刚才的小改动出了问题。例如，Linux操作系统包含了成千上万行代码，但它也不是一开始就规划好了内存管理、设备管理、文件系统、网络等等大的模块，一开始它仅仅是Linus Torvalds用来琢磨Intel 80386芯片而写的小程序。据Larry Greenfield 说，“Linus的早期工程之一是编写一个交替打印AAAA和BBBB的程序，这玩意儿后来进化成了Linux。”（引自The Linux User's Guide Beta1版）在后面的章节中会给出更多关于调试和编程实践的建议。","text_tokens":["系统","很多","接下","然后","误信","问题","臭虫","the","每次","玩意儿","c语言","只好","对于","总有","不仅","了","到底","但","提示信息","柯南","时候","而是","可能","并","规划","编写","这样","语言","调试","继续","非常","等等","后面","应该","顺利","像是","提示","成千","编译器","里","一只","明确","程序员","-","只能","认为","甚至","这类","没","生成","该","动脑","time","程序","大量","、","出","编译","越来越","对","交替","像","之一","地","从此以后","还是","还","因为","debug","观察","结果","部分","两种","出错","怎么样","会花","会犯","计算机","误导","判断","觉得","语法","看过","找","沉稳","人","低级","每","只会","半天","语义","章节","期望","分为","严重","）","回事","自然语言","经常","看上","快","过程","复杂","学习","剔除","代码","实验","句子","错","几种","到","aaaa","时会","立刻","据说","一件","第三","培养","时间","从","小","琢磨","哪","正确","乐趣","罢工","遇到","意味","，","某种","看上去","一点","角度看","产生","回过","有","沮丧","能够","一个","上万","叫做","否则","引自","说","做","工程师","失败","发现错误","看起","这些","前","简单","修改","首先","关于","操作系统","一次","把","一定","“","全部","成","虽然","而且","：","实践","但是","不能","典故","linux","更","去","所以","几类","侦探","管理","即使","后续","信息","情况","什么","时","将","可以","事实","另外","刚才","写","会少","接下来","不过","给出","造成","过头","大","真正","任何","大部分","例如","文件系统","执行","你","据","有时","要","用来","别的","发现","翻译","参考","我们","greenfield","运气","进行","所","相比","打印","中","linus","需要","不","总是","是","guide","经验","读懂","不管","起来","”","让","好","这","模块","一些","beta1","很少","再试一次","工作","区分","很大","玩意","之后","逐步","思路","加以","包含","得","推断","—","想到","会","福尔","时刻","摩斯","错误","直到","根据","改动","解决","不是","清醒","输出","难免","都","行文","得到","运行","也","干","十分","逼近","非常复杂","被","越来","清晰","则","建议","清楚","的","最有","注意","福尔摩斯","按","小规模","而","中要","规模","钻进","预期","容易"," ","观点","intel","想要","星期","一步","慢慢","正常","通过观察","见","；","来说","剩下","s","如果","为止","意味着","行","角度","几章","一台","几个","和","后来","网络","一条","个别","就是","不到","下来","有些","有时候","接着","进化","事情","来","版","当","设备","在","无法","操作","bbbb","。","技能","run","崩溃","回过头来","下面","看到","就","科学","内存","纠正","仅仅","线索","当然","体积","不出","larry","'","很","大部","再","怎么","文件","即","多","意思","第三类","工程","很小","bug","语法错误","自然","上去","获得","等到","那么","宽容","看起来","一种","哪怕","编程","要求","芯片","丰富","最后","错误信息","通过","哪里","torvalds","挑战","user","假设","在于","帮助","原因","找出","最","它","头脑","仍然","读者","没有","成千上万","检查","算机","计算","从此","吧","概念","性格","找到","千上万","三类","开始","一","80386","只要","逻辑","以后","两个","感到","早期","掌握","可执行文件","得不到","能","导致","好处","一门","下","们","（"],"title":"程序的调试","title_tokens":["调试","程序","的"]},{"location":"计算机基础/1.2.基本概念.html#_4","text":"变量（Variable）是编程语言最重要的概念之一。 变量是计算机存储器中的一块命名的空间，可以在里面存储一个值（Value），存储的值是可以随时变的，比如这次存个字符 'a' 下次存个字符 'b' ，正因为变量的值可以随时变所以才叫变量。 也就是说，变量有一个储存地址，该地址储存的值是可以改变的。或者说，变量是一种使用方便的占位符，用于引用计算机内存地址，变量创建后会占用一定的内存空间。 不要弄混变量和变量名，变量名是标识符的一种。 占位符 ：先占住一个固定的位置，等待值添加到该位置的符号。 变量的类型决定了它所占的存储空间的大小。 变量的行为一共有四种：声明、定义、初始化、赋值。 声明 ：告诉编译器/解析器有这个变量的存在，这个行为不分配内存空间。 定义 ：为变量分配内存空间。 实际上，从广义的角度来说，声明有两种： 引用性声明（defining declaration）：不需要建立储存空间的声明，例如 extern in a 中的变量 a 已经在别的文件中被定义。 定义性声明（referencing declaration）：需要建立储存空间的声明，例如 int a 在声明时就建立了 a 的储存空间。 可见从广义的角度来说，声明包含了定义，而并非所有的声明都是定义。一般的情况下我们常常这样叙述，把建立空间的声明称之为\"定义\"，而把不需要建立存储空间称之为\"声明\"。 定义和声明的本质区别就是：定义会给变量分配内存空间，而声明则不会。 初始化 ：在定义变量之后，系统为变量分配的内存空间内并没有值，此时值是不确定的。为保证程序的安全性和确定性，需要对这个内存空间进行初始化。初始化一般伴随着定义而产生。初始化是从无到有的过程。 如果变量的定义没有初始化，那这个最初分配的空间的值是随机的（空间上原来存储的值）。不经过初始化的变量可能会为程序带来不安全与不确定性。 赋值 ：赋值是变量值得刷新操作。赋值是从旧到新的过程。","text_tokens":["需要","系统","保证","比如","伴随","等待","不","是","就是","从","本质","才","分配","存","正","b","最初","占用","添加","了","叙述","存储","在","建立","操作","。","从无到有","初始","定性","确定","这个","与","之后","，","defining","一块","就","内存","给","定义","产生","有","一个","使用方便","可能","后","并","'","这样","语言","为","下次","包含","经过","或者说","会为","\"","会","占","编译器","之为","确定性","文件","实际上","使用","这次","把","安全","用于","或者","value","一定","弄混","上","解析器","该","空间","程序","、","符号","占住","值得","extern","字符","编译","都","：","对","符","可见","随机","int","是从","之一","declaration","着","存储空间","已经","位置","变","地址","一种","声明","编程","所以","因为","大小","也就是说","内存空间","两种","改变","四种","赋值","被","编程语言","告诉","计算机","情况","则","就是说","的","可以","时","行为","/","a","解析","标识符","个字符","先占住","不会","内存地址","创建","类型","variable","存在","广义","最","本质区别","安全性","不确定性","方便","而","区别","初始化","它","变量"," ","并非","没有","命名","标识","重要","算机","刷新","计算","）","概念","存储器","一共","内","例如","referencing","不要","一般","常常","固定","那","引用","分配内存","里面","过程","决定","旧到","别的","来说","占位","性","值","我们","叫","如果","带来","变量名","储存","称之为","进行","新","到","in","角度","随时","所","和","下","此时","所有","实际","中","原来","（"],"title":"变量及其行为","title_tokens":["及其","行为","变量"]},{"location":"计算机基础/1.2.基本概念.html#_5","text":"assignment ：Assignments do not copy data — they just bind names to objects. assignment操作不会拷贝，只是把名字和对象做一个绑定。也就是assignment语句是起一个绑定或重绑定的作用（bind or rebind）。函数调用的参数传递是传引用，不是拷贝。 引用（reference ） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。因此，引用亦常被称为==该资料==的 指标 或 位址 。 标识符（identifier，缩写为ID） ：又称为识别码，是一个用来识别不同对象的名称。 在编程语言中，标识符就是程序员自己规定的具有特定含义的词，比如函数名、方法名、类名，变量名、常量名等。 对象（object） ：是一个记忆体位址，其中拥有值，这个位址可能有标识符指向此处。台湾译作物件。对象是某个类的实例。我们将数据和对数据的操作融为一体，形成具有静态信息和动态行为的对象。 每个对象都具有一个ID、一个类型、一个值。对象一旦建立，ID便不会改变。这里所说的ID是是对象在内存中的地址，而不是identifier。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 标识符并不是对象的属性，一个对象可以指向不同的标识符。而管理这些名字（标识符）的事物就是“命名空间”。 命名空间（Namespace） ：名字（标识符）到对象的==映射==。 A namespace is a mapping from names to objects. 各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。 现今 Python 的大部分命名空间是通过字典来实现的，也即一个命名空间就是名字到对象的映射，标识符是键，对象则是值。 与命名空间相对的一个概念就是“作用域” 。 作用域（Scope） ：本质是一块文本区域，Python 通过该文本区域可以 直接访问 相应的命名空间。 直接访问 ：Python 中不加 . 的访问为直接访问，反之为属性访问。 命名空间与作用域的联系 ：作用域是 Python 的一块文本区域，即一块代码区域，需要代码区域引用名字（标识符）来访问变量，那么作用域与命名空间之间就有了联系。 名字作用域 ：名字可以影响到的代码文本区域。 命名空间的作用域 ：就是这个命名空间可以影响到的代码文本区域。 显然可以存在这样的一个代码文本区域，它可以被多个命名空间影响。 面向对象编程 ：基于对象概念来分析问题和设计解法，这就是面向对象编程（object-orientation programming，简称OOP）。通过OOP所得到的程序是一个由很多对象组成的系统，可以向对象发送消息来实现对数据的处理，全体对象通过相互协作来完成程序的数据处理功能。 面向过程编程 ：得到的程序是一组对数据进行操作的过程，通过按顺序执行这些过程来实现程序功能。","text_tokens":["需要","很多","系统","不同","assignment","传","比如","物件","is","通过","此处","是","一般而言","方法","类名","之间","就是","参数传递","具有","”","本质","问题","相互","每个","=","让","这","事物","又","存取",".","id","数据","动态","特定","相对","namespace","识别码","来","了","操作","在","建立","起","rebind","。","实例","融为一体","字典","向","但","这个","bind","与","，","某种","就","一块","内存","亦","中不加","名称","有","某个","常量","一个","名","可能","解法","并","数据处理","相应","这样","语言","简称","由","为","中一","或","大部","做","copy","功能","—","传递","一旦","映射","会","这些","记忆","词","数据类型","关系","即","程式","全体","反之","于","程序员","把","python","-","其他","“","基于","该","mapping","不是","reference","空间","程序","they","资料","、","影响","属于","函数调用","都","：","对","分析","得到","形成","中","显然","对象","names","那么","not","普通","其中","不能","类","相互协作","也","电脑","名字","地址","静态","编程","重名","所以","面向","处理","台湾","object","多个","现今","这里","管理","部分","一组","区域","programming","assignments","to","所说","规定","被","识别","改变","信息","编程语言","各个","独立","则","联系","译作","的","可以","含义","将","视为","do","函数","装置","只是","标识符","行为","a","实现","设计","文本","不会","参数","存在","类型","面向对象编程","广义","一体","scope","按","data","不加","顺序","而","协作","常","from","直接","便","它","变量","identifier","实体"," ","没有","命名","而言","键","标识","一样","间接","拥有","组成","）","完成","概念","任何","大部分","orientation","一般","或重","数传","引用","发送","指向","过程","因此","执行","用来","调用","等","代码","作用域","称为","objects","属性","语句","值","我们","变量名","作用","储存","消息","进行","到","just","访问","or","拷贝","oop","缩写","绑定","所","和","自己","指标","记忆体","（","位址","融为"],"title":"基本术语解释","title_tokens":["术语","基本","解释"]},{"location":"计算机基础/1.2.基本概念.html#_6","text":"类是类型概念的发展。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 用计算机解决问题时，首先需要明确问题中涉及哪些数据，并在程序中将这些数据用编程语言提供的数据类型表示出来，然后再去考虑需要对这些数据执行何种操作。 为了表示数据，编程语言一般提供若干 基本数据类型 （如Python的int、float、str和list等类型） ，并为这些基本类型提供相应的基本操作（如Python中对int、float、str和list都提供了+运算，尽管含义不同）。 然而，实际问题中往往涉及很复杂的数据，不能用基本数据类型直接表示。为了表示复杂数据，大体有两种办法： 一种是将复杂数据分解成若干个简单数据项，以便每个数据项可以用基本类型表示 另一种是由用户自定义新的数据类型，以便对复杂数据进行直接的、整体的表示。 例如，如果要表示一个学生的姓名，可以简单地用一个字符串数据表示；如果要表示一个学生的年龄，可以简单地用一个整数数据表示。但如果要整体表示一个“学生”，包括该学生的姓名、年龄、地址等信息，就没法用基本数据类型直接表示了。 一种解决办法是将整体的“学生”分解成姓名、年龄、地址等简单数据，并通过分别处理这些简单数据而达到处理“学生”数据的目的。但这不是好办法，因为这种表示法丢失了数据的整体性，在维护姓名、年龄、地址等数据间的联系时很麻烦。 另一种解决办法是将学生整体视为一个数据值，并为这种数据值定义新的数据类型（因为编程语言中没有现成的类型能够表示该数据）。 假设我们要为“学生“数据定义一个新的数据类型S，那么S应该是由若干更简单的数据项构成的（如学号、姓名等），我们称这些构成S的成员数据为S的属性。除了定义S类型数据的属性，还需要定义能对S数据执行什么操作（如修改姓名或年龄、读取地址等）。可以利用编程语言提供的基本类型和新类型定义机制来实现S，例如用str类型表示姓名和学号，用int类型表示年龄之类，用函数实现对S数据的操作。定义了S，就好像为编程语言添加了一个新的数据类型，应用程序就可以像使用整数、字符串等基本类型一样去使用S。 由此，我们从传统的数据类型概念发展出了“类”的概念。类（class）是广义的数据类型，能够定义复杂数据的特性，包括静态特性（即数据）和动态特性（即对数据的操作方法）。 类的值就是“对象”，也称为类的实例。","text_tokens":["需要","不同","包括","是","然后","整体性","成员","方法","”","目的","问题","从","就是","每个","好","若干","为了","这","数据","动态","以便","了","何种","尽管","来","添加","在","操作","str","之类","大体","。","实例","类型定义","自定","但","分别","，","某种","就","号","出来","定义","有","用","能够","一个","并","相应","语言","很","为","由","地用","或","自定义","再","构成","应该","维护","中将","间","这些","数据类型","现成","考虑","简单","修改","首先","即","使用","明确","python","学号","表示法","称","发展","解决","“","该","丢失","不是","解决问题","程序","基本","分解成","、","出","字符","属于","都","用户","对","：","字符串","如学","麻烦","像","体性","int","对象","往往","那么","普通","不能","类","也","读取","更","表示","一种","地址","去","没法","编程","应用","还","class","静态","处理","达到","因为","涉及","+","两种","若干个","list","通过","基本操作","另","编程语言","信息","计算机","联系","假设","什么","没法用","利用","的","可以","时","含义","视为","将","函数","应用程序","实现","解决办法","整体","类型","广义","操作方法","学生","提供","而","由此","直接","float","这种","好像","数据表","分解"," ","没有","哪些","一样","数据项","算机","计算","办法","传统","）","概念","数据表示","例如","定义新","一般","因此","执行","复杂","要","等","；","然而","年龄","机制","称为","属性","值","能","我们","s","如果","特性","新","进行","运算","姓名","除了","和","如","实际","整数","中","（"],"title":"类的概念","title_tokens":["概念","的","类"]},{"location":"计算机基础/1.2.基本概念.html#vs","text":"python的入门者可能很容易把变量和对象混为一谈。在Python中，变量的准确说法应该name（名字）。 在python中，对象属于某一个类型，而名字是没有类型的。所有的名字都是内存中一个对象的“引用”，也就是说名字对应着对象的地址，而不是储存了对象本身。 例如： nfoo = 1 #一个指向int数据类型的nfoo（再次提醒，nfoo没有类型），在这里，具有类型的是1 lstFoo = [ 1 ] #一个指向list类型的lstFoo，这个list中包含一个整数1","text_tokens":["入门者","入门","很","名字","对应","地址","）","是","再次","包含","准确","没有","”","就是","应该","具有","例如","这里","也就是说","=","引用","指向","list","数据类型","数据","[","就是说","的","name","python","把","了","在","对象","提醒","lstfoo","说法","。","类型","“","储存","不是","1","nfoo","]","这个","而","，","混为一谈","内存","属于","都","和","：","所有","容易","变量","整数","本身","混为"," ","中","可能","某","一个","（","int","着","#"],"title":"对象  vs  变量","title_tokens":["变量","vs"," ","对象"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html","text":"编译型语言和解释型语言的优缺点对比 编程语言可以分为：完全的编译型，纯粹的解释型或者两者相互混合的编程语言。实际上，大部分现有的编程语言都同时拥有其编译型和解释型版本。 编译型语言和解释型语言分别有其各自的优势和不足。下面从编译型语言开始介绍。 编译型语言： 编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%。 编译型程序比解释型程序消耗的内存更少。 不利的一面——编译器比解释器要难写得多。 编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置。 可执行的编译型代码要比相同的解释型代码大许多。例如，C/C++的.exe文件要比同样功能的Java的.class文件大很多。 编译型程序是面向特定平台的因而是平台依赖的。 编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的） 由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。 解释型语言： 解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的。 另一个优势是解释器比编译器容易实现 解释型语言最大的优势之一是其平台独立性 解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的 中间语言代码的大小比编译型可执行代码小很多 平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素。 解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存。 由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多。 解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。 原文链接： http://www.codeproject.com/Articles/1825/The-Common-Language-Runtime-CLR-and-Java-Runtime-E Pros and cons of compiled and interpreted languages Languages can be developed either as fully-compiled, pure-interpreted, or hybrid compiled-interpreted. As a matter of fact, most of the current programming languages have both a compiled and interpreted versions available. Both compiled and interpreted approaches have their advantages and disadvantages. I will start with the compiled languages. Compiled languages One of the biggest advantages of Compiled languages is their execution speed. A program written in C/C++ runs 30-70 % faster then an equivalent program written in Java. Compiled code also takes less memory as compared to an interpreted program. On the down side - a compiler is much more difficult to write than an interpreter. A compiler does not provide much help in debugging a program - how many times have you received a \"Null pointer exception\" in your C code and have spent hours trying to figure out where in your source code did the exception occurred. The executable Compiled code is much bigger in size than an equivalent interpreted code e.g. a C/C++ .exe file is much bigger than an equivalent Java .class file Compiled programs are targeted towards a particular platform and hence are platform dependent. Compiled programs do not allow security to be implemented with in the code - e.g. a compiled program can access any area of the memory, and can do whatever it wants with your PC (most of the viruses are made in compiled languages). Due to loose security and platform dependence - a compiled language is not particularly suited to be used to develop Internet or web-based applications. Interpreted languages Interpreted language provides excellent debugging support. A Java programmer only spends a few minutes fixing a \"Null pointer exception\", because Java runtime not only specifies the nature of exception but also gives the exact line number and function call sequence (the famous stack trace information) where the exception occurred. This facility is something that a compiled language can never provide. Another advantage is that Interpreters are much easier to build then a compiler. One of the biggest advantages of Interpreters is that they make platform-independence possible. Interpreted language also allow high degree of security - something badly needed for an Internet application. An intermediate language code size is much smaller than a compiled executable code. Platform independence, and tight security are the two most important factors that make an interpreted language ideally suited for Internet and web-based applications. Interpreted languages have some serious drawbacks. The interpreted applications take up more memory and CPU resources. This is because in order to run a program written in interpreted language; the corresponding interpreter must be run first. Interpreters are sophisticated, intelligent and resource hungry programs and they take up lot of CPU cycles and RAM. Due to interpreted application's decode-fetch-execute cycle; they are much slower than compiled programs. Interpreters also do lot of code-optimization, security violation checking at run-time; these extra steps take up even more resources and further slows the application down.","text_tokens":["很多","programs","1825","based","their","因特","access","the","便利","some","slows","c语言","internet","不仅","几分钟","ideally","ram","了","依赖","占用","一面","到底","优势","many","对比","checking","一名","made","而是","help","few","并","编写","这样","语言","调试","e","never","you","trace","area","resources","\"","编译器","实际上","towards","使用","cycle","明确","-","程序员","基于","pros","完全","其","time","程序","大量","they","function","成为","applications","编译","函数调用","对","hybrid","fully","line","只","之一","许多","代码优化","位置","support","面向","它们","因为","dependent","松散","部分","implemented","区域","programming","than","to","另","依赖性","a","使","received","指针","articles","70","性质","size","excellent","it","支持","specifies","speed","分为","适合","严重","）","written","are","联网","fixing","with","exe","famous","快","复杂","花费",";","代码","因素","smaller","disadvantages","security","hours","发生","个","even","慢","额外","解码",",","one","病毒","make","nature","do","loose","build","因而","中间","从","小","drawbacks","相互","程序运行","特定","2","智能","how","viruses","互联","遇到","，","平台","指明","型","violation","有","language","high","一个","优化","hungry","exception","versions","30%","做","allow","速度","想","easier","because","这些","首先","did","具体","或者","“","code","developed","call","解释","order","an","互联网","而且","：","must","缺点","i","factors","common","targeted","几分","更","languages","available","intelligent","小时","biggest","信息","编程语言","独立","什么","可以","时","memory","that","most","%","more","due","resource","spends","可","安全性","分钟","提供","写","环境","解释器","给出","can","跟踪","either","重要","拥有","大","任何","further","大部分","例如","pointer","c","步骤","并且","释器","执行","你","不太","要","因而是","调用","compiled","extra","executable","facility","used","in","访问","资源","比用","important","also","serious","中","platform","需要","空","provides","something","web","is","不","sequence","是","badly","”","java","less","equivalent","为了","著名","compiler","一些","codeproject","spent","定位","times","相关","programmer","好几个","优缺点","两者","分别","fact","用","cycles","bigger","迫切","both","得","c++","—","trying","由于","http","source","会","whatever","debugging","错误","安全","理想","on","以及","因特网","down","decode","cpu","链接","clr","现有","都","sophisticated","运行","not","much","as","也","介绍","approaches","pure","应用","difficult","gives","大小","up","语言所","of","的","高度","null","存在","原文","take","顺序","current","figure","容易","纯粹","have","start"," ","independence","一步","runs","program","another","；","possible","execution","intermediate","抓取","occurred","多少","s","几个","hence","进一步","和","particularly","(","these","www","保证","cons","side","suited","70%","compared","就是","be","消耗",")","不足","难",".","事情","30","minutes","develop","不利","来","g","在","无法","then","。","write","run","matter","下面","就","内存","开发","'","stack","大部","file","修复","功能","周期","严密","does","degree","will","文件","runtime","次","多","tight","first","最大","比","dependence","number","advantage","这是","不了","only","optimization","and","同时","降低","class","编程","particular","少","takes","版本","迫切需要","for","this","帮助","advantages","/","函数","调试程序","实现","lot","but","out","where","同样","最",":","异常","your","slower","它","好几","极佳","two","information","检查","interpreters","独立性","at","application","any","堆栈","开始","混合","com","provide","interpreter","必须","steps","pc","interpreted","wants","相同","各自","or","needed","exact","execute","fetch","实际","行号","corresponding","faster","（"],"title":"1.3.编译型语言和解释型语言的优缺点对比","title_tokens":["1.3","语言","型","编译","和","缺点",".","优缺点","的","解释","对比"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#_1","text":"编程语言可以分为：完全的编译型，纯粹的解释型或者两者相互混合的编程语言。实际上，大部分现有的编程语言都同时拥有其编译型和解释型版本。 编译型语言和解释型语言分别有其各自的优势和不足。下面从编译型语言开始介绍。","text_tokens":["分为","介绍","语言","同时","拥有","编程","大部","从","大部分","相互","部分","版本","开始","不足","编程语言","混合","实际上","的","可以","或者","。","完全","其","优势","两者","各自","解释","分别","下面","，","型","编译","现有","都","：","和","纯粹","有","实际"," "],"title":"编译型语言和解释型语言的优缺点对比","title_tokens":["语言","型","编译","和","缺点","优缺点","的","解释","对比"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#_2","text":"编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%。 编译型程序比解释型程序消耗的内存更少。 不利的一面——编译器比解释器要难写得多。 编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置。 可执行的编译型代码要比相同的解释型代码大许多。例如，C/C++的.exe文件要比同样功能的Java的.class文件大很多。 编译型程序是面向特定平台的因而是平台依赖的。 编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的） 由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。","text_tokens":["需要","空","很多","web","因而","不","是","因特","70%","就是","java","”","程序运行","消耗","c语言","难",".","事情","特定","不利","来","依赖","一面","在","。","到底","优势","遇到","好几个","，","平台","型","内存","有","开发","用","一个","而是","编写","语言","调试","大部","得","30%","c++","做","功能","—","由于","速度","想","编译器","文件","次","多","使用","错误","明确","-","安全","或者","最大","比","“","基于","其","因特网","程序","解释","不了","编译","对","之一","运行","许多","位置","更","class","应用","面向","松散","小时","少","部分","区域","什么","依赖性","帮助","的","时","可以","/","调试程序","实现","可","同样","安全性","指针","异常","提供","写","它","解释器","好几"," ","支持","适合","大","）","任何","例如","大部分","exe","c","快","并且","释器","执行","你","不太","要","因而是","花费","代码","多少","pc","相同","访问","几个","和","比用","病毒","中","（"],"title":"编译型语言：","title_tokens":["编译","语言","型","："]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#_3","text":"解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的。 另一个优势是解释器比编译器容易实现 解释型语言最大的优势之一是其平台独立性 解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的 中间语言代码的大小比编译型可执行代码小很多 平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素。 解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存。 由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多。 解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。 原文链接： http://www.codeproject.com/Articles/1825/The-Common-Language-Runtime-CLR-and-Java-Runtime-E","text_tokens":["需要","空","很多","保证","1825","web","是","中间","”","java","小","the","便利","消耗","为了","著名","一些",".","codeproject","不仅","几分钟","2","定位","了","占用","智能","无法","相关","。","互联","优势","，","平台","就","指明","型","内存","一名","language","一个","优化","并","编写","这样","语言","调试","迫切","e","做","修复","—","由于","http","周期","速度","会","编译器","这些","严密","runtime","首先","多","程序员","-","安全","具体","理想","最大","“","比","其","以及","程序","decode","cpu","解释","大量","这是","链接","成为","clr","编译","函数调用","而且","互联网","：","缺点","只","运行","之一","代码优化","common","and","也","几分","位置","降低","更","应用","它们","因为","大小","语言所","信息","另","独立","迫切需要","的","可以","时","/","函数","高度","实现","使","存在","原文","可","安全性","分钟","指针","最",":","异常","articles","提供","顺序","性质","容易","环境","解释器","极佳","给出","支持"," ","跟踪","适合","检查","重要","一步","严重","）","独立性","联网","堆栈","步骤","并且","释器","执行","复杂","调用","；","com","代码","抓取","因素","必须","发生","个","慢","资源","额外","解码","和","execute","进一步","fetch","行号","www","（"],"title":"解释型语言：","title_tokens":["型","语言","解释","："]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#pros-and-cons-of-compiled-and-interpreted-languages","text":"Languages can be developed either as fully-compiled, pure-interpreted, or hybrid compiled-interpreted. As a matter of fact, most of the current programming languages have both a compiled and interpreted versions available. Both compiled and interpreted approaches have their advantages and disadvantages. I will start with the compiled languages. Compiled languages One of the biggest advantages of Compiled languages is their execution speed. A program written in C/C++ runs 30-70 % faster then an equivalent program written in Java. Compiled code also takes less memory as compared to an interpreted program. On the down side - a compiler is much more difficult to write than an interpreter. A compiler does not provide much help in debugging a program - how many times have you received a \"Null pointer exception\" in your C code and have spent hours trying to figure out where in your source code did the exception occurred. The executable Compiled code is much bigger in size than an equivalent interpreted code e.g. a C/C++ .exe file is much bigger than an equivalent Java .class file Compiled programs are targeted towards a particular platform and hence are platform dependent. Compiled programs do not allow security to be implemented with in the code - e.g. a compiled program can access any area of the memory, and can do whatever it wants with your PC (most of the viruses are made in compiled languages). Due to loose security and platform dependence - a compiled language is not particularly suited to be used to develop Internet or web-based applications. Interpreted languages Interpreted language provides excellent debugging support. A Java programmer only spends a few minutes fixing a \"Null pointer exception\", because Java runtime not only specifies the nature of exception but also gives the exact line number and function call sequence (the famous stack trace information) where the exception occurred. This facility is something that a compiled language can never provide. Another advantage is that Interpreters are much easier to build then a compiler. One of the biggest advantages of Interpreters is that they make platform-independence possible. Interpreted language also allow high degree of security - something badly needed for an Internet application. An intermediate language code size is much smaller than a compiled executable code. Platform independence, and tight security are the two most important factors that make an interpreted language ideally suited for Internet and web-based applications. Interpreted languages have some serious drawbacks. The interpreted applications take up more memory and CPU resources. This is because in order to run a program written in interpreted language; the corresponding interpreter must be run first. Interpreters are sophisticated, intelligent and resource hungry programs and they take up lot of CPU cycles and RAM. Due to interpreted application's decode-fetch-execute cycle; they are much slower than compiled programs. Interpreters also do lot of code-optimization, security violation checking at run-time; these extra steps take up even more resources and further slows the application down.","text_tokens":["provides","programs","loose","build","based","side","suited","is","web","sequence","something","their","badly","compared","java","be","less","access","the","drawbacks","equivalent",")","some","compiler","slows","internet",".","30","spent","minutes","develop","ideally","ram","g","times","how","viruses","then","write","programmer","run","matter","many","fact","checking","violation","made","language","platform","high","help","cycles","few","bigger","'","hungry","e","never","time","exception","both","you","versions","stack","file","trace","c++","allow","trying","area","resources","easier","source","because","\"","does","whatever","will","degree","runtime","debugging","did","towards","tight","cycle","-","first","on","dependence","down","code","developed","number","call","advantage","function","they","cpu","order","decode","applications","an","sophisticated","only","must","hybrid","fully","line","optimization","i","factors","not","much","as","targeted","and","support","approaches","pure","class","languages","available","difficult","gives","dependent","intelligent","particular","implemented","biggest","takes","up","programming","than","to","of","for","this","advantages","memory","/","a","that","most","%","more","null","due","but","resource","lot","spends","out","received","where","take","your","current","70","slower","size","excellent","figure","it","have","start","can"," ","specifies","speed","two","information","either","independence","interpreters","runs","written","program","are","fixing","at","with","application","further","pointer","exe","any","another","c","famous","possible","execution","intermediate",";","provide","interpreter","occurred","smaller","s","compiled","extra","steps","disadvantages","executable","interpreted","security","wants","pc","hours","used","facility","in","needed","or","even","exact","hence",",","execute","one","important","particularly","(","fetch","make","nature","also","serious","corresponding","faster","these","do"],"title":"Pros and cons of compiled and interpreted languages","title_tokens":["and","cons","compiled","languages","pros","of","interpreted"," "]},{"location":"计算机基础/1.4.字符编码.html","text":"相对于数字，字符串比较特殊的是还有一个编码问题。 一般，计算机的系统结构是基于数字信号来搭建的，计算机中的计算基于数字电路。在计算机内部，所有信息最终都是一个二进制值。计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。 每一个二进制位（bit）有 0 和 1 两种状态，最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），因此一个字节可以表示256种状态（$2^8=256$），每一个状态对应一个符号，就是256个符号，从 00000000 到 11111111 。一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是 65535 ，4个字节可以表示的最大整数是 4294967295 。 ASCII码 因为计算机是美国人发明的，所以在上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。ASCII 码一共规定了128个字符的编码，比如空格 SPACE 是32（二进制 00100000 ），大写的字母 A 是65（二进制 01000001 ）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为 0 。 非ASCII码 英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的 é 的编码为130（二进制 10000010 ）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了 é ，在希伯来语编码中却代表了字母 Gimel ( ג )，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。 GB2312码 汉字多达10万左右，要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了 GB2312 编码，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 可以想得到的是，全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。 Unicode 正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode就像它的名字都表示的，这是一种所有符号的编码。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，可以查询 unicode.org ，或者专门的 汉字对应表 。 Unicode 的问题 需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。（ 这里说的储存是储存在 ROM 中，比如说硬盘。 ） 比如，汉字 严 的 Unicode 是十六进制数 4E25 ，转换成二进制数足足有15位（ 100111000100101 ），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0 ，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 因此不能用Unicode码直接储存文件。 它们造成的结果是： 出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。 Unicode 在很长一段时间内无法推广，直到互联网的出现。 UTF-8 互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。 ==强调一下Unicode和UTF-8的区别：UTF-8是Unicode的一种储存形式，但计算机只能读取二进制的内容，因此计算机读取UTF-8编码的文件，需要将文件转码为Unicode（Unicode是完全二进制的形式）。也就是说，文件以UTF-8的形式储存在硬盘上，以Unicode的形式储存在内存（Ram）中。==例如： 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。很多网页的源码上会有类似 <meta charset=\"UTF-8\" /> 的信息，表示该网页正是用的UTF-8编码。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为 0 ，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于 n 字节的符号（ n > 1 ），第一个字节的前 n 位都设为 1 ，第 n + 1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母 x 表示可用编码的位。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是 0 ，则这个字节单独就是一个字符；如果第一位是 1 ，则连续有多少个 1 ，就表示当前字符占用多少个字节。 下面，还是以汉字 严 为例，演示如何实现 UTF-8 编码。 严 的 Unicode 是 4E25 （ 100111000100101 ），根据上表，可以发现 4E25 处在第三行的范围内（ 0000 0800 - 0000 FFFF ），因此 严 的 UTF-8 编码需要三个字节，即格式是 1110xxxx 10xxxxxx 10xxxxxx 。然后，从 严 的最后一个二进制位开始，依次从后向前填入格式中的 x ，多出的位补 0 。这样就得到了， 严 的 UTF-8 编码是 11100100 10111000 10100101 ，转换成十六进制就是 E4B8A5 。 UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。 参考 字符编码笔记：ASCII，Unicode 和 UTF-8","text_tokens":["系统","很多","对应","出现","然后","一位","space","问题","注音符号","段时间","大多数","gb2312","专门","对于","ram","110xxxxx","不可","0xxxxxxx","了","占用","三个","存储","音符","但","这个","世纪","rom","代表","理论","单字节","世界","时候","可能","0000","这样","语言","继续","4294967295","为","中国","非常","单字","同一","后面","应该","更大","位设","\"","表","里","实际上","使用","-","只能","文本文件","其他","保存","强烈要求","甚至","11111111","基于","上","生成","完全","该","后文","换成",">","gimel","大量","最高","日文","才能","对","向前","像","只","一部","许多","服务器","地","着","已经","还是","3","跟据","采用","它们","还","于是","因为","多个","结果","这里","部分","只有","第一个","+","两种","多数","n","规定","7","另","é","计算机","二进制位","冲突","a","10xxxxxx","文本","不会","浏览","一下","人","4","状态","区别","极大","每","euc","支持","如何","字母","万个","严重","）","系统结构","结构","现在","完成","长度","联网","内","记事","常常","笔记","代码","正如","知道","强烈","0080","邮件","新","11100100","到","个","0800","额外","许多种","至少","集","第一位","utf","比如","11110xxx","第三","kr","时间","meta","从","每个","毫无关系","作为","避免","相对","10000010","2","二三倍","就够","互联","英文字母","集合","65","bit","，","出来","三倍","体系","有","一个","否则","byte","多出","100","比较","说","做","十进制","想","一套","却","内部","进制","这些","unicode","前","格式","简单","空格","操作系统","于","把","转换成","填入","或者","charset","全部","解释","符号","成","字符","虽然","用到","互联网","字符串","而且","：","搭建","100111000100101","数字电","但是","不能","更","一来","所以","也就是说","容纳","信息","编程语言","大出","什么","时","可以","将","设计","最多","只是","从文件","显示","可用","汉字编码","不够","浪费","正是","种","直接","不过","二条","怎样","造成","130","四个","这样一来","00000000","本文","先","范围","大多","内容","第三行","？","例如","一般","决定","毫无","演示","要","用来","传输","发现","非","还有","参考","我们","60","左右","储存","上表","收信人","查询","英文字","编码","打印","中","255","需要","特点","包括","不","是","|","不管","之间","遗留","接受","=","这","8","一些","应运而生","记事本","二进制","工作","中文","统一","1","x","只用","注音","很大","网页","发信人","不断","分别","编入","常用","设","发明","用","无关","提及","严","不管怎样","一段","足足有","或","强调","形式","65536","百种","会","码","有二到","沿用至今","错误","直到","务器","很长","信号","根据","打开","不是","基本","英文","16","连续","都","得到","07ff","也","数字信号","最终","表示","上会","至今","比特","处理","韩国","历史","变化","大小","为例","被","则","利用","就是说","的","65535","0001","电路","乱码","注意","个字符","存在","ג","非常简单","而","不用","最早","规模","十六进制","俄语"," ","15","编码方式","汉字","0010","软件","e4b8a5","以","控制","十六","源码","足足","为什么","国家","日本","；","来说","剩下","二个","法语","称为","00100000","多少","如果","转码","上个","shift","从后","比如说","规则","一直","码是","和","(","一律","<","10","当前","呢","两位","看成","上方","不同","127","万左右","就是","希伯来","gb","一节","多达",")","美国","不可避免","又",".","4e25","同一个","动态","处在","来","当","在","无法","操作","年代","变长","。","一段时间","数字","与","下面","就","三行","内存","大写","普及","后","编辑","字节","很","256","再有","闲置","总结","数","再","第二","怎么","多万个","ascii","关系","文件","推广","编","浏览器","欧洲","即","多","多万","希伯来语","沿用","最大","偏僻","发展","0","$","前面","这是","文字","应运","显然","10111000","1110xxxx","方式","那么","类","收信","007f","服务","名字","读取","一种","哪怕","多种","编程","要求","第二个","制定","最后","一部分","~","32","韩文","^","发信","想得到","所说","位","设为","_","必然","数字电路","电子邮件","/","全世界","实现","类似","最","org","下表","它","最广","依次","特殊","没有","现代","一样","算机","01000001","10100101","计算","一共","解读","各国","第一","上个世纪","第","因此","开始","jis","二三","混合","标准","128","两个","位补","英语","硬盘","值","必须","能","转换","ffff","位为","相同","单独","好处","电子","下","所有","整数","实际","（"],"title":"1.4.字符编码","title_tokens":[".","编码","字符","1.4"]},{"location":"计算机基础/1.4.字符编码.html#ascii","text":"因为计算机是美国人发明的，所以在上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。ASCII 码一共规定了128个字符的编码，比如空格 SPACE 是32（二进制 00100000 ），大写的字母 A 是65（二进制 01000001 ）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为 0 。","text_tokens":["比如","包括","是","之间","一位","space","美国","这","了","二进制","占用","在","统一","年代","。","与","65","世纪","，","出来","大写","发明","一个","字节","为","做","后面","一套","进制","ascii","码","关系","空格","沿用至今","沿用","0","符号","前面","字符","对","只","不能","至今","所以","因为","制定","32","规定","被","位","7","计算机","二进制位","的","a","个字符","最","人"," ","字母","算机","01000001","计算","）","一共","控制","上个世纪","128","英语","称为","00100000","60","上个","个","一直","编码","打印","（"],"title":"ASCII码","title_tokens":["ascii","码"]},{"location":"计算机基础/1.4.字符编码.html#ascii_1","text":"英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的 é 的编码为130（二进制 10000010 ）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了 é ，在希伯来语编码中却代表了字母 Gimel ( ג )，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。","text_tokens":["上方","比如","不同","出现","不","是","127","不管","问题","希伯来","注音符号",")","这","又","一些","10000010","了","二进制","在","无法","就够","。","注音","音符","编入","，","就","代表","体系","有","用","一个","这样","语言","不管怎样","一段","字节","为","256","闲置","却","进制","这些","会","ascii","码","欧洲","使用","希伯来语","-","其他","0","gimel","符号","最高","都","方式","但是","表示","哪怕","一来","它们","于是","这里","位","另","é","利用","的","可以","最多","只是","ג","不够","它","俄语"," ","怎样","130","这样一来","编码方式","一样","字母","）","决定","因此","国家","用来","128","英语","法语","新","个","编码","(","所有","中","255","（"],"title":"非ASCII码","title_tokens":["码","ascii","非"]},{"location":"计算机基础/1.4.字符编码.html#gb2312","text":"汉字多达10万左右，要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了 GB2312 编码，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 可以想得到的是，全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。","text_tokens":["需要","utf","kr","出现","是","万左右","就是","gb","=","毫无关系","多达","gb2312","不可避免","8","避免","不可","了","中文","在","。","x","与","，","就","出来","理论","有","用","无关","世界","一个","语言","字节","256","中国","65536","百种","会","ascii","unicode","里","关系","编","多","使用","-","把","上","后文","符号","日文","虽然","都","而且","得到","显然","但是","地","不能","类","表示","还","所以","处理","韩国","多个","制定","结果","韩文","想得到","_","的","可以","冲突","乱码","全世界","文本","显示","最","汉字编码","不够","euc"," ","汉字","各国","毫无","jis","要","日本","混合","标准","两个","左右","shift","到","个","和","编码","至少","10","中"],"title":"GB2312码","title_tokens":["码","gb2312"]},{"location":"计算机基础/1.4.字符编码.html#unicode","text":"正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode就像它的名字都表示的，这是一种所有符号的编码。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，可以查询 unicode.org ，或者专门的 汉字对应表 。","text_tokens":["需要","系统","不同","对应","出现","不","是","就是","问题","一节","每个","大多数","专门","应运而生",".","同一个","了","二进制","在","操作","统一","。","很大","发信人","数字","不断","但","集合","，","常用","就","用","世界","一个","否则","这样","语言","字节","再有","100","非常","同一","想","一套","进制","会","多万个","unicode","表","里","文件","使用","错误","操作系统","多万","把","文本文件","或者","打开","偏僻","发展","上","解释","符号","这是","成","应运","字符","用到","都","像","方式","着","收信","也","名字","表示","一种","多种","编程","因为","多数","发信","所说","容纳","被","编程语言","什么","的","可以","电子邮件","乱码","文本","不会","存在","最","4","org","直接","规模","它"," ","支持","现代","编码方式","一样","本文","万个","汉字","大多","）","现在","？","解读","常常","因此","为什么","要","标准","两个","正如","知道","必须","如果","邮件","到","个","收信人","电子","查询","和","编码","所有","（"],"title":"Unicode","title_tokens":["unicode"]},{"location":"计算机基础/1.4.字符编码.html#unicode_1","text":"需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。（ 这里说的储存是储存在 ROM 中，比如说硬盘。 ） 比如，汉字 严 的 Unicode 是十六进制数 4E25 ，转换成二进制数足足有15位（ 100111000100101 ），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0 ，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 因此不能用Unicode码直接储存文件。 它们造成的结果是： 出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。 Unicode 在很长一段时间内无法推广，直到互联网的出现。","text_tokens":["需要","不同","比如","出现","是","时间","就是","问题","接受","每个","段时间","这","对于","4e25","2","了","二进制","三个","存储","在","统一","二三倍","无法","就够","。","互联","只用","一段时间","英文字母","这个","分别","rom","，","就","三倍","有","用","一个","可能","严","一段","字节","足足有","或","说","数","第二","应该","更大","却","怎么","进制","会","unicode","ascii","前","有二到","码","文件","格式","推广","多","直到","很长","转换成","文本文件","或者","其他","甚至","不是","换成","0","英文","符号","这是","文字","互联网","才能","都","：","100111000100101","只","那么","方式","许多","不能","已经","3","更","表示","它们","多种","第二个","结果","这里","大小","也就是说","第一个","规定","位","大出","计算机","必然","就是说","的","可以","只是","注意","文本","4","浪费","区别","而","极大","直接","它","十六进制"," ","造成","没有","四个","15","如何","字母","算机","本文","汉字","计算","严重","）","呢","联网","？","内","第一","十六","足足","因此","二三","用来","两个","来说","代码","二个","硬盘","知道","转换","我们","如果","储存","比如说","个","英文字","和","许多种","至少","中","集","（"],"title":"Unicode 的问题","title_tokens":["问题","的","unicode"," "]},{"location":"计算机基础/1.4.字符编码.html#utf-8","text":"互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。 ==强调一下Unicode和UTF-8的区别：UTF-8是Unicode的一种储存形式，但计算机只能读取二进制的内容，因此计算机读取UTF-8编码的文件，需要将文件转码为Unicode（Unicode是完全二进制的形式）。也就是说，文件以UTF-8的形式储存在硬盘上，以Unicode的形式储存在内存（Ram）中。==例如： 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。很多网页的源码上会有类似 <meta charset=\"UTF-8\" /> 的信息，表示该网页正是用的UTF-8编码。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为 0 ，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于 n 字节的符号（ n > 1 ），第一个字节的前 n 位都设为 1 ，第 n + 1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母 x 表示可用编码的位。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是 0 ，则这个字节单独就是一个字符；如果第一位是 1 ，则连续有多少个 1 ，就表示当前字符占用多少个字节。 下面，还是以汉字 严 为例，演示如何实现 UTF-8 编码。 严 的 Unicode 是 4E25 （ 100111000100101 ），根据上表，可以发现 4E25 处在第三行的范围内（ 0000 0800 - 0000 FFFF ），因此 严 的 UTF-8 编码需要三个字节，即格式是 1110xxxx 10xxxxxx 10xxxxxx 。然后，从 严 的最后一个二进制位开始，依次从后向前填入格式中的 x ，多出的位补 0 。这样就得到了， 严 的 UTF-8 编码是 11100100 10111000 10100101 ，转换成十六进制就是 E4B8A5 。 UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。","text_tokens":["需要","utf","很多","特点","第一位","不同","两位","11110xxx","第三","看成","出现","包括","是","|","然后","meta","一位","就是","从","遗留","=",")","对于","8","动态","4e25","处在","ram","110xxxxx","记事本","2","0xxxxxxx","了","二进制","当","占用","三个","在","工作","统一","变长","互联","。","1","x","网页","但","这个","下面","，","就","设","内存","三行","有","单字节","用","时候","提及","一个","普及","0000","后","严","这样","编辑","继续","字节","为","很","多出","或","总结","强调","再","单字","非常","后面","形式","位设","\"","进制","会","unicode","码","ascii","里","简单","文件","前","浏览器","格式","实际上","即","使用","务器","-","把","只能","根据","转换成","填入","或者","其他","保存","最大","强烈要求","charset","上","生成","该","完全",">","0","换成","基本","全部","大量","符号","16","连续","字符","互联网","都","：","向前","100111000100101","得到","10111000","只","1110xxxx","一部","方式","服务器","07ff","007f","还是","服务","读取","跟据","上会","一种","表示","要求","还","所以","历史","变化","最后","一部分","~","32","也就是说","只有","第一个","+","为例","部分","n","被","位","设为","信息","7","则","计算机","二进制位","就是说","的","将","可以","/","0001","实现","10xxxxxx","从文件","浏览","一下","类似","4","可用","非常简单","正是","不用","区别","而","下表","它","最广","不过","二条","十六进制"," ","依次","没有","支持","四个","编码方式","如何","字母","算机","10100101","汉字","0010","计算","范围","）","软件","完成","长度","内容","第三行","联网","内","解读","e4b8a5","例如","以","记事","第一","十六","源码","第","演示","因此","开始","；","传输","位补","两个","发现","剩下","英语","硬盘","转换","多少","如果","转码","强烈","0080","储存","上表","ffff","位为","11100100","从后","到","个","相同","0800","单独","好处","规则","额外","码是","和","下","编码","(","一律","实际","<","10","中","当前","（"],"title":"UTF-8","title_tokens":["utf","-","8"]},{"location":"计算机基础/1.4.字符编码.html#_1","text":"字符编码笔记：ASCII，Unicode 和 UTF-8","text_tokens":["utf","，","-","字符","和","：","ascii","编码","unicode","8"," ","笔记"],"title":"参考","title_tokens":["参考"]}]}