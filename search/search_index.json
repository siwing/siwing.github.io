{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Python基础/2.1.python基本语法.html","text":"运行环境 Windows 10 Python 3.7.3 @ MSC v.1915 64 bit (AMD64) 交互模式 Python是一种解释型语言，Python解释器通过一次执行一条语句的方式运行程序。从 tty 读取命令时, 我们称解释器工作于交互模式 (interactive mode)。可以在cmd窗口通过 python 命令启动CPython解释器的交互模式，交互模式下CPython通过主提示符 (primary prompt) 提示下一条命令, 主提示符为 >>> ，而从提示符 ··· 提示一条命令的续行。 加强的交互式解释器(IPython)的提示符是一种编号的风格，如 In[2] ，而不是标准的 >>> 。 python保留字 保留字（又称为关键字）， 不能把它们用作任何标识符名称 。Python的标准库提供了一个keyword模块，可以输出当前版本的所有关键字： import keyword keyword . kwlist print ( keyword . kwlist ) ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 注释 Python中单行注释以 # 开头。多行注释则使用： ''' 或者 \"\"\" 。实际上python只有单行注释。多行注释的本质是字符串对象。 # 这是单行注释 ''' 这是多行注释 这是多行注释 ''' 代码块 python最具特色的就是使用缩进来表示代码块，不是使用大括号{}。而冒号表示一段缩进代码块的开始，其后所有相同层次的代码必须保持相同的缩进量，缩进量则可以随意，直至代码块结束。 一般约定俗成使用4个空格的缩进。 if True : print ( \"True\" ) else : print ( \"False\" ) True 代码续行 如果语句很长，可以使用反斜杠 \\ 来续行，例如： a = 3 + \\ 4 + \\ 5 a 12 在 [] , {} , 或 () 中的多行语句 1 ，不需要使用反斜杠 \\ ，例如： total = [ 'item_one' , 'item_two' , 'item_three' , 'item_four' , 'item_five' ] total ['item_one', 'item_two', 'item_three', 'item_four', 'item_five'] 同一行书写多条语句 Python可以在同一行中使用多条语句，语句之间使用半角分号 ; 分隔。但这样的做法一般不推荐，因为会使代码的可读性变差。 空行 函数、类方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同， 空行并不是Python语法的一部分。 书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。空行也是程序代码的一部分。 Print 输出 print函数默认输出是换行的，如果要实现不换行打印，需要更改print函数的 end 参数： # 换行输出 print ( \"a\" ) print ( \"b\" ) print ( '-' * 10 ) # 不换行输出 print ( \"a\" , end = \" \" ) print ( \"b\" , end = \" \" ) print () a b ---------- a b import 与 from...import 在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块 ( module ) 导入： import somemodule 从某个模块中导入某个函数： from somemodule import somefunction 从某个模块中导入多个函数： from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入： from somemodule import * 转义符 \\ 如果要在字符串中输入一些特殊的字符（这些字符特殊之处在于不能直接输出），这就需要“转义符”。所谓转义，就是不采用符号原先的含义，而采用另外一含义。在Pyhton中， \\ 代表转义符。 下面表格中列出常用的转义符： 转义字符 描述 \\ 在字符串行尾的续行符 \\\\ 反斜杠符号 \\' 单引号 \\\" 双引号 \\a 蜂鸣器响铃（不是喇叭发声），现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效 \\b 退格（Backspace），将光标位置移到前一列 \\e 转义 \\000 空 \\n 换行符 \\v 纵向制表符 \\t 横向制表符，即 Tab 键，一般相当于四个空格 \\r 回车符 \\f 换页 \\oyy 八进制数，yy代表字符，例如： \\o12 代表换行 \\xyy 十六进制数，yy代表字符，例如： \\x0a 代表换行 \\other 其它的字符以普通格式输出 有时候，字符串包含了很多 \\ ，Python默认将'\\'作为转义符处理，但实际上我们想输出的是反斜杠符号 \\ ，（例如输入文件路径）。此时，自然可以在反斜杠前加上转义符 \\ ，但是这样未免太麻烦。Python提供了一个简化的操作，Pyhon允许用 r'字符串内容' 表示 '字符串内容' 内部的字符串默认不转义： print ( ' \\\\\\t\\\\ ' ) print ( '-' * 10 ) print ( r ' \\\\ \\t \\\\ ' ) \\ \\ ---------- \\\\\\t\\\\ name与object 提到编程语言，常常会提起变量这个概念，但在Python中，变量一词更准确的说法应该是name（名字）。有观点认为Python不存在变量这个概念，也有观点认为Python存在变量的概念（即name），只不过Python的变量的行为和其他编程语言有所区别。但在这里不深入探究，在本系列的文章中， 变量 和 名字（name） 具有等同的内涵； 变量值（变量的值） 和 对象（object） 具有等同的内涵。 Python是动态类型的语言，变量不需要声明、定义和初始化，变量会在赋值时被创建。 Objects 所有Python对象都有: 一个惟一的 identity （由id(x)返回的一个整数，注意：identity 不是 identifier） 一个类型（由type(x)返回） 一些值 无法改变对象的identity，也不能改变对象的类型。 改变位于某一地址的对象的引用与类型是不可能的，只能把对象销毁，然后重新创建。 Note 在CPython2.2及更新的版本中，你可以在相当有限的情况下更改对象的类型。 一些对象允许你改变它们的值（在不改变它们的identity和type的情况下），这种对象被称为 mutable object ；而一些对象并不允许你改变它们的值，它们被称为 immutable object 。 类型由 类对象 表示（类对象往往知道类的对象要占多少内存，有什么方法等等）。 一个对象可以有： 零个或多个方法（由类对象提供） 零个或多个 名字 某些对象具有允许你更改对象内容（即对其进行修改）的方法。某些对象仅具有允许您访问内容而不更改内容的方法。一些对象没有任何方法。即使对象具有方法，你也不能改变它们的类型或者identity。 Names name不是object的属性，object并不知道它们的name（名字）。 所有name在创建时必须关联（bind）到一个object，否则在需要引用该name时会报错。 name可以在创建以后指向任何一个object（包括不同类型），所以name本身没有类别，但name关联的object是有类别的。 在python中可以使用type（name）来查看name关联的object的类型。 一个对象可以关联（bind）多个名字，也可以没有名字。 Name存在于namespace（命名空间），例如模块命名空间、实例命名空间、函数的局部命名空间等等。 assignment Python也有assignment这个英文概念，它的中文或许译为 分配 或者 命名 更为恰当，因为在Python中，assignment语句会改动namespace，而不是改动了object。 换而言之，如果在python中有一个assignment statement如下： a = 10 这个assignment语句表示将名称a添加到namespace，并且namespace的a键 2 所对应的value为10。 如果名称已经存在，assignment语句将替换原始名称： a = 10 a = 20 这意味着首先要将名称a添加到namespace，并使其指向包含值10的整数对象。然后再使a其指向包含值20的整数对象。原来的整数对象10不受此操作的影响。 如果这样做： a = [] a . append （ 1 ） 第一条语句将 a 关联到一个空列表对象，这会修改命名空间，第二条语句修改了该列表的内容，这并不会触及namespace。 综上所述，assignment statement在python中有两个作用： 用于（重新）将名称绑定到对象 修改可变对象的属性（内容） 单引号与双引号 在Python中单引号和双引号都可以用来表示一个字符串，比如： str1 = 'python' str2 = \"python\" str1和str2是没有任何区别的。 Python以其易用性而著名，但单引号和双引号却不仅仅是为了方便。想想I'm a big fans of Python.这个字符串应该怎么定义？可以这样写： str3 = 'I \\' m a big fan of Python.' 那么We all know that 'A' and 'B' are two capital letters.又该怎么定义呢？ str4 = 'We all know that \\' A \\' and \\' B \\' are two capital letters.' 显然太多的转义符看起来并不好看，而且容易出错了。那么，在Python中，还可以这样写： str4 = \"We all know that 'A' and 'B' are two capital letters.\" 这样就人性化多了，这就是Python支持双引号和单引号都能用来定义字符串的原因。反之，如果字符串中有双引号，为了避免使用转义符，你可以使用单引号来定义这个字符串。比如： str5 = 'The teacher said: \"Practice makes perfect\" is a very famous proverb.' 这就是Python易用性和人性化的一个极致体现，当你用单引号' '定义字符串的时候，它就会认为你字符串里面的双引号\" \"是普通字符，从而不需要转义。反之当你用双引号定义字符串的时候，就会认为你字符串里面的单引号是普通字符无需转义。 进制数表示 0b 开头表示二进制数： 0b10 2 0o 开头表示八进制数： 0o10 8 0x 开头表示十六进制数： 0x10 16 Lambdas 正常创建函数（使用 def ）会自动将其赋值给变量，这与创建其他对象（例如字符串和整数）不同，后者可以动态创建，而无需将它们分配给变量。但只要使用lambda语法创建函数，函数也可以这样做，以这种方式创建的函数称为匿名（anonymous）函数。将简单函数作为参数传递给另一个函数时，最常使用此方法。语法如下： # my_func是正常创建的函数（named function） def my_func ( f , arg ): return f ( arg ) my_func ( lambda x : 2 * x * x , 5 ) 50 在上面的代码中，我们动态创建了一个匿名函数，并使用参数调用它。Lambda函数没有命名函数（named function）那么强大。Lambda函数只能包含一个表达式，通常相当于一行代码。实际上，Lambda函数可以分配给变量，并像普通函数一样使用。但是，很少有充分的理由这样做。通常使用 def 来定义函数通常更好。 double = lambda x : x * 2 print ( double ( 7 )) 14 运算符 算术运算符 运算符 描述 + 加 - 减 * 乘 / 除 % 取模 ** 幂 // 取整除 比较运算符 运算符 描述 == 等于 != 不等于 > 大于 < 小于 >= 大于等于 <= 小于等于 赋值运算符 运算符 描述 = 简单的赋值运算符 += 加法赋值运算符 -= 减法赋值运算符 *= 乘法赋值运算符 /= 除法赋值运算符 %= 取模赋值运算符 **= 幂赋值运算符 //= 取整除赋值运算符 按位运算符 运算符 描述 << 左移运算符：运算数的各二进位全部左移若干位，由 << 右边的数指定移动的位数，高位丢弃，低位补0 >> 右移运算符：把 > 左边的运算数的各二进位全部右移若干位， >> 右边的数指定移动的位数 & 与运算符：参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为0 | 或运算符：只要对应的二个二进位有一个为1时，结果位就为1 ^ 异或运算符：当两对应的二进位相异时，结果为1 ~ 取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1。 ~x 类似于 -x-1 左移和右移的意思就是把位数整体向左或者向右移动若干位。比如1111向右移一位就变成了0111，原来没有的位自动填0，超出范围的位舍弃掉。看几个例子： print ( 0b1111 >> 1 ) print (( 0b1111 >> 1 ) is 0b111 is 7 ) 7 True print ( 0b1010 << 2 ) print (( 0b1010 << 2 ) is 0b101000 is 40 ) 40 True 如果使用十进制（或者其他进制数），也是对其二进制形式进行移位： print ( 0b1111 is 15 ) print (( 15 >> 1 ) is 7 is 0b111 ) True True 其他按位运算符的例子： print (( 0b1111 & 0b1010 ) is 0b1010 is 10 ) print (( 0b1111 | 0b1010 ) is 0b1111 is 15 ) print (( 0b1111 ^ 0b1010 ) is 0b0101 is 5 ) print (( ~ 0b1010 ) is ( - 0b1010 - 1 ) is - 11 ) True True True True 如果使用十进制（或者其他进制数），也是对其二进制形式进行移位： print (( 15 & 10 ) is 0b1010 is 10 ) print (( 15 | 10 ) is 0b1111 is 15 ) print (( 15 ^ 10 ) is 0b0101 is 5 ) print (( ~ 10 ) is ( - 10 - 1 ) is - 0b1011 ) True True True True 逻辑运算符 运算符 逻辑表达式 描述 and x and y x、y同时为真，则结果为真，否则为假 or x or y x、y两者有一个为真，则结果为真，否则为假 not not x x为真，结果为假；x为假，结果为真 成员运算符 运算符 描述 in 如果在指定的序列中找到值返回 True，否则返回 False not in 如果在指定的序列中没有找到值返回 True，否则返回 False 身份运算符 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b) 。如果引用的不是同一个对象则返回结果 True，否则返回 False 运算符优先级 运算符 描述 优先级 {key:value, ...} 字典显示 16 [...] 列表显示 16 (...) 将表达式用括号括起或元组显示 16 x[index]、x[index1:index2]、f(args...)、x.attribute 元素访问、切片、函数调用、属性引用 15 ** 幂运算 14 ~ 按位求补 13 *、/、//、%、@ 乘、除、取整、取模 12 +、- 加、减 11 <<、>> 左移位、右移位 10 & 按位与 9 ^ 按位异或 8 | 按位或 7 <、<=、>、>=、==、!= 比较运算符 6 is、is not 身份运算符 6 in、not in 成员运算符 6 not 逻辑运算符 5 and 逻辑运算符 4 or 逻辑运算符 3 if - else 条件表达式 2 lambda Lambda 表达式 1 具有相同优先级的运算符将从左至右的方式依次进行。用小括号 () 可以改变运算顺序。 包括函数、类的定义。 ↩ 目前Python的命名空间使用字典实现，但日后可能会改变。 ↩","text_tokens":["若干","assignment","单行","tab","赋值","两","转义","prompt","str2","10","除法","最","号","层次","人性","'","主","程序代码","该","数传","two","很长","仅","从而","backspace","不","默认","lambda","*","算符","three","调用","读取","填","字典","分隔","第二条","符","行为","支持","...","7","0b0101","英文","修改","in","每个","这","符号","内涵","note","一行","64","有所","掉","不是","thirdfunc","pyhon","惟一","否则","{","yield","空","对应","部分","书写","第一","four","是","arg","整个","呢","不会","当","启动","本质","条件","格式","某个",";","列出","not","四个","方式","程序","这样","objects","后者","function","del","类似","初始","0b","右边","表达式","只能","bind","并","分","python","实现","查看","3","不仅","str5","keyword","一词","13","日后","相当","替换","namespace","由类","访问","append","再","小括号","and","中有","0x10","包括","相同","来","工作","somemodule","语法","整除","移动","左边","is","更改","库","elif","有效","n",")","同一","cpython","计算","块","整体","。","导入","综上所述","打印","除","至","m","十进制","的","mutable","其","&","充分","1111","列表","一列","nonlocal","版本","了","编号"," ","普通","很多","行尾","这里","<","+","交互","缩进","仅仅","item","字符串","同一个","半角","处理","这个","实例","理由","将","换行符","o12","all","则","使用","可变","end","或","5","!","变量值","%","代表","即","怎么","序列","finally","比如","二进制","a","一条","时会","易用性","其后","局部","被","0b111","占","未免","元素","二进位","这是","它","一段","value","注释","实际","显然","相当于","2","由","}","动态","amd64","系列","还","\\","单引号","重新","输入","原来","插入","fans","传递","添加","位数","运算符","try","改变","等等","特色","·","因为","反","cmd","斜杠","_","和","位置","double","并不知道","提供","第一条","该位","we","8","响铃","中","0o10","必须","做","切片","函数","当前","释器","；","continue","制表符","一种","await","加上","未免太","b","v","反之","而","false","3.7","简单","不同","解释器","attribute","0o","某些","首先","乘法","左移","位于","oyy","移到","保留字","，","kwlist","随意","与","]","e","超出范围","型","index","print","没有","内部","都","常","func","关键字","50","perfect","proverb","teacher","双引号","顺序","看起来","lambdas","=","功能","左","一位","更好","or","即使","names","含义","我们","综上","而且","多","import","capital","不知","时候","太多","恰当","并且","如","您","整数","one","第二","按位","就","fan","数","舍弃","而言","使","纵向","给","tty","cpython2.2","of","用","及","十六","二条","the","that","实际上","1","分配","那么","风格","高位","异或","减","移位","运行","none","下面","范围","标识","多个","小于","若干位","取整","几个","有","注意","行中","区别","关联","包含","except","常用","换","自动","两个","(","正常","观点","里面","primary","while","raise","续行","括起","例子","0b1010","名称","一部","喇叭","用来","参数","一部分","幂","如果","到","0b10","0b101000","编程语言","续行符","identifier","原始","原因","mode","else","等同","时","空行","自然","编程","结束","求补","名字","类型","said","重构","于","通过","另外","字符","0111","msc","一些","采用","描述","index2","很少","路径","初始化","只要","这会","回车符","？","影响","各","0b1111","此","推荐","ipython","简化","地址","所","big","原先","前","两者","other","变量","可以","secondfunc","译","“","key","named","看","@","会","进位","最具","全部","你","极致","方法","一样","约定","类","开头","更","然后","属性","args","开始","八进制","[","000","|","相应","匿名","t","约定俗成","要","之","值","位","超出","命令","表达","提示","为","说法","不过","取","index1","留字","称为","11","例如","一般","进行","容易","易用","保持","famous","name","销毁","are","任何","对","不受","total","windows","0b1011","操作","^","命名","只有","横向","在于","somefunction","以其","0x","4",":","9","自","便于","之间","情况","算机","无需","bit","f","为了","用作","本","本身","像","pyhton","提起","不仅仅","显示","创建","丢弃","二进制位","称","x","指向","意思","12","强大","文章","v.1915",".","维护","表格","什么","一定","practice","通常","取反","但是","anonymous","一个","制表","变差","乘","类别","意味着","逻辑","class","statement","当于","代码","letters","想想","好看","其他","所述","\"","上面","依次","这些","假","if","所有","某一","0","yy","可读性","指定","冒号","标识符","找到","空间","进来","def","触及","蜂鸣器","现在","中文","量值","更为","取模","想","6","可读","内存","需要","my","变成","（","文件","immutable","以后","出错","知道","str3","break","global","具有","作用","pass","十六进制","for","换行","应该","环境","却","结果","允许","认为","不能","减法","报错","interactive","函数调用","存在","标准","体现","个","有时候","成员","括号","15","或许","特殊","~","声明","true","算术","#","它们","发声","有所区别","模块","优先级","把","右","有限","five","优先","转义字符","id","参与","缩","窗口","看起","解释","提到","）","比较","40","身份",">","无法","关键","计算机","用于","常常","能","绑定","r","module","object","起来","、","零个","形式","有时","探究","/","async","加强","在","二个","相异","参数传递","动态创建","是不是","引用","20","准确","大于","makes","此时","元组","意味","但","with","概念","know","多条","x0a","直至","表示","改动","16","assert","加","对象","也","i","交互式","语言","多行","返回","补","更新","这种","y","运算","另","处","-","：","新","直接","目前","突出","所以","大括号","就是","方便","语句","入口","量","提示符","其它","very","return","不带","两段","行","低位","进制","type","如下","加法","著名","空格","----------","回车","判断","又","输出","做法","14","多少","右移","一次","保留","往往","已经","str1","向","深入","退格","写","定义","数据","identity","光标","避免","引号","一","内容","↩","str4","同时",",","换页","xyy","执行","”","从","作为","以","或者","可能","下","麻烦","人性化","所谓","等于","变为","from","真","只不过","as","达式","模式","键","firstfunc"],"title":"2.1.python基本语法","title_tokens":["基本",".","python","语法","2.1"]},{"location":"Python基础/2.1.python基本语法.html#_1","text":"Python是一种解释型语言，Python解释器通过一次执行一条语句的方式运行程序。从 tty 读取命令时, 我们称解释器工作于交互模式 (interactive mode)。可以在cmd窗口通过 python 命令启动CPython解释器的交互模式，交互模式下CPython通过主提示符 (primary prompt) 提示下一条命令, 主提示符为 >>> ，而从提示符 ··· 提示一条命令的续行。 加强的交互式解释器(IPython)的提示符是一种编号的风格，如 In[2] ，而不是标准的 >>> 。","text_tokens":["tty",">","编号","不是","]"," ","型","可以","prompt","交互式","语言","mode","交互","interactive","是","释器","一种","一次","时","工作","风格","启动","2","主","标准","运行","而","加强","在","ipython","解释器",",","通过","方式","程序","我们","于",")","执行","cpython","从","语句","。","读取","[","下","提示符","·","如","cmd","命令","(","提示","为","一条","的","python","，","称","in","窗口","解释","primary","模式","续行"],"title":"交互模式","title_tokens":["模式","交互"]},{"location":"Python基础/2.1.python基本语法.html#python","text":"保留字（又称为关键字）， 不能把它们用作任何标识符名称 。Python的标准库提供了一个keyword模块，可以输出当前版本的所有关键字： import keyword keyword . kwlist print ( keyword . kwlist ) ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']","text_tokens":["pass","名称","for","不能","else","标准","'","lambda","true","它们","try","模块","把","in","提供","）","关键","可以","yield","当前","continue","await","async","false","not","del","[","with","保留字","python","，","称为","留字","kwlist","keyword","assert","任何","]","print","and","关键字","or","：","is","库","elif",")","用作","import","。","的","return","nonlocal","版本","了","."," ","一个","class","又","输出","保留","none","标识","if","所有",",","标识符","def","except","finally","(","（","from","as","break","global","while","raise"],"title":"python保留字","title_tokens":["保留字","留字","保留","python"]},{"location":"Python基础/2.1.python基本语法.html#_2","text":"Python中单行注释以 # 开头。多行注释则使用： ''' 或者 \"\"\" 。实际上python只有单行注释。多行注释的本质是字符串对象。 # 这是单行注释 ''' 这是多行注释 这是多行注释 '''","text_tokens":["这是","中","单行","对象"," ","多行","注释","实际上","是","实际","只有","字符串","'","本质","\"","：","则","使用","字符","开头","#","或者","以","。","的","python"],"title":"注释","title_tokens":["注释"]},{"location":"Python基础/2.1.python基本语法.html#_3","text":"python最具特色的就是使用缩进来表示代码块，不是使用大括号{}。而冒号表示一段缩进代码块的开始，其后所有相同层次的代码必须保持相同的缩进量，缩进量则可以随意，直至代码块结束。 一般约定俗成使用4个空格的缩进。 if True : print ( \"True\" ) else : print ( \"False\" ) True","text_tokens":["保持","随意","不是","必须"," ","可以","一段","{","空格","print","else","代码","缩进","相同","层次","}","结束","4","个","而","最具","\"","false",":","括号","所有","if","约定","使用","冒号","则","true",")","进来","大括号","就是","开始","块","。","量","特色","约定俗成","(","的","python","，","其后","缩","直至","表示","一般"],"title":"代码块","title_tokens":["块","代码"]},{"location":"Python基础/2.1.python基本语法.html#_4","text":"如果语句很长，可以使用反斜杠 \\ 来续行，例如： a = 3 + \\ 4 + \\ 5 a 12 在 [] , {} , 或 () 中的多行语句 1 ，不需要使用反斜杠 \\ ，例如： total = [ 'item_one' , 'item_two' , 'item_three' , 'item_four' , 'item_five' ] total ['item_one', 'item_two', 'item_three', 'item_four', 'item_five']","text_tokens":["中","]","如果"," ","可以","{","多行","total","+","1","four","item","来","'","}","4","=","two","很长","\\","在","：","不",",","使用",")","或","5","例如","three","语句","[","需要","反","斜杠","(","a","_","的","five","，","one","12","3","续行"],"title":"代码续行","title_tokens":["续行","代码"]},{"location":"Python基础/2.1.python基本语法.html#_5","text":"Python可以在同一行中使用多条语句，语句之间使用半角分号 ; 分隔。但这样的做法一般不推荐，因为会使代码的可读性变差。","text_tokens":["使"," ","可以","变差","做法","代码","号","半角","会","在",";","之间","不","可读性","使用","这样","同一","行中","语句","。","分隔","可读","因为","但","的","分","python","，","多条","推荐","一般"],"title":"同一行书写多条语句","title_tokens":["同一","多条","语句","行","书写"]},{"location":"Python基础/2.1.python基本语法.html#_6","text":"函数、类方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同， 空行并不是Python语法的一部分。 书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。空行也是程序代码的一部分。","text_tokens":["作用","维护","日后","不是","一部","与","用","也"," ","一部分","但是","一段","函数","部分","书写","代码","缩进","是","释器","、","时","空行","不会","在于","程序代码","运行","功能","语法","重构","便于","方法","之间","新","不","不同","解释器","类","含义","插入","程序","或","突出","开始","。","以","入口","分隔","和","并","的","python","，","出错","两段","解释","表示","一行"],"title":"空行","title_tokens":["空行"]},{"location":"Python基础/2.1.python基本语法.html#print","text":"print函数默认输出是换行的，如果要实现不换行打印，需要更改print函数的 end 参数： # 换行输出 print ( \"a\" ) print ( \"b\" ) print ( '-' * 10 ) # 不换行输出 print ( \"a\" , end = \" \" ) print ( \"b\" , end = \" \" ) print () a b ---------- a b","text_tokens":["换行","参数","如果"," ","----------","print","函数","10","输出","是","'","b","=","\"","-","：","不","更改","默认",",","*","end",")","#","打印","要","需要","(","a","的","，","实现"],"title":"Print 输出","title_tokens":["输出","print"," "]},{"location":"Python基础/2.1.python基本语法.html#import-fromimport","text":"在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块 ( module ) 导入： import somemodule 从某个模块中导入某个函数： from somemodule import somefunction 从某个模块中导入多个函数： from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入： from somemodule import *","text_tokens":["中","用","thirdfunc"," ","secondfunc","函数","module","来","整个","somefunction","somemodule","多个","在","某个","将","全部","：",",","*",")","import","从","。","或者","导入","模块","相应","...","(","的","python","from","firstfunc"],"title":"import 与 from...import","title_tokens":["...","与"," ","from","import"]},{"location":"Python基础/2.1.python基本语法.html#_7","text":"如果要在字符串中输入一些特殊的字符（这些字符特殊之处在于不能直接输出），这就需要“转义符”。所谓转义，就是不采用符号原先的含义，而采用另外一含义。在Pyhton中， \\ 代表转义符。 下面表格中列出常用的转义符： 转义字符 描述 \\ 在字符串行尾的续行符 \\\\ 反斜杠符号 \\' 单引号 \\\" 双引号 \\a 蜂鸣器响铃（不是喇叭发声），现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效 \\b 退格（Backspace），将光标位置移到前一列 \\e 转义 \\000 空 \\n 换行符 \\v 纵向制表符 \\t 横向制表符，即 Tab 键，一般相当于四个空格 \\r 回车符 \\f 换页 \\oyy 八进制数，yy代表字符，例如： \\o12 代表换行 \\xyy 十六进制数，yy代表字符，例如： \\x0a 代表换行 \\other 其它的字符以普通格式输出 有时候，字符串包含了很多 \\ ，Python默认将'\\'作为转义符处理，但实际上我们想输出的是反斜杠符号 \\ ，（例如输入文件路径）。此时，自然可以在反斜杠前加上转义符 \\ ，但是这样未免太麻烦。Python提供了一个简化的操作，Pyhon允许用 r'字符串内容' 表示 '字符串内容' 内部的字符串默认不转义： print ( ' \\\\\\t\\\\ ' ) print ( '-' * 10 ) print ( r ' \\\\ \\t \\\\ ' ) \\ \\ ---------- \\\\\\t\\\\","text_tokens":["十六进制","喇叭","tab","换行","如果","转义","允许","续行符","不能","10","实际","相当于","自然","'","\\","有时候","单引号","backspace","特殊","不","输入","默认","另外","字符","*","一些","采用","描述","发声","路径","符","反","斜杠","回车符","转义字符","位置","这","符号","提供","简化","）","原先","响铃","中","不是","前","other","pyhon","计算机","可以","空","r","是","“","制表符","加上","未免太","b","有时","v","而","格式","在","列出","四个","这样","八进制","000","此时","oyy","t","要","之","移到","但","python","，","x0a","表示","例如","一般","相当","e","print","内部","都","操作","横向","在于","双引号","键","处","-","：","算机","f","含义","有效","直接","n","我们",")","所以","就是","计算","。","pyhton","时候","其它","的","不带","就","一列","数","表格","了","纵向","一定","进制","用"," ","普通","很多","但是","十六","行尾","制表","空格","一个","----------","回车","实际上","输出","当于","字符串","处理","下面","退格","\"","这些","将","光标","引号","一","换行符","内容","o12","yy","换页","xyy","”","包含","蜂鸣器","作为","以","现在","代表","即","常用","想","麻烦","需要","所谓","(","（","a","文件","未免","续行"],"title":"转义符\\","title_tokens":["转义","\\","符"]},{"location":"Python基础/2.1.python基本语法.html#nameobject","text":"提到编程语言，常常会提起变量这个概念，但在Python中，变量一词更准确的说法应该是name（名字）。有观点认为Python不存在变量这个概念，也有观点认为Python存在变量的概念（即name），只不过Python的变量的行为和其他编程语言有所区别。但在这里不深入探究，在本系列的文章中， 变量 和 名字（name） 具有等同的内涵； 变量值（变量的值） 和 对象（object） 具有等同的内涵。 Python是动态类型的语言，变量不需要声明、定义和初始化，变量会在赋值时被创建。","text_tokens":["）","有所","中","name","应该","对象","赋值","也"," ","变量","编程语言","认为","语言","常常","这里","具有","是","object","；","存在","等同","编程","、","时","这个","其他","动态","会","名字","深入","探究","系列","定义","类型","在","有","不","声明","更","区别","准确","变量值","本","初始","。","量值","提起","即","有所区别","初始化","值","需要","但","行为","创建","和","概念","说法","的","（","python","，","观点","不过","只不过","内涵","被","提到","文章","一词"],"title":"name与object","title_tokens":["object","与","name"]},{"location":"Python基础/2.1.python基本语法.html#objects","text":"所有Python对象都有: 一个惟一的 identity （由id(x)返回的一个整数，注意：identity 不是 identifier） 一个类型（由type(x)返回） 一些值 无法改变对象的identity，也不能改变对象的类型。 改变位于某一地址的对象的引用与类型是不可能的，只能把对象销毁，然后重新创建。 Note 在CPython2.2及更新的版本中，你可以在相当有限的情况下更改对象的类型。 一些对象允许你改变它们的值（在不改变它们的identity和type的情况下），这种对象被称为 mutable object ；而一些对象并不允许你改变它们的值，它们被称为 immutable object 。 类型由 类对象 表示（类对象往往知道类的对象要占多少内存，有什么方法等等）。 一个对象可以有： 零个或多个方法（由类对象提供） 零个或多个 名字 某些对象具有允许你更改对象内容（即对其进行修改）的方法。某些对象仅具有允许您访问内容而不更改内容的方法。一些对象没有任何方法。即使对象具有方法，你也不能改变它们的类型或者identity。","text_tokens":["允许","identifier","不能","由","名字","类型","仅","重新","不","一些","它们","改变","等等","把","有限","和","修改","id","提供","note","地址","）","不是","中","惟一","无法","可以","是","object","；","零个","而","在","你","方法","类","引用","然后","某些","位于","要","值","只能","并","python","，","称为","表示","进行","相当","对象","销毁","与","任何","也","对","由类","返回","没有","访问","更新","都","这种",":","即使","：","情况","更改",")","。","您","创建","整数","的","x","mutable","其","版本","什么","cpython2.2","type","及"," ","一个","多少","往往","多个","identity","某一","所有","有","内容","注意","或","可能","或者","下","即","内存","(","（","immutable","知道","被","占","具有"],"title":"Objects","title_tokens":["objects"]},{"location":"Python基础/2.1.python基本语法.html#names","text":"name不是object的属性，object并不知道它们的name（名字）。 所有name在创建时必须关联（bind）到一个object，否则在需要引用该name时会报错。 name可以在创建以后指向任何一个object（包括不同类型），所以name本身没有类别，但name关联的object是有类别的。 在python中可以使用type（name）来查看name关联的object的类型。 一个对象可以关联（bind）多个名字，也可以没有名字。 Name存在于namespace（命名空间），例如模块命名空间、实例命名空间、函数的局部命名空间等等。","text_tokens":["）","不是","name","中","type","任何","必须"," ","到","否则","一个","可以","也","namespace","类别","没有","函数","报错","object","是","对象","包括","来","存在","时","命名","、","该","名字","类型","多个","在","实例","所有","有","不同","于","使用","引用","空间","所以","属性","关联","本身","它们","。","不知","模块","等等","需要","但","创建","bind","（","的","查看","时会","，","以后","知道","并不知道","指向","python","局部","例如"],"title":"Names","title_tokens":["names"]},{"location":"Python基础/2.1.python基本语法.html#assignment","text":"Python也有assignment这个英文概念，它的中文或许译为 分配 或者 命名 更为恰当，因为在Python中，assignment语句会改动namespace，而不是改动了object。 换而言之，如果在python中有一个assignment statement如下： a = 10 这个assignment语句表示将名称a添加到namespace，并且namespace的a键 2 所对应的value为10。 如果名称已经存在，assignment语句将替换原始名称： a = 10 a = 20 这意味着首先要将名称a添加到namespace，并使其指向包含值10的整数对象。然后再使a其指向包含值20的整数对象。原来的整数对象10不受此操作的影响。 如果这样做： a = [] a . append （ 1 ） 第一条语句将 a 关联到一个空列表对象，这会修改命名空间，第二条语句修改了该列表的内容，这并不会触及namespace。 综上所述，assignment statement在python中有两个作用： 用于（重新）将名称绑定到对象 修改可变对象的属性（内容）","text_tokens":["作用","名称","assignment","它","如果","到","value","原始","10","存在","2","该","或许","重新","原来","添加","第二条","因为","这会","影响","英文","修改","此","这","第一条","所","）","中","不是","做","用于","空","对应","绑定","译","第一","object","不会","会","而","在","这样","20","属性","然后","首先","[","意味","之","要","值","概念","为","并","python","，","表示","改动","对象","]","也","替换","namespace","不受","append","再","操作","中有","命名","=","：","综上","语句","。","综上所述","恰当","并且","整数","的","其","指向","列表","第二","而言","使","了",".","如下"," ","一个","二条","意味着","statement","1","分配","已经","这个","所述","将","有","内容","可变","空间","关联","触及","包含","或者","更为","中文","换","两个","a","（","一条","键"],"title":"assignment","title_tokens":["assignment"]},{"location":"Python基础/2.1.python基本语法.html#_8","text":"在Python中单引号和双引号都可以用来表示一个字符串，比如： str1 = 'python' str2 = \"python\" str1和str2是没有任何区别的。 Python以其易用性而著名，但单引号和双引号却不仅仅是为了方便。想想I'm a big fans of Python.这个字符串应该怎么定义？可以这样写： str3 = 'I \\' m a big fan of Python.' 那么We all know that 'A' and 'B' are two capital letters.又该怎么定义呢？ str4 = 'We all know that \\' A \\' and \\' B \\' are two capital letters.' 显然太多的转义符看起来并不好看，而且容易出错了。那么，在Python中，还可以这样写： str4 = \"We all know that 'A' and 'B' are two capital letters.\" 这样就人性化多了，这就是Python支持双引号和单引号都能用来定义字符串的原因。反之，如果字符串中有双引号，为了避免使用转义符，你可以使用单引号来定义这个字符串。比如： str5 = 'The teacher said: \"Practice makes perfect\" is a very famous proverb.' 这就是Python易用性和人性化的一个极致体现，当你用单引号' '定义字符串的时候，它就会认为你字符串里面的双引号\" \"是普通字符，从而不需要转义。反之当你用双引号定义字符串的时候，就会认为你字符串里面的单引号是普通字符无需转义。","text_tokens":["用来","应该","它","却","如果","转义","原因","认为","str2","显然","人性","'","该","体现","two","\\","还","said","从而","单引号","不","fans","字符","符","支持","和","？","这","看起","big","we","中","可以","能","是","起来","呢","当","b","会","反之","而","在","你","极致","这样","makes","但","know","并","python","，","表示","不仅","容易","str5","易用","famous","are","任何","i","没有","都","and","中有","来","perfect","proverb","teacher","双引号","以其","看起来","=",":","：","无需","is","为了","而且","多","就是","方便","。","capital","时候","太多","不仅仅","very","m","的","就","fan",".","了","practice","of","用"," ","普通","一个","著名","the","that","又","仅仅","那么","letters","字符串","想想","str1","这个","好看","写","定义","\"","避免","引号","all","str4","使用","区别","怎么","人性化","比如","需要","a","易用性","str3","出错","里面"],"title":"单引号与双引号","title_tokens":["与","双引号","引号","单引号"]},{"location":"Python基础/2.1.python基本语法.html#_9","text":"0b 开头表示二进制数： 0b10 2 0o 开头表示八进制数： 0o10 8 0x 开头表示十六进制数： 0x10 16","text_tokens":["8","十六进制","进制","0o10"," ","0b10","十六","0x10","2","0x","：","开头","0o","0b","八进制","二进制","表示","数","16"],"title":"进制数表示","title_tokens":["表示","数","进制"]},{"location":"Python基础/2.1.python基本语法.html#lambdas","text":"正常创建函数（使用 def ）会自动将其赋值给变量，这与创建其他对象（例如字符串和整数）不同，后者可以动态创建，而无需将它们分配给变量。但只要使用lambda语法创建函数，函数也可以这样做，以这种方式创建的函数称为匿名（anonymous）函数。将简单函数作为参数传递给另一个函数时，最常使用此方法。语法如下： # my_func是正常创建的函数（named function） def my_func ( f , arg ): return f ( arg ) my_func ( lambda x : 2 * x * x , 5 ) 50 在上面的代码中，我们动态创建了一个匿名函数，并使用参数调用它。Lambda函数没有命名函数（named function）那么强大。Lambda函数只能包含一个表达式，通常相当于一行代码。实际上，Lambda函数可以分配给变量，并像普通函数一样使用。但是，很少有充分的理由这样做。通常使用 def 来定义函数通常更好。 double = lambda x : x * 2 print ( double ( 7 )) 14","text_tokens":["赋值","参数","它","最","实际","时","相当于","2","动态","lambda","字符","*","传递","#","调用","它们","很少","只要","_","和","7","double","此","这","一行","）","中","变量","可以","做","函数","arg","是","named","会","而","在","简单","参数传递","方法","动态创建","一样","不同","方式","这样","后者","function","表达式","匿名","但","只能","表达","并","，","称为","例如","相当","对象","与","也","print","没有","这种","常","命名","func","50","来","另","=","语法",":","更好","：","无需","f","我们",")","。","像","创建","整数","其","的","return","x","充分","强大","了","给","通常","如下"," ","anonymous","普通","一个","但是","实际上","分配","当于","代码","14","那么","字符串","其他","定义","上面","理由","将","有",",","使用","5","def","包含","作为","以","自动","my","正常","(","（","达式","数传"],"title":"Lambdas","title_tokens":["lambdas"]},{"location":"Python基础/2.1.python基本语法.html#_10","text":"","text_tokens":[],"title":"运算符","title_tokens":["运算符","算符","运算"]},{"location":"Python基础/2.1.python基本语法.html#_11","text":"运算符 描述 + 加 - 减 * 乘 / 除 % 取模 ** 幂 // 取整除","text_tokens":["除","运算","加","取模","*","幂","算符","减"," ","/","取","运算符","乘","%","描述","整除","-","+"],"title":"算术运算符","title_tokens":["运算","运算符","算符","算术"]},{"location":"Python基础/2.1.python基本语法.html#_12","text":"运算符 描述 == 等于 != 不等于 > 大于 < 小于 >= 大于等于 <= 小于等于","text_tokens":["不","运算",">","等于","算符","!"," ","运算符","=","大于","描述","小于","<"],"title":"比较运算符","title_tokens":["算符","比较","运算符","运算"]},{"location":"Python基础/2.1.python基本语法.html#_13","text":"运算符 描述 = 简单的赋值运算符 += 加法赋值运算符 -= 减法赋值运算符 *= 乘法赋值运算符 /= 除法赋值运算符 %= 取模赋值运算符 **= 幂赋值运算符 //= 取整除赋值运算符","text_tokens":["幂","加法","赋值"," ","减法","+","除法","运算","/","=","整除","-","简单","*","算符","运算符","%","乘法","描述","取模","的","取"],"title":"赋值运算符","title_tokens":["赋值","运算符","算符","运算"]},{"location":"Python基础/2.1.python基本语法.html#_14","text":"运算符 描述 << 左移运算符：运算数的各二进位全部左移若干位，由 << 右边的数指定移动的位数，高位丢弃，低位补0 >> 右移运算符：把 > 左边的运算数的各二进位全部右移若干位， >> 右边的数指定移动的位数 & 与运算符：参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为0 | 或运算符：只要对应的二个二进位有一个为1时，结果位就为1 ^ 异或运算符：当两对应的二进位相异时，结果为1 ~ 取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1。 ~x 类似于 -x-1 左移和右移的意思就是把位数整体向左或者向右移动若干位。比如1111向右移一位就变成了0111，原来没有的位自动填0，超出范围的位舍弃掉。看几个例子： print ( 0b1111 >> 1 ) print (( 0b1111 >> 1 ) is 0b111 is 7 ) 7 True print ( 0b1010 << 2 ) print (( 0b1010 << 2 ) is 0b101000 is 40 ) 40 True 如果使用十进制（或者其他进制数），也是对其二进制形式进行移位： print ( 0b1111 is 15 ) print (( 15 >> 1 ) is 7 is 0b111 ) True True 其他按位运算符的例子： print (( 0b1111 & 0b1010 ) is 0b1010 is 10 ) print (( 0b1111 | 0b1010 ) is 0b1111 is 15 ) print (( 0b1111 ^ 0b1010 ) is 0b0101 is 5 ) print (( ~ 0b1010 ) is ( - 0b1010 - 1 ) is - 11 ) True True True True 如果使用十进制（或者其他进制数），也是对其二进制形式进行移位： print (( 15 & 10 ) is 0b1010 is 10 ) print (( 15 | 10 ) is 0b1111 is 15 ) print (( 15 ^ 10 ) is 0b0101 is 5 ) print (( ~ 10 ) is ( - 10 - 1 ) is - 0b1011 ) True True True True","text_tokens":["例子","二进位","0b1010","若干","两","如果","0b101000","结果","10","时","由","2","15","~","于","0111","原来","true","算符","位数","运算符","描述","填","把","只要","右","0b0101","和","各","7","0b1111","每个","参与","该位","）","掉","40",">","否则","对应","是","看","形式","当","进位","全部","二个","相异","类似","左移","右边","|","相应","位","值","超出","为","，","11","进行","与","也","超出范围","对","print","没有","补","0b1011","都","^","运算","左","-","移动","一位","左边","：","is",")","就是","整体","。","丢弃","十进制","二进制位","的","x","&","其","1111","意思","按位","就","数","舍弃","了","取反","低位","进制"," ","一个","<","1","右移","高位","异或","移位","其他","向","范围","数据","若干位","几个","有","0","指定","则","使用","或","5","或者","即","自动","比如","变成","两个","二进制","变为","(","（","0b111"],"title":"按位运算符","title_tokens":["运算符","算符","运算","按位"]},{"location":"Python基础/2.1.python基本语法.html#_15","text":"运算符 逻辑表达式 描述 and x and y x、y同时为真，则结果为真，否则为假 or x or y x、y两者有一个为真，则结果为真，否则为假 not not x x为真，结果为假；x为假，结果为真","text_tokens":["两者"," ","结果","否则","一个","逻辑","and","；","y","、","运算","假","or","有","not","同时","则","算符","运算符","描述","表达式","表达","为","x","真","，","达式"],"title":"逻辑运算符","title_tokens":["逻辑","运算符","算符","运算"]},{"location":"Python基础/2.1.python基本语法.html#_16","text":"运算符 描述 in 如果在指定的序列中找到值返回 True，否则返回 False not in 如果在指定的序列中没有找到值返回 True，否则返回 False","text_tokens":["中"," ","如果","否则","返回","没有","运算","false","在","not","指定","true","找到","算符","运算符","描述","序列","值","的","in","，"],"title":"成员运算符","title_tokens":["成员","运算符","算符","运算"]},{"location":"Python基础/2.1.python基本语法.html#_17","text":"运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b) 。如果引用的不是同一个对象则返回结果 True，否则返回 False","text_tokens":["不是","对象"," ","如果","否则","一个","结果","判断","返回","是","y","同一个","运算","b","=","标识","实例","false","自","not","is","是不是","不同",",","则","引用","标识符","true","算符",")","同一","!","运算符","类似","描述","。","两个","(","a","x","的","，","id"],"title":"身份运算符","title_tokens":["运算","运算符","算符","身份"]},{"location":"Python基础/2.1.python基本语法.html#_18","text":"运算符 描述 优先级 {key:value, ...} 字典显示 16 [...] 列表显示 16 (...) 将表达式用括号括起或元组显示 16 x[index]、x[index1:index2]、f(args...)、x.attribute 元素访问、切片、函数调用、属性引用 15 ** 幂运算 14 ~ 按位求补 13 *、/、//、%、@ 乘、除、取整、取模 12 +、- 加、减 11 <<、>> 左移位、右移位 10 & 按位与 9 ^ 按位异或 8 | 按位或 7 <、<=、>、>=、==、!= 比较运算符 6 is、is not 身份运算符 6 in、not in 成员运算符 6 not 逻辑运算符 5 and 逻辑运算符 4 or 逻辑运算符 3 if - else 条件表达式 2 lambda Lambda 表达式 1 具有相同优先级的运算符将从左至右的方式依次进行。用小括号 () 可以改变运算顺序。 包括函数、类的定义。 ↩ 目前Python的命名空间使用字典实现，但日后可能会改变。 ↩","text_tokens":["幂","value","10","else","函数调用","2","}","求补","成员","括号","15","~","lambda","*","算符","运算符","调用","index2","描述","字典","优先级","改变","右","...","7","优先","in","8","比较","身份",">","可以","{","切片","函数","key","、","@","会","/","条件","not","attribute","类","引用","方式","属性","args","[","元组","|","表达式","但","表达","python","实现","index1","，","11","13","3","进行","16","日后","加","与","]","index","访问","^","小括号","and","命名","包括","相同","运算","顺序","4","=","左",":","-","9","or","is","f","目前",")","。","除","显示","至","x","的","&","列表","12","按位",".","用"," ","乘","<","逻辑","+","1","具有","14","异或","减","移位","定义","依次","取整","将","if","↩",",","使用","空间","或","!","5","%","从","可能","取模","6","(","元素","达式","括起"],"title":"运算符优先级","title_tokens":["运算","算符","优先","运算符","优先级"]},{"location":"Python基础/2.2.语句.html","text":"语句 if 语句 if 语句的语法如下： age = 20 if age >= 18 : print ( 'your age is' , age ) print ( 'adult' ) else : print ( 'your age is' , age ) print ( 'teenager' ) your age is 20 adult 注意不要少写了冒号 : 。 类似R语言的else if，在python中则是使用 elif ： kid elif 是 else if 的缩写，使用缩写是为了避免过度缩进。完全可以有多个 elif ，所以 if 语句的完整形式就是： if < 条件判断1 > : < 执行1 > elif < 条件判断2 > : < 执行2 > elif < 条件判断3 > : < 执行3 > else : < 执行4 > if 判断条件还可以简写，比如写： if True : print ( 'True' ) True 在python中， False 、 0 、 '' 、 [] 、 () 、 {} 都视作False，否则为True。 注意，负值也是被判断为真。 断言 断言语句检查条件是否满足，如果不满足，就引发 AssertionError 异常（并可提供错误消息）。语法如下： assert condition 等价于 if not condition : crash program 例子： assert age >= 12 , 'Children under the age of 12 are not allowed' ---------------------------------------------------------------------------AssertionError Traceback (most recent call last)<ipython-input-1-7c799b440abf> in <module> ----> 1 assert age >= 12, 'Children under the age of 12 are not allowed' AssertionError: Children under the age of 12 are not allowed 循环 Python的循环有两种: for 循环 while 循环 for语句 for 循环， 依次把可迭代对象中的每个元素迭代出来 ，可包含 else 子句。看例子： # 执行这段代码，会依次打印`names`的每一个元素 names = [ 'Michael' , 'Bob' , 'Tracy' ] for name in names : print ( name ) Michael Bob Tracy 所以 for x in ... 循环就是把每个元素代入变量 x ，然后执行缩进块的语句。 while语句 while 语句用于在指定条件为真时反复地执行（循环），条件不满足时退出循环， 比如我们要计算100以内所有奇数之和，可以用while循环实现： sum = 0 n = 99 # 在循环内部变量`n`不断自减，直到变为`-1`时，不再满足while条件，循环退出 while n > 0 : sum = sum + n n = n - 2 print ( sum ) 2500 break 在循环中， break 语句可以提前退出循环。例如 注意 break语句只能用于循环中。 i = 1 while i < 100 : i = i + 1 print ( \"结束循环\" ) break print ( i ) 结束循环 break 的作用是退出当前循环， print(i) 语句不会执行。 continue continue 语句：跳过当前的这次循环，直接开始下一次循环。 注意 continue 语句只能用于循环中。 n = 0 while n < 10 : n = n + 1 print ( n , end = \" \" ) 1 2 3 4 5 6 7 8 9 10 上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用 continue 语句跳过某些循环： n = 0 while n < 10 : n = n + 1 if n % 2 == 0 : # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print ( n , end = \" \" ) 1 3 5 7 9 执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。 循环中的 else 子句 else 子句不仅可以用在 if 语句，还可以用在循环语句。循环语句中的 else 子句在循环迭代完成时、执行条件为 false （对于 while ）时执行，但循环被 break 中止的情况下不会执行。 # for循环 i = 1 for i in range ( 1 , 10 , 2 ): print ( i , end = \" \" ) else : print ( \"i=\" , i ) # while循环 i = 1 while i < 5 : print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) # break子句直接结束循环，循环语句一次也没有执行，此时else子句不会执行。 # 注意，这与while子句中条件为false，循环语句没有执行不同 i = 1 for i in range ( 1 , 10 , 2 ): break print ( i , end = \" \" ) else : print ( \"i=\" , i ) i = 1 while i < 5 : break print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) 1 3 5 7 9 i= 9 1 2 3 4 i= 5 小结 break 、 continue 语句通常都配合 if 语句使用。 要特别注意，不要滥用 break 和 continue 语句。 break 和 continue 会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到 break 和 continue 语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉 break 和 continue 语句。 pass 语句 pass 语句什么也不做。它用于那些语法上必须要有什么语句，但程序什么也不做的场合，例如: # 死循环 while True : pass # Busy-wait for keyboard interrupt (Ctrl+C) # 创建最小结构的类: class MyEmptyClass : pass return 语句 return 语句结束函数的执行并返回一个值。如果没有指定值，将返回 None 。示例： 注意 return 语句只能用于函数中。 def func1 (): return 4 , 2 def func2 (): return print ( func1 ()) print ( func2 ()) (4, 2) None","text_tokens":["例子","作用","这次","造成","pass","for","中则","traceback","如果","多数","它","而是","99","迭代","myemptyclass","10","完全","else","那些","last","时","引发","2","'","}","结束","还","滥用","不","等价","于","通过","true","#","kid","缩写","---------------------------------------------------------------------------","把","...","和","7","修改","in","每个","这","提供","对于","ipython","adult","段","call","负值","）","8","2500","中",">","必须","变量","可以","否则","{","用于","bob","做","示例","input","函数","当前","r","module","是","continue","、","看","形式","不会","改写","偶数","会","去掉","条件","your","range","false","在","not","michael","不同","keyboard","只","死循环","程序","类","20","然后","某些","代入","类似","以内","开始","并不需要","[","此时","上","要","之","recent","错误","跳过","但","100","只能","两个","为","并","python","，","实现","3","满足","例如","继续","一轮","不仅","分叉","容易","完整","assert","两种","name","对象","are","过度","]","也","i","crash","与","语言","print","teenager","age","内部","没有","结构","返回","都","反复","代码执行","元素","c","interrupt","需要","少写","简写","4","=","----","语法",":","-","9","是否","：","condition","names","退出","情况","is","wait","elif","为了","检查","我们","n","直接",")","场合","所以","就是","计算","语句","块","。","most","看到","大多数","打印","中止","allowed","创建","不再","的","x","return","不断","12","就","小结","18","子句","func2","完成","了","什么","通常","异常","可","ctrl","如下","of","出来","用"," ","循环","sum","一个","自减","但是","func1","判断","<","the","+","逻辑","1","class","值","缩进","代码","消息","`","一次","出","tracy","none","写","断言","过多","\"","多个","依次","上面","奇数","避免","if","所有","将","有","0","under","直到","指定",",","使用","冒号","program","end","注意","5","不要","执行","busy","def","包含","提前","%","7c799b440abf","或者","下","6","想","配合","assertionerror","真时","比如","视作","～","特别","(","变为","（","每","children","地","大多","真","后续","出错","最小","break","被","用到","while"],"title":"2.2.语句","title_tokens":["2.2","语句","."]},{"location":"Python基础/2.2.语句.html#_1","text":"","text_tokens":[],"title":"语句","title_tokens":["语句"]},{"location":"Python基础/2.2.语句.html#if","text":"if 语句的语法如下： age = 20 if age >= 18 : print ( 'your age is' , age ) print ( 'adult' ) else : print ( 'your age is' , age ) print ( 'teenager' ) your age is 20 adult 注意不要少写了冒号 : 。 类似R语言的else if，在python中则是使用 elif ： kid elif 是 else if 的缩写，使用缩写是为了避免过度缩进。完全可以有多个 elif ，所以 if 语句的完整形式就是： if < 条件判断1 > : < 执行1 > elif < 条件判断2 > : < 执行2 > elif < 条件判断3 > : < 执行3 > else : < 执行4 > if 判断条件还可以简写，比如写： if True : print ( 'True' ) True 在python中， False 、 0 、 '' 、 [] 、 () 、 {} 都视作False，否则为True。 注意，负值也是被判断为真。","text_tokens":["中则","完全","else","2","'","}","还","true","kid","缩写","adult","负值","中",">","可以","否则","{","r","是","、","形式","条件","your","false","在","20","类似","[","为","python","，","3","完整","过度","]","也","语言","print","teenager","age","都","少写","简写","4","=","语法",":","：","is","elif","为了",")","所以","就是","语句","。","的","18","了","如下"," ","判断","<","1","缩进","写","多个","避免","if","有","0",",","使用","冒号","注意","不要","执行","比如","视作","(","真","被"],"title":"if 语句","title_tokens":["语句","if"," "]},{"location":"Python基础/2.2.语句.html#_2","text":"断言语句检查条件是否满足，如果不满足，就引发 AssertionError 异常（并可提供错误消息）。语法如下： assert condition 等价于 if not condition : crash program 例子： assert age >= 12 , 'Children under the age of 12 are not allowed' ---------------------------------------------------------------------------AssertionError Traceback (most recent call last)<ipython-input-1-7c799b440abf> in <module> ----> 1 assert age >= 12, 'Children under the age of 12 are not allowed' AssertionError: Children under the age of 12 are not allowed","text_tokens":["例子","）","异常","可","assert",">","如下","of","are","traceback","如果"," ","crash","age","the","<","input","1","last","module","消息","引发","'","条件","=","断言","----","语法",":","-","是否","：","condition","if","under","not","不","等价","于","检查",",","program",")","语句","7c799b440abf","。","most","assertionerror","allowed","---------------------------------------------------------------------------","错误","recent","(","（","并","children","in","，","提供","12","ipython","就","满足","call"],"title":"断言","title_tokens":["断言"]},{"location":"Python基础/2.2.语句.html#_3","text":"Python的循环有两种: for 循环 while 循环","text_tokens":["两种","for","的","循环","python"," ",":","while","有"],"title":"循环","title_tokens":["循环"]},{"location":"Python基础/2.2.语句.html#for","text":"for 循环， 依次把可迭代对象中的每个元素迭代出来 ，可包含 else 子句。看例子： # 执行这段代码，会依次打印`names`的每一个元素 names = [ 'Michael' , 'Bob' , 'Tracy' ] for name in names : print ( name ) Michael Bob Tracy 所以 for x in ... 循环就是把每个元素代入变量 x ，然后执行缩进块的语句。","text_tokens":["例子","for","可","对象","中","name","出来","]"," ","循环","变量","一个","bob","迭代","print","else","代码","缩进","`","看","'","tracy","会","=","依次",":","：","names","michael",",",")","所以","然后","执行","代入","#","包含","就是","块","语句","。","[","打印","把","(","...","每","的","x","in","，","每个","这","元素","段","子句"],"title":"for语句","title_tokens":["语句","for"]},{"location":"Python基础/2.2.语句.html#while","text":"while 语句用于在指定条件为真时反复地执行（循环），条件不满足时退出循环， 比如我们要计算100以内所有奇数之和，可以用while循环实现： sum = 0 n = 99 # 在循环内部变量`n`不断自减，直到变为`-1`时，不再满足while条件，循环退出 while n > 0 : sum = sum + n n = n - 2 print ( sum ) 2500","text_tokens":["）","2500",">","sum","用"," ","循环","可以","用于","变量","99","自减","print","内部","+","1","反复","`","时","2","条件","=","在","-","奇数",":","退出","所有","：","0","直到","不","指定","我们","n",")","执行","#","计算","以内","语句","真时","要","比如","之","100","和","地","为","（","变为","不再","，","实现","(","不断","满足","while"],"title":"while语句","title_tokens":["while","语句"]},{"location":"Python基础/2.2.语句.html#break","text":"在循环中， break 语句可以提前退出循环。例如 注意 break语句只能用于循环中。 i = 1 while i < 100 : i = i + 1 print ( \"结束循环\" ) break print ( i ) 结束循环 break 的作用是退出当前循环， print(i) 语句不会执行。","text_tokens":["作用","中","i"," ","循环","可以","用于","print","<","+","1","当前","是","不会","结束","=","\"","在",":","退出",")","注意","执行","提前","语句","。","只能","100","(","的","，","break","例如","while"],"title":"break","title_tokens":["break"]},{"location":"Python基础/2.2.语句.html#continue","text":"continue 语句：跳过当前的这次循环，直接开始下一次循环。 注意 continue 语句只能用于循环中。 n = 0 while n < 10 : n = n + 1 print ( n , end = \" \" ) 1 2 3 4 5 6 7 8 9 10 上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用 continue 语句跳过某些循环： n = 0 while n < 10 : n = n + 1 if n % 2 == 0 : # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print ( n , end = \" \" ) 1 3 5 7 9 执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。","text_tokens":["这次","8","中","用"," ","循环","可以","用于","但是","如果","而是","print","<","10","+","当前","1","代码","是","continue","一次","出","不会","2","偶数","会","4","=","\"","上面",":","9","奇数","if","：","0",",","只","程序","直接","n","end","注意",")","5","我们","某些","执行","#","开始","语句","%","。","看到","下","6","打印","想","一轮","跳过","～","只能","(","7","不再","的","，","后续","3","while","继续"],"title":"continue","title_tokens":["continue"]},{"location":"Python基础/2.2.语句.html#else","text":"else 子句不仅可以用在 if 语句，还可以用在循环语句。循环语句中的 else 子句在循环迭代完成时、执行条件为 false （对于 while ）时执行，但循环被 break 中止的情况下不会执行。 # for循环 i = 1 for i in range ( 1 , 10 , 2 ): print ( i , end = \" \" ) else : print ( \"i=\" , i ) # while循环 i = 1 while i < 5 : print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) # break子句直接结束循环，循环语句一次也没有执行，此时else子句不会执行。 # 注意，这与while子句中条件为false，循环语句没有执行不同 i = 1 for i in range ( 1 , 10 , 2 ): break print ( i , end = \" \" ) else : print ( \"i=\" , i ) i = 1 while i < 5 : break print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) 1 3 5 7 9 i= 9 1 2 3 4 i= 5","text_tokens":["完成","）","for","中","与","用","while"," ","循环","可以","i","也","迭代","print","没有","<","10","+","else","1","、","一次","时","不会","2","结束","条件","=","还","range","\"","4","false","在",":","9","if","情况","不同",",","直接",")","end","5","注意","执行","#","语句","。","此时","下","中止","但","(","7","（","为","的","in","，","对于","这","break","被","3","不仅","子句"],"title":"循环中的else子句","title_tokens":["中","的","循环","else","子句"]},{"location":"Python基础/2.2.语句.html#_4","text":"break 、 continue 语句通常都配合 if 语句使用。 要特别注意，不要滥用 break 和 continue 语句。 break 和 continue 会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到 break 和 continue 语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉 break 和 continue 语句。","text_tokens":["例子","分叉","造成","通常","多数"," ","循环","可以","逻辑","都","代码","代码执行","continue","、","改写","会","去掉","条件","过多","滥用","上面","if","使用","通过","注意","不要","并不需要","执行","语句","大多数","。","或者","配合","要","需要","两个","特别","和","的","大多","修改","，","出错","break","用到","容易"],"title":"小结","title_tokens":["小结"]},{"location":"Python基础/2.2.语句.html#pass","text":"pass 语句什么也不做。它用于那些语法上必须要有什么语句，但程序什么也不做的场合，例如: # 死循环 while True : pass # Busy-wait for keyboard interrupt (Ctrl+C) # 创建最小结构的类: class MyEmptyClass : pass","text_tokens":["pass","什么","ctrl","for","也"," ","它","做","用于","必须","循环","结构","myemptyclass","class","+","那些","c","interrupt","语法",":","-","有","wait","不","keyboard","类","死循环","程序","场合","true",")","busy","#","语句","。","上","要","但","创建","(","最小","的","，","例如","while"],"title":"pass 语句","title_tokens":["pass","语句"," "]},{"location":"Python基础/2.2.语句.html#return","text":"return 语句结束函数的执行并返回一个值。如果没有指定值，将返回 None 。示例： 注意 return 语句只能用于函数中。 def func1 (): return 4 , 2 def func2 (): return print ( func1 ()) print ( func2 ()) (4, 2) None","text_tokens":["中"," ","如果","一个","用于","func1","print","示例","没有","返回","函数","2","结束","none","4",":","将","：","指定",",",")","注意","执行","def","语句","。","值","只能","(","并","return","的","，","func2"],"title":"return 语句","title_tokens":["语句","return"," "]},{"location":"Python基础/2.3.List.html","text":"列表的方 法 描 述 aList.append(obj) 等同于aList[len(aList):len(aList)] = [obj] aList.clear() 删除aList的所有元素 aList.count(obj) 返回aList中与obj相等的元素个数 aList.copy() 返回aList的副本。请注意，这是浅复制，即不会复制元素 aList.extend(sequence) 等同于aList[len(aList):len(aList)] = sequence aList.index(obj) 返回aList中第一个与obj相等的元素的索引；如果没有这样的元素，就引发 ValueError异常 aList.insert(index, obj) 如果index >= 0，就等同于aList[index:index] = [obj]；如果index < 0，就 将指定的对象加入到列表开头 aList.pop([index]) 删除并返回指定索引（默认为-1 )处的元素 aList.remove(obj) 等同于del aList[aList.index(obj)] aList.reverse。 就地按相反的顺序排列列表的元素 aList.sort([cmp][,key][,reverse]) 就地对aList的元素进行排序（稳定排序）。可通过提供比较函数cmp、键函数 key (创建用户排序的键）和降序标志reverse (—个布尔值）进行定制 list的方法 创建一个list # 查看list的方法、属性 [ method for method in dir ( list ()) if not method . startswith ( \"_\" )] ['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] 修改list元素的值 修改现有list的值，通过索引、切片来完成。 list_1 = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] # 修改某个索引对应元素的值 list_1 [ 0 ] = 12 ; list_1 [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 修改某个连续区域的值 # 切片的长度 和 用于赋值的列表长度 可以不同，如下： list_1 [ 0 : 5 ] = [ 11 , 12 , 13 , 14 , 15 , 16 , 17 ]; list_1 [11, 12, 13, 14, 15, 16, 17, 5, 6, 7, 8, 9, 10] 添加一个新元素到末尾 append 方法每次只能添加一个新元素 list_1 = list ( range ( 4 )); print ( list_1 ) list_1 . append ( 12 ); print ( list_1 ) [0, 1, 2, 3] [0, 1, 2, 3, 12] 添加任意个新元素到末尾 extend 方法允许我们通过另一个list来扩充当前的list。实际上，这看起来像是用 + 拼接list，但 extend 方法会直接修改原列表，不返回副本。 list_1 = list ( range ( 4 )) list_2 = [ '0' , '00' , '000' ] list_1 + list_2 # 此时list_1没有被修改 print ( \"使用+运算符：\" , list_1 ) list_1 . extend ( list_2 ) # 此时list_1被修改 print ( \"使用extend方法：\" , list_1 ) 使用+运算符： [0, 1, 2, 3] 使用extend方法： [0, 1, 2, 3, '0', '00', '000'] 可以看出，使用 + 拼接list会创建一个新对象，显然拼接的效率回比 extend 方法的效率低。 还可以借助切片来扩充list，像这样： list_1 = list ( range ( 4 )) list_2 = [ '0' , '00' , '000' ] # 这样做可读性不高 list_1 [ len ( list_1 ):] = list_2 list_1 [0, 1, 2, 3, '0', '00', '000'] 在任意位置插入新元素 insert 方法将一个对象插入指定位置 list_1 = list ( range ( 4 )); print ( \"原列表：\" , list_1 ) list_1 . insert ( 0 , \"新元素\" ); print ( \"新列表：\" , list_1 ) 原列表： [0, 1, 2, 3] 新列表： ['新元素', 0, 1, 2, 3] 当然，也可以借助切片在任意位置插入元素。注意的是，对一个list使用切片，必定会得到一个list，这就需要用一个list对切片赋值。 # 这样虽然巧妙，但是可读性比不上insert。 list_1 = list ( range ( 4 )); print ( \"原列表：\" , list_1 ) list_1 [ 0 : 0 ] = [ \"新元素\" ]; print ( \"新列表：\" , list_1 ) 原列表： [0, 1, 2, 3] 新列表： ['新元素', 0, 1, 2, 3] 删除\\取出最后一个（任意位置的）元素 list_2 = [ '0' , '00' , '000' ] # 注意，pop是list中唯一一个修改原列表，并且有返回值的方法 list_2 . pop () '000' list_2 = [ '0' , '00' , '000' ] # pop默认删除最后一个元素，但是也可以输入索引值，指定删除元素的位置 list_2 . pop ( 0 ) list_2 ['00', '000'] 删除第一次出现的元素 list_1 = [ 1 , 2 , 3 , 1 ] list_1 . remove ( 1 ) list_1 [2, 3, 1] 反序排序 list_1 = [ 1 , 2 , 3 ] list_1 . reverse () list_1 [3, 2, 1] 排序 方法 sort 接受两个可选参数： key 和 reverse 。将 key 设置为一个用于排序的**函数。然而，不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。对于另一个关键字参数 reverse ，只需将其指定为 True 或 False ，以指出是否要按相反的顺序对列表进行排序。 list_3 = [ 'aardvark' , 'abalone' , 'acme' , 'add' , 'aerate' ] list_3 . sort ( key = len ) list_3 ['add', 'acme', 'aerate', 'abalone', 'aardvark'] # 按照长度降序排序 list_3 . sort ( key = len , reverse = True ) list_3 ['aardvark', 'abalone', 'aerate', 'acme', 'add'] 统计元素出现的次数 list_1 = [ 1 , 2 , 3 , 1 ] list_1 . count ( 1 ) 2 得到某个值第一次出现时对应的索引值 list_1 = [ 1 , 2 , 3 , 1 ] list_1 . index ( 1 ) 0 深拷贝列表 list_1 = [ 1 , 2 , 3 ] list_4 = list_1 list_1 [ 0 ] = \"修改了\" print ( \"list_1：\" , list_1 ) print ( \"list_4：\" , list_4 ) list_1： ['修改了', 2, 3] list_4： ['修改了', 2, 3] # 深拷贝 list_1 = [ 1 , 2 , 3 ] list_5 = list_1 . copy () list_1 [ 0 ] = \"修改了\" print ( \"list_1：\" , list_1 ) print ( \"list_5：\" , list_5 ) list_1： ['修改了', 2, 3] list_5： [1, 2, 3] 清空列表 list_1 . clear () list_1 []","text_tokens":["list","for","赋值","参数","len","如果","到","虽然","它","允许","而是","效率","10","—","被","等同","实际","显然","引发","2","'","巧妙","时","相反","小","个","clear","长度","还","\\","唯一","需","根据","startswith","15","不","输入","默认","通过","插入","*","true","算符","添加","布尔值","#","运算符","等同于","copy","请","清空","新元素","删除","_","和","7","指出","修改","in","insert","位置","这","提供","看起","每个","对于","方","method","）","比较","定制","8","必定","中",">","稳定","深","可以","用于","做","切片","关键","对应","看出","同于","函数","当前","第一","用户","是","起来","；","加入","key","remove","、","不会","排列","会","add","range","出现","在","某个","false",";","方法","借助","not","拷贝","不同","只","这样","开头","属性","取出","del","aerate","[","000","count","此时","次数","要","值","顺序排列","但","只能","低","extend","为","并","查看","复制","法","，","连续","00","sequence","11","原","3","描","进行","13","16","不高","按照","对象","与","]","也","index","对","print","返回","没有","append","排序","再","标志","新元","来","运算","现有","然而","关键字","acme","pop","顺序","另","看起来","像是","4","=","个数","17","处","每次",":","-","9","是否","：","新","浅","回比","我们","直接",")","相等","扩充","。","像","reverse","当然","末尾","统计","并且","sort","创建","的","其","必定会","降序","得到","列表","12","拼接","就","接受","区域","完成","最后",".","了","第一个","异常","可","如下","用"," ","但是","aardvark","一个","按","副本","<","判断","+","1","实际上","14","一次","设置","比不上","这个","索引","\"","这些","将","abalone","if","所有","dir","有","0","返回值","cmp","指定","述",",","使用","可读性","选","比","注意","5","或","以","即","6","obj","任意","反序","可读","alist","布尔","需要","两个","(","valueerror","（","地","定会","元素","键","第一次"],"title":"2.3.List","title_tokens":[".","list","2.3"]},{"location":"Python基础/2.3.List.html#list","text":"创建一个list # 查看list的方法、属性 [ method for method in dir ( list ()) if not method . startswith ( \"_\" )] ['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']","text_tokens":["method",".","list","for","]"," ","index","一个","append","、","remove","'","pop","clear","\"","if","dir","方法","startswith","not",",",")","属性","#","[","count","copy","reverse","sort","创建","(","_","extend","的","查看","in","insert"],"title":"list的方法","title_tokens":["list","的","方法"]},{"location":"Python基础/2.3.List.html#list_1","text":"修改现有list的值，通过索引、切片来完成。 list_1 = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] # 修改某个索引对应元素的值 list_1 [ 0 ] = 12 ; list_1 [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 修改某个连续区域的值 # 切片的长度 和 用于赋值的列表长度 可以不同，如下： list_1 [ 0 : 5 ] = [ 11 , 12 , 13 , 14 , 15 , 16 , 17 ]; list_1 [11, 12, 13, 14, 15, 16, 17, 5, 6, 7, 8, 9, 10]","text_tokens":["完成","list","8","赋值","如下","]"," ","可以","用于","切片","对应","10","1","14","、","来","现有","2","16","13","4","=","17","索引","长度",":","某个","9",";","：","0","15","不同",",","通过","5","#","。","[","6","值","_","7","和","的","修改","连续","，","列表","12","元素","11","3","区域"],"title":"修改list元素的值","title_tokens":["list","值","的","修改","元素"]},{"location":"Python基础/2.3.List.html#_1","text":"append 方法每次只能添加一个新元素 list_1 = list ( range ( 4 )); print ( list_1 ) list_1 . append ( 12 ); print ( list_1 ) [0, 1, 2, 3] [0, 1, 2, 3, 12]","text_tokens":[".","list","]"," ","一个","print","append","1","新元","2","4","=","每次","range",";","方法","0",",",")","添加","[","新元素","只能","_","(","12","元素","3"],"title":"添加一个新元素到末尾","title_tokens":["新元素","添加","到","一个","末尾","元素","新元"]},{"location":"Python基础/2.3.List.html#_2","text":"extend 方法允许我们通过另一个list来扩充当前的list。实际上，这看起来像是用 + 拼接list，但 extend 方法会直接修改原列表，不返回副本。 list_1 = list ( range ( 4 )) list_2 = [ '0' , '00' , '000' ] list_1 + list_2 # 此时list_1没有被修改 print ( \"使用+运算符：\" , list_1 ) list_1 . extend ( list_2 ) # 此时list_1被修改 print ( \"使用extend方法：\" , list_1 ) 使用+运算符： [0, 1, 2, 3] 使用extend方法： [0, 1, 2, 3, '0', '00', '000'] 可以看出，使用 + 拼接list会创建一个新对象，显然拼接的效率回比 extend 方法的效率低。 还可以借助切片来扩充list，像这样： list_1 = list ( range ( 4 )) list_2 = [ '0' , '00' , '000' ] # 这样做可读性不高 list_1 [ len ( list_1 ):] = list_2 list_1 [0, 1, 2, 3, '0', '00', '000']","text_tokens":["list","len","允许","效率","实际","显然","2","'","还","不","通过","算符","#","运算符","_","修改","这","看起","可以","做","切片","看出","当前","起来","会","range","借助","方法","这样","[","000","此时","但","低","extend","00","，","原","3","不高","对象","]","print","返回","没有","来","运算","另","像是","看起来","4","=",":","：","新","回比","我们","直接",")","扩充","。","像","创建","的","拼接","列表",".","用"," ","一个","副本","+","实际上","1","\"","0","可读性",",","使用","可读","(","被"],"title":"添加任意个新元素到末尾","title_tokens":["任意","新元素","添加","到","个","末尾","元素","新元"]},{"location":"Python基础/2.3.List.html#_3","text":"insert 方法将一个对象插入指定位置 list_1 = list ( range ( 4 )); print ( \"原列表：\" , list_1 ) list_1 . insert ( 0 , \"新元素\" ); print ( \"新列表：\" , list_1 ) 原列表： [0, 1, 2, 3] 新列表： ['新元素', 0, 1, 2, 3] 当然，也可以借助切片在任意位置插入元素。注意的是，对一个list使用切片，必定会得到一个list，这就需要用一个list对切片赋值。 # 这样虽然巧妙，但是可读性比不上insert。 list_1 = list ( range ( 4 )); print ( \"原列表：\" , list_1 ) list_1 [ 0 : 0 ] = [ \"新元素\" ]; print ( \"新列表：\" , list_1 ) 原列表： [0, 1, 2, 3] 新列表： ['新元素', 0, 1, 2, 3]","text_tokens":[".","list","必定","对象","赋值","]","也"," ","用","可以","一个","对","切片","虽然","但是","print","1","新元","是","2","'","巧妙","比不上","4","=","range","\"","在",":","将",";","方法","：","0","新","借助","指定",",","使用","插入","可读性",")","注意","这样","#","[","。","当然","任意","可读","新元素","需要","_","(","的","位置","insert","，","定会","必定会","得到","列表","这","元素","就","原","3"],"title":"在任意位置插入新元素","title_tokens":["任意","新元素","插入","位置","元素","在","新元"]},{"location":"Python基础/2.3.List.html#_4","text":"list_2 = [ '0' , '00' , '000' ] # 注意，pop是list中唯一一个修改原列表，并且有返回值的方法 list_2 . pop () '000' list_2 = [ '0' , '00' , '000' ] # pop默认删除最后一个元素，但是也可以输入索引值，指定删除元素的位置 list_2 . pop ( 0 ) list_2 ['00', '000']","text_tokens":["最后",".","list","中","]","也"," ","但是","可以","一个","返回","是","2","'","pop","=","索引","唯一","方法","有","0","返回值","输入",",","默认","指定",")","注意","#","[","000","值","并且","删除","_","(","的","修改","00","，","位置","列表","元素","原"],"title":"删除\\取出最后一个（任意位置的）元素","title_tokens":["最后","任意","）","删除","（","的","取出","位置","一个","\\","元素"]},{"location":"Python基础/2.3.List.html#_5","text":"list_1 = [ 1 , 2 , 3 , 1 ] list_1 . remove ( 1 ) list_1 [2, 3, 1]","text_tokens":[".","list",",","remove","_","2","]","("," ",")","=","[","3","1"],"title":"删除第一次出现的元素","title_tokens":["元素","一次","删除","的","出现","第一","第一次"]},{"location":"Python基础/2.3.List.html#_6","text":"list_1 = [ 1 , 2 , 3 ] list_1 . reverse () list_1 [3, 2, 1]","text_tokens":[".","list",",","_","2","]","("," ",")","=","reverse","[","3","1"],"title":"反序排序","title_tokens":["反序","排序"]},{"location":"Python基础/2.3.List.html#_7","text":"方法 sort 接受两个可选参数： key 和 reverse 。将 key 设置为一个用于排序的**函数。然而，不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。对于另一个关键字参数 reverse ，只需将其指定为 True 或 False ，以指出是否要按相反的顺序对列表进行排序。 list_3 = [ 'aardvark' , 'abalone' , 'acme' , 'add' , 'aerate' ] list_3 . sort ( key = len ) list_3 ['add', 'acme', 'aerate', 'abalone', 'aardvark'] # 按照长度降序排序 list_3 . sort ( key = len , reverse = True ) list_3 ['aardvark', 'abalone', 'aerate', 'acme', 'add']","text_tokens":["list","参数","它","len","而是","'","相反","小","需","长度","根据","true","*","#","指出","和","_","每个","对于","关键","用于","函数","key","不会","add","false","方法","只","aerate","[","要","为","，","3","进行","按照","]","对","排序","再","来","关键字","然而","acme","另","顺序","=","是否","：","直接",")","。","reverse","sort","创建","的","其","降序","接受","列表",".","可"," ","aardvark","一个","按","判断","设置","这个","这些","将","abalone","选","指定","使用",",","比","或","以","两个","(","元素","键"],"title":"排序","title_tokens":["排序"]},{"location":"Python基础/2.3.List.html#_8","text":"list_1 = [ 1 , 2 , 3 , 1 ] list_1 . count ( 1 ) 2","text_tokens":[".","list",",","_","2","]","("," ",")","=","[","count","3","1"],"title":"统计元素出现的次数","title_tokens":["元素","的","出现","次数","统计"]},{"location":"Python基础/2.3.List.html#_9","text":"list_1 = [ 1 , 2 , 3 , 1 ] list_1 . index ( 1 ) 0","text_tokens":["0",".","list",",","_","2","]","("," ",")","index","=","[","3","1"],"title":"得到某个值第一次出现时对应的索引值","title_tokens":["值","一次","时","的","得到","对应","索引","出现","某个","第一","第一次"]},{"location":"Python基础/2.3.List.html#_10","text":"list_1 = [ 1 , 2 , 3 ] list_4 = list_1 list_1 [ 0 ] = \"修改了\" print ( \"list_1：\" , list_1 ) print ( \"list_4：\" , list_4 ) list_1： ['修改了', 2, 3] list_4： ['修改了', 2, 3] # 深拷贝 list_1 = [ 1 , 2 , 3 ] list_5 = list_1 . copy () list_1 [ 0 ] = \"修改了\" print ( \"list_1：\" , list_1 ) print ( \"list_5：\" , list_5 ) list_1： ['修改了', 2, 3] list_5： [1, 2, 3]","text_tokens":["了","list",".","深","]"," ","print","1","2","'","4","=","\"","：","0","拷贝",",",")","5","#","[","copy","_","(","修改","3"],"title":"深拷贝列表","title_tokens":["列表","拷贝","深"]},{"location":"Python基础/2.3.List.html#_11","text":"list_1 . clear () list_1 []","text_tokens":[".","list","_","(",")","]"," ","clear","[","1"],"title":"清空列表","title_tokens":["清空","列表"]},{"location":"Python基础/2.4.String.html","text":"多行字符串 str_1 = \"\"\" 这是一个多行字符串 这是第二行 \"\"\" print ( str_1 ) str_2 = \" \\n 这是一个多行字符串 \\n 这是第二行 \\n \" print ( str_2 ) str_1 == str_2 这是一个多行字符串 这是第二行 这是一个多行字符串 这是第二行 True 转义 如果要在字符串里面输入特殊字符，需要使用转义符\\，例如输入转义符本身： str_3 = \"12 \\\\ 14\" print ( str_3 ) 12\\14 前缀 在Python中，字符串可以添加前缀 r\\R 、 b 、 u\\U 、 f 。 r\\R ：表示非转义的原始字符串，常用于正则表达式。 b ：Python3里默认的str是(Python2里的)unicode，bytes是(Python2)的str， b前缀代表的就是bytes。Python2里, b前缀没什么具体意义，只是为了兼容Python3的这种写法 。 u\\U ：表示unicode字符串，代表是对字符串进行unicode编码。 一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。建议所有编码方式采用UTF-8。 f ：表示 f 格式字符串。 字符编码 Python有两种不同的字符串，一种存储文本，一种存储字节。对于文本，Python内部采用Unicode存储，而字节字符串显示原始字节序列或者ASCII。在Python3当中，文本字符串类型（使用Unicode数据存储）被命名为 str , 字节字符串类型被命名为 bytes 。但在python2中，文本字符串类型叫做 unicode ，字节字符串类型叫做 str 。也就是说： $$ \\begin{array}{} Python\\ 3\\ \\mathbf{str} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{unicode} \\\\ Python\\ 3\\ \\mathbf{bytes} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{str} \\end{array} $$ 所以，如果想将以unicode形式储存的字符串转换为二进制类型的字符串，需要将unicode字符串编码，反之，则需要解码。 编码：在python中，编码指的是将Unicode字符按照编码规则（如UTF-8）编成二进制序列。 在python3中实例化一个字符串 str_1 = \"中国\" # 编码 str_1 . encode () b'\\xe4\\xb8\\xad\\xe5\\x9b\\xbd' # 创建一个二进制字符串 str_2 = b ' \\xe4\\xb8\\xad\\xe5\\x9b\\xbd ' # 解码 str_2 . decode () '中国' bytes字符 文本字符类型在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把 str 变为以字节为单位的 bytes 。 Python3对 bytes 类型的数据用带 b 前缀的单引号或双引号表示。 bytes_8 = b \"ABC\" bytes_8 b'ABC' 要注意的是：bytes字面值中只允许ASCII字符（无论源代码声明的编码为何）。任何超出127的二进制值必须使用相应的转义序列形式加入bytes字面值。 例如，可以对str（unicode类型）对象使用 encode() 方法，编码为bytes的形式（16进制表示）。 '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 要注意的是， encode 的对象不能超出指定编码的范围，例如不能对中文字符使用 .encode(\"ascii\") ，因为中文不在ascii码的范围内。 '中文' . encode ( 'ascii' ) ---------------------------------------------------------------------------UnicodeEncodeError Traceback (most recent call last)<ipython-input-1-76f41cd8dafa> in <module> ----> 1 '中文'.encode('ascii') UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) 纯英文的str可以用ASCII编码为bytes，内容是一样的，但无法显示为ASCII字符的字节，用 \\x 显示（16进制转义表示）。 'ABC' . encode ( 'ascii' ) b'ABC' '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用 decode() 方法： b 'ABC' . decode ( 'ascii' ) 'ABC' b ' \\xe4\\xb8\\xad\\xe6\\x96\\x87 ' . decode ( 'utf-8' ) '中文' 如果bytes中包含无法解码的字节， decode() 方法会报错： b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' ) ---------------------------------------------------------------------------UnicodeDecodeError Traceback (most recent call last)<ipython-input-1-cd8de1b11dcd> in <module> ----> 1 b'\\xe4\\xb8\\xad\\xff'.decode('utf-8') UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte 但是，如果bytes中只有一小部分无效的字节，可以传入 errors = 'ignore' 忽略错误的字节： \"中\" . encode ( \"utf-8\" ) # 中 原来的编码 b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' , errors = 'ignore' ) '中' 在对str和bytes互相转换时，为了避免乱码问题，应该使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： # !/usr/bin/env python3 # -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释。第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，在源代码中写的中文输出可能会有乱码。 但是申明了UTF-8编码只是让Python解释器按UTF-8的编码规则读取源代码，并不意味着源代码一定是使用UT8-8编码保存的，必须并且要确保文本编辑器正在使用UTF-8编码。 格式化 C printf 样式的格式化 字符串具有一种特殊的内置操作：使用 % (取模)运算符，可以格式化字符串，此时 % 也被称为字符串的格式化运算符或插值运算符。对于format % values(其中format为一个字符串)，在format中的 % 转换标记符将被替换为零个或多个values条目。 其效果类似于在C语言中使用sprintf()。 'Hello, %s ' % 'world' # 省略括号 'Hello, world' 'Hi, %s , you have $ %d ' % ( 'Michael' , 10000.58 ) 'Hi, Michael, you have $10000' 转换标记符 包含两个或更多字符，由以下元素组成，且必须遵循此处规定的顺序： % 字符，用于标记转换符的起始。 映射键（可选），由加圆括号的字符序列组成(例如(somename))。 转换标志（可选） - 表示左对齐 + 表示转换后的内容前方加上正负号 空格 表示正数前方保留一个空格 0 表示如果转换位置位数不够时，用0填充 最小字段宽度（可选），转换后字段的最小宽度，如果不足自动用空格补齐；如果最小字段宽度值为 * ，则从元组中读取。 精度（可选），在 . 之后加精度值的形式给出。如果指定为为 * ，则从元组中读取。 长度修饰符（可选）。 转换类型。 Conversion Meaning d 格式化整数 i 格式化整数 o 8 进制 u 格式化无符号整型(已过时) x 16 进制， 小写字母 X 16 进制， 大写字母 e 浮点指数格式， 小写字母 E 浮点指数格式， 大写字母 f 浮点数 F 浮点数 g 浮点数， 如果指数小于 -4 或小于精度， 则使用小写指数格式， 否则使用小数格式 G 浮点数， 类似 g , 使用大写指数 c 单个字符， 格式化字符及其 ASCII 码 r 字符串， 使用 repr() 转换任何 Python 对象 s 字符串， 使用 str() 转换任何 Python 对象 % % 字符 # 映射键 ## 如果值是一个字典，那么必须使用映射键. 如： print ( ' %(num)d ' % { \"num\" : 10 }) 10 # 最小字段宽度 print ( ' %2s ' % 123456 ) print ( ' %8s ' % 123456 ) print ( ' %*s ' % ( 10 , 123456 )) 123456 123456 123456 # 精度 print ( ' %.2f ' % 100.256 ) print ( ' %.*f ' % ( 2 , 100.256 )) 100.26 100.26 # 转换标志 print ( ' %-8d ' % 123456 ) print ( ' %+8d ' % 123456 ) print ( ' %08d ' % 123456 ) 123456 +123456 00123456 format方法 < 模板字符串 >. format ( < 逗号分隔的参数 > ) <模板字符串> 由一系列的槽 {} 组成，用来控制修改字符串中嵌入值出现的位置，其基本思想是将format()方法的 <逗号分隔的参数> 中的参数按照序号关系替换到 <模板字符串> 的槽中。如果大括号中没有序号，则按照出现顺序替换。该方法会创建新字符串对象，不会修改原值。 {}中指定顺序，按指定的顺序替换 print ( \" {2} : {1} : {0} \" . format ( \"1\" , \"2\" , \"3\" )) 3 : 2 : 1 没有指定顺序，按出现的顺序依次替换 print ( \" {} : {} : {} \" . format ( \"1\" , \"2\" , \"3\" )) 1 : 2 : 3 format()方法中 <模板字符串> 的槽除了包括参数序号，还可以包括格式控制信息。此时，槽的内部样式如下： 替换字段 - replacement_field ::= \"{\" [ field_name ] [ \"!\" conversion ] [ \":\" format_spec ] \"}\" 字段名 - field_name ::= arg_name ( \".\" attribute_name | \"[\" element_index \"]\" ) * 参数名 - arg_name ::= [ identifier | integer ] 属性名 - attribute_name ::= identifier 元素索引 - element_index ::= integer | index_string 索引字符串 - index_string ::= < any source character except \"]\" > + 转换字段 - conversion ::= \"r\" | \"s\" 格式规范说明符 - format_spec ::= < described in the next section > 注意事项： 参数名 可以为 整数 或 关键字 。整数为位置参数， 关键字为命名关键字参数。 如果整数类似于 {0}{1}{2}, 则可以省略， 即： {}{}{} 等价于 {0}{1}{2}。 如果参数存在属性， 可以通过 arg_name.attribute_name 的形式获取属性值。 如果参数为可迭代对象， 可以通过 arg_name[integer|index_string] 的形式获取索引位置的元素。 转换字段 由 ! 开始， r 代表调用 repr(), s 代表调用 str(). 格式规范说明符 由 : 开始。 其中， <格式控制标记> 用来控制参数显示时的格式，可以使用的参数如下： format_spec ::= [ [fill ] align ] [ sign ][ # ][ 0 ][ width ][ grouping_option ][ .precision ][ type ] fill ::= < any character > align ::= \"<\" | \">\" | \"=\" | \"^\" sign ::= \"+\" | \"-\" | \" \" width ::= digit + grouping_option ::= \"_\" | \",\" precision ::= digit + type ::= \"b\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" | \"g\" | \"G\" | \"n\" | \"o\" | \"s\" | \"x\" | \"X\" | \"%\" 填充字符 ：如果指定了对齐选项，则可以使用填充字符。默认为空格. 对齐选项 ：默认右对齐，各种对齐选项的含义如下： 选项 意义 '<' 强制字段在可用空间内左对齐（这是大多数对象的默认值）。 '>' 强制字段在可用空间内右对齐（这是数字的默认值）。 '=' 强制将填充放置在符号（如果有）之后但在数字之前。这用于以“+000000120”形式打印字段。此对齐选项仅对数字类型有效。当'0'紧接在字段宽度之前时，它成为默认值。 '^' 强制字段在可用空间内居中。 sign ：仅对数字类型有效，可以是以下之一： 选项 意义 '+' 表示标志应该用于正数和负数。 '-' 表示标志应仅用于负数（这是默认行为）。 space 表示应在正数上使用前导空格，在负数上使用减号。 # ：仅适用于数字参数，同时仅适用于2、8、16进制的数字。会在输出的数字前添加 0b、0o、0x前缀。 宽度 ：指定最小字段宽度。 千位分隔符 ：只能使用 _ 或 , 作为千位分隔符。 精度 ： 类型 ：该选项决定了数据应该如何呈现。 可用的字符串表示类型： Type Meaning s 字符串格式， 字符串的默认类型， 可省略 None 同 s 可用的整数表示类型： Type Meaning b 输出为 2 进制整数 c 输出为为相应的 unicode 字符 d 输出为 10 进制整数 o 输出为 8 进制整数 x 输出为 16 进制整数， 使用小写字母 X 输出为 16 进制整数， 使用大写字母 n 类似 d , 会使用当前区域设置插入适当的数字分隔符 None 同 d 可用的浮点数和小数值表示类型： Type Meaning e 指数表示法， 使用字母 e 以科学记数法打印数字， 默认进度为 6 E 类似 e , 使用字母 E f 浮点数， 默认进度为 6 F 浮点数， 同 f g 一般形式， 受 precision 选项影响 G 类似 g , 当使用指数表示法时， 使用 E 而不是 e n 和 g 相同， 会使用当前区域设置插入适当的数字分隔符 % 百分数表示 None 同 g # 填充、对齐、符号、宽度、分组选项、精度 # 填充*号、居中、正号标记、2精度 \" {0:*^+20.2f} \" . format ( 120 ) '******+120.00*******' # 填充*号、居中、正号标记、_分隔符、2精度 \"{0:*^+20_.2f}\" . format ( 12000 ) '*****+12_000.00*****' # 填充*号、居中、正号标记、,分隔符、2精度 \" {0:*^+20,.2f} \" . format ( 12000 ) '*****+12,000.00*****' # 填充*号、左对齐、正号标记、2精度 \" {0:*<+20.2f} \" . format ( - 120 ) '-120.00*************' # 填充*号、左对齐、负号标记、2精度 \" {0:*>-20.2f} \" . format ( - 120 ) '*************-120.00' 方法 逻辑方法 方法 描述 .isalnum if all characters in the string are alpha-numeric and there is at least one character .isalpha if all characters in the string are alphabetic and there is at least one character .isnumeric if all characters in the string are numeric and there is at least one character .isascii ASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too . .isdecimal if all characters in the string are decimal and there is at least one character .isdigit if all characters in the string are digits and there is at least one character .isidentifier Use keyword.iskeyword() to test for reserved identifiers such as \"def\" and \"class\". .islower if all cased characters in the string are lowercase and there is at least one cased character .isupper if all cased characters in the string are uppercase and there is at least one cased character .isprintable if all of its characters are considered printable in repr() or if it is empty. .isspace if all characters in the string are whitespace and there is at least one character .istitle In a title-cased string, upper- and title-case characters may only follow uncased characters and lowercase characters only cased ones. 方法 描述 .startswith(prefix[, start[, end]]) 如果字符串以 prefix 开头 .endswith(suffix[, start[, end]]) 如果字符串以 suffix 结尾 大小字母转换 方法 描述 .lower 返回转换为小写的字符串的副本。 .upper 返回转换为大写的字符串的副本。 .capitalize 使第一个字符字母大写，其余字符字母小写，返回副本。 .swapcase 将大写字符转换为小写，将小写字符转换为大写，返回副本。 .title 每个单词都用大写字母开头，返回副本。 拆分字符串 方法 描述 .split(sep=None, maxsplit=-1) 从左到右以 sep 分割字符串 .rsplit(sep=None, maxsplit=-1) 从右到左以 sep 分割字符串 .splitlines(keepends=False) 以回车符或换行符分割字符串 .partition(sep, /) 从左到右以第一个出现的 sep 分割字符串，返回包括3个元素的元组 \"123#456#789\" . split ( sep = \"#\" , maxsplit = 1 ) ['123', '456#789'] \"123#456#789\" . rsplit ( sep = \"#\" , maxsplit = 1 ) ['123#456', '789'] \"123 \\r\\n 456 \\r\\n 789\" . splitlines ( keepends = False ) ['123', '456', '789'] \"123 \\r\\n 456 \\r\\n 789\" . splitlines ( keepends = True ) ['123\\r\\n', '456\\r\\n', '789'] \"123#456#789\" . partition ( \"#\" ) ('123', '#', '456#789') 合并字符串 \"_\" . join ([ \"a\" , \"b\" , \"c\" ]) 'a_b_c' 替换字符串 方法 描述 .replace(old, new, count=-1) 返回一个副本，其中所有出现的子字符串 old 都替换为 new 。 .strip(chars=None) 返回字符串的副本，其中前导和尾随空格删除。 .lstrip(chars=None) 返回删除前导空格的字符串副本。 .rstrip(chars=None) 返回删除尾随空格的字符串副本。 .expandtabs(tabsize=8) 返回一个副本，其中所有制表符都使用 tabsize 个空格代替。 \" \\n abc \\t\\n\\r \" . strip () 'abc' \" \\n abc \\t\\n\\r \" . lstrip () 'abc\\t\\n\\r ' \" \\n abc \\t\\n\\r \" . rstrip () ' \\nabc' \" \\n abc \\t\\n\\r \" . expandtabs ( tabsize = 8 ) ' \\nabc \\n\\r ' 格式化字符串 方法 描述 .format 格式化字符串。 .format_map 格式化字符串。 .ljust(width, fillchar=' ') 返回长度为 width 的左对齐字符串。使用 fillchar 填充。 .rjust(width, fillchar=' ') 返回长度为 width 的右对齐字符串。使用 fillchar 填充。 .center(width, fillchar=' ') 返回长度为 width 的居中字符串。使用 fillchar 填充。 .zfill(width) 返回长度为 width 的字符串，若长度不够，用零从左边填充。 .format_map 与 .format 在用法上大体一致，但有一个区别： # format_map 和 format 的区别 # 如果要使用关键字 format必须这样使用 \" {name} , {sex} \" . format ( name = \"Jack\" , sex = \"male\" ) # format_map 可以用dict \" {name} , {sex} \" . format_map ({ \"name\" : \"Jack\" , \"sex\" : \"male\" }) 'Jack, male' print ( \"abc\" . ljust ( 10 , \"#\" )) print ( \"abc\" . rjust ( 10 , \"#\" )) print ( \"abc\" . center ( 10 , \"#\" )) print ( \"123\" . zfill ( 10 )) # 非数字字符串也可以 print ( \"abc\" . zfill ( 10 )) abc####### #######abc ###abc#### 0000000123 0000000abc 统计子字符串出现次数 \"abcAbc\" . count ( \"c\" , 0 , 6 ) 2 查找子字符串第一次出现的位置 .index 与 .find 的功能是一样的，只不过 .index 方法若找不到子字符串会抛出ValueError，而 .find 会返回 -1 。 \"abcAbc\" . index ( \"bc\" , 0 , 6 ) \"abcAbc\" . find ( \"bc\" , 0 , 6 ) 1 \"abcAbc\" . index ( \"bc\" , 0 , 2 ) ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-f8cead4644a3> in <module> ----> 1 \"abcAbc\".index(\"bc\", 0, 2) ValueError: substring not found \"abcAbc\" . find ( \"bc\" , 0 , 2 ) -1","text_tokens":["若干","浮点","字","多数","转义","123456","10","decimal","字段","最","遵循","position","号","keepends","found","'","该","前导","记数法","代替","127","长度","仅","dict","male","大小","digit","不","mathbf","默认","*","算符","bin","调用","integer","xe6","读取","字典","零","分隔","事项","二行","符","读到","行为","指数","信息","英文","存储","in","化","修改","对于","这","符号","居中","每个","条目","段","中国","一行","正负号","不是","new","否则","转换","{","序号","对应","小写字母","若干个","部分","给出","endswith","第一","arg","是","next","不会","当","code","成为","alpha","range","格式","uncased","python3","not","对齐","decode","方式","程序","这样","从右到左","类似","ljust","文本","width","0b","正负","表达式","原值","align","不到","叫做","错误","2f","只能","lstrip","并","python","样式","也就是说","digits","3","规范","keyword","两种","按照","ignore","如何","务必","替换","fill","abc","and","strip","grouping","包括","相同","补齐","文本文件","character","title","c#","----","数字","prefix","左边","you","is","有效","n",")","007f","流","适用","大多数","。","反过","写法","to","打印","follow","基本","xbd","points","的","begin","&","其","修饰符","嵌入","maxsplit","isalnum","放置","以下","了","isascii","field","标记"," ","尾随","zfill","<","+","start","映射","字符串","减号","这个","sep","789","单个","unicode","实例","小部","一小","将","换行符","all","使用","则","end","或","!","%","iskeyword","代表","即","建议","xb8","序列","split","test","conversion","槽","二进制","由于","isdecimal","本文","a","大多","被","元素","at","紧接在","longleftrightarrow","百分数","不够","编成","这是","traceback","它","000.00","大写字母","注释","last","说明","replace","除了","由","2","里","}","互相","系列","还","\\","同","单引号","its","表明","大写","获取","startswith","输入","lowercase","原来","插入","rsplit","isidentifier","适当","添加","位数","element","运算符","过来","写字","printable","join","正在","因为","网络","isspace","删除","_","传输","和","位置","磁盘","系统","c语言","8","%-","中","特殊字符","必须","space","文本编辑","0xff","值为","解析","当前","前方","#######","释器","；","制表符","一种","unicodedecodeerror","加上","b","反之","uppercase","而","出现","str","false","10000","其中","中写","不同","解释器","只","attribute","isalpha","可执行程序","0o","填充","whitespace","count","ab","第一行","大体一致","##","其余","###","，","o","可用","纯","errors","ordinal","与","]","e","index","lower","print","编辑","没有","内部","都","标志","过时","整型","c","关键字","only","双引号","string","顺序","=","功能","左","就是说","isprintable","or","千位","含义","我们","告诉","characters","多","08d","正则表达式","_.","时候","format","之前","并且","ascii","如","xe4","整数","one","第二","就","从左到右","区域","由加","使","unicodeencodeerror","any","第一个","of","用","按","说明符","the","cased","1","点数","那么","前缀","120","设置","none","范围","面值","多个","小于","meaning","upper","有","找","选","rstrip","注意","区别","包含","00123456","except","常用","插值","默认值","自动","bc","两个","(","正常","里面","swapcase","源代码","及其","查找","hi","%+","第一次","isnumeric","用来","规则","忽略","s","如果","到","参数","结尾","f8cead4644a3","coding","原始","identifier","迭代","正数","0000","时","后字","array","小","需","类型","兼容","储存","于","somename","通过","字符","反过来","jack","科学","xff","采用","描述","use","正则","---------------------------------------------------------------------------","之一","单词","回车符","影响","表示法","分数","此","istitle","控制","10000.58","ipython","may","所","call","substring","符将","负数","拆分","前","120.00","数值","可以","input","repr","用法","“","加入","8s","$","0000000abc","会","20.2","can","分组","你","内","ut8","center","方法","一样","michael","开头","更","属性","12000","000000120","x9b","开始","[","alphabetic","|","相应","t","要","超出","值","128","表达","为","splitlines","不过","称为","例如","当中","进行","一般","name","are","任何","it","对","windows","操作","^","紧接","命名","逗号","此处","只有","受","xe5","0x","4",":","字段名","values","f","为了","100.256","env","精度","本身","most","linux","第二行","显示","创建","各种","x","一旦","12","问题","什么",".","通常","os","一定","可","宽度","小写","无效","但是","一个","制表","意味着","逻辑","class","浮点数","代码","x96","确保","索引","\"","依次","if","所有","指","0","指定","无","空间","fillchar","乱码","编码方式","printf","%.","def","分割","只是","取模","中文","器","想","6","进度","应","一致","内存","需要","xad","为何","（","文件","u","最小","圆括号","负号","已","numeric","num","具有","empty","转义序列","for","identifiers","应该","字母","option","换行","允许","格式化","不能","名","报错","百分","后","described","关系","存在","section","没什么","个","d","中以","注意事项","括号","保存","invalid","特殊","considered","######","等价","声明","true","不足","合并","cd8de1b11dcd","there","#","若","子","把","右","规定","partition","省略","选项","用带","解释","replacement","isdigit","isupper","bytes","）","起始","76f41cd8dafa","too","sex",">","字节","无法","关键","用于","应仅","case","0000000123","2s","r","module","、","零个","形式","正","让","无论","precision","内右","/","chars","在","行程","123","20","abcabc","find","两行","上","utf","此时","元组","大体","编码","意味","g","次数","byte","recent","但","一系","sign","tabsize","码","islower","codec","have","表示","之后","suffix","16","呈现","x87","source","加","对象","nabc","spec","也","i","多行","语言","rjust","返回","这种","内置","expandtabs","encode","运算","且","-","具体","决定","such","：","效果","新","所以","大括号","就是","小数","统计","一系列","old","不带","reserved","ones","capitalize","8d","一小部分","传入","解码","进制","type","如下","空格","world","副本","回车","456","14","输出","保留","一次","非","map","小字","单位","修饰","强制","写","100.26","数据","接在","避免","引号","内容","usr","同时",",","模板","执行","sprintf","从","hello","”","或者","以","可能","作为","python2","下","抛出","分隔符","least","思想","变为","申明","valueerror","意义","只不过","控制参数","as","达式","记数","组成","键"],"title":"2.4.String","title_tokens":[".","string","2.4"]},{"location":"Python基础/2.4.String.html#_1","text":"str_1 = \"\"\" 这是一个多行字符串 这是第二行 \"\"\" print ( str_1 ) str_2 = \" \\n 这是一个多行字符串 \\n 这是第二行 \\n \" print ( str_2 ) str_1 == str_2 这是一个多行字符串 这是第二行 这是一个多行字符串 这是第二行 True","text_tokens":["这是"," ","一个","多行","print","1","字符串","2","=","\\","\"","str","true","字符","n",")","第二行","二行","_","(","第二"],"title":"多行字符串","title_tokens":["字符","多行","字符串"]},{"location":"Python基础/2.4.String.html#_2","text":"如果要在字符串里面输入特殊字符，需要使用转义符\\，例如输入转义符本身： str_3 = \"12 \\\\ 14\" print ( str_3 ) 12\\14","text_tokens":["特殊字符","如果"," ","转义","print","14","字符串","=","\\","\"","在","str","：","特殊","输入","使用","字符",")","本身","要","需要","符","_","(","3","里面","，","12","例如"],"title":"转义","title_tokens":["转义"]},{"location":"Python基础/2.4.String.html#_3","text":"在Python中，字符串可以添加前缀 r\\R 、 b 、 u\\U 、 f 。 r\\R ：表示非转义的原始字符串，常用于正则表达式。 b ：Python3里默认的str是(Python2里的)unicode，bytes是(Python2)的str， b前缀代表的就是bytes。Python2里, b前缀没什么具体意义，只是为了兼容Python3的这种写法 。 u\\U ：表示unicode字符串，代表是对字符串进行unicode编码。 一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。建议所有编码方式采用UTF-8。 f ：表示 f 格式字符串。","text_tokens":["转义","原始","里","\\","没什么","需","兼容","表明","于","默认","字符","添加","采用","正则","英文","所","bytes","8","中","必须","可以","否则","转换","解析","r","是","；","、","b","会","格式","出现","在","str","python3","方式","utf","表达式","编码","表达","python","，","表示","一般","进行","对","都","这种","-","具体","：","f","为了",")","所以","就是","。","正则表达式","写法","基本","的","各种","不带","一旦","就","什么"," ","但是","前缀","字符串","非","unicode","所有",",","使用","乱码","编码方式","只是","中文","代表","python2","常用","下","建议","(","正常","u","意义","达式"],"title":"前缀","title_tokens":["前缀"]},{"location":"Python基础/2.4.String.html#_4","text":"Python有两种不同的字符串，一种存储文本，一种存储字节。对于文本，Python内部采用Unicode存储，而字节字符串显示原始字节序列或者ASCII。在Python3当中，文本字符串类型（使用Unicode数据存储）被命名为 str , 字节字符串类型被命名为 bytes 。但在python2中，文本字符串类型叫做 unicode ，字节字符串类型叫做 str 。也就是说： $$ \\begin{array}{} Python\\ 3\\ \\mathbf{str} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{unicode} \\\\ Python\\ 3\\ \\mathbf{bytes} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{str} \\end{array} $$ 所以，如果想将以unicode形式储存的字符串转换为二进制类型的字符串，需要将unicode字符串编码，反之，则需要解码。 编码：在python中，编码指的是将Unicode字符按照编码规则（如UTF-8）编成二进制序列。 在python3中实例化一个字符串 str_1 = \"中国\" # 编码 str_1 . encode () b'\\xe4\\xb8\\xad\\xe5\\x9b\\xbd' # 创建一个二进制字符串 str_2 = b ' \\xe4\\xb8\\xad\\xe5\\x9b\\xbd ' # 解码 str_2 . decode () '中国'","text_tokens":["编成","规则","如果","原始","2","array","}","'","\\","类型","储存","mathbf","字符","#","采用","_","存储","化","对于","中国","）","bytes","8","中","字节","转换","{","是","一种","形式","$","b","反之","而","在","str","python3","不同","decode","x9b","文本","utf","编码","叫做","但","为","python","，","也就是说","3","当中","两种","按照","内部","命名","encode","xe5","=","-","就是说","：",")","所以","就是","。","ascii","显示","如","xe4","xbd","创建","的","begin","&",".","解码","进制"," ","一个","1","字符串","unicode","数据","实例","\"","将","指","有",",","使用","则","end","或者","以","python2","想","xb8","序列","需要","xad","二进制","(","（","被","longleftrightarrow"],"title":"字符编码","title_tokens":["字符","编码"]},{"location":"Python基础/2.4.String.html#bytes","text":"文本字符类型在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把 str 变为以字节为单位的 bytes 。 Python3对 bytes 类型的数据用带 b 前缀的单引号或双引号表示。 bytes_8 = b \"ABC\" bytes_8 b'ABC' 要注意的是：bytes字面值中只允许ASCII字符（无论源代码声明的编码为何）。任何超出127的二进制值必须使用相应的转义序列形式加入bytes字面值。 例如，可以对str（unicode类型）对象使用 encode() 方法，编码为bytes的形式（16进制表示）。 '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 要注意的是， encode 的对象不能超出指定编码的范围，例如不能对中文字符使用 .encode(\"ascii\") ，因为中文不在ascii码的范围内。 '中文' . encode ( 'ascii' ) ---------------------------------------------------------------------------UnicodeEncodeError Traceback (most recent call last)<ipython-input-1-76f41cd8dafa> in <module> ----> 1 '中文'.encode('ascii') UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) 纯英文的str可以用ASCII编码为bytes，内容是一样的，但无法显示为ASCII字符的字节，用 \\x 显示（16进制转义表示）。 'ABC' . encode ( 'ascii' ) b'ABC' '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用 decode() 方法： b 'ABC' . decode ( 'ascii' ) 'ABC' b ' \\xe4\\xb8\\xad\\xe6\\x96\\x87 ' . decode ( 'utf-8' ) '中文' 如果bytes中包含无法解码的字节， decode() 方法会报错： b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' ) ---------------------------------------------------------------------------UnicodeDecodeError Traceback (most recent call last)<ipython-input-1-cd8de1b11dcd> in <module> ----> 1 b'\\xe4\\xb8\\xad\\xff'.decode('utf-8') UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte 但是，如果bytes中只有一小部分无效的字节，可以传入 errors = 'ignore' 忽略错误的字节： \"中\" . encode ( \"utf-8\" ) # 中 原来的编码 b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' , errors = 'ignore' ) '中' 在对str和bytes互相转换时，为了避免乱码问题，应该使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： # !/usr/bin/env python3 # -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释。第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，在源代码中写的中文输出可能会有乱码。 但是申明了UTF-8编码只是让Python解释器按UTF-8的编码规则读取源代码，并不意味着源代码一定是使用UT8-8编码保存的，必须并且要确保文本编辑器正在使用UTF-8编码。","text_tokens":["转义序列","若干","这是","应该","忽略","规则","字","如果","到","traceback","转义","允许","它","coding","不能","注释","last","报错","position","时","互相","'","127","\\","类型","中以","保存","单引号","invalid","不","声明","原来","字符","反过来","*","cd8de1b11dcd","#","过来","xff","bin","xe6","读取","正在","把","因为","网络","---------------------------------------------------------------------------","二行","读到","_","传输","和","英文","用带","in","这","解释","ipython","磁盘","系统","call","一行","bytes","8","）","76f41cd8dafa","中",">","必须","字节","无法","可以","0xff","转换","否则","文本编辑","对应","input","若干个","部分","第一","module","是","释器","加入","unicodedecodeerror","形式","让","当","无论","b","会","/","range","can","在","str","python3","内","你","ut8","方法","not","一样","中写","解释器","只","decode","行程","程序","可执行程序","开头","两行","文本","上","utf","编码","相应","意味","t","要","值","超出","recent","但","byte","128","错误","第一行","为","并","码","python","，","codec","纯","表示","例如","3","进行","16","x87","errors","ignore","按照","对象","ordinal","任何","也","务必","对","编辑","windows","abc","encode","只有","文本文件","双引号","=","----","-",":","：","为了","我们","告诉",")","env","characters","所以","流","就是","。","most","反过","linux","第二行","时候","并且","ascii","xe4","显示","的","x","第二","就","问题","一小部分",".","了","unicodeencodeerror","解码","传入","进制","通常","os","无效","用","一定"," ","但是","一个","按","意味着","<","1","输出","代码","start","x96","那么","前缀","这个","单位","范围","写","确保","面值","unicode","数据","\"","一小","小部","避免","引号","内容","0","有","usr","指定",",","使用","或","注意","乱码","!","执行","包含","从","或者","以","中文","可能","只是","器","xb8","序列","内存","需要","xad","二进制","变为","（","为何","(","由于","本文","文件","申明","源代码"],"title":"bytes字符","title_tokens":["字符","bytes"]},{"location":"Python基础/2.4.String.html#_5","text":"","text_tokens":[],"title":"格式化","title_tokens":["格式化","格式"]},{"location":"Python基础/2.4.String.html#c-printf","text":"字符串具有一种特殊的内置操作：使用 % (取模)运算符，可以格式化字符串，此时 % 也被称为字符串的格式化运算符或插值运算符。对于format % values(其中format为一个字符串)，在format中的 % 转换标记符将被替换为零个或多个values条目。 其效果类似于在C语言中使用sprintf()。 'Hello, %s ' % 'world' # 省略括号 'Hello, world' 'Hi, %s , you have $ %d ' % ( 'Michael' , 10000.58 ) 'Hi, Michael, you have $10000' 转换标记符 包含两个或更多字符，由以下元素组成，且必须遵循此处规定的顺序： % 字符，用于标记转换符的起始。 映射键（可选），由加圆括号的字符序列组成(例如(somename))。 转换标志（可选） - 表示左对齐 + 表示转换后的内容前方加上正负号 空格 表示正数前方保留一个空格 0 表示如果转换位置位数不够时，用0填充 最小字段宽度（可选），转换后字段的最小宽度，如果不足自动用空格补齐；如果最小字段宽度值为 * ，则从元组中读取。 精度（可选），在 . 之后加精度值的形式给出。如果指定为为 * ，则从元组中读取。 长度修饰符（可选）。 转换类型。 Conversion Meaning d 格式化整数 i 格式化整数 o 8 进制 u 格式化无符号整型(已过时) x 16 进制， 小写字母 X 16 进制， 大写字母 e 浮点指数格式， 小写字母 E 浮点指数格式， 大写字母 f 浮点数 F 浮点数 g 浮点数， 如果指数小于 -4 或小于精度， 则使用小写指数格式， 否则使用小数格式 G 浮点数， 类似 g , 使用大写指数 c 单个字符， 格式化字符及其 ASCII 码 r 字符串， 使用 repr() 转换任何 Python 对象 s 字符串， 使用 str() 转换任何 Python 对象 % % 字符 # 映射键 ## 如果值是一个字典，那么必须使用映射键. 如： print ( ' %(num)d ' % { \"num\" : 10 }) 10 # 最小字段宽度 print ( ' %2s ' % 123456 ) print ( ' %8s ' % 123456 ) print ( ' %*s ' % ( 10 , 123456 )) 123456 123456 123456 # 精度 print ( ' %.2f ' % 100.256 ) print ( ' %.*f ' % ( 2 , 100.256 )) 100.26 100.26 # 转换标志 print ( ' %-8d ' % 123456 ) print ( ' %+8d ' % 123456 ) print ( ' %08d ' % 123456 ) 123456 +123456 00123456","text_tokens":["%+","不够","浮点","字母","s","如果","格式化","大写字母","123456","10","后","最","遵循","被","正数","时","由","后字","'","}","2","长度","类型","d","括号","特殊","大写","于","somename","字符","不足","算符","*","位数","运算符","#","写字","读取","字典","符","规定","指数","省略","位置","对于","符号","10000.58","条目","段","正负号","c语言","符将","起始","）","8","中","%-","必须","值为","可以","转换","用于","否则","{","小写字母","给出","2s","前方","r","repr","是","；","一种","零个","形式","8s","$","加上","格式","在","str","10000","其中","对齐","michael","更","填充","类似","此时","正负","元组","g","值","2f","##","为","码","python","，","o","称为","have","表示","例如","之后","16","已","加","对象","任何","也","i","e","替换","语言","print","操作","标志","内置","过时","此处","整型","运算","补齐","c","顺序","4","且","左","-",":","：","效果","you","values","f","100.256",")","精度","多","08d","。","小数","format","ascii","如","整数","的","其","x","修饰符","以下","8d","由加",".","宽度","小写","可","进制","标记","用"," ","一个","空格","world","+","浮点数","具有","点数","映射","那么","字符串","保留","小字","修饰","单个","100.26","\"","多个","小于","meaning","内容","0","选",",","使用","则","指定","无","或","%.","sprintf","%","hello","包含","从","取模","00123456","插值","序列","自动","两个","conversion","(","最小","（","u","圆括号","负号","元素","及其","num","组成","键","hi"],"title":"C printf 样式的格式化","title_tokens":["c"," ","的","样式","printf","格式化","格式"]},{"location":"Python基础/2.4.String.html#format","text":"< 模板字符串 >. format ( < 逗号分隔的参数 > ) <模板字符串> 由一系列的槽 {} 组成，用来控制修改字符串中嵌入值出现的位置，其基本思想是将format()方法的 <逗号分隔的参数> 中的参数按照序号关系替换到 <模板字符串> 的槽中。如果大括号中没有序号，则按照出现顺序替换。该方法会创建新字符串对象，不会修改原值。 {}中指定顺序，按指定的顺序替换 print ( \" {2} : {1} : {0} \" . format ( \"1\" , \"2\" , \"3\" )) 3 : 2 : 1 没有指定顺序，按出现的顺序依次替换 print ( \" {} : {} : {} \" . format ( \"1\" , \"2\" , \"3\" )) 1 : 2 : 3 format()方法中 <模板字符串> 的槽除了包括参数序号，还可以包括格式控制信息。此时，槽的内部样式如下： 替换字段 - replacement_field ::= \"{\" [ field_name ] [ \"!\" conversion ] [ \":\" format_spec ] \"}\" 字段名 - field_name ::= arg_name ( \".\" attribute_name | \"[\" element_index \"]\" ) * 参数名 - arg_name ::= [ identifier | integer ] 属性名 - attribute_name ::= identifier 元素索引 - element_index ::= integer | index_string 索引字符串 - index_string ::= < any source character except \"]\" > + 转换字段 - conversion ::= \"r\" | \"s\" 格式规范说明符 - format_spec ::= < described in the next section > 注意事项： 参数名 可以为 整数 或 关键字 。整数为位置参数， 关键字为命名关键字参数。 如果整数类似于 {0}{1}{2}, 则可以省略， 即： {}{}{} 等价于 {0}{1}{2}。 如果参数存在属性， 可以通过 arg_name.attribute_name 的形式获取属性值。 如果参数为可迭代对象， 可以通过 arg_name[integer|index_string] 的形式获取索引位置的元素。 转换字段 由 ! 开始， r 代表调用 repr(), s 代表调用 str(). 格式规范说明符 由 : 开始。 其中， <格式控制标记> 用来控制参数显示时的格式，可以使用的参数如下： format_spec ::= [ [fill ] align ] [ sign ][ # ][ 0 ][ width ][ grouping_option ][ .precision ][ type ] fill ::= < any character > align ::= \"<\" | \">\" | \"=\" | \"^\" sign ::= \"+\" | \"-\" | \" \" width ::= digit + grouping_option ::= \"_\" | \",\" precision ::= digit + type ::= \"b\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" | \"g\" | \"G\" | \"n\" | \"o\" | \"s\" | \"x\" | \"X\" | \"%\" 填充字符 ：如果指定了对齐选项，则可以使用填充字符。默认为空格. 对齐选项 ：默认右对齐，各种对齐选项的含义如下： 选项 意义 '<' 强制字段在可用空间内左对齐（这是大多数对象的默认值）。 '>' 强制字段在可用空间内右对齐（这是数字的默认值）。 '=' 强制将填充放置在符号（如果有）之后但在数字之前。这用于以“+000000120”形式打印字段。此对齐选项仅对数字类型有效。当'0'紧接在字段宽度之前时，它成为默认值。 '^' 强制字段在可用空间内居中。 sign ：仅对数字类型有效，可以是以下之一： 选项 意义 '+' 表示标志应该用于正数和负数。 '-' 表示标志应仅用于负数（这是默认行为）。 space 表示应在正数上使用前导空格，在负数上使用减号。 # ：仅适用于数字参数，同时仅适用于2、8、16进制的数字。会在输出的数字前添加 0b、0o、0x前缀。 宽度 ：指定最小字段宽度。 千位分隔符 ：只能使用 _ 或 , 作为千位分隔符。 精度 ： 类型 ：该选项决定了数据应该如何呈现。 可用的字符串表示类型： Type Meaning s 字符串格式， 字符串的默认类型， 可省略 None 同 s 可用的整数表示类型： Type Meaning b 输出为 2 进制整数 c 输出为为相应的 unicode 字符 d 输出为 10 进制整数 o 输出为 8 进制整数 x 输出为 16 进制整数， 使用小写字母 X 输出为 16 进制整数， 使用大写字母 n 类似 d , 会使用当前区域设置插入适当的数字分隔符 None 同 d 可用的浮点数和小数值表示类型： Type Meaning e 指数表示法， 使用字母 e 以科学记数法打印数字， 默认进度为 6 E 类似 e , 使用字母 E f 浮点数， 默认进度为 6 F 浮点数， 同 f g 一般形式， 受 precision 选项影响 G 类似 g , 当使用指数表示法时， 使用 E 而不是 e n 和 g 相同， 会使用当前区域设置插入适当的数字分隔符 % 百分数表示 None 同 g # 填充、对齐、符号、宽度、分组选项、精度 # 填充*号、居中、正号标记、2精度 \" {0:*^+20.2f} \" . format ( 120 ) '******+120.00*******' # 填充*号、居中、正号标记、_分隔符、2精度 \"{0:*^+20_.2f}\" . format ( 12000 ) '*****+12_000.00*****' # 填充*号、居中、正号标记、,分隔符、2精度 \" {0:*^+20,.2f} \" . format ( 12000 ) '*****+12,000.00*****' # 填充*号、左对齐、正号标记、2精度 \" {0:*<+20.2f} \" . format ( - 120 ) '-120.00*************' # 填充*号、左对齐、负号标记、2精度 \" {0:*>-20.2f} \" . format ( - 120 ) '*************-120.00'","text_tokens":["浮点","字","多数","10","字段","最","号","'","该","前导","记数法","仅","digit","默认","*","调用","integer","分隔","事项","行为","指数","信息","修改","in","这","符号","居中","段","不是","转换","{","序号","小写字母","arg","是","next","不会","当","成为","格式","对齐","类似","width","0b","原值","align","2f","只能","样式","3","规范","按照","如何","替换","fill","grouping","包括","相同","character","数字","有效","n",")","适用","大多数","。","打印","基本","的","嵌入","其","放置","以下","了","field","标记"," ","<","+","字符串","减号","unicode","将","则","使用","!","或","%","代表","即","conversion","槽","大多","元素","紧接在","百分数","这是","它","000.00","大写字母","说明","除了","由","2","}","系列","还","同","获取","大写","插入","适当","添加","element","写字","_","和","位置","8","中","space","当前","b","而","出现","str","其中","attribute","0o","填充","，","o","可用","]","e","index","print","没有","内部","标志","关键字","c","string","顺序","=","左","千位","含义","_.","format","之前","整数","区域","any","按","说明符","the","1","点数","前缀","120","设置","none","meaning","有","注意","except","默认值","(","用来","参数","s","到","如果","identifier","迭代","正数","时","小","类型","于","通过","字符","科学","之一","影响","表示法","分数","此","控制","负数","前","120.00","数值","可以","repr","“","会","20.2","分组","内","方法","属性","12000","000000120","开始","[","|","相应","值","为","一般","name","对","^","紧接","命名","逗号","受","0x",":","字段名","f","精度","显示","创建","x","各种","12",".","宽度","小写","可","浮点数","索引","\"","依次","0","指定","空间","6","进度","应","（","负号","应该","option","字母","名","百分","described","关系","存在","section","d","注意事项","括号","等价","#","右","省略","选项","replacement","）",">","关键","用于","应仅","r","、","形式","正","precision","内右","在","20","此时","上","g","一系","但","sign","之后","表示","16","呈现","source","对象","spec","-","决定","：","新","大括号","一系列","进制","type","如下","空格","输出","小字","强制","接在","数据","同时",",","模板","”","作为","以","分隔符","思想","意义","控制参数","记数","组成"],"title":"format方法","title_tokens":["format","方法"]},{"location":"Python基础/2.4.String.html#_6","text":"","text_tokens":[],"title":"方法","title_tokens":["方法"]},{"location":"Python基础/2.4.String.html#_7","text":"方法 描述 .isalnum if all characters in the string are alpha-numeric and there is at least one character .isalpha if all characters in the string are alphabetic and there is at least one character .isnumeric if all characters in the string are numeric and there is at least one character .isascii ASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too . .isdecimal if all characters in the string are decimal and there is at least one character .isdigit if all characters in the string are digits and there is at least one character .isidentifier Use keyword.iskeyword() to test for reserved identifiers such as \"def\" and \"class\". .islower if all cased characters in the string are lowercase and there is at least one cased character .isupper if all cased characters in the string are uppercase and there is at least one cased character .isprintable if all of its characters are considered printable in repr() or if it is empty. .isspace if all characters in the string are whitespace and there is at least one character .istitle In a title-cased string, upper- and title-case characters may only follow uncased characters and lowercase characters only cased ones. 方法 描述 .startswith(prefix[, start[, end]]) 如果字符串以 prefix 开头 .endswith(suffix[, start[, end]]) 如果字符串以 suffix 结尾","text_tokens":["isnumeric","for","identifiers","如果","结尾","decimal","its","startswith","considered","lowercase","字符","isidentifier","there","描述","use","printable","isspace","in","istitle","may","isdigit","isupper","too","case","endswith","repr","code","alpha","uppercase","range","uncased","方法","isalpha","开头","whitespace","[","alphabetic","islower","digits","have","suffix","keyword","are","]","it","and","title","only","character","string","-","such","isprintable","or","prefix","is",")","characters","007f","follow","to","ascii","points","one","reserved","isalnum","ones",".","isascii","of"," ","the","class","+","cased","start","字符串","\"","if","upper","all",",","end","def","以","iskeyword","least","test","isdecimal","(","a","u","as","at","numeric","0000","empty"],"title":"逻辑方法","title_tokens":["逻辑","方法"]},{"location":"Python基础/2.4.String.html#_8","text":"方法 描述 .lower 返回转换为小写的字符串的副本。 .upper 返回转换为大写的字符串的副本。 .capitalize 使第一个字符字母大写，其余字符字母小写，返回副本。 .swapcase 将大写字符转换为小写，将小写字符转换为大写，返回副本。 .title 每个单词都用大写字母开头，返回副本。","text_tokens":["使",".","小写","第一个","字母","用"," ","转换","一个","大写字母","lower","副本","返回","都","第一","title","字符串","将","upper","方法","大写","字符","开头","写字","描述","。","单词","其余","为","的","，","每个","swapcase","capitalize"],"title":"大小字母转换","title_tokens":["转换","字母","大小"]},{"location":"Python基础/2.4.String.html#_9","text":"方法 描述 .split(sep=None, maxsplit=-1) 从左到右以 sep 分割字符串 .rsplit(sep=None, maxsplit=-1) 从右到左以 sep 分割字符串 .splitlines(keepends=False) 以回车符或换行符分割字符串 .partition(sep, /) 从左到右以第一个出现的 sep 分割字符串，返回包括3个元素的元组 \"123#456#789\" . split ( sep = \"#\" , maxsplit = 1 ) ['123', '456#789'] \"123#456#789\" . rsplit ( sep = \"#\" , maxsplit = 1 ) ['123#456', '789'] \"123 \\r\\n 456 \\r\\n 789\" . splitlines ( keepends = False ) ['123', '456', '789'] \"123 \\r\\n 456 \\r\\n 789\" . splitlines ( keepends = True ) ['123\\r\\n', '456\\r\\n', '789'] \"123#456#789\" . partition ( \"#\" ) ('123', '#', '456#789')","text_tokens":[".","第一个","换行","]"," ","一个","回车","返回","456","1","第一","r","包括","字符串","'","sep","none","/","=","个","789","\"","\\","false","-","出现","方法","换行符","rsplit",",","true","字符","123",")","或","n","从右到左","#","分割","描述","以","[","元组","split","(","回车符","partition","的","splitlines","，","maxsplit","元素","从左到右","keepends","3"],"title":"拆分字符串","title_tokens":["字符","拆分","字符串"]},{"location":"Python基础/2.4.String.html#_10","text":"\"_\" . join ([ \"a\" , \"b\" , \"c\" ]) 'a_b_c'","text_tokens":[".","c",",","_","(","a","b"," ","]",")","'","\"","[","join"],"title":"合并字符串","title_tokens":["字符","合并","字符串"]},{"location":"Python基础/2.4.String.html#_11","text":"方法 描述 .replace(old, new, count=-1) 返回一个副本，其中所有出现的子字符串 old 都替换为 new 。 .strip(chars=None) 返回字符串的副本，其中前导和尾随空格删除。 .lstrip(chars=None) 返回删除前导空格的字符串副本。 .rstrip(chars=None) 返回删除尾随空格的字符串副本。 .expandtabs(tabsize=8) 返回一个副本，其中所有制表符都使用 tabsize 个空格代替。 \" \\n abc \\t\\n\\r \" . strip () 'abc' \" \\n abc \\t\\n\\r \" . lstrip () 'abc\\t\\n\\r ' \" \\n abc \\t\\n\\r \" . rstrip () ' \\nabc' \" \\n abc \\t\\n\\r \" . expandtabs ( tabsize = 8 ) ' \\nabc \\n\\r '","text_tokens":[".","8","nabc","new"," ","一个","替换","尾随","空格","制表","副本","返回","abc","1","都","r","strip","expandtabs","replace","字符串","制表符","'","none","前导","代替","=","chars","个","\"","\\","出现","-","所有","方法","其中","rstrip",",","使用","字符","n",")","描述","。","count","子","t","old","删除","(","和","lstrip","为","的","tabsize","，"],"title":"替换字符串","title_tokens":["替换","字符","字符串"]},{"location":"Python基础/2.4.String.html#_12","text":"方法 描述 .format 格式化字符串。 .format_map 格式化字符串。 .ljust(width, fillchar=' ') 返回长度为 width 的左对齐字符串。使用 fillchar 填充。 .rjust(width, fillchar=' ') 返回长度为 width 的右对齐字符串。使用 fillchar 填充。 .center(width, fillchar=' ') 返回长度为 width 的居中字符串。使用 fillchar 填充。 .zfill(width) 返回长度为 width 的字符串，若长度不够，用零从左边填充。 .format_map 与 .format 在用法上大体一致，但有一个区别： # format_map 和 format 的区别 # 如果要使用关键字 format必须这样使用 \" {name} , {sex} \" . format ( name = \"Jack\" , sex = \"male\" ) # format_map 可以用dict \" {name} , {sex} \" . format_map ({ \"name\" : \"Jack\" , \"sex\" : \"male\" }) 'Jack, male' print ( \"abc\" . ljust ( 10 , \"#\" )) print ( \"abc\" . rjust ( 10 , \"#\" )) print ( \"abc\" . center ( 10 , \"#\" )) print ( \"123\" . zfill ( 10 )) # 非数字字符串也可以 print ( \"abc\" . zfill ( 10 )) abc####### #######abc ###abc#### 0000000123 0000000abc","text_tokens":["不够","如果","格式化","10","'","}","长度","dict","male","######","字符","jack","#","描述","若","零","右","_","和","居中","sex","必须","关键","可以","{","0000000123","用法","#######","0000000abc","格式","在","center","方法","对齐","123","这样","填充","ljust","width","上","ab","大体","要","但","大体一致","###","为","，","name","与","也","rjust","print","返回","abc","关键字","c#","=","数字","左",":","左边","：",")","。","format","的",".","用"," ","zfill","一个","字符串","非","map","\"","有",",","使用","fillchar","区别","从","一致","("],"title":"格式化字符串","title_tokens":["字符","格式化","格式","字符串"]},{"location":"Python基础/2.4.String.html#_13","text":"\"abcAbc\" . count ( \"c\" , 0 , 6 ) 2","text_tokens":["0",".","c",",","(","2",")"," ","abcabc","\"","count","6"],"title":"统计子字符串出现次数","title_tokens":["字符串","字符","出现","次数","子","统计"]},{"location":"Python基础/2.4.String.html#_14","text":".index 与 .find 的功能是一样的，只不过 .index 方法若找不到子字符串会抛出ValueError，而 .find 会返回 -1 。 \"abcAbc\" . index ( \"bc\" , 0 , 6 ) \"abcAbc\" . find ( \"bc\" , 0 , 6 ) 1 \"abcAbc\" . index ( \"bc\" , 0 , 2 ) ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-f8cead4644a3> in <module> ----> 1 \"abcAbc\".index(\"bc\", 0, 2) ValueError: substring not found \"abcAbc\" . find ( \"bc\" , 0 , 2 ) -1","text_tokens":[".","substring",">","与","traceback"," ","f8cead4644a3","index","返回","<","input","1","last","module","是","字符串","found","2","会","功能","----","而","\"","-",":","方法","找","一样","0","not",",","字符",")","abcabc","find","抛出","。","most","若","子","6","不到","bc","---------------------------------------------------------------------------","recent","(","valueerror","的","不过","，","只不过","in","ipython","call"],"title":"查找子字符串第一次出现的位置","title_tokens":["字符串","一次","字符","的","位置","出现","查找","子","第一","第一次"]},{"location":"Python基础/2.5.Tuple.html","text":"tuple是一种一维的，定长的、不可变的Python对象序列，元素写在小括号 () 里，元素之间用逗号隔开，元组中的元素类型可以不相同。 不可变的tuple有什么意义？ 因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 Tuple的陷阱——1个元素的Tuple 定义个一个Tuple，需要传入一个iterable对象。 tuple ( \"123\" ) ('1', '2', '3') 如果需要定义一个空的Tuple，则可以这样定义： # 通过tuple类来定义 a = tuple () type ( a ) # 或者用 () 定义 a = () type ( a ) # 是的，通过()可以定义一个空tuple tuple 但是如果要定义一个只有一个元素的tuple，就得要注意了。如果我们这样定义，则是错误的： b = ( \"123\" ) type ( b ) str 定义只有一个元素的tuple，需要这样定义： b = ( \"123\" ,) type ( b ) tuple 或者这样定义： b = tuple ([ \"123\" ]) type ( b ) tuple 为什么会这样呢？因为 () 在python中可以表示运算符的 () ，也可以表示Tuple。这就不可避免地产生了歧义，为了消除歧义，Python规定括号里面只有一个元素时，按运算符的 () 进行解析。 Tuple的陷阱——“可变的”Tuple 前面说过，Tuple是一种不可变的对象。但是有时我们又会发现Tuple是“可变的”。 c = ( 'a' , 'b' , [ 'A' , 'B' ]) print ( \"原始的Tuple：\" , c ) c [ 2 ][ 0 ] = 'X' c [ 2 ][ 1 ] = 'Y' print ( \"修改后的Tuple：\" , c ) 原始的Tuple： ('a', 'b', ['A', 'B']) 修改后的Tuple： ('a', 'b', ['X', 'Y']) 前面说过tuple一旦定义后就不可变，那上面的c怎么就改变了呢？其实，c的元素并没有改变，改变的只是list中的元素，tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素的指向永远不变。即指向 a ，就不能改成指向 b ，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 所以要创建一个内容也不变的tuple，那就必须保证tuple的每一个元素本身也不能变。 Tuple的方法 因为Tuple是一个不可变的列表，没有用于修改列表的方法，所以Tuple对象的方法很少。 d = ( 0 , 1 , 2 , 3 , 4 , 4 ) [ method for method in dir ( d ) if not method . startswith ( \"_\" )] ['count', 'index'] 统计元素出现的次数 d . count ( 4 ) 2 元素第一次出现时对应的索引值 d . index ( 4 ) 4","text_tokens":["list","for","它","如果","虽然","一维","原始","永远","不能","后","—","时","里","'","2","得","能用","代替","个","类型","d","歧义","括号","startswith","iterable","不","通过","隔开","算符","#","运算符","很少","改变","因为","不可避免","规定","！","_","？","tuple","修改","不变","每个","in","这","method","中","必须","尽量","可以","用于","空","解析","别的","对应","第一","是","“","、","一种","呢","b","有时","会","出现","在","str","方法","产生","not","123","这样","更","开始","[","其实","count","次数","元组","要","值","定长","但","错误","说","并","python","，","发现","过","表示","3","进行","对象","]","也","index","print","没有","消除","小括号","逗号","y","相同","陷阱","只有","运算","c","改成","=","4","变","：","之间","为了","我们",")","所以","本身","。","统计","创建","的","x","一旦","指向","列表","就","什么","传入","了",".","type","用","保证"," ","但是","一个","按","类来","1","又","代码","一次","这个","其他","不可","写","定义","索引","\"","上面","避免","if","一","dir","有","0","内容",",","则","可变","注意","包含","”","可能","或者","只是","即","怎么","序列","前面","安全","比如","需要","为什么","(","所谓","a","地","意义","每","里面","元素","那","第一次"],"title":"2.5.Tuple","title_tokens":[".","tuple","2.5"]},{"location":"Python基础/2.5.Tuple.html#tuple1tuple","text":"定义个一个Tuple，需要传入一个iterable对象。 tuple ( \"123\" ) ('1', '2', '3') 如果需要定义一个空的Tuple，则可以这样定义： # 通过tuple类来定义 a = tuple () type ( a ) # 或者用 () 定义 a = () type ( a ) # 是的，通过()可以定义一个空tuple tuple 但是如果要定义一个只有一个元素的tuple，就得要注意了。如果我们这样定义，则是错误的： b = ( \"123\" ) type ( b ) str 定义只有一个元素的tuple，需要这样定义： b = ( \"123\" ,) type ( b ) tuple 或者这样定义： b = tuple ([ \"123\" ]) type ( b ) tuple 为什么会这样呢？因为 () 在python中可以表示运算符的 () ，也可以表示Tuple。这就不可避免地产生了歧义，为了消除歧义，Python规定括号里面只有一个元素时，按运算符的 () 进行解析。","text_tokens":["如果","时","2","'","得","个","歧义","括号","iterable","通过","算符","#","运算符","因为","不可避免","规定","？","tuple","这","中","可以","空","解析","是","呢","b","会","str","在","产生","123","这样","[","要","错误","python","，","表示","3","进行","对象","]","也","消除","只有","运算","=","：","为了","我们",")","。","的","就","传入","了","什么","type","用"," ","但是","一个","按","类来","1","不可","定义","\"","避免",",","则","注意","或者","需要","为什么","(","a","地","里面","元素"],"title":"Tuple的陷阱——1个元素的Tuple","title_tokens":["—","陷阱","tuple","的","个","元素","1"]},{"location":"Python基础/2.5.Tuple.html#tupletuple","text":"前面说过，Tuple是一种不可变的对象。但是有时我们又会发现Tuple是“可变的”。 c = ( 'a' , 'b' , [ 'A' , 'B' ]) print ( \"原始的Tuple：\" , c ) c [ 2 ][ 0 ] = 'X' c [ 2 ][ 1 ] = 'Y' print ( \"修改后的Tuple：\" , c ) 原始的Tuple： ('a', 'b', ['A', 'B']) 修改后的Tuple： ('a', 'b', ['X', 'Y']) 前面说过tuple一旦定义后就不可变，那上面的c怎么就改变了呢？其实，c的元素并没有改变，改变的只是list中的元素，tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素的指向永远不变。即指向 a ，就不能改成指向 b ，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 所以要创建一个内容也不变的tuple，那就必须保证tuple的每一个元素本身也不能变。","text_tokens":["list","原始","永远","不能","后","2","'","改变","！","？","tuple","不变","修改","每个","中","必须","别的","是","“","一种","呢","有时","b","会","开始","[","其实","要","但","说","并","，","发现","过","对象","]","也","print","没有","y","c","改成","=","变","：","我们",")","所以","本身","。","创建","的","x","一旦","指向","就","了","保证"," ","但是","一个","1","又","这个","其他","不可","定义","\"","上面","一","内容","0",",","可变","”","只是","即","怎么","前面","所谓","(","a","每","元素","那"],"title":"Tuple的陷阱——“可变的”Tuple","title_tokens":["“","—","陷阱","可变","tuple","的","”"]},{"location":"Python基础/2.5.Tuple.html#tuple","text":"因为Tuple是一个不可变的列表，没有用于修改列表的方法，所以Tuple对象的方法很少。 d = ( 0 , 1 , 2 , 3 , 4 , 4 ) [ method for method in dir ( d ) if not method . startswith ( \"_\" )] ['count', 'index']","text_tokens":["method",".","for","对象","]"," ","index","一个","用于","没有","1","是","2","'","不可","4","=","\"","d","变","if","方法","dir","0","not","startswith",",",")","所以","。","[","count","很少","因为","(","_","tuple","的","修改","in","，","列表","3"],"title":"Tuple的方法","title_tokens":["tuple","的","方法"]},{"location":"Python基础/2.5.Tuple.html#_1","text":"d . count ( 4 ) 2","text_tokens":[".","(","2",")"," ","4","d","count"],"title":"统计元素出现的次数","title_tokens":["元素","的","出现","次数","统计"]},{"location":"Python基础/2.5.Tuple.html#_2","text":"d . index ( 4 ) 4","text_tokens":[".","(",")"," ","index","4","d"],"title":"元素第一次出现时对应的索引值","title_tokens":["元素","值","一次","时","的","对应","索引","出现","第一","第一次"]},{"location":"Python基础/2.6.Dict.html","text":"映射（mapping）是通过名称来访问其各个值的数据结构。字典是Python中唯一的内置映射类型，其中的值不按顺序排列，而是存储在键下。键可能是数、字符串或元组。 创建dict 字典以类似于下面的方式表示： phonebook = { 'Alice' : '2341' , 'Beth' : '9102' , 'Cecil' : '3258' } 字典由键及其相应的值组成，这种键--值对称为项（item）。每个键与其值之间都用冒号 : 分隔，item之间用逗号分隔，而整个字典放在花括号内。空字典（没有任何项）用两个花括号 {} 表示。 注意 在字典（以及其他映射类型）中，键必须是独一无二的，而字典中的值无需如此。 可使用dict类从其他映射（如其他字典）或键–值对序列创建字典。 items = [( 'name' , 'Gumby' ), ( 'age' , 42 )] dict ( items ) {'name': 'Gumby', 'age': 42} 还可使用关键参数，如下所示： dict ( name = 'Gumby' , age = 42 ) {'name': 'Gumby', 'age': 42} Dict的方法 字典的基本行为在很多方面都类似于序列。 len(d)返回字典d包含的项（键--值对）数。 d[k]返回与键k相关联的值。 d[k] = v将值v关联到键k。 del d[k]删除键为k的项。 k in d检查字典d是否包含键为k的项。 虽然字典和列表有多个相同之处，但也有一些重要的不同之处。 自动添加。 dict可以给不存在的项赋值，即是字典中原本没有的键，也可以给它赋值。而如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值。 成员资格。 表达式k in d (其中d是一个字典）査找的是键而不是值；而表达式v in 1 (其中1是一个列表）查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自然。毕竟如果字典包含指定的键，检查相应的值就很容易。 clear 删除所有的字典项 要注意的是，clear是清除了一个字典对象，而不是解除了名称与字典对象的绑定。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a a . clear () # 可以看到，a、b都变成了字典 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {} b的值: {} copy 浅拷贝 a = { \"a\" : 1 , \"b\" : 2 , \"c\" :[ 1 , 2 ]} b = a . copy () b [ \"c\" ][ 0 ] = 10 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {'a': 1, 'b': 2, 'c': [10, 2]} b的值: {'a': 1, 'b': 2, 'c': [10, 2]} fromkeys dict . fromkeys ( key , value ) 方法 fromkeys 创建一个新字典，其中包含指定的键，且每个键对应的值都是None，也可以指定值， dict . fromkeys ([ \"a\" , \"b\" ]) {'a': None, 'b': None} dict . fromkeys ([ \"a\" , \"b\" ], 10 ) {'a': 10, 'b': 10} get 方法 get 为访问字典项提供了宽松的环境。通常，如果你试图访问字典中没有的项，将引发错误。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a [ \"d\" ] ---------------------------------------------------------------------------KeyError Traceback (most recent call last)<ipython-input-1-b0ca58477f0c> in <module> 1 a = {\"a\":1,\"b\": 2,\"c\":3} ----> 2 a[\"d\"] KeyError: 'd' 而使用 get 不会这样 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . get ( \"d\" ) # 默认返回None，也可以指定返回值 a . get ( \"d\" , \"N/A\" ) 'N/A' items 方法 items 返回一个包含所有字典项的列表，其中每个元素都为 (key, value) 的形式。字典项在列表中的排列顺序不确定。返回值属于一种名为字典视图的特殊类型。字典视图可用于迭代。另外，你还可确定其长度以及对其执行成员资格检查。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . items () dict_items([('a', 1), ('b', 2), ('c', 3)]) # dict_items类型 type ( a . items ()) dict_items # 迭代 for i in a . items (): print ( i ) ('a', 1) ('b', 2) ('c', 3) # 迭代 for key , value in a . items (): print ( key , end = \" \" ) print ( value ) a 1 b 2 c 3 # 检查成员资格 ( \"a\" , 1 ) in a . items () True keys 和 values 方法 keys 返回一个字典视图，其中包含字典中的键。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . keys () dict_keys(['a', 'b', 'c']) 方法 values 返回一个字典视图，其中包含字典中的键。 a . values () dict_values([1, 2, 3]) pop 方法pop可用于获取与指定键相关联的值，并将该键-值对从字典中删除。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a . pop ( \"a\" ) print ( \"b的值\" , b ) print ( \"a的值\" , a ) b的值 1 a的值 {'b': 2, 'c': 3} popitem 方法 popitem 类似于 list.pop ，但 list.pop 弹出列表中的最后一个元素，而 popitem 随机地弹出一个字典项，因为字典项的顺序是不确定的，没有“最后一个元素”的概念。如果你要以高效地方式 逐个 删除并处理所有字典项，这可能很有用，因为这样无需先获取键列表。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . popitem () ('c', 3) a {'a': 1, 'b': 2} setdefault 方法 setdefault 有点像get，因为它也获取与指定键相关联的值，但除此之外，setdefault还在字典不包含指定的键时，在字典中添加指定的键-值对。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . setdefault ( \"a\" ) a a . setdefault ( \"d\" ) a {'a': 1, 'b': 2, 'c': 3, 'd': None} 如你所见，指定的键不存在时，setdefault返回指定的值并相应地更新字典。如果指定的键存在，就返回其值，并保持字典不变。与 get 一样，值是可选的，如果没有指定，默认为None。 update 方法update使用一个字典中的项来更新另一个字典。对于通过参数提供的字典，将其项添加到当前字典中。如果当前字典包含键相同的项，就替换它。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . update ({ \"d\" : 4 }) a {'a': 1, 'b': 2, 'c': 3, 'd': 4} 可像调用本章前面讨论的函数dict（类型构造函数）那样调用方法update。这意味着调用update时，可向它提供一个映射、一个由键-值对组成的序列（或其他可迭代对象）或关键字参数。 a . update ( zip ([ \"e\" , \"f\" ],[ 5 , 6 ])) a {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}","text_tokens":["赋值","42","10","'","cecil","长度","dict","唯一","不","各个","不同之处","默认","调用","其项","字典","copy","分隔","行为","独一无二","所示","存储","in","每个","这","对于","与其","不是","与键","{","空","对应","是","査","整个","不会","拷贝","方式","这样","del","类似","表达式","update","错误","并","python","弹","3","相当","替换","相关联","结构","age","访问","append","来","相同","----","将值","n",")","。","看到","基本","清除","alice","看似","其","的","列表","了"," ","很多","<","映射","item","字符串","处理","先","将","使用","end","或","5","即","序列","解除","a","地弹","属于","元素","很","构造函数","它","traceback","而是","value","毕竟","last","2","}","还","获取","添加","b0ca58477f0c","该键","因为","删除","_","和","提供","本章","中","必须","如此","函数","当前","；","一种","b","v","而","其中","不同","讨论","方面","，","与","]","e","print","没有","都","c","关键字","试图","顺序","=","其值","随机","由键","宽松","keys","浅","视图","gumby","如","习惯","就","数","给","用","按","1","下面","none","多个","有","找","注意","关联","包含","可向","前面","自动","两个","(","花","查找","及其","名称","参数","len","如果","到","除此之外","相同之处","迭代","确定","2341","时","自然","引发","clear","类型","之处","于","通过","另外","字符","逐个","一些","有用","---------------------------------------------------------------------------","资格","ipython","call","可以","keyerror","或键","input","“","key","会","你","内","方法","一样","k","类","[","有点","相应","要","值","表达","原本","为","数据结构","称为","3258","容易","保持","name","任何","对","逗号","fromkeys","get","独一","4",":","是否","之间","无需","values","f","most","可像","重要","beth","创建","最后",".","通常","可","一个","items","意味着","项","其他","放在","索引","\"","popitem","所有","0","返回值","指定","冒号","有点像","不太","一致","6","zip","变成","（","地","可选","觉得","所见","--","list","for","环境","虽然","构造","不能","后","存在","之外","除此","d","成员","括号","特殊","–","true","#","项来","到键","不变","那样","）",">","关键","用于","绑定","module","、","形式","排列","9102","/","在","phonebook","元组","意味","顺序排列","但","recent","以及","概念","键为","表示","setdefault","对象","也","i","返回","更新","这种","内置","pop","另","且","-","：","新","检查","相关","type","如下","mapping","出","数据",",","高效","执行","”","从","可能","以","下","名为","达式","组成","键"],"title":"2.6.Dict","title_tokens":[".","2.6","dict"]},{"location":"Python基础/2.6.Dict.html#dict","text":"字典以类似于下面的方式表示： phonebook = { 'Alice' : '2341' , 'Beth' : '9102' , 'Cecil' : '3258' } 字典由键及其相应的值组成，这种键--值对称为项（item）。每个键与其值之间都用冒号 : 分隔，item之间用逗号分隔，而整个字典放在花括号内。空字典（没有任何项）用两个花括号 {} 表示。 注意 在字典（以及其他映射类型）中，键必须是独一无二的，而字典中的值无需如此。 可使用dict类从其他映射（如其他字典）或键–值对序列创建字典。 items = [( 'name' , 'Gumby' ), ( 'age' , 42 )] dict ( items ) {'name': 'Gumby', 'age': 42} 还可使用关键参数，如下所示： dict ( name = 'Gumby' , age = 42 ) {'name': 'Gumby', 'age': 42}","text_tokens":["参数","42","2341","'","}","cecil","还","类型","dict","括号","于","–","字典","分隔","独一无二","所示","每个","与其","）","中","必须","关键","{","空","如此","或键","是","整个","9102","而","在","内","phonebook","类","方式","类似","[","相应","值","以及","，","称为","表示","3258","name","任何","]","对","没有","age","都","这种","逗号","独一","=",":","由键","：","之间","无需",")","。","gumby","beth","alice","如","创建","的","可","如下","用"," ","items","项","映射","item","其他","放在","下面",",","使用","冒号","注意","从","以","序列","两个","(","（","花","及其","组成","键","--"],"title":"创建dict","title_tokens":["创建","dict"]},{"location":"Python基础/2.6.Dict.html#dict_1","text":"字典的基本行为在很多方面都类似于序列。 len(d)返回字典d包含的项（键--值对）数。 d[k]返回与键k相关联的值。 d[k] = v将值v关联到键k。 del d[k]删除键为k的项。 k in d检查字典d是否包含键为k的项。 虽然字典和列表有多个相同之处，但也有一些重要的不同之处。 自动添加。 dict可以给不存在的项赋值，即是字典中原本没有的键，也可以给它赋值。而如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值。 成员资格。 表达式k in d (其中d是一个字典）査找的是键而不是值；而表达式v in 1 (其中1是一个列表）查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自然。毕竟如果字典包含指定的键，检查相应的值就很容易。","text_tokens":["很","赋值","len","它","如果","虽然","相同之处","毕竟","不能","后","存在","自然","dict","d","成员","不","不同之处","之处","于","添加","一些","字典","到键","行为","删除","和","in","这","资格","）","中","不是","与键","可以","是","；","査","v","会","而","在","你","方法","其中","k","不同","del","类似","[","表达式","相应","值","但","方面","表达","原本","键为","，","容易","相当","]","也","对","相关联","返回","没有","append","都","相同","=","将值","是否","检查",")","。","重要","基本","看似","习惯","的","列表","就","查找","数","给","相关"," ","很多","一个","项","1","其他","索引","多个","有","找","指定","使用","或","关联","包含","不太","即","一致","序列","自动","(","（","觉得","元素","达式","键","--"],"title":"Dict的方法","title_tokens":["的","方法","dict"]},{"location":"Python基础/2.6.Dict.html#clear","text":"要注意的是，clear是清除了一个字典对象，而不是解除了名称与字典对象的绑定。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a a . clear () # 可以看到，a、b都变成了字典 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {} b的值: {}","text_tokens":["了","名称",".","不是","对象","与"," ","可以","一个","{","print","1","绑定","都","是","c","、","2","}","b","=","clear","而","\"",":",",",")","注意","#","。","看到","字典","要","清除","解除","变成","值","(","a","的","，","3"],"title":"clear删除所有的字典项","title_tokens":["删除","的","clear","项","字典","所有"]},{"location":"Python基础/2.6.Dict.html#copy","text":"a = { \"a\" : 1 , \"b\" : 2 , \"c\" :[ 1 , 2 ]} b = a . copy () b [ \"c\" ][ 0 ] = 10 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {'a': 1, 'b': 2, 'c': [10, 2]} b的值: {'a': 1, 'b': 2, 'c': [10, 2]}","text_tokens":[".","]"," ","{","print","10","1","c","2","'","}","b","=","\"",":","0",",",")","[","copy","值","(","a","的"],"title":"copy浅拷贝","title_tokens":["拷贝","浅","copy"]},{"location":"Python基础/2.6.Dict.html#fromkeys","text":"dict . fromkeys ( key , value ) 方法 fromkeys 创建一个新字典，其中包含指定的键，且每个键对应的值都是None，也可以指定值， dict . fromkeys ([ \"a\" , \"b\" ]) {'a': None, 'b': None} dict . fromkeys ([ \"a\" , \"b\" ], 10 ) {'a': 10, 'b': 10}","text_tokens":[".","]","也"," ","可以","一个","{","value","对应","10","都","是","key","fromkeys","'","}","b","none","且","\"","dict",":","方法","其中","新","指定",",",")","包含","[","字典","值","创建","(","a","的","，","每个","键"],"title":"fromkeys","title_tokens":["fromkeys"]},{"location":"Python基础/2.6.Dict.html#get","text":"方法 get 为访问字典项提供了宽松的环境。通常，如果你试图访问字典中没有的项，将引发错误。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a [ \"d\" ] ---------------------------------------------------------------------------KeyError Traceback (most recent call last)<ipython-input-1-b0ca58477f0c> in <module> 1 a = {\"a\":1,\"b\": 2,\"c\":3} ----> 2 a[\"d\"] KeyError: 'd' 而使用 get 不会这样 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . get ( \"d\" ) # 默认返回None，也可以指定返回值 a . get ( \"d\" , \"N/A\" ) 'N/A'","text_tokens":["了",".","通常","中",">","]","环境"," ","如果","traceback","也","{","keyerror","可以","没有","<","项","访问","input","1","返回","last","module","c","试图","引发","2","get","b","}","'","不会","none","/","=","----","而","\"",":","d","你","将","-","方法","宽松","返回值","指定",",","使用","默认","n",")","这样","#","b0ca58477f0c","。","[","most","字典","---------------------------------------------------------------------------","recent","错误","(","a","为","的","in","，","提供","ipython","3","call"],"title":"get","title_tokens":["get"]},{"location":"Python基础/2.6.Dict.html#items","text":"方法 items 返回一个包含所有字典项的列表，其中每个元素都为 (key, value) 的形式。字典项在列表中的排列顺序不确定。返回值属于一种名为字典视图的特殊类型。字典视图可用于迭代。另外，你还可确定其长度以及对其执行成员资格检查。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . items () dict_items([('a', 1), ('b', 2), ('c', 3)]) # dict_items类型 type ( a . items ()) dict_items # 迭代 for i in a . items (): print ( i ) ('a', 1) ('b', 2) ('c', 3) # 迭代 for key , value in a . items (): print ( key , end = \" \" ) print ( value ) a 1 b 2 c 3 # 检查成员资格 ( \"a\" , 1 ) in a . items () True","text_tokens":[".","可","中","type","for","]","i"," ","对","一个","用于","value","{","迭代","items","返回","确定","项","print","1","都","key","c","一种","形式","排列","2","'","}","b","顺序","=","还","长度","类型","\"","在","成员","你",":","dict","所有","方法","其中","返回值","特殊","不",",","检查","另外","true",")","end","执行","#","包含","。","[","字典","视图","以及","(","_","a","为","的","属于","名为","，","每个","其","in","列表","资格","元素","3"],"title":"items","title_tokens":["items"]},{"location":"Python基础/2.6.Dict.html#keysvalues","text":"方法 keys 返回一个字典视图，其中包含字典中的键。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . keys () dict_keys(['a', 'b', 'c']) 方法 values 返回一个字典视图，其中包含字典中的键。 a . values () dict_values([1, 2, 3])","text_tokens":[".","中","]"," ","一个","{","返回","1","c","2","'","}","b","=","\"","dict",":","方法","其中","keys","values",",",")","包含","。","[","字典","视图","(","_","a","的","，","3","键"],"title":"keys和values","title_tokens":["keys","values","和"]},{"location":"Python基础/2.6.Dict.html#pop","text":"方法pop可用于获取与指定键相关联的值，并将该键-值对从字典中删除。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a . pop ( \"a\" ) print ( \"b的值\" , b ) print ( \"a的值\" , a ) b的值 1 a的值 {'b': 2, 'c': 3}","text_tokens":[".","相关","可","中","与"," ","对","用于","相关联","{","print","1","c","2","'","}","pop","b","=","\"","-",":","将","方法","获取","指定",",",")","关联","从","该键","。","字典","值","删除","(","a","并","的","，","3","键"],"title":"pop","title_tokens":["pop"]},{"location":"Python基础/2.6.Dict.html#popitem","text":"方法 popitem 类似于 list.pop ，但 list.pop 弹出列表中的最后一个元素，而 popitem 随机地弹出一个字典项，因为字典项的顺序是不确定的，没有“最后一个元素”的概念。如果你要以高效地方式 逐个 删除并处理所有字典项，这可能很有用，因为这样无需先获取键列表。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . popitem () ('c', 3) a {'a': 1, 'b': 2}","text_tokens":["最后",".","list","很","中"," ","如果","一个","{","确定","没有","项","1","是","“","c","出","2","处理","}","pop","顺序","b","'","=","先","而","\"",":","随机","popitem","你","所有","方法","无需","获取","不","于",",","方式","高效","这样",")","逐个","类似","”","。","以","可能","字典","有用","因为","要","但","删除","(","概念","地","的","地弹","弹","，","并","这","a","列表","元素","3","键"],"title":"popitem","title_tokens":["popitem"]},{"location":"Python基础/2.6.Dict.html#setdefault","text":"方法 setdefault 有点像get，因为它也获取与指定键相关联的值，但除此之外，setdefault还在字典不包含指定的键时，在字典中添加指定的键-值对。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . setdefault ( \"a\" ) a a . setdefault ( \"d\" ) a {'a': 1, 'b': 2, 'c': 3, 'd': None} 如你所见，指定的键不存在时，setdefault返回指定的值并相应地更新字典。如果指定的键存在，就返回其值，并保持字典不变。与 get 一样，值是可选的，如果没有指定，默认为None。","text_tokens":[".","保持","相关","中","与","它"," ","也","对","除此之外","相关联","{","如果","返回","没有","更新","1","是","之外","c","除此","时","2","'","get","b","}","存在","none","=","还","其值","\"","在","-",":","d","你","方法","一样","获取","不","指定",",","默认",")","有点像","添加","关联","包含","。","有点","字典","相应","因为","值","但","如","(","a","并","的","地","不变","，","可选","为","所见","就","3","setdefault","键"],"title":"setdefault","title_tokens":["setdefault"]},{"location":"Python基础/2.6.Dict.html#update","text":"方法update使用一个字典中的项来更新另一个字典。对于通过参数提供的字典，将其项添加到当前字典中。如果当前字典包含键相同的项，就替换它。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . update ({ \"d\" : 4 }) a {'a': 1, 'b': 2, 'c': 3, 'd': 4} 可像调用本章前面讨论的函数dict（类型构造函数）那样调用方法update。这意味着调用update时，可向它提供一个映射、一个由键-值对组成的序列（或其他可迭代对象）或关键字参数。 a . update ( zip ([ \"e\" , \"f\" ],[ 5 , 6 ])) a {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}","text_tokens":["构造函数","参数","它","到","如果","构造","迭代","时","2","'","}","类型","dict","d","通过","添加","调用","其项","字典","项来","那样","对于","提供","本章","这","）","中","关键","{","函数","当前","、","b","方法","[","讨论","意味","update","值","，","3","对象","]","e","对","替换","更新","相同","c","关键字","另","4","=",":","-","由键","f",")","。","可像","的","就",".","可"," ","一个","意味着","项","1","映射","其他","\"","将",",","使用","或","5","包含","6","可向","前面","序列","zip","(","a","（","组成","键"],"title":"update","title_tokens":["update"]},{"location":"Python基础/2.7.推导式.html","text":"import pprint 列表推导式 列表推导式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的推导式。 运用列表推导式， 可以写出非常简洁的代码 。 举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 可以用 list(range(1, 11)) ： list ( range ( 1 , 11 )) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成 [1x1, 2x2, 3x3, ..., 10x10] 怎么做？方法一是循环： L = [] for x in range ( 1 , 11 ): L . append ( x * x ) pprint . pprint ( L ) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表推导式则可以用一行语句代替循环生成上面的list： [ x * x for x in range ( 1 , 11 )] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 写列表推导式时，把 要生成的元素 x * x 放到前面 ，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： [ x * x for x in range ( 1 , 11 ) if x % 2 == 0 ] [4, 16, 36, 64, 100] 还可以使用两层循环，可以生成全排列： [ m + n for m in 'ABC' for n in 'XYZ' ] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 三层和三层以上的循环就很少用到了。 for 循环其实可以同时使用两个甚至多个变量，比如 dict 的 items() 可以同时迭代key和value： d = { 'x' : 'A' , 'y' : 'B' , 'z' : 'C' } for k , v in d . items (): print ( k , '=' , v ) x = A y = B z = C 因此，列表推导式也可以使用两个变量来生成list： d = { 'x' : 'A' , 'y' : 'B' , 'z' : 'C' } [ k + '=' + v for k , v in d . items ()] ['x=A', 'y=B', 'z=C'] 最后把一个list中所有的字符串变成小写： L = [ 'Hello' , 'World' , 'IBM' , 'Apple' ] [ s . lower () for s in L ] ['hello', 'world', 'ibm', 'apple'] 字典推导式 字典推导式和列表推导式是类似的： { key : value for key , value in enumerate ( range ( 4 ))} {0: 0, 1: 1, 2: 2, 3: 3}","text_tokens":["例子","list","全","cy","for","用来","s","却","如果","l","value","举个","迭代","10","cx","多写","bz","时","2","'","}","生成","代替","还","平方","dict","筛选","d","*","ax","字符","字典","熟悉","xyz","很少","把","有用","ay","...","7","？","和","in","1x1","写出","一行","pprint","64","8","中","变量","可以","做","{","繁琐","是","key","排列","加上","偶数","36","b","很快","v","三层","range","而","简单","方法","k","这样","非常","z","类似","[","其实","太","推导","要","但","100","python","comprehensions","，","11","3","16","几次","以上","81","]","也","十分","甚至","print","lower","append","abc","这种","内置","cz","两层","y","c","来","出仅","4","=","10x10","语法",":","9","：","一是","我们","n",")","import","语句","。","简洁","后面","创建","m","的","x","az","apple","因此","列表","就","强大","最后",".","了","小写","3x3","用","出来"," ","循环","但是","by","一个","ibm","放到","world","items","判断","+","1","代码","49","字符串","非常简单","25","写","2x2","上面","多个","enumerate","if","bx","所有","0","同时",",","则","运用","跟","使用","5","%","hello","即","6","怎么","前面","比如","变成","两个","(","a","式","元素","用到"],"title":"2.7.推导式","title_tokens":[".","2.7","式","推导"]},{"location":"Python基础/2.7.推导式.html#_1","text":"列表推导式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的推导式。 运用列表推导式， 可以写出非常简洁的代码 。 举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 可以用 list(range(1, 11)) ： list ( range ( 1 , 11 )) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成 [1x1, 2x2, 3x3, ..., 10x10] 怎么做？方法一是循环： L = [] for x in range ( 1 , 11 ): L . append ( x * x ) pprint . pprint ( L ) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表推导式则可以用一行语句代替循环生成上面的list： [ x * x for x in range ( 1 , 11 )] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 写列表推导式时，把 要生成的元素 x * x 放到前面 ，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： [ x * x for x in range ( 1 , 11 ) if x % 2 == 0 ] [4, 16, 36, 64, 100] 还可以使用两层循环，可以生成全排列： [ m + n for m in 'ABC' for n in 'XYZ' ] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 三层和三层以上的循环就很少用到了。 for 循环其实可以同时使用两个甚至多个变量，比如 dict 的 items() 可以同时迭代key和value： d = { 'x' : 'A' , 'y' : 'B' , 'z' : 'C' } for k , v in d . items (): print ( k , '=' , v ) x = A y = B z = C 因此，列表推导式也可以使用两个变量来生成list： d = { 'x' : 'A' , 'y' : 'B' , 'z' : 'C' } [ k + '=' + v for k , v in d . items ()] ['x=A', 'y=B', 'z=C'] 最后把一个list中所有的字符串变成小写： L = [ 'Hello' , 'World' , 'IBM' , 'Apple' ] [ s . lower () for s in L ] ['hello', 'world', 'ibm', 'apple']","text_tokens":["例子","list","全","cy","for","用来","s","却","如果","l","value","举个","迭代","10","cx","多写","bz","时","2","'","}","生成","代替","还","平方","dict","筛选","d","*","ax","字符","熟悉","xyz","很少","把","有用","ay","...","7","？","和","in","1x1","写出","一行","pprint","64","8","中","变量","可以","做","{","繁琐","是","key","排列","加上","偶数","36","b","很快","v","三层","range","而","简单","方法","k","这样","非常","z","[","其实","太","推导","要","但","100","python","comprehensions","，","11","3","16","几次","以上","81","]","也","十分","甚至","print","lower","append","abc","这种","内置","cz","两层","y","c","来","出仅","4","=","10x10","语法",":","9","：","一是","我们","n",")","语句","。","简洁","后面","创建","m","的","x","az","apple","因此","列表","就","强大","最后",".","了","小写","3x3","用","出来"," ","循环","但是","by","一个","ibm","放到","world","items","判断","+","1","代码","49","字符串","非常简单","25","写","2x2","上面","多个","if","bx","所有","0","同时",",","则","运用","跟","使用","5","%","hello","即","6","怎么","前面","比如","变成","两个","(","a","式","元素","用到"],"title":"列表推导式","title_tokens":["式","列表","推导"]},{"location":"Python基础/2.7.推导式.html#_2","text":"字典推导式和列表推导式是类似的： { key : value for key , value in enumerate ( range ( 4 ))} {0: 0, 1: 1, 2: 2, 3: 3}","text_tokens":["for"," ","{","value","1","是","key","2","}","4","range",":","enumerate","：","0",",",")","类似","字典","推导","(","和","的","in","式","列表","3"],"title":"字典推导式","title_tokens":["式","字典","推导"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html","text":"赋值 引用（reference） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。 一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。因此，引用亦常被称为该资料的指标或位址。 Python的赋值都是传引用，即name是value的引用。 在python里面，一个变量保存的值是某个对象的引用。Python赋值语句将左侧的符号名称与右侧的值 相关联 。在Python中，我们说名称引用值，或者名称是对值的引用。 下次我们使用这个名称时，便得到与名称相关联的值。 assignment永远不会复制数据，并且多个name可以引用同一个value。 当值具有多个名称时，很容易混淆并将其视为两个名称和两个值。： x = 23 y = x 但将已有的变量赋值给新变量时，Python永远不会复制值。分配只是使左侧的名称引用右侧的值。在这种情况下，我们只有一个23， x 和 y 都引用它，就像我们在上图中看到的那样。 名称是独立于其他名称重新分配的。 如果两个名称引用相同的值，则不会链接这两个名称。重新分配其中一个不会导致另一个也被重新分配： x = 23 y = x x = 12 如果上面嵌入的网页失效，可以参考以下动图： 值一直存在，直到没有名称引用它。 Python会跟踪每个值有多少引用，并自动清除没有引用的值。这被称为“垃圾收集”，意味着你不必清楚值，当它们不再需要时它们会自行消失。 mutable 和 immutable Python的数据类型可以分为原子类型和容器类器： 原子类型：string、number 容器类型：list、tuple、dict、set 原子类型只能保存一个值；容器类型则可以保存多个值。 虽然string可以包含多个字符，但Python中没有字符类型，因此字符串也属于原子类型。 Python对原子类型和容器类型的赋值方式都是一样的： 对于原子类型，name直接指向object 对于容器类器，name指向容器类型对象，容器的每一个元素指向各个元素对象 Python的数据类型还可以分为 immutable 和 mutable ： immutable object : string、tuple、number mutable object : list、dict、set 所谓的mutable、immutable是指name指向的object可不可以在原地址被修改。如果不可以在原地址修改，就只能在新地址创建新对象，name指向新对象（旧对象若没有引用，则会被内存回收机制销毁）： name = 10 print ( \"name的id：\" , id ( name )) name = 20 print ( \"name的id：\" , id ( name )) name的id： 140724285510752 name的id： 140724285511072 如果可以在原地址被修改，那么name的指向就不会改变（容器类型的对象实际上保存的是元素的引用）： name = [ 1 , 2 , 3 , 4 , 5 ] print ( \"name的值:\" , name , \" \" , \"name的id：\" , id ( name )) for num , i in enumerate ( name ): print ( f \"第 {num} 个元素的id\" , id ( i )) name [ 0 ] = 20 print ( \"name的值:\" , name , \" \" , \"name的id：\" , id ( name )) for num , i in enumerate ( name ): print ( f \"第 {num} 个元素的id\" , id ( i )) name的值: [1, 2, 3, 4, 5] name的id： 1441647216520 第0个元素的id 140724285510464 第1个元素的id 140724285510496 第2个元素的id 140724285510528 第3个元素的id 140724285510560 第4个元素的id 140724285510592 name的值: [20, 2, 3, 4, 5] name的id： 1441647216520 第0个元素的id 140724285511072 第1个元素的id 140724285510496 第2个元素的id 140724285510528 第3个元素的id 140724285510560 第4个元素的id 140724285510592 immutable的本质 神话：Python以不同的方式分配可变和不可变的值。 因为mutable对象是可变的，immutable对象不可变，人们可能会觉得mutable对象和immutable对象的值分配方式不一样。但事实上，mutable对象和immutable对象所有的赋值的方式都是一样的。 mutable、immutable只是python语言的一个规定。 从硬件角度说，硬件提供给用户的接口是按照规定设定好的。比如说，操作内存的方式是固定的，不存在可变和不可变。实现python的mutable、immutable就是调用了不同的底层API，或者是不同底层API相互组合来实现的。python将这些规定以python语法的形式提供给用户使用，最后还是编译成0、1去让计算机执行。对于用户来说，可变和不可变对象是语言提供的一个特性，可以完成一些功能，但是对于计算机其实是没区别的。 因此，mutable和immutable的本质区别是Python有没有提供修改值的方法。 不管是可变对象还是不可变对象，Python的赋值方式都是一样的，都是将对象绑定到名字（参见上面的图示和示例代码）。 赋值陷阱——浅拷贝和深拷贝 神话：值是有范围的。 在python中存在作用域这样的概念，人们可能会觉得作用域指的是值（对象）的作用范围，但事实上， 值是没有范围的，作用域指的是名称的作用范围。 我们可以定义一个简单的函数与验证这点。 def check_name_space_range ( x ): print ( \"x的内存地址是：\" + str ( id ( x ))) # 先在最外层的作用域赋值，并打印地址 a = 10 print ( \"a的内存地址是：\" + str ( id ( a ))) check_name_space_range ( a ) a的内存地址是：140724285510752 x的内存地址是：140724285510752 很明显，在内外层作用域的值都是同一个。 陷阱：因为值没有范围，并且赋值不会复制值，这就可能出现可变对象被意外地改变： def variable_change ( x ): x [ 0 ] = 10 return x a = [ 1 , 2 , 3 ] a_other = variable_change ( a ) print ( a ) print ( a_other ) [10, 2, 3] [10, 2, 3] 可以看到， a 、 a_other 都被改变了，因为 a 、 a_other 都是同一个对象。 print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) a的内存地址是：1441620592200 a_other的内存地址是：1441620592200 因此，如果要在函数里面更改可变对象参数的值，最好复制一个副本。 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ] = 10 else : pass return x a = [ 1 , 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [1, 2, 3] [10, 2, 3] a的内存地址是：1441623564040 a_other的内存地址是：1441647218056 a 的值并没有改变，上面的结果看似是没问题的，但还是会有新的”惊喜“。 我们来修改一下 variable_change_shallow 函数 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ][ 0 ] = 10 else : pass return x a = [[ 1 , 2 ], 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [[10, 2], 2, 3] [[10, 2], 2, 3] a的内存地址是：1441667197256 a_other的内存地址是：1441648401544 ”惊喜“就是 a 的值也改变了。因为 x.copy() 只是浅拷贝。 在python里面有三种方式去引用某个值： 引用另一个变量 浅拷贝 深拷贝 这三种方式是有区别的。 import copy a = [ 1 , 2 ,[ 1 , 2 ]] a_reference = a a_shallow = copy . copy ( a ) a_deep_copy = copy . deepcopy ( a ) 变量 a 和 a_reference 都是同一个对象的名称。 浅拷贝得到变量 a_shallow ，它是一个新对象，但 a_shallow 的第三个元素 a_shallow[2] 却是一个已经存在的对象，这和 a 、 a_reference 一样。 深拷贝得到变量 a_deep_copy ，它是一个新对象，并且它的每一个元素也是新的对象。 如果浅拷贝的对象包含了mutable对象，则mutable对象不会拷贝；而深拷贝则会完整拷贝对象。 赋值陷阱——引用不仅仅限于名称 以上所有示例都使用名称作为值的引用，但引用也可以是其他东西。 Python有许多复合数据结构，每个结构都包含对值的引用：列表元素，字典键和值，对象属性等。 其中每一个都可以在赋值符号的左侧使用，以上所有细节都适用于它们。 任何可以出现在赋值语句左侧的内容都是引用 ，在本文中说“名称”的任何地方都可以用“引用”替换。 在上面的示意图中，数字被显示为元素，但实际上，每个元素都是对数字的引用，因此它应该像这样绘制： nums = [ 1 , 2 , 3 ] 但这很快变得复杂，所以上面的绘图用了视觉速记： 如果你有列表元素引用其他可变值，例如子列表，请务必记住列表元素只是对值的引用。 这是一些其他assignment的例子。这些左侧中的每一个都是引用（reference）： my_obj . attr = 23 # 类属性 my_dict [ key ] = 24 # 字典 my_list [ index ] = 25 # 列表 my_obj . attr [ key ][ index ] . attr = \"etc, etc\" # 多个对象嵌套 i = x 指定了名称 i ，但 i[0] = x 并不是指定名称 i ，而是指定了 i 的值的第一个元素。 很多东西都是Assignment。 正如上面所说，许多东西都可以作为引用，python里面有很多东西可以作为assignments。 这些行中的每一行都是名称 X 的赋值： X = ... for X in ... [ ... for X in ... ] ( ... for X in ... ) { ... for X in ... } class X ( ... ): def X ( ... ): def fn ( X ): ... ; fn ( 12 ) with ... as X : except ... as X : import X from ... import X import ... as X from ... import ... as X 注意，我并不是说这些语句像assignments，我的意思是这些语句都是赋值。它们都使名称 X 引用某个值。上面所说的关于赋值的所有内容都适用于所有这些赋值。 在大多数情况下，这些语句将 X 定义在与语句相同的作用域内。Python 2和Python 3之间的细节略有不同。但它们都是真正的赋值，而且每个事实都是关于赋值适用于所有这些。 Python通过赋值来传递函数参数。 让我们来看看这些上面assignment列表中最有趣的一个：调用一个函数。当我定义一个函数时，我将其参数命名为： def my_func ( x , y ): return x + y 这里 x 和 y 是函数 my_func 的参数。当我调用 my_func 时，我提供了实际值作为函数的参数。这些值分配给 参数名称 ，就像使用了赋值语句一样： def my_func ( x , y ): return x + y print ( my_func ( 8 , 9 )) 17 调用 my_func 时，8被赋值给名称 x ，9被赋值给名称 y 。该赋值与我们一直在讨论的简单赋值语句完全相同。名称 x 和 y 是函数的本地名称（local），因此当函数返回时，这些名称就会消失。但是，如果它们引用的值仍然被其他名称引用，则值仍然存在。 就像所有其他赋值一样，可变值可以传递给函数，并且通过其所有名称可以看到对值的更改。这在<浅拷贝和深拷贝>中已经提到。 名称和值的一些细节 任何名称都可以随时引用任何值。 Python是动态类型的，这意味着名称没有类型。任何名称都可以随时引用任何值。名称可以引用整数，然后引用字符串，然后引用函数，然后引用模块。当然，这可能是一个非常混乱的程序，你不应该这样做，但Python语言不会介意。 名称没有类型，值没有范围。 正如名称没有类型一样，值也没有范围。当我们说一个函数有一个局部变量时，我们的意思是该名称的作用域是函数：你不能在函数外部使用该名称，当函数返回时，名称将被销毁。但是正如我们所看到的，如果名称的值具有其他引用，它将继续在函数调用之外。它是本地名称，而不是本地值。 值不能删除，只有名称可以删除。 Python的内存管理对其行为至关重要，你不仅不必删除值，而且无法删除值。 nums = [ 1 , 2 , 3 ] del nums 这不会删除值 nums ，它会删除名称 nums 。该名称将从其范围中删除，然后通常的引用计数开始执行：如果 nums 的值只有一个引用，则将回收该值。但如果它有其他引用，那么它不会被回收。 神话：Python没有变量。 有些人喜欢说，“Python没有变量，它有名字。”这个口号具有误导性。事实是Python有变量，它们的工作方式与C中的变量不同。 名称是Python的变量：它们引用值，并且这些值可以在程序的过程中发生变化（变化）。仅仅因为另一种语言（尽管是一种重要的语言）表现不同，没有理由将Python描述为没有变量。","text_tokens":["assignment","赋值","多数","地方","还是","10","最","该","指标","dict","assignments","set","表现","不","各个","生变","原子","链接","调用","change","误导性","copy","字典","请","计数","比如说","行为","...","传","tuple","修改","in","每个","意外","这","符号","对于","管理","内存地址","一行","参见","不是","{","该值","特性","所说","东西","第一","是","不会","当","有没有","本质","记住","range","某个","看看",";","拷贝","方式","程序","实体","这样","del","译成","23","只能","嵌套","并","python","复制","实现","原","3","不仅","1441667197256","按照","左侧","务必","替换","相关联","结构","当值","等","相同","来","第三个","工作","三个","语法","数字","更改",")","同一","计算","适用","大多数","。","看到","打印","当然","存取","清除","看似","的","程式","其","特定","因此","嵌入","mutable","得到","列表","以下","了","作用域"," ","很多","140724285510464","这里","<","+","仅仅","同一个","字符串","25","这个","混乱","先","理由","将","直到","使用","则","可变","或","5","便","reference","即","shallow","比如","却是","a","本文","属于","大多","局部","元素","被","这点","很","这是","它","相互","而是","value","限于","外部","口号","实际","2","}","动态","还","至关","重新","deep","传递","中说","三种","改变","因为","删除","_","和","许多","提供","check","8","中","消失","space","验证","做","右侧","示例","函数","fn","；","一种","很快","关于","一般而言","中一","而","出现","str","简单","其中","不同","isinstance","讨论","重新分配","好","说","，","继续","事实","与","]","编译成","index","print","没有","attr","local","都","常","140724285510592","func","陷阱","接口","c","string","1441623564040","=","功能","变","浅","而且","我们","视觉","import","并打印","底层","局部变量","并且","整数","间接","自行","对值","就","1441648401544","而言","使","给","第一个","用","不管","实际上","分配","1","略有","那么","误导","不可","范围","多个","有","人","在内","注意","行中","关联","区别","包含","键和值","except","动图","一下","obj","变化","自动","正如","两个","nums","(","里面","人们","随时","例子","名称","参数","如果","到","图示","值有","else","—","时","名字","类型","有些","储存","有趣","于","略有不同","通过","字符","垃圾","亦","失效","一些","描述","变得","硬件","数据类型","尽管","variable","细节","地址","所","other","变量","可以","“","key","来说","会","你","内","神话","我","方法","一样","分为","示意","140724285510560","类","非常","意图","属性","然后","开始","[","其实","本地","绘图","旧","要","值","为","数据结构","网页","称为","例如","一般","容易","固定","以上","name","销毁","任何","对","可不","deepcopy","140724285510752","操作","图","命名","只有","传递函数","4",":","9","情况","之间","算机","f","像","最好","重要","不仅仅","显示","创建","不再","x","过程","指向","意思","12","视为","收集","问题","最后","完成",".","通常","但是","一个","第","意味着","class","24","代码","至关重要","其他","\"","位址","上面","这些","enumerate","if","指","所有","0","下次","指定","def","容器","只是","编译","内存","需要","my","（","地","immutable","觉得","资料","外层","num","清楚","具有","复合","作用","pass","发生","list","回收","for","应该","虽然","结果","number","永远","不能","完全","不必","函数调用","存在","之外","140724285510528","个","api","保存","1441647216520","绘制","#","它们","若","子","角度","模块","介意","规定","去","完全相同","那样","etc","id","提到","变得复杂","）","140724285510496","设定","深","事实上","一直",">","导致","无法","计算机","本质区别","绑定","用户","object","、","形式","混淆","让","1441647218056","明显","在","引用","20","上","意味","组合","惊喜","但","已有","with","概念","独立","喜欢","完整","对象","也","i","语言","速记","返回","这种","参考","y","另","17","机制","复杂","：","新","直接","所以","就是","语句","类器","没","return","可不可以","相关","真正","140724285511072","副本","示意图","发生变化","多少","记忆","已经","定义","数据","内容","跟踪",",","电脑","仍然","执行","1441620592200","”","从","作为","或者","以","可能","记忆体","下","第三","所谓","每","from","它会","as","装置"],"title":"2.8.赋值、immutable、深拷贝","title_tokens":[".","拷贝","、","深","赋值","immutable","2.8"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#_1","text":"引用（reference） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。 一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。因此，引用亦常被称为该资料的指标或位址。 Python的赋值都是传引用，即name是value的引用。 在python里面，一个变量保存的值是某个对象的引用。Python赋值语句将左侧的符号名称与右侧的值 相关联 。在Python中，我们说名称引用值，或者名称是对值的引用。 下次我们使用这个名称时，便得到与名称相关联的值。 assignment永远不会复制数据，并且多个name可以引用同一个value。 当值具有多个名称时，很容易混淆并将其视为两个名称和两个值。： x = 23 y = x 但将已有的变量赋值给新变量时，Python永远不会复制值。分配只是使左侧的名称引用右侧的值。在这种情况下，我们只有一个23， x 和 y 都引用它，就像我们在上图中看到的那样。 名称是独立于其他名称重新分配的。 如果两个名称引用相同的值，则不会链接这两个名称。重新分配其中一个不会导致另一个也被重新分配： x = 23 y = x x = 12 如果上面嵌入的网页失效，可以参考以下动图： 值一直存在，直到没有名称引用它。 Python会跟踪每个值有多少引用，并自动清除没有引用的值。这被称为“垃圾收集”，意味着你不必清楚值，当它们不再需要时它们会自行消失。","text_tokens":["名称","很","assignment","赋值","它","如果","值有","value","永远","不必","存在","时","该","指标","储存","保存","重新","于","垃圾","亦","链接","失效","它们","和","传","那样","每个","这","符号","）","中","一直","消失","导致","变量","可以","右侧","是","“","不会","让","混淆","当","会","一般而言","中一","在","某个","你","其中","引用","实体","上","23","意味","重新分配","值","但","说","已有","并","python","，","复制","独立","网页","称为","一般","容易","name","对象","左侧","与","也","相关联","没有","都","常","这种","参考","图","当值","y","只有","相同","另","=","：","情况","新","我们","同一","语句","。","像","看到","存取","并且","清除","间接","不再","的","程式","其","特定","因此","x","嵌入","对值","得到","12","自行","视为","就","以下","收集","而言","使","给","相关"," ","一个","意味着","分配","多少","同一个","记忆","这个","其他","数据","位址","多个","上面","将","直到","下次","跟踪","使用","则","电脑","或","便","关联","装置","”","或者","只是","记忆体","reference","即","下","动图","自动","需要","两个","（","里面","资料","被","清楚","具有"],"title":"赋值","title_tokens":["赋值"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#mutable-immutable","text":"Python的数据类型可以分为原子类型和容器类器： 原子类型：string、number 容器类型：list、tuple、dict、set 原子类型只能保存一个值；容器类型则可以保存多个值。 虽然string可以包含多个字符，但Python中没有字符类型，因此字符串也属于原子类型。 Python对原子类型和容器类型的赋值方式都是一样的： 对于原子类型，name直接指向object 对于容器类器，name指向容器类型对象，容器的每一个元素指向各个元素对象 Python的数据类型还可以分为 immutable 和 mutable ： immutable object : string、tuple、number mutable object : list、dict、set 所谓的mutable、immutable是指name指向的object可不可以在原地址被修改。如果不可以在原地址修改，就只能在新地址创建新对象，name指向新对象（旧对象若没有引用，则会被内存回收机制销毁）： name = 10 print ( \"name的id：\" , id ( name )) name = 20 print ( \"name的id：\" , id ( name )) name的id： 140724285510752 name的id： 140724285511072 如果可以在原地址被修改，那么name的指向就不会改变（容器类型的对象实际上保存的是元素的引用）： name = [ 1 , 2 , 3 , 4 , 5 ] print ( \"name的值:\" , name , \" \" , \"name的id：\" , id ( name )) for num , i in enumerate ( name ): print ( f \"第 {num} 个元素的id\" , id ( i )) name [ 0 ] = 20 print ( \"name的值:\" , name , \" \" , \"name的id：\" , id ( name )) for num , i in enumerate ( name ): print ( f \"第 {num} 个元素的id\" , id ( i )) name的值: [1, 2, 3, 4, 5] name的id： 1441647216520 第0个元素的id 140724285510464 第1个元素的id 140724285510496 第2个元素的id 140724285510528 第3个元素的id 140724285510560 第4个元素的id 140724285510592 name的值: [20, 2, 3, 4, 5] name的id： 1441647216520 第0个元素的id 140724285511072 第1个元素的id 140724285510496 第2个元素的id 140724285510528 第3个元素的id 140724285510560 第4个元素的id 140724285510592","text_tokens":["list","回收","for","赋值","如果","虽然","number","10","实际","140724285510528","2","}","还","个","类型","dict","set","保存","不","各个","1441647216520","字符","原子","若","数据类型","改变","和","tuple","修改","in","id","对于","地址","）","140724285510496","中","可以","{","是","object","；","、","不会","会","在","一样","分为","140724285510560","方式","引用","20","[","旧","值","但","只能","python","，","原","3","name","对象","销毁","]","也","i","对","可不","print","没有","140724285510752","都","140724285510592","元素","string","4","=",":","机制","：","新","f","直接",")","。","创建","类器","的","mutable","因此","指向","就","可不可以"," ","一个","140724285510464","第","140724285511072","实际上","1","那么","字符串","不可","数据","多个","\"","enumerate","指","0",",","则","5","包含","容器","内存","所谓","(","（","每","属于","immutable","被","num"],"title":"mutable 和 immutable","title_tokens":["和","immutable"," ","mutable"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#immutable","text":"神话：Python以不同的方式分配可变和不可变的值。 因为mutable对象是可变的，immutable对象不可变，人们可能会觉得mutable对象和immutable对象的值分配方式不一样。但事实上，mutable对象和immutable对象所有的赋值的方式都是一样的。 mutable、immutable只是python语言的一个规定。 从硬件角度说，硬件提供给用户的接口是按照规定设定好的。比如说，操作内存的方式是固定的，不存在可变和不可变。实现python的mutable、immutable就是调用了不同的底层API，或者是不同底层API相互组合来实现的。python将这些规定以python语法的形式提供给用户使用，最后还是编译成0、1去让计算机执行。对于用户来说，可变和不可变对象是语言提供的一个特性，可以完成一些功能，但是对于计算机其实是没区别的。 因此，mutable和immutable的本质区别是Python有没有提供修改值的方法。 不管是可变对象还是不可变对象，Python的赋值方式都是一样的，都是将对象绑定到名字（参见上面的图示和示例代码）。","text_tokens":["赋值","到","相互","图示","还是","存在","名字","api","不","调用","一些","硬件","角度","因为","规定","比如说","去","和","修改","对于","提供","）","设定","参见","事实上","计算机","可以","本质区别","示例","特性","绑定","用户","是","、","形式","让","有没有","来说","本质","会","神话","方法","一样","不同","方式","译成","其实","组合","值","好","但","说","python","，","实现","固定","事实","按照","对象","编译成","语言","没有","都","操作","来","接口","功能","语法","变","：","算机","就是","计算","。","底层","的","mutable","没","因此","最后","完成","了","给"," ","但是","一个","不管","1","分配","代码","不可","上面","这些","将","所有","0","使用","可变","执行","区别","从","以","可能","只是","或者","编译","内存","比如","（","immutable","人们","觉得"],"title":"immutable的本质","title_tokens":["本质","的","immutable"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#_2","text":"神话：值是有范围的。 在python中存在作用域这样的概念，人们可能会觉得作用域指的是值（对象）的作用范围，但事实上， 值是没有范围的，作用域指的是名称的作用范围。 我们可以定义一个简单的函数与验证这点。 def check_name_space_range ( x ): print ( \"x的内存地址是：\" + str ( id ( x ))) # 先在最外层的作用域赋值，并打印地址 a = 10 print ( \"a的内存地址是：\" + str ( id ( a ))) check_name_space_range ( a ) a的内存地址是：140724285510752 x的内存地址是：140724285510752 很明显，在内外层作用域的值都是同一个。 陷阱：因为值没有范围，并且赋值不会复制值，这就可能出现可变对象被意外地改变： def variable_change ( x ): x [ 0 ] = 10 return x a = [ 1 , 2 , 3 ] a_other = variable_change ( a ) print ( a ) print ( a_other ) [10, 2, 3] [10, 2, 3] 可以看到， a 、 a_other 都被改变了，因为 a 、 a_other 都是同一个对象。 print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) a的内存地址是：1441620592200 a_other的内存地址是：1441620592200 因此，如果要在函数里面更改可变对象参数的值，最好复制一个副本。 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ] = 10 else : pass return x a = [ 1 , 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [1, 2, 3] [10, 2, 3] a的内存地址是：1441623564040 a_other的内存地址是：1441647218056 a 的值并没有改变，上面的结果看似是没问题的，但还是会有新的”惊喜“。 我们来修改一下 variable_change_shallow 函数 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ][ 0 ] = 10 else : pass return x a = [[ 1 , 2 ], 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [[10, 2], 2, 3] [[10, 2], 2, 3] a的内存地址是：1441667197256 a_other的内存地址是：1441648401544 ”惊喜“就是 a 的值也改变了。因为 x.copy() 只是浅拷贝。 在python里面有三种方式去引用某个值： 引用另一个变量 浅拷贝 深拷贝 这三种方式是有区别的。 import copy a = [ 1 , 2 ,[ 1 , 2 ]] a_reference = a a_shallow = copy . copy ( a ) a_deep_copy = copy . deepcopy ( a ) 变量 a 和 a_reference 都是同一个对象的名称。 浅拷贝得到变量 a_shallow ，它是一个新对象，但 a_shallow 的第三个元素 a_shallow[2] 却是一个已经存在的对象，这和 a 、 a_reference 一样。 深拷贝得到变量 a_deep_copy ，它是一个新对象，并且它的每一个元素也是新的对象。 如果浅拷贝的对象包含了mutable对象，则mutable对象不会拷贝；而深拷贝则会完整拷贝对象。","text_tokens":["作用","这点","pass","名称","很","list","赋值","参数","它","如果","结果","还是","10","else","最","存在","2","deep","#","change","copy","三种","改变","因为","去","_","和","修改","variable","id","这","check","意外","内存地址","地址","）","深","事实上","中","space","other","可以","验证","变量","函数","是","“","；","、","不会","1441647218056","会","明显","range","而","出现","在","str","某个","神话","简单","一样","拷贝","方式","引用","这样","isinstance","[","要","值","惊喜","但","概念","并","python","，","复制","3","1441667197256","完整","事实","name","对象","与","]","也","deepcopy","print","没有","140724285510752","都","元素","陷阱","来","第三个","1441623564040","另","=","三个",":","：","新","浅","更改","我们",")","同一","import","就是","并打印","。","看到","最好","打印","并且","看似","的","x","return","没","因此","mutable","得到","就","1441648401544","问题","了",".","作用域"," ","一个","副本","+","1","同一个","已经","范围","定义","先","\"","上面","if","指","有","0",",","则","可变","在内","区别","def","1441620592200","”","包含","可能","只是","reference","一下","内存","shallow","第三","却是","(","（","a","地","每","里面","人们","觉得","外层","被"],"title":"赋值陷阱——浅拷贝和深拷贝","title_tokens":["—","浅","拷贝","陷阱","深","赋值","和"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#_3","text":"以上所有示例都使用名称作为值的引用，但引用也可以是其他东西。 Python有许多复合数据结构，每个结构都包含对值的引用：列表元素，字典键和值，对象属性等。 其中每一个都可以在赋值符号的左侧使用，以上所有细节都适用于它们。 任何可以出现在赋值语句左侧的内容都是引用 ，在本文中说“名称”的任何地方都可以用“引用”替换。 在上面的示意图中，数字被显示为元素，但实际上，每个元素都是对数字的引用，因此它应该像这样绘制： nums = [ 1 , 2 , 3 ] 但这很快变得复杂，所以上面的绘图用了视觉速记： 如果你有列表元素引用其他可变值，例如子列表，请务必记住列表元素只是对值的引用。 这是一些其他assignment的例子。这些左侧中的每一个都是引用（reference）： my_obj . attr = 23 # 类属性 my_dict [ key ] = 24 # 字典 my_list [ index ] = 25 # 列表 my_obj . attr [ key ][ index ] . attr = \"etc, etc\" # 多个对象嵌套 i = x 指定了名称 i ，但 i[0] = x 并不是指定名称 i ，而是指定了 i 的值的第一个元素。 很多东西都是Assignment。 正如上面所说，许多东西都可以作为引用，python里面有很多东西可以作为assignments。 这些行中的每一行都是名称 X 的赋值： X = ... for X in ... [ ... for X in ... ] ( ... for X in ... ) { ... for X in ... } class X ( ... ): def X ( ... ): def fn ( X ): ... ; fn ( 12 ) with ... as X : except ... as X : import X from ... import X import ... as X from ... import ... as X 注意，我并不是说这些语句像assignments，我的意思是这些语句都是赋值。它们都使名称 X 引用某个值。上面所说的关于赋值的所有内容都适用于所有这些赋值。 在大多数情况下，这些语句将 X 定义在与语句相同的作用域内。Python 2和Python 3之间的细节略有不同。但它们都是真正的赋值，而且每个事实都是关于赋值适用于所有这些。 Python通过赋值来传递函数参数。 让我们来看看这些上面assignment列表中最有趣的一个：调用一个函数。当我定义一个函数时，我将其参数命名为： def my_func ( x , y ): return x + y 这里 x 和 y 是函数 my_func 的参数。当我调用 my_func 时，我提供了实际值作为函数的参数。这些值分配给 参数名称 ，就像使用了赋值语句一样： def my_func ( x , y ): return x + y print ( my_func ( 8 , 9 )) 17 调用 my_func 时，8被赋值给名称 x ，9被赋值给名称 y 。该赋值与我们一直在讨论的简单赋值语句完全相同。名称 x 和 y 是函数的本地名称（local），因此当函数返回时，这些名称就会消失。但是，如果它们引用的值仍然被其他名称引用，则值仍然存在。 就像所有其他赋值一样，可变值可以传递给函数，并且通过其所有名称可以看到对值的更改。这在<浅拷贝和深拷贝>中已经提到。","text_tokens":["例子","作用","名称","list","这是","assignment","for","赋值","应该","参数","它","地方","如果","多数","而是","完全","最","实际","存在","时","2","}","该","dict","有趣","assignments","于","略有不同","通过","绘制","传递","#","一些","调用","它们","中说","字典","变得","子","请","完全相同","_","...","和","许多","etc","in","每个","细节","这","符号","提供","提到","变得复杂","一行","）","8","深","中","不是","一直","消失",">","可以","{","示例","函数","所说","东西","第一","fn","是","“","key","让","当","很快","关于","会","记住","出现","在","某个","你","内","我",";","看看","简单","其中","示意","一样","拷贝","不同","类","引用","这样","意图","属性","[","讨论","本地","23","绘图","值","但","with","说","嵌套","为","并","python","，","数据结构","3","例如","以上","事实","左侧","对象","与","任何","也","]","务必","对","替换","index","i","结构","速记","attr","print","返回","local","都","命名","等","元素","func","相同","来","y","传递函数","17","=","数字",":","9","复杂","：","情况","之间","浅","更改","而且","我们",")","所以","视觉","import","适用","语句","大多数","。","像","看到","并且","显示","的","x","其","return","因此","对值","列表","12","意思","就","使","了",".","第一个","给","作用域","用"," ","但是","很多","一个","真正","示意图","class","+","这里","实际上","1","24","略有","分配","<","已经","25","其他","定义","数据","上面","\"","多个","这些","将","所有","有","内容","0","指定",",","使用","可变","则","注意","仍然","行中","def","包含","作为","键和值","”","只是","except","reference","下","obj","正如","my","nums","(","每","本文","（","大多","from","里面","as","被","复合"],"title":"赋值陷阱——引用不仅仅限于名称","title_tokens":["仅仅","—","名称","陷阱","不仅仅","引用","赋值","限于","不仅"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#_4","text":"任何名称都可以随时引用任何值。 Python是动态类型的，这意味着名称没有类型。任何名称都可以随时引用任何值。名称可以引用整数，然后引用字符串，然后引用函数，然后引用模块。当然，这可能是一个非常混乱的程序，你不应该这样做，但Python语言不会介意。 名称没有类型，值没有范围。 正如名称没有类型一样，值也没有范围。当我们说一个函数有一个局部变量时，我们的意思是该名称的作用域是函数：你不能在函数外部使用该名称，当函数返回时，名称将被销毁。但是正如我们所看到的，如果名称的值具有其他引用，它将继续在函数调用之外。它是本地名称，而不是本地值。 值不能删除，只有名称可以删除。 Python的内存管理对其行为至关重要，你不仅不必删除值，而且无法删除值。 nums = [ 1 , 2 , 3 ] del nums 这不会删除值 nums ，它会删除名称 nums 。该名称将从其范围中删除，然后通常的引用计数开始执行：如果 nums 的值只有一个引用，则将回收该值。但如果它有其他引用，那么它不会被回收。 神话：Python没有变量。 有些人喜欢说，“Python没有变量，它有名字。”这个口号具有误导性。事实是Python有变量，它们的工作方式与C中的变量不同。 名称是Python的变量：它们引用值，并且这些值可以在程序的过程中发生变化（变化）。仅仅因为另一种语言（尽管是一种重要的语言）表现不同，没有理由将Python描述为没有变量。","text_tokens":["作用","发生","名称","回收","应该","它","如果","不能","不必","外部","口号","函数调用","之外","时","2","动态","该","名字","类型","有些","至关","表现","不","字符","生变","调用","误导性","描述","它们","计数","模块","因为","介意","尽管","删除","行为","管理","这","所","）","不是","中","变量","可以","做","无法","该值","函数","是","“","一种","不会","当","而","在","你","神话","一样","不同","引用","程序","方式","这样","非常","然后","del","开始","[","本地","意味","值","但","说","为","python","，","3","不仅","继续","喜欢","事实","销毁","与","任何","也","]","对","语言","没有","返回","都","只有","c","工作","另","=","：","而且","我们","。","看到","当然","重要","局部变量","并且","整数","的","其","过程","意思","通常","作用域"," ","但是","一个","意味着","1","发生变化","仅仅","至关重要","那么","字符串","误导","这个","其他","混乱","范围","理由","这些","将","有","人",",","使用","则","执行","”","从","可能","变化","内存","正如","nums","（","局部","它会","随时","被","具有"],"title":"名称和值的一些细节","title_tokens":["名称","值","和","的","细节","一些"]},{"location":"Python基础/2.9.函数.html","text":"函数 关键字 def 引入了一个函数定义。后面必须跟上函数名和在圆括号里的参数序列。函数体从第一行开始，并且一定要缩进。 def func (): pass 函式体的第一个语句可以是字串。这个字串就是函式的文档字符串，或称为 docstring。有很多能将文档字串自动转换为在线或可打印文档的工具，或让用户在代码中交互地浏览它的工具。 执行函数会引入局部命名空间。所有在函数中被赋值的变量和值都将存储在局部命名空间中。 变量引用会首先在函数的局部命名空间里寻找，然后才是闭包函数的局部命名空间，再然后是全局命名空间，最后是内置命名空间。在函数中可以引用全局变量，但是不可直接赋值 (除非用 global 语句进行声明)。 具体细节参考 命名空间和作用域。 根据其它语言的经验，你可能会指出 fib 不是一个函数，而是一个程序，因为它不返回值。事实上，即使没有写 return 语句的函数也会返回一个值—— None 。如果要唯一输出的值是 None，那么解释器会正当的抑制这次返回。如你实在想看看这个值，可以使用 print() 函数。 return 语句从函式中返回一个值。没有表达式参数的 return 语句返回 None。直到函式结束也没有 return 语句也返回 。 函数传参 刚学Python的人可能会疑惑，Python函数传参，到底是传值，还是传引用？ 答案很直接，Python函数传参永远都是传引用。 实际上，Python函数传参就是赋值，所以传参的行为和赋值的行为是一样的。在对可变对象的参数进行操作前，最好先深拷贝参数的值，否则可能会影响全局变量。 参数 函数有四种参数概念：位置参数、默认参数、关键字参数、可变参数。 函数有三种合法调用形式： 仅给出强制参数 给出所有强制参数和部分可选参数 给出所有参数 位置参数 调用函数时可以省略形参名字，根据函数定义的参数位置来传递参数。传入的参数顺序必须和定义参数的顺序一致，且少一个参数都不可以。 def print_hello ( name , sex ): sex_dict = { 1 : u '先生' , 2 : u '女士' } print ( 'hello %s %s , welcome to python world!' % ( name , sex_dict . get ( sex , u '先生' ))) print_hello ( 'Jack' , 1 ) hello Jack 先生, welcome to python world! 关键字参数 函数调用时，可以通过“键=值”形式指定。这可以让函数更加清晰、容易使用，同时关键字参数不需要按顺序指定。 # 以下是用关键字参数正确调用函数的实例 print_hello ( 'tanggu' , sex = 1 ) print_hello ( name = 'tanggu' , sex = 1 ) print_hello ( sex = 1 , name = 'tanggu' ) hello tanggu 先生, welcome to python world! hello tanggu 先生, welcome to python world! hello tanggu 先生, welcome to python world! # 以下是错误的调用方式 print_hello ( 1 , name = 'tanggu' ) print_hello ( name = 'tanggu' , 1 ) print_hello ( sex = 1 , 'tanggu' ) 通过上面的代码可以发现： 有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序的 。 默认参数 用于定义函数，为参数提供默认值，调用函数时可传可不传该默认参数的值。 注意：所有位置参数必须出现在默认参数前，包括函数定义和调用。 # 正确的默认参数定义方式--> 位置参数在前，默认参数在后 def print_hello ( name , sex = 1 ): .... # 错误的定义方式 def print_hello ( sex = 1 , name ): .... # 调用时不传sex的值，则使用默认值1 # print_hello('tanggu') # 调用时传入sex的值，并指定为2 # print_hello('tanggu', 2) 可变参数 定义函数时，有时候我们不确定调用的时候会传递多少个参数（不传参也可以）。此时，可用包裹（packing）位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。 包裹位置传递 def func ( * args ): .... ↓ # func() # func(a) # func(a, b, c) 我们传进的所有参数都会被 args 变量收集，它会根据传进参数的位置合并为一个元组(tuple)， args 是元组类型，这就是包裹位置传递。 包裹关键字传递 def func ( ** kargs ): .... ↓ # func(a=1) # func(a=1, b=2, c=3) kargs是一个字典(dict)，收集所有关键字参数 解包裹参数 * 和 ** ，也可以在函数调用的时候使用，称之为解包裹(unpacking) 在传递元组时，让元组的每一个元素对应一个位置参数 def print_hello ( name , sex ): print name , sex # args = ('tanggu', '男') # print_hello(*args) # tanggu 男 在传递字典时，让字典的每个键值对作为一个关键字参数传递给函数 def print_hello ( kargs ): print kargs # kargs = {'name': 'tanggu', 'sex', u'男'} # print_hello(**kargs) # {'name': 'tanggu', 'sex', u'男'} 位置参数、默认参数、可变参数的混合使用 顺序是：位置参数、默认参数、包裹位置、包裹关键字，定义和调用都应遵循这个顺序。 def func ( name , age , sex = 1 , * args , ** kargs ): print name , age , sex , args , kargs # func('tanggu', 25, 2, 'music', 'sport', class=2) # tanggu 25 1 ('music', 'sport') {'class'=2}","text_tokens":["赋值","还是","形参","遵循","docstring","'","仅","唯一","dict","不","默认","*","调用","字典","行为","传","tuple","存储","每个","这","传值","一行","不是","sport","否则","转换","{","对应","正确","部分","给出","第一","是","看看","拷贝","程序","方式","跟上","表达式","kargs","闭包","错误","并","python","工具","清晰","3","包裹","age","music","再","包括","来","抑制","全局变量",")","传参","....","。","to","打印","先后","的","以下","了","作用域"," ","很多","正当","交互","缩进","字符串","25","这个","全局","实例","将","直到","使用","可变","则","或","!","%","序列","a","局部","被","元素","很","经验","它","而是","浏览","刚学","实际","里","2","}","先后顺序","合法","函式","传递","三种","因为","_","和","位置","提供","女士","中","必须","解","函数","释器","b","出现","字串","少","解释器","首先","不传","第一行","，","可用","事实","更加","print","没有","都","func","关键字","c","顺序","=","到底","即使","在线","我们","实在","时候","并且","如","给","第一个","用","之为","按","实际上","1","那么","不可","none","有","人","选","packing","注意","默认值","前面","自动","(","永远都是","这次","参数","s","传该","如果","答案","确定","—","时","结束","名字","才","类型","称之为","通过","字符","男","jack","？","影响","细节","可传","前","变量","可以","“","寻找","会","你","一样","混合","非常","然后","args","开始","时不传","要","值","表达","为","称为","进行","容易","unpacking","name","对","可不","操作","命名","welcome","调用函数","get","↓",":","之间","最好","后面","收集","最后",".","一定","可","但是","一个","class","代码","上面","文档","所有","返回值","指定","空间","def","一致","想","应","需要","地","（","函式体","u","圆括号","global","--","作用","pass","时可传","tanggu","永远","名","后","函数调用","存在","键值","个","有时候","根据","括号","声明","合并","#","引入","指出","省略","解释","sex","）","事实上",">","关键","用于","能","用户","、","形式","让","有时","显得","在","参数传递","引用","fib","此时","元组","但","传进","概念","疑惑","发现","对象","也","体从","语言","除非","返回","内置","参考","先生","键","且","具体","：","先深","直接","所以","就是","方便","语句","其它","return","传入","参","world","输出","多少","四种","操作前","强制","写","定义","同时",",","执行","”","从","hello","作为","可能","或者","每","它会","达式","数传"],"title":"2.9.函数","title_tokens":["函数",".","2.9"]},{"location":"Python基础/2.9.函数.html#_1","text":"关键字 def 引入了一个函数定义。后面必须跟上函数名和在圆括号里的参数序列。函数体从第一行开始，并且一定要缩进。 def func (): pass 函式体的第一个语句可以是字串。这个字串就是函式的文档字符串，或称为 docstring。有很多能将文档字串自动转换为在线或可打印文档的工具，或让用户在代码中交互地浏览它的工具。 执行函数会引入局部命名空间。所有在函数中被赋值的变量和值都将存储在局部命名空间中。 变量引用会首先在函数的局部命名空间里寻找，然后才是闭包函数的局部命名空间，再然后是全局命名空间，最后是内置命名空间。在函数中可以引用全局变量，但是不可直接赋值 (除非用 global 语句进行声明)。 具体细节参考 命名空间和作用域。 根据其它语言的经验，你可能会指出 fib 不是一个函数，而是一个程序，因为它不返回值。事实上，即使没有写 return 语句的函数也会返回一个值—— None 。如果要唯一输出的值是 None，那么解释器会正当的抑制这次返回。如你实在想看看这个值，可以使用 print() 函数。 return 语句从函式中返回一个值。没有表达式参数的 return 语句返回 None。直到函式结束也没有 return 语句也返回 。","text_tokens":["作用","pass","这次","经验","赋值","参数","它","如果","而是","名","浏览","—","docstring","里","结束","才","唯一","根据","括号","函式","不","声明","字符","引入","因为","指出","和","存储","细节","解释","一行","事实上","中","不是","必须","变量","关键","可以","转换","能","函数","第一","用户","是","释器","让","寻找","会","在","你","看看","字串","解释器","引用","程序","然后","首先","跟上","开始","fib","表达式","第一行","要","值","闭包","表达","为","，","称为","工具","进行","事实","也","体从","语言","print","除非","返回","没有","再","都","内置","参考","命名","func","关键字",":","具体","抑制","即使","全局变量","在线","直接",")","就是","实在","语句","。","打印","并且","其它","后面","如","的","return","最后","了","第一个","一定","可","作用域","用"," ","但是","很多","一个","正当","交互","缩进","代码","输出","那么","字符串","这个","不可","none","写","定义","全局","将","文档","所有","有","直到","返回值","使用","空间","或","执行","def","从","可能","想","序列","自动","(","地","函式体","圆括号","局部","global","被","达式"],"title":"函数","title_tokens":["函数"]},{"location":"Python基础/2.9.函数.html#_2","text":"刚学Python的人可能会疑惑，Python函数传参，到底是传值，还是传引用？ 答案很直接，Python函数传参永远都是传引用。 实际上，Python函数传参就是赋值，所以传参的行为和赋值的行为是一样的。在对可变对象的参数进行操作前，最好先深拷贝参数的值，否则可能会影响全局变量。","text_tokens":["很","对象","赋值","参数"," ","变量","答案","对","还是","否则","永远","函数","实际上","操作","是","刚学","实际","操作前","会","全局","到底","在","一样","拷贝","全局变量","人","引用","直接","可变","先深","传参","所以","就是","可能","。","最好","值","行为","和","？","传","的","疑惑","python","，","永远都是","影响","传值","进行"],"title":"函数传参","title_tokens":["函数","传参"]},{"location":"Python基础/2.9.函数.html#_3","text":"函数有四种参数概念：位置参数、默认参数、关键字参数、可变参数。 函数有三种合法调用形式： 仅给出强制参数 给出所有强制参数和部分可选参数 给出所有参数","text_tokens":["可","参数"," ","关键","函数","部分","给出","四种","、","关键字","形式","强制","仅","合法","：","所有","有","选","默认","可变","调用","。","三种","和","概念","位置"],"title":"参数","title_tokens":["参数"]},{"location":"Python基础/2.9.函数.html#_4","text":"调用函数时可以省略形参名字，根据函数定义的参数位置来传递参数。传入的参数顺序必须和定义参数的顺序一致，且少一个参数都不可以。 def print_hello ( name , sex ): sex_dict = { 1 : u '先生' , 2 : u '女士' } print ( 'hello %s %s , welcome to python world!' % ( name , sex_dict . get ( sex , u '先生' ))) print_hello ( 'Jack' , 1 ) hello Jack 先生, welcome to python world!","text_tokens":["传入","sex",".","name","参数","s","必须"," ","可以","一个","{","print","world","函数","1","都","形参","来","时","welcome","2","'","调用函数","}","顺序","get","名字","先生","=","定义","且","dict",":","根据","少","不",",",")","传递","!","jack","def","调用","hello","%","。","to","一致","_","和","(","省略","的","u","位置","，","python","女士"],"title":"位置参数","title_tokens":["参数","位置"]},{"location":"Python基础/2.9.函数.html#_5","text":"函数调用时，可以通过“键=值”形式指定。这可以让函数更加清晰、容易使用，同时关键字参数不需要按顺序指定。 # 以下是用关键字参数正确调用函数的实例 print_hello ( 'tanggu' , sex = 1 ) print_hello ( name = 'tanggu' , sex = 1 ) print_hello ( sex = 1 , name = 'tanggu' ) hello tanggu 先生, welcome to python world! hello tanggu 先生, welcome to python world! hello tanggu 先生, welcome to python world! # 以下是错误的调用方式 print_hello ( 1 , name = 'tanggu' ) print_hello ( name = 'tanggu' , 1 ) print_hello ( sex = 1 , 'tanggu' ) 通过上面的代码可以发现： 有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序的 。","text_tokens":["sex","name","更加","tanggu","参数","用","必须"," ","可以","关键","按","正确","print","world","函数","1","代码","是","“","函数调用","、","关键字","时","形式","让","'","调用函数","welcome","顺序","存在","先生","=","实例","上面","在","先后顺序","：","有","之间","同时","不","指定",",","通过","使用","方式",")","!","#","调用","”","hello","。","容易","to","前面","先后","值","需要","错误","但","_","(","的","python","，","发现","这","位置","以下","清晰","键"],"title":"关键字参数","title_tokens":["参数","关键字","关键"]},{"location":"Python基础/2.9.函数.html#_6","text":"用于定义函数，为参数提供默认值，调用函数时可传可不传该默认参数的值。 注意：所有位置参数必须出现在默认参数前，包括函数定义和调用。 # 正确的默认参数定义方式--> 位置参数在前，默认参数在后 def print_hello ( name , sex = 1 ): .... # 错误的定义方式 def print_hello ( sex = 1 , name ): .... # 调用时不传sex的值，则使用默认值1 # print_hello('tanggu') # 调用时传入sex的值，并指定为2 # print_hello('tanggu', 2)","text_tokens":["sex","可传","传入","时可传","前",">","name","参数","tanggu","传该"," ","必须","用于","可不","正确","print","函数","1","后","包括","时","2","'","调用函数","=","定义","出现","在",":","：","所有","指定","默认",",","方式","则","使用",")","注意","#","调用","def","hello","....","。","默认值","时不传","值","错误","_","和","(","为","的","并","位置","，","提供","--"],"title":"默认参数","title_tokens":["参数","默认"]},{"location":"Python基础/2.9.函数.html#_7","text":"定义函数时，有时候我们不确定调用的时候会传递多少个参数（不传参也可以）。此时，可用包裹（packing）位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。","text_tokens":["包裹","）","参数","参","也","可以","关键","确定","函数","多少","关键字","来","时","有时","会","数传","定义","个","显得","有时候","参数传递","不","我们","packing","传递","非常","不传","调用","方便","。","或者","此时","时候","（","的","位置","，","可用","进行"],"title":"可变参数","title_tokens":["可变","参数"]},{"location":"Python基础/2.9.函数.html#_8","text":"def func ( * args ): .... ↓ # func() # func(a) # func(a, b, c) 我们传进的所有参数都会被 args 变量收集，它会根据传进参数的位置合并为一个元组(tuple)， args 是元组类型，这就是包裹位置传递。","text_tokens":["包裹","参数"," ","变量","一个","都","是","func","c","↓","b","会","类型",":","根据","所有",",","我们","*",")","合并","传递","args","def","#","就是","....","。","元组","传进","(","a","为","的","tuple","位置","，","这","它会","被","收集"],"title":"包裹位置传递","title_tokens":["包裹","传递","位置"]},{"location":"Python基础/2.9.函数.html#_9","text":"def func ( ** kargs ): .... ↓ # func(a=1) # func(a=1, b=2, c=3) kargs是一个字典(dict)，收集所有关键字参数","text_tokens":["参数"," ","关键","一个","1","是","func","c","关键字","2","↓","b","=","dict",":","所有",",","*",")","def","#","....","字典","kargs","(","a","，","收集","3"],"title":"包裹关键字传递","title_tokens":["包裹","传递","关键字","关键"]},{"location":"Python基础/2.9.函数.html#_10","text":"* 和 ** ，也可以在函数调用的时候使用，称之为解包裹(unpacking) 在传递元组时，让元组的每一个元素对应一个位置参数 def print_hello ( name , sex ): print name , sex # args = ('tanggu', '男') # print_hello(*args) # tanggu 男 在传递字典时，让字典的每个键值对作为一个关键字参数传递给函数 def print_hello ( kargs ): print kargs # kargs = {'name': 'tanggu', 'sex', u'男'} # print_hello(**kargs) # {'name': 'tanggu', 'sex', u'男'}","text_tokens":["包裹","sex","给","name","tanggu","参数","之为","也"," ","可以","一个","对","关键","{","解","对应","print","函数","函数调用","键值","关键字","时","让","'","}","=","称之为","在",":","参数传递",",","使用","*","男",")","传递","args","def","调用","hello","#","作为","元组","字典","时候","kargs","(","和","每","_","的","u","位置","，","每个","元素","数传","unpacking"],"title":"解包裹参数","title_tokens":["包裹","参数","解"]},{"location":"Python基础/2.9.函数.html#_11","text":"顺序是：位置参数、默认参数、包裹位置、包裹关键字，定义和调用都应遵循这个顺序。 def func ( name , age , sex = 1 , * args , ** kargs ): print name , age , sex , args , kargs # func('tanggu', 25, 2, 'music', 'sport', class=2) # tanggu 25 1 ('music', 'sport') {'class'=2}","text_tokens":["包裹","sex","name","tanggu","参数"," ","sport","关键","{","print","age","class","music","1","都","是","遵循","func","、","关键字","2","'","25","这个","顺序","}","=","定义",":","：","默认",",","*",")","args","def","调用","#","。","应","kargs","(","和","位置","，"],"title":"位置参数、默认参数、可变参数的混合使用","title_tokens":["、","默认","使用","可变","参数","混合","的","位置"]},{"location":"Python基础/3.1.异常.html","text":"异常处理机制 异常处理无外乎几件事: 断言（assert） 抛错（raise） 检查（try） 捕获（except） 处理（except, else, finally） 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。当Python脚本发生异常时，异常会从发生异常的位置向程序上层传播。例如异常从函数向外传播到调用函数的地方，如果在这里没有被捕获，则继续向上传播，如果一直都没有被捕获，则传播到程序的最顶层，即主程序（全局作用域）。如果在主程序中也没有处理异常的程序，python将调用默认的异常处理程序，自动匹配异常的类型，然后中止程序并显示栈跟踪信息。 # 在cause_error函数中抛出异常 def cause_error (): raise Exception ( \"Somrthing is wrong\" ) # 在call_cause_error函数中调用cause_error函数 def call_cause_error (): cause_error () def deal_error (): try : cause_error () except : print ( \"Exception handled\" ) call_cause_error () ---------------------------------------------------------------------------Exception Traceback (most recent call last)<ipython-input-1-eb81f11bf5d9> in <module> ----> 1 call_cause_error() <ipython-input-1-ec5e029839e0> in call_cause_error() 1 def call_cause_error(): ----> 2 cause_error() 3 <ipython-input-1-11326a099618> in cause_error() 1 def cause_error(): ----> 2 raise Exception(\"Somrthing is wrong\") 3 Exception: Somrthing is wrong deal_error () Exception handled 如你所见，cause_error中引发的异常依次从cause_error和call_cause_error向外传播，最终导致显示一条栈跟踪信息。调用deal_error时，异常在传播到deal_error时被捕获，并被这里的try/except语句处理。 异常是Python对象，表示一个错误。异常可以作为类被定义, 也可以人为引发异常。 异常处理语句 try : #' try语句中代码首先被运行 < statement > except ： #' 捕获任何在try中引发的异常 < statement > except < name > ： #' 捕获在try中引发的<name>异常 < statement > except < name > ， < data > : #' 如果引发了'name'异常，获得附加的数据 < statement > except ( < name1 > , < name2 >... ): #' 捕获列出的多个异常 < statement > else : #' 如果没有异常发生 < statement > finally : #' 退出try时总会执行 < statement > raise #' 人为引发错误 assert < judgement > #' 断言,判断一定要返回True否则会引发AssertionError raise语句 使用raise...from...语句来提供自己的异常上下文，也可以使用None来禁止上下文。 # 默认输出异常上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 1 try: ----> 2 1/0 3 except ZeroDivisionError: ZeroDivisionError: division by zero During handling of the above exception, another exception occurred: ValueError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError 5 ValueError: # 自定义上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from ZeroDivisionError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)ZeroDivisionError: The above exception was the direct cause of the following exception: ValueError Traceback (most recent call last)<ipython-input-1-00ed5b67ecd8> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from ZeroDivisionError 5 ValueError: # 禁止上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from None ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-d9388897f61c> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from None ValueError: 内置异常 异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告 参考 Python异常处理 python在异常捕获里抛出异常 异常处理","text_tokens":["浮点","tab","地方","somrthing","最","'","该","默认","调用","零","eoferror","行为","...","信息","附加","in","对于","禁止","runtime","不是","否则","转换","ec5e029839e0","cause","特性","是","基类","当","提升","列出","keyboardinterrupt","generatorexit","程序","初始","错误","并","environmenterror","python","实现","查询","3","name1","到达","访问","nameerror","来","----","语法","上层","is",")","计算","above","。","导入","除","error","的","总会","attributeerror","了","作用域","标记"," ","代码生成","11326a099618","这里","<","映射","缩进","处理","这个","几件事","referenceerror","全局","unicode","将","exception","deprecationwarning","无外乎","则","使用","或","5","wrong","judgement","arithmeticerror","匹配","reference","即","序列","finally","userwarning","一条","stopiteration","被","futurewarning","弱","traceback","未声明","last","2","里","ioerror","输入","eof","主程序","occurred","算错","try","name2","未","改变","警告","_","和","位置","提供","致命","系统","standarderror","indentationerror","中","runtimewarning","notimplementederror","最大","函数","释器","为长","unicodedecodeerror","关于","向上","typeerror","解释器","首先","几件","栈","失败","，","内建","继续","处理程序","成器","index","print","没有","都","通知","整型","c","overflowwarning","试图","限制","多","中断","中止","如","就","上下文","程序执行","unicodeencodeerror","of","用","warning","the","1","运行","none","floatingpointerror","抛错","多个","runtimeerror","有","常规","except","systemexit","自动","assertionerror","正常","(","00ed5b67ecd8","raise","废弃","名称","参数","到","如果","迭代","else","pendingdeprecationwarning","时","引发","生成","data","类型","将会","垃圾","following","描述","handling","数据类型","初始化","---------------------------------------------------------------------------","影响","此","ipython","call","unicodetranslateerror","自己","数值","变量","可以","56b5a2b441f0","keyerror","another","input","during","会","memoryerror","你","内","方法","类","更","事件","然后","属性","weak","unicodeerror","本地","generator","旧","要","值","超出","自定","windowserror","例如","一般","可疑","name","任何","对","操作","^","下文","调用函数","4",":","情况","zero","most","特征","显示","overflowerror","过程","语义","importerror","顶层","通常","一定","无效","一个","statement","代码","zerodivisionerror","上下","lookuperror","混用","syntaxwarning","索引","\"","依次","handled","所有","0","语法错误","def","取模","器","内存","计算错误","（","所见","作用","发生","回收","传播","构造","d9388897f61c","taberror","long","操作系统","标准","被弃","声明","true","#","was","baseexception","模块","解释","）","一直",">","导致","无法","deal","用户","module","向外","unboundlocalerror","/","在","脚本","引用","编码","recent","表示","indexerror","assert","对象","也","尚未","人为","返回","behavior","内置","参考","获得","运算","-","机制","：","退出","溢出","direct","检查","捕获","语句","division","请求","传入","相关","异常","解码","syntaxerror","by","空格","判断","输出","已经","向","断言","定义","数据","最终","生成器","跟踪","自定义",",","执行","eb81f11bf5d9","从","作为","抛出","建","下","将来","oserror","valueerror","from","键","systemerror"],"title":"3.1.异常","title_tokens":["3.1",".","异常"]},{"location":"Python基础/3.1.异常.html#_1","text":"异常处理无外乎几件事: 断言（assert） 抛错（raise） 检查（try） 捕获（except） 处理（except, else, finally） 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。当Python脚本发生异常时，异常会从发生异常的位置向程序上层传播。例如异常从函数向外传播到调用函数的地方，如果在这里没有被捕获，则继续向上传播，如果一直都没有被捕获，则传播到程序的最顶层，即主程序（全局作用域）。如果在主程序中也没有处理异常的程序，python将调用默认的异常处理程序，自动匹配异常的类型，然后中止程序并显示栈跟踪信息。 # 在cause_error函数中抛出异常 def cause_error (): raise Exception ( \"Somrthing is wrong\" ) # 在call_cause_error函数中调用cause_error函数 def call_cause_error (): cause_error () def deal_error (): try : cause_error () except : print ( \"Exception handled\" ) call_cause_error () ---------------------------------------------------------------------------Exception Traceback (most recent call last)<ipython-input-1-eb81f11bf5d9> in <module> ----> 1 call_cause_error() <ipython-input-1-ec5e029839e0> in call_cause_error() 1 def call_cause_error(): ----> 2 cause_error() 3 <ipython-input-1-11326a099618> in cause_error() 1 def cause_error(): ----> 2 raise Exception(\"Somrthing is wrong\") 3 Exception: Somrthing is wrong deal_error () Exception handled 如你所见，cause_error中引发的异常依次从cause_error和call_cause_error向外传播，最终导致显示一条栈跟踪信息。调用deal_error时，异常在传播到deal_error时被捕获，并被这里的try/except语句处理。 异常是Python对象，表示一个错误。异常可以作为类被定义, 也可以人为引发异常。","text_tokens":["作用","发生","传播","traceback","到","地方","如果","somrthing","else","last","最","时","引发","2","该","类型","默认","#","调用","主程序","try","---------------------------------------------------------------------------","_","信息","和","影响","位置","in","ipython","call","）","中","一直",">","导致","无法","可以","deal","cause","ec5e029839e0","input","函数","module","是","向外","当","会","/","在","你","脚本","向上","类","程序","事件","然后","几件","栈","recent","错误","并","python","，","表示","例如","3","一般","继续","处理程序","assert","对象","也","print","没有","人为","都","调用函数","----",":","-","情况","上层","is","检查",")","捕获","语句","。","most","中止","如","显示","error","的","过程","就","程序执行","了","顶层","异常","作用域"," ","一个","11326a099618","这里","<","1","处理","几件事","向","断言","抛错","全局","\"","依次","定义","将","handled","最终","exception","跟踪","无外乎",",","则","wrong","执行","def","eb81f11bf5d9","从","作为","抛出","except","匹配","即","下","自动","finally","正常","(","（","一条","所见","被","raise"],"title":"异常处理机制","title_tokens":["机制","处理","异常"]},{"location":"Python基础/3.1.异常.html#_2","text":"try : #' try语句中代码首先被运行 < statement > except ： #' 捕获任何在try中引发的异常 < statement > except < name > ： #' 捕获在try中引发的<name>异常 < statement > except < name > ， < data > : #' 如果引发了'name'异常，获得附加的数据 < statement > except ( < name1 > , < name2 >... ): #' 捕获列出的多个异常 < statement > else : #' 如果没有异常发生 < statement > finally : #' 退出try时总会执行 < statement > raise #' 人为引发错误 assert < judgement > #' 断言,判断一定要返回True否则会引发AssertionError","text_tokens":["发生","了","异常","assert","中",">","name","一定","任何"," ","如果","否则","name1","没有","<","人为","判断","statement","else","返回","代码","获得","时","引发","'","运行","会","data","断言","数据","多个","在",":","：","列出","退出",",","true",")","捕获","首先","执行","#","judgement","语句","try","except","name2","要","finally","assertionerror","错误","(","...","的","附加","，","总会","被","raise"],"title":"异常处理语句","title_tokens":["处理","语句","异常"]},{"location":"Python基础/3.1.异常.html#raise","text":"使用raise...from...语句来提供自己的异常上下文，也可以使用None来禁止上下文。 # 默认输出异常上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 1 try: ----> 2 1/0 3 except ZeroDivisionError: ZeroDivisionError: division by zero During handling of the above exception, another exception occurred: ValueError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError 5 ValueError: # 自定义上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from ZeroDivisionError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)ZeroDivisionError: The above exception was the direct cause of the following exception: ValueError Traceback (most recent call last)<ipython-input-1-00ed5b67ecd8> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from ZeroDivisionError 5 ValueError: # 禁止上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from None ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-d9388897f61c> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from None ValueError:","text_tokens":["异常",">","自己","of","也"," ","traceback","可以","56b5a2b441f0","by","d9388897f61c","cause","another","<","input","the","1","输出","last","module","下文","zerodivisionerror","来","2","上下","during","none","/","4","----","定义",":","-","0","exception","direct","自定义","默认","使用",",","自定",")","zero","5","following","#","above","语句","occurred","。","try","except","most","was","division","handling","---------------------------------------------------------------------------","recent","...","(","valueerror","的","from","，","in","3","提供","00ed5b67ecd8","ipython","上下文","call","raise","禁止"],"title":"raise语句","title_tokens":["语句","raise"]},{"location":"Python基础/3.1.异常.html#_3","text":"异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告","text_tokens":["发生","弱","名称","回收","浮点","废弃","tab","参数","构造","未声明","taberror","迭代","long","pendingdeprecationwarning","操作系统","被","标准","时","生成","ioerror","类型","被弃","输入","eof","声明","将会","垃圾","调用","描述","算错","未","baseexception","零","数据类型","模块","改变","初始化","eoferror","警告","行为","和","此","对于","致命","解释","系统","standarderror","indentationerror","unicodetranslateerror","runtime","中","不是","数值","runtimewarning","变量","notimplementederror","转换","keyerror","最大","特性","用户","是","基类","释器","为长","unicodedecodeerror","unboundlocalerror","关于","/","会","memoryerror","提升","内","keyboardinterrupt","方法","typeerror","解释器","generatorexit","引用","更","属性","初始","weak","unicodeerror","本地","generator","编码","旧","超出","值","错误","environmenterror","失败","python","实现","查询","windowserror","内建","indexerror","一般","可疑","成器","对象","尚未","index","对","没有","到达","访问","behavior","操作","^","通知","nameerror","整型","c","来","运算","试图","overflowwarning","语法","限制","退出","溢出",")","多","计算","语句","导入","中断","除","特征","overflowerror","的","语义","attributeerror","importerror","请求","了","通常","异常","传入","相关","解码","unicodeencodeerror","标记","无效","用"," ","syntaxerror","代码生成","空格","warning","输出","映射","缩进","代码","zerodivisionerror","已经","这个","lookuperror","运行","混用","floatingpointerror","断言","索引","数据","referenceerror","unicode","syntaxwarning","runtimeerror","所有","有","exception","生成器","deprecationwarning","语法错误",",","或","arithmeticerror","执行","常规","取模","建","reference","systemexit","器","将来","序列","自动","assertionerror","oserror","内存","userwarning","(","计算错误","valueerror","stopiteration","futurewarning","键","systemerror"],"title":"内置异常","title_tokens":["异常","内置"]},{"location":"Python基础/3.1.异常.html#_4","text":"Python异常处理 python在异常捕获里抛出异常 异常处理","text_tokens":["异常","里","处理"," ","python","捕获","抛出","在"],"title":"参考","title_tokens":["参考"]},{"location":"Python基础/3.2.命名空间和作用域.html","text":"命名空间 Namespace : namespace 是一个从 name 到 object 的映射。现在大部分的 namespace 通过Python字典 1 实现，将来可能会改变实现方式。 namespace：中文称为命名空间，或者名字空间。 命名空间的最重要的作用是避免名字冲突，各个命名空间是独立的，因此不同的命名空间可以重名。 Namespace 的种类 一般而言，name 产生地点决定其所处的 namespace。例如，在函数内定义的 name 会位于（函数的）局部命名空间。但使用了 global 、 nonlocal 语句会改变这种情况，这个在后面会说到。 built-in namespace ：builtins 模块定义的所有名字存在内置命名空间，这些名字包括内置函数、内置异常、内置常量、内置类型。如果是Python 2，则是 __builtin__ 模块。 global namespace ：每个模块都有全局命名空间，包括所有在模块最外层的作用域中定义的名字，例如类、函数、常量、被导入的模块。 local namespace ：相对于全局命名空间，每一个局部作用域都有一个局部命名空间。例如，函数或类所定义的命名空间，记录了函数参数、函数内的变量、类属性、类方法等。 enclosing namespace ：闭包命名空间不仅记录了当前嵌套函数内定义的变量，还记录了嵌套函数引用的外部变量。 Namespace生命周期 不同类型的命名空间有不同的生命周期： built-in：在 Python 解释器启动时创建，解释器退出时销毁 global：在模块定义被解释器读入时创建，通常也会一直保存到解释器退出，除非使用 del 语句。 local：这里要区分 function 以及 class 定义： 函数的局部命名空间：在函数调用时创建，函数返回或者产生未被捕获的异常时销毁 - 类定义的局部命名空间：在解释器读到类定义创建，离开类定义时创建class object。这个类对象实际上就是这个局部命名空间的包装（见官方对类定义的 说明 ）。 查看Namespace 局部命名空间可以通过 locals() 来访问 全局 （模块级别）命名空间可以通过 globals() 来访问 虽然都是返回命名空间，但 globals() 和 locals() 有一点不一样。 locals() 返回的是局部命名空间的副本，所以修改 locals() 对象并不会影响局部名字空间。 globals 返回是全局命名空间，而不是副本，所以修改 globals() 对象会影响全局命名空间。 # 修改局部命名空间无效 def change_local (): x = 123 print ( \"当前的局部命名空间\" , locals (), sep = \"：\" ) locals ()[ \"x\" ] = 6789 print ( \"修改locals()，并不影响x的值\" , f \"x= {x} \" , sep = \"：\" ) change_local () 当前的局部命名空间：{'x': 123} 修改locals()，并不影响x的值：x=123 # 修改全局命名空间生效 y = 123 globals ()[ \"y\" ] = 456 print ( \"修改全局命名空间生效：\" , f \"y= {y} \" ) 修改全局命名空间生效： y=456 作用域 scope : scope 是Python程序的一块文本区域（即一个代码区域），在这个区域可以直接访问namespace 。 直接访问意味着无须特性的指明引用。在Python中，直接访问是指直接使用name访问对象，如 name ，这会在命名空间搜索名字 name ；而间接访问是指使用形如 objname.attrname 的方式，即引用对象的属性，这不会在命名空间搜索名字 attrname ，而是搜索名字 objname ，再访问其属性。 换而言之，作用域其实就是一个命名空间可以发生作用的代码区域，发生作用是指命名空间可以被作用域直接访问。 作用域与命名空间的关系 命名空间保存着名字到对象的映射，映射关系在作用域中被定义，同时作用域可以通过引用命名空间的名字访问对象。代码区域可以直接引用哪个命名空间中的名字，它也就是哪个命名空间的作用域。有些代码区域可以访问多个命名空间的名字，那么它同时是多个命名空间的作用域。 作用域是静态的（它只是代码文本），而命名空间是动态的，命名空间随着解释器的执行而产生。 有些文章认为动态的作用域就是命名空间。其实并不是，命名空间是一种映射，作用域是一块代码区域。 Python对象通过命名空间被访问，而作用域则限制了Python对象的使用范围。 名字搜索顺序（LEGB） 当一行代码需要使用名字 X 所对应的值， Python会从当前层级的Namespace开始 ，并根据以下顺序，去查找名字 X ： local namespace ：包含局部名字的最内层（innermost）作用域，如函数、方法、类的内部局部作用域。 Enclosing ：根据嵌套层次从内到外搜索，包含非局部（nonlocal）非全局（nonglobal）名字的任意封闭函数的作用域。如两个嵌套的函数，内层函数的作用域是局部作用域，外层函数作用域就是内层函数的 Enclosing 作用域。 global built-in NameError ：如果 Python 在以上4个namespace找不到 X ，将放弃搜索并抛出 NameError 异常： NameError: name 'a' is not defined 程序在运行时，local、global、built-in三个namespace一定存在，但Enclosing namespace不一定存在。 Namespace和scope总结 不能在名字未定义前引用该名字（命名空间不存在该映射关系）。 built-in、global两个命名空间的引入是不能够通过代码操作的，Python 解释器会自动引入它们。注意，这里说的是引入，而不是修改。built-in命名空间是不能被修改的（已经预定义好），但global命名空间可以被Python代码修改。 类定义、函数定义、推导式会引入local命名空间 ，闭包函数定义会引入enclosing命名空间。 会导致命名空间被修改的情况： 类定义、函数定义 2. 赋值语句 3. import 语句、 if 语句、 for 语句、 while 语句5. if 、 for 、 while 语句并不会引入新的命名空间。 作用范围最大的命名空间是global namespace，但global namespace也只是模块级别的。 a 模块不能直接引用在 b 模块定义的name，即使 a 模块已经导入了整个 b 模块： import b 。除非直接导入name： from b import name 。 导入 b 模块中其中一个name： from b import name ，整个 b 模块都会被执行。因为 Python 并不知道 name 在 b.py 文档的何处，为了能够找到 name ，Python 需要执行整个 b.py。 import 语句不一定会改变global namespace，例如 import 语句写在函数内。 根据LEGB搜索规则，外层作用域不能引用内层作用域的变量。 def try_to_define_name (): '''函数中定义了名字i，并绑定了一个整数对象1''' i = 1 # 引用名字i之前，先调用函数定义i try_to_define_name () # 在引用名字i之前，明明调用了函数，定义了名字i，可是还是找不到这个名字。 print ( i ) NameError : name 'i' is not defined 虽然定义了名字 i ，但是定义在了函数的局部作用域对应的局部命名空间中，按照 LEGB 搜索规则，在全局作用域中自然访问不到局部作用域的命名空间；再者，函数调用结束后，这个命名空间被销毁了。 global 和 nonlocal 根据LEGB搜索规则，任何时候，Python程序都可以直接读取全局变量，但是却不可以在内层作用域直接改写上层变量。 可以读取全部变量，这容易理解，因为任何时候，global namespace都可以被访问。但为什么在内层作用域全局变量可以被访问，却不能被修改呢？这看起来像是Python的一个规定，但其实是很自然的事情。在Python中修改变量意味着将一个名字绑定到另一个对象，这需要使用assignment运算符 = 。 这意味着 = 左边的名字会被加入当前的命名空间，名字对应着 = 右边的对象。 例如下面的代码： a = 1 def change_a (): a = 10 change_a () a # 1 1 a = 10 语句在函数作用域中，当它被Python执行时，Python会将 a 加入函数的局部命名空间，而不会将 a 视作全局命名空间的 a 。当我们在最外层作用域引用 a 时，按照LEGB搜索规则，Python会从 a 所在的作用域对应的命名空间（即全局命名空间）开始搜索 a 对应的对象，而不会搜索局部命名空间。再者，此时函数 change_a() 执行完之后，局部命名空间已经被销毁，即使想搜索也搜索不到。 相信你从上面的叙述已经意识到，如果想让Python在内层作用域修改外层作用域的变量，那就需要让Python知道这个变量来自外层作用域。 global 语句和 nonlocal 语句正是可以起到这样的作用。 global 语句声明列在其后的所有标识符将被解析为全局变量。 使用global时有以下两条限制： 在同一代码块中，列在global语句中的所有标识符不能在该global语句前出现。 列在global 语句后的标识符不能被定义成形参，不能出现在for循环控制的目标、类定义和函数定义，或者import语句中。 CPython实现细节：当前实现并未强制履行上面两条限制 2 ，但程序不应该滥用这种自由，因为未来的版本可能会强制履行它们或者不留痕迹的改变程序含义。 nonlocal 语句声明列在其后的所有标识符 关联 到 最近的 enclosing 作用域里定义过的同名变量（不包括全局变量，只是最近的 enclosing 作用域的变量）。 def scope_test (): def do_local (): spam = \"local spam of do_local\" def do_nonlocal (): nonlocal spam spam = \"nonlocal spam of do_nonlocal\" def do_global (): global spam spam = \"global spam of do_global\" spam = \"test spam of scope_test\" # do_local函数内部的赋值不影响scope_test作用域的spam do_local () print ( \"After local assignment:\" , spam ) # do_nonlocal函数内部的赋值影响scope_test作用域的spam，但是不影响全局的spam do_nonlocal () print ( \"After nonlocal assignment:\" , spam ) # do_global 函数内声明的spam存在于全局作用域，而不影响scope_test作用域的 do_global () print ( \"After global assignment:\" , spam ) scope_test () print ( \"In global scope:\" , spam ) After local assignment: test spam of scope_test After nonlocal assignment: nonlocal spam of do_nonlocal After global assignment: nonlocal spam of do_nonlocal In global scope: global spam of do_global nonlocal 语句和 global 语句有两个不同点： 其一， global 语句只是声明标识符来存在于全局命名空间，并不会在当前作用域创建该标识符； nonlocal 语句则会在子函数命名空间中创建与父函数变量同名的标识符： gv = 'a global var' def func (): global gv lv = 'a local var' print ( locals ()) def inn_func (): nonlocal lv global gv print ( locals ()) return inn_func a = func () a () {'lv': 'a local var'} {'lv': 'a local var'} 之所以 nonlocal 语句与 global 语句的处理不同，是因为全局变量的作用域生存期很长，在模块内随时都可以访问，而父函数的局部作用域在父函数执行完毕后便会直接释放，因此 nonlocal 语句必须将父函数的标识符和引用写入enclosing namespace。 其二， global 语句可以声明全局作用域还没存在的名字，而 nonlocal 语句只能将它声明的名字关联到enclosing作用域中已经存在的绑定： # nonlocal 语句之前的eclosing作用域不存在spam 则报错 def scope_test (): def do_nonlocal (): # 父函数作用域要先定义spam，否则报错 nonlocal spam spam = \"nonlocal spam of do_nonlocal\" scope_test () File \"<ipython-input-1-e77162de9535>\", line 5 nonlocal spam ^ SyntaxError: no binding for nonlocal 'spam' found nonlocal 语句只能声明的名字会绑定到离 nonlocal 语句最近的enclosing 作用域（如果enclosing 作用域存在 nonlocal 语句声明的名字）： def scope_test (): spam = \"local spam of scope_test\" def do_local (): spam = \"local spam of do_local\" print ( \"After local assignment:\" , spam ) def do_nonlocal (): # 通过nonlocal声明将spam和最近的enclosing作用域的spam关联 # 所以关联的是do_local函数的spam nonlocal spam spam = \"nonlocal spam of do_nonlocal\" do_nonlocal () print ( \"After nonlocal assignment:\" , spam ) do_local () print ( \"After nonlocal assignment, scope_test's spam:\" , spam ) scope_test () After local assignment: local spam of do_local After nonlocal assignment: nonlocal spam of do_nonlocal After nonlocal assignment, scope_test's spam: local spam of scope_test 因此 nonlocal 语句重新绑定的name的真实作用域是不清楚的，这取决于已经存在的name本来位于那一层作用域。 nonlocal 语句和 global 语句有一个相同点： 当前作用域不能在 nonlocal 语句和 global 语句之前绑定两者声明的标识符： # global def scope_test (): spam = \"conflict\" global spam spam = \"nonlocal spam of do_nonlocal\" scope_test () # nonlocal def scope_test (): spam = \"local spam of scope_test\" def do_nonlocal (): spam = \"conflict\" nonlocal spam spam = \"nonlocal spam of do_nonlocal\" do_nonlocal () print ( \"After nonlocal assignment, scope_test's spam:\" , spam ) scope_test () File \"<ipython-input-1-d9548726e53c>\", line 5 global spam ^ SyntaxError: name 'spam' is assigned to before global declaration 类的作用域和命名空间 类定义的作用域和函数定义的作用域都可以产生局部命名空间，但它们执行机制不一样，有不小的区别。 其一，函数初始化时不会被执行，类初始化时会被执行。 Python读入函数定义时，函数不会被执行： def func (): print ( \"executed\" ) Python读入类定义时，类作用域的代码会被执行： class A : print ( \"executed_A\" ) def A_func ( self ): print ( \"executed_A_func\" ) class B : print ( \"executed_B\" ) class C : print ( \"executed_C\" ) executed_A executed_B executed_C 这看起来感觉有点不可思议，大家都是定义，为什么类定义会被执行，难道不应该是定义被引用时才执行吗？ 其实这也是很自然的事情。Python解释器读入函数定义时，只需要在当前命名空间绑定函数名，不需要创建函数的局部命名空间，自然不需要执行函数作用域的代码。 命名空间的动态性：命名空间在作用域被执行时才产生。 而类定义实际上是类局部命名空间的包装，因此Python解释器读入类定义时，不仅需要在当前命名空间绑定类名，还需要创建类局部命名空间。而命名空间在作用域被执行时才会产生，因此类定义需要在读入的时候就被执行。注意：类方法内的作用域和函数一样，是不会被执行的。 为什么读入类定义就需要创建类局部命名空间？ 因为类具有属性和方法，创建类属性就必须执行代码（进行赋值）。那为什么在读入类定义就创建类属性呢？因为类是创建实例、生成其他类（涉及继承、重载等）的对象，必须在实例之前被创建，在代码加载时就被创建有助于提高效率和降低逻辑复杂度。 另外，类还有一个特点：类可以直接被调用，不一定要先创建实例。这个特点就要求类初始化时就创建类命名空间。例如，创建一个类用于统一管理某一类常量： class Math_Constant : pi = 3.1415926 e = 2.7182818 sqrt_2 = 1.4142135 rho = 1.3247195 如果 Math_Constant 的类属性需要创建一个实例才能被调用，那就太麻烦了，而且类方法、静态方法也就没了意义。 而方法本质是函数，不会在读入定义时被执行。 为什么读入函数定义时不需要创建函数局部命名空间？ 一般来说，函数的局部命名空间主要与参数有关，而参数在函数被调用时才传入，创建了命名空间也意义不大。另外函数不像类那么复杂，也就没必要读入定义时就创建局部命名空间。 其二，类的局部命名空间不在名字搜索路径中。 例如： class A : pi = 3.1415926 def print_pi ( self ): print ( pi ) A () . print_pi () NameError : name 'pi' is not defined 类 A 是 print_pi 方法的外层作用域，按照设想， print_pi 方法中找不到变量 pi ，应该会到上一层作用域中查找，但是 print_pi 方法并没有在类 A 的作用域中查找，而是直接抛出异常。 又例如： class A (): a = 1 b = [ a + i for i in range ( 3 )] #NameError: name 'a' is not defined 执行上段代码，我们可以发现在类 A 内列表推导式无法调取 a 的值。 列表推导式也会产生局部命名空间。 但在函数中，完全没问题： def func (): a = 1 b = [ a + i for i in range ( 3 )] print ( b ) func () # [ 1 , 2 , 3 ] 因此，类 A 中的 a 不同于函数 func 中的 a 在局部命名空间中可以被任意引用。之所以强调”不可以被任意读取”，原因在于在类 A 的局部空间内， a 在当前层级的作用域是可以被直接引用的： class A (): a = 1 c = a + 2 A . c # 3 3 因此，类内可以产生局部命名空间的代码（方法、推导式等）严格上不是作用域。 脚注 参考 python的嵌套函数中局部作用域问题? Python进阶 - 对象，名字以及绑定 即 {name:object} 。 ↩ 当前的CPython已经实现第一条限制，至少在0.29.14版本的CPython中已经实现。 ↩","text_tokens":["生命","assignment","指明","赋值","不留","父","还是","self","完毕","效率","10","最","一类","found","层次","'","真实","该","很长","履行","重载","不","各个","innermost","算符","必要","调用","change","读取","字典","再者","读到","包装","修改","in","每个","管理","这","还有","段","一行","declaration","起到","所处","不是","否则","binding","{","对应","同于","特性","部分","第一","是","哪个","整个","呢","不会","当","启动","一层","本质","6789","range","产生","not","方式","程序","这样","defined","function","del","初始","文本","形","右边","不到","读入","闭包","相同点","嵌套","只能","会到","并","查看","python","实现","能够","3","不仅","按照","调取","namespace","正是","访问","再","nameerror","等","包括","来","之所以","相同","取决","executed","进阶","三个","左边","上层","is","全局变量","1.4142135","预定",")","同一","生存期","cpython","块","。","导入","不像","何处","to","统一","而父","的","objname","其","因此","列表","eclosing","不小","以下","nonlocal","版本","了","line","相信","动态性","作用域"," ","意识","循环","未定义","这里","<","+","不同于","映射","高效率","pi","处理","这个","sep","主要","先","全局","实例","将","周期","使用","则","5","便","conflict","特点","要求","即","类内","提高","某","test","a","一条","时会","其后","局部","式","d9548726e53c","被","builtin","那","很","未定","它","大","而是","痕迹","外部","说明","实际","2","里","}","动态","还","释放","重新","legb","运算符","try","未","改变","因为","_","和","before","并不知道","第一条","中","必须","写入","解析","取决于","可是","最大","函数","当前","一般来说","释器","；","一种","总结","b","一般而言","而","本来","有关","出现","其一","提高效率","其中","不同","解释器","只","随着","built","推导","位于","类名","重名","其所处","说","级别","同名","，","存期","外","义好","与","]","e","列","constant","print","没有","内部","local","都","大部","func","c","脚注","顺序","看起来","难道","涉及","时才","=","1.3247195","限制","即使","含义","我们","而且","内层","import","不知","时候","之前","有助","如","整数","间接","感觉","对类","就","区域","而言","of","离","或类","2.7182818","1","实际上","那么","设想","sqrt","运行","范围","下面","attrname","不可","标识","多个","有","找","注意","关联","inn","区别","包含","换","自动","为什么","两个","视作","(","随时","查找","while","吗","不同点","参数","规则","生存","到","如果","s","原因","不能引用","不可思议","静态方法","时","自然","结束","名字","生成","类型","有些","no","严格","于","通过","scope","e77162de9535","另外","冲突","初始化","路径","这会","？","影响","细节","控制","ipython","所","种类","前","两者","变量","可以","并未","input","搜索","globals","加入","来说","会","全部","你","内","方法","一样","生命周期","类","属性","目标","开始","[","其实","有点","太","之","要","值","大家","至少","为","过","称为","例如","一般","容易","进行","以上","name","销毁","任何","才能","操作","^","命名","一点","明明","在于","调用函数","像是","4",":","define","思议","复杂度","情况","f","为了","重要","后面","创建","x","来自","继承","文章","问题",".","什么","通常","一定","gv","无效","enclosing","但是","一个","意味着","逻辑","class","locals","代码","其他","math","\"","上面","这些","if","所有","指","文档","0.29","而类","找到","标识符","空间","叙述","def","spam","只是","现在","中文","助于","想","任意","需要","其二","（","知道","强调","global","外层","清楚","lv","具有","相对","作用","发生","封闭","for","应该","却","地点","虽然","成形","降低","认为","离开","不能","未来","完全","名","报错","后","关系","函数调用","存在","是因为","个","滥用","见","根据","保存","3.1415926","声明","#","它们","引入","放弃","模块","所在","去","规定","看起","解释","同点","）","一直",">","导致","无法","用于","事情","绑定","object","起来","、","改写","让","函数参数","在","?","引用","123","有助于","此时","上","意味","但","以及","after","发现","独立","之后","改变程序","子函数","对象","也","i","区分","除非","返回","这种","内置","参考","y","一块","运算","记录","另","两条","-","机制","决定","复杂","：","退出","新","builtins","直接","do","所以","捕获","就是","生效","语句","理解","静态","最近","return","没","自由","传入","异常","参","syntaxerror","副本","456","又","14","层级","rho","已经","官方","非","py","加载","强制","写","定义","避免","将父","常量","↩","同时",",","file","高效","执行","无须","从","”","可能","或者","抛出","nonglobal","将来","大部分","麻烦","完","assigned","时有","每","意义","from","着","var","__"],"title":"3.2.命名空间和作用域","title_tokens":["作用","命名",".","和","空间","作用域","3.2"]},{"location":"Python基础/3.2.命名空间和作用域.html#_1","text":"Namespace : namespace 是一个从 name 到 object 的映射。现在大部分的 namespace 通过Python字典 1 实现，将来可能会改变实现方式。 namespace：中文称为命名空间，或者名字空间。 命名空间的最重要的作用是避免名字冲突，各个命名空间是独立的，因此不同的命名空间可以重名。","text_tokens":["作用","name"," ","到","可以","一个","namespace","部分","1","大部","映射","是","object","命名","最","会","名字",":","避免","：","各个","不同","通过","方式","空间","从","。","现在","可能","中文","字典","大部分","将来","或者","改变","重要","冲突","重名","的","python","实现","，","因此","独立","称为"],"title":"命名空间","title_tokens":["命名","空间"]},{"location":"Python基础/3.2.命名空间和作用域.html#namespace","text":"一般而言，name 产生地点决定其所处的 namespace。例如，在函数内定义的 name 会位于（函数的）局部命名空间。但使用了 global 、 nonlocal 语句会改变这种情况，这个在后面会说到。 built-in namespace ：builtins 模块定义的所有名字存在内置命名空间，这些名字包括内置函数、内置异常、内置常量、内置类型。如果是Python 2，则是 __builtin__ 模块。 global namespace ：每个模块都有全局命名空间，包括所有在模块最外层的作用域中定义的名字，例如类、函数、常量、被导入的模块。 local namespace ：相对于全局命名空间，每一个局部作用域都有一个局部命名空间。例如，函数或类所定义的命名空间，记录了函数参数、函数内的变量、类属性、类方法等。 enclosing namespace ：闭包命名空间不仅记录了当前嵌套函数内定义的变量，还记录了嵌套函数引用的外部变量。","text_tokens":["作用","参数","到","地点","如果","外部","最","存在","2","名字","还","类型","于","改变","模块","in","每个","所","）","所处","中","变量","函数","当前","是","、","会","一般而言","函数参数","在","内","方法","产生","类","引用","属性","built","位于","闭包","其所处","但","说","嵌套","python","，","例如","不仅","一般","name","namespace","local","都","这种","内置","命名","等","包括","记录","-","决定","：","情况","builtins","语句","。","导入","后面","的","nonlocal","而言","了","异常","作用域"," ","enclosing","或类","一个","这个","定义","全局","这些","所有","常量","有","使用","则","空间","（","每","局部","global","被","外层","builtin","__","相对"],"title":"Namespace 的种类","title_tokens":["namespace","种类"," ","的"]},{"location":"Python基础/3.2.命名空间和作用域.html#namespace_1","text":"不同类型的命名空间有不同的生命周期： built-in：在 Python 解释器启动时创建，解释器退出时销毁 global：在模块定义被解释器读入时创建，通常也会一直保存到解释器退出，除非使用 del 语句。 local：这里要区分 function 以及 class 定义： 函数的局部命名空间：在函数调用时创建，函数返回或者产生未被捕获的异常时销毁 - 类定义的局部命名空间：在解释器读到类定义创建，离开类定义时创建class object。这个类对象实际上就是这个局部命名空间的包装（见官方对类定义的 说明 ）。","text_tokens":["）","生命","通常","异常","销毁","一直","对象","也"," ","到","区分","离开","除非","这里","class","函数","local","返回","实际上","说明","命名","释器","被","函数调用","object","实际","时","官方","启动","这个","会","定义","类型","在","-","见","：","退出","有","保存","产生","生命周期","不同","周期","解释器","使用","类","空间","function","捕获","del","调用","就是","语句","。","built","或者","未","模块","读入","要","读到","创建","以及","包装","（","的","in","python","，","局部","对类","解释","global"],"title":"Namespace生命周期","title_tokens":["namespace","生命周期","周期","生命"]},{"location":"Python基础/3.2.命名空间和作用域.html#namespace_2","text":"局部命名空间可以通过 locals() 来访问 全局 （模块级别）命名空间可以通过 globals() 来访问 虽然都是返回命名空间，但 globals() 和 locals() 有一点不一样。 locals() 返回的是局部命名空间的副本，所以修改 locals() 对象并不会影响局部名字空间。 globals 返回是全局命名空间，而不是副本，所以修改 globals() 对象会影响全局命名空间。 # 修改局部命名空间无效 def change_local (): x = 123 print ( \"当前的局部命名空间\" , locals (), sep = \"：\" ) locals ()[ \"x\" ] = 6789 print ( \"修改locals()，并不影响x的值\" , f \"x= {x} \" , sep = \"：\" ) change_local () 当前的局部命名空间：{'x': 123} 修改locals()，并不影响x的值：x=123 # 修改全局命名空间生效 y = 123 globals ()[ \"y\" ] = 456 print ( \"修改全局命名空间生效：\" , f \"y= {y} \" ) 修改全局命名空间生效： y=456","text_tokens":["）","不是","对象","无效","]"," ","可以","虽然","{","print","返回","副本","locals","访问","local","当前","都","456","命名","globals","是","一点","来","y","不会","'","}","名字","会","sep","=","6789","全局","而","\"",":","：","有","一样","不","f",",","通过","123","空间",")","所以","#","def","change","生效","。","[","模块","值","级别","但","(","和","（","并","的","修改","影响","，","_","局部","x"],"title":"查看Namespace","title_tokens":["namespace","查看"]},{"location":"Python基础/3.2.命名空间和作用域.html#_2","text":"scope : scope 是Python程序的一块文本区域（即一个代码区域），在这个区域可以直接访问namespace 。 直接访问意味着无须特性的指明引用。在Python中，直接访问是指直接使用name访问对象，如 name ，这会在命名空间搜索名字 name ；而间接访问是指使用形如 objname.attrname 的方式，即引用对象的属性，这不会在命名空间搜索名字 attrname ，而是搜索名字 objname ，再访问其属性。 换而言之，作用域其实就是一个命名空间可以发生作用的代码区域，发生作用是指命名空间可以被作用域直接访问。","text_tokens":["作用","发生","）",".","中","指明","name","对象","作用域"," ","可以","一个","namespace","而是","意味着","特性","访问","再","代码","是","命名","搜索","；","一块","不会","这个","名字","attrname","而","在",":","指","scope","使用","程序","直接","引用","空间","方式","属性","无须","就是","文本","。","形","其实","即","意味","换","之","如","这会","（","间接","的","objname","python","，","其","这","被","区域","而言"],"title":"作用域","title_tokens":["作用","作用域"]},{"location":"Python基础/3.2.命名空间和作用域.html#_3","text":"命名空间保存着名字到对象的映射，映射关系在作用域中被定义，同时作用域可以通过引用命名空间的名字访问对象。代码区域可以直接引用哪个命名空间中的名字，它也就是哪个命名空间的作用域。有些代码区域可以访问多个命名空间的名字，那么它同时是多个命名空间的作用域。 作用域是静态的（它只是代码文本），而命名空间是动态的，命名空间随着解释器的执行而产生。 有些文章认为动态的作用域就是命名空间。其实并不是，命名空间是一种映射，作用域是一块代码区域。 Python对象通过命名空间被访问，而作用域则限制了Python对象的使用范围。","text_tokens":["作用","）","了","中","对象","不是","作用域","它","到","也","可以"," ","认为","访问","映射","代码","命名","哪个","关系","那么","是","释器","一种","一块","动态","名字","范围","定义","而","多个","有些","在","限制","保存","产生","同时","解释器","通过","引用","直接","则","空间","随着","使用","执行","就是","文本","。","只是","其实","静态","（","并","的","python","，","着","解释","被","文章","区域"],"title":"作用域与命名空间的关系","title_tokens":["作用","命名","关系","作用域","与","空间","的"]},{"location":"Python基础/3.2.命名空间和作用域.html#legb","text":"当一行代码需要使用名字 X 所对应的值， Python会从当前层级的Namespace开始 ，并根据以下顺序，去查找名字 X ： local namespace ：包含局部名字的最内层（innermost）作用域，如函数、方法、类的内部局部作用域。 Enclosing ：根据嵌套层次从内到外搜索，包含非局部（nonlocal）非全局（nonglobal）名字的任意封闭函数的作用域。如两个嵌套的函数，内层函数的作用域是局部作用域，外层函数作用域就是内层函数的 Enclosing 作用域。 global built-in NameError ：如果 Python 在以上4个namespace找不到 X ，将放弃搜索并抛出 NameError 异常： NameError: name 'a' is not defined 程序在运行时，local、global、built-in三个namespace一定存在，但Enclosing namespace不一定存在。","text_tokens":["作用","封闭","到","如果","最","存在","层次","时","'","名字","个","根据","不","innermost","放弃","去","in","所","一行","）","对应","函数","当前","搜索","是","、","当","会","在","内","方法","not","类","程序","defined","开始","built","不到","值","但","嵌套","并","python","，","外","以上","name","namespace","内部","local","nameerror","顺序","4","三个","-",":","：","is","内层","就是","。","如","x","的","以下","nonlocal","异常","一定","作用域"," ","enclosing","层级","代码","非","运行","全局","将","找","使用","包含","从","抛出","nonglobal","任意","需要","两个","（","a","局部","外层","global","查找"],"title":"名字搜索顺序（LEGB）","title_tokens":["搜索","）","（","顺序","legb","名字"]},{"location":"Python基础/3.2.命名空间和作用域.html#namespacescope","text":"不能在名字未定义前引用该名字（命名空间不存在该映射关系）。 built-in、global两个命名空间的引入是不能够通过代码操作的，Python 解释器会自动引入它们。注意，这里说的是引入，而不是修改。built-in命名空间是不能被修改的（已经预定义好），但global命名空间可以被Python代码修改。 类定义、函数定义、推导式会引入local命名空间 ，闭包函数定义会引入enclosing命名空间。 会导致命名空间被修改的情况： 类定义、函数定义 2. 赋值语句 3. import 语句、 if 语句、 for 语句、 while 语句5. if 、 for 、 while 语句并不会引入新的命名空间。 作用范围最大的命名空间是global namespace，但global namespace也只是模块级别的。 a 模块不能直接引用在 b 模块定义的name，即使 a 模块已经导入了整个 b 模块： import b 。除非直接导入name： from b import name 。 导入 b 模块中其中一个name： from b import name ，整个 b 模块都会被执行。因为 Python 并不知道 name 在 b.py 文档的何处，为了能够找到 name ，Python 需要执行整个 b.py。 import 语句不一定会改变global namespace，例如 import 语句写在函数内。 根据LEGB搜索规则，外层作用域不能引用内层作用域的变量。 def try_to_define_name (): '''函数中定义了名字i，并绑定了一个整数对象1''' i = 1 # 引用名字i之前，先调用函数定义i try_to_define_name () # 在引用名字i之前，明明调用了函数，定义了名字i，可是还是找不到这个名字。 print ( i ) NameError : name 'i' is not defined 虽然定义了名字 i ，但是定义在了函数的局部作用域对应的局部命名空间中，按照 LEGB 搜索规则，在全局作用域中自然访问不到局部作用域的命名空间；再者，函数调用结束后，这个命名空间被销毁了。","text_tokens":["作用","未定","for","赋值","规则","虽然","还是","不能引用","不能","后","关系","函数调用","存在","自然","2","'","该","结束","名字","根据","不","通过","legb","#","调用","它们","try","引入","模块","改变","因为","再者","_","修改","in","并不知道","解释","）","前","不是","中","导致","变量","可以","对应","可是","最大","函数","绑定","是","释器","搜索","；","、","整个","不会","b","会","而","在","内","其中","not","解释器","类","引用","defined","built","推导","不到","闭包","级别","但","说","并","python","能够","，","3","例如","义好","按照","name","对象","销毁","也","i","namespace","print","除非","访问","local","操作","都","命名","nameerror","明明","调用函数","=","-","define",":","即使","：","情况","新","is","为了","直接","预定","内层",")","import","语句","。","导入","何处","to","不知","之前","整数","的",".","了","一定","作用域"," ","enclosing","但是","一个","未定义","这里","1","映射","代码","已经","py","这个","范围","写","定义","先","全局","if","文档","找","找到","空间","注意","5","执行","def","只是","自动","需要","两个","(","（","a","from","式","知道","局部","global","被","外层","while"],"title":"Namespace和scope总结","title_tokens":["namespace","和","scope","总结"]},{"location":"Python基础/3.2.命名空间和作用域.html#global-nonlocal","text":"根据LEGB搜索规则，任何时候，Python程序都可以直接读取全局变量，但是却不可以在内层作用域直接改写上层变量。 可以读取全部变量，这容易理解，因为任何时候，global namespace都可以被访问。但为什么在内层作用域全局变量可以被访问，却不能被修改呢？这看起来像是Python的一个规定，但其实是很自然的事情。在Python中修改变量意味着将一个名字绑定到另一个对象，这需要使用assignment运算符 = 。 这意味着 = 左边的名字会被加入当前的命名空间，名字对应着 = 右边的对象。 例如下面的代码： a = 1 def change_a (): a = 10 change_a () a # 1 1 a = 10 语句在函数作用域中，当它被Python执行时，Python会将 a 加入函数的局部命名空间，而不会将 a 视作全局命名空间的 a 。当我们在最外层作用域引用 a 时，按照LEGB搜索规则，Python会从 a 所在的作用域对应的命名空间（即全局命名空间）开始搜索 a 对应的对象，而不会搜索局部命名空间。再者，此时函数 change_a() 执行完之后，局部命名空间已经被销毁，即使想搜索也搜索不到。 相信你从上面的叙述已经意识到，如果想让Python在内层作用域修改外层作用域的变量，那就需要让Python知道这个变量来自外层作用域。 global 语句和 nonlocal 语句正是可以起到这样的作用。 global 语句声明列在其后的所有标识符将被解析为全局变量。 使用global时有以下两条限制： 在同一代码块中，列在global语句中的所有标识符不能在该global语句前出现。 列在global 语句后的标识符不能被定义成形参，不能出现在for循环控制的目标、类定义和函数定义，或者import语句中。 CPython实现细节：当前实现并未强制履行上面两条限制 2 ，但程序不应该滥用这种自由，因为未来的版本可能会强制履行它们或者不留痕迹的改变程序含义。 nonlocal 语句声明列在其后的所有标识符 关联 到 最近的 enclosing 作用域里定义过的同名变量（不包括全局变量，只是最近的 enclosing 作用域的变量）。 def scope_test (): def do_local (): spam = \"local spam of do_local\" def do_nonlocal (): nonlocal spam spam = \"nonlocal spam of do_nonlocal\" def do_global (): global spam spam = \"global spam of do_global\" spam = \"test spam of scope_test\" # do_local函数内部的赋值不影响scope_test作用域的spam do_local () print ( \"After local assignment:\" , spam ) # do_nonlocal函数内部的赋值影响scope_test作用域的spam，但是不影响全局的spam do_nonlocal () print ( \"After nonlocal assignment:\" , spam ) # do_global 函数内声明的spam存在于全局作用域，而不影响scope_test作用域的 do_global () print ( \"After global assignment:\" , spam ) scope_test () print ( \"In global scope:\" , spam ) After local assignment: test spam of scope_test After nonlocal assignment: nonlocal spam of do_nonlocal After global assignment: nonlocal spam of do_nonlocal In global scope: global spam of do_global nonlocal 语句和 global 语句有两个不同点： 其一， global 语句只是声明标识符来存在于全局命名空间，并不会在当前作用域创建该标识符； nonlocal 语句则会在子函数命名空间中创建与父函数变量同名的标识符： gv = 'a global var' def func (): global gv lv = 'a local var' print ( locals ()) def inn_func (): nonlocal lv global gv print ( locals ()) return inn_func a = func () a () {'lv': 'a local var'} {'lv': 'a local var'} 之所以 nonlocal 语句与 global 语句的处理不同，是因为全局变量的作用域生存期很长，在模块内随时都可以访问，而父函数的局部作用域在父函数执行完毕后便会直接释放，因此 nonlocal 语句必须将父函数的标识符和引用写入enclosing namespace。 其二， global 语句可以声明全局作用域还没存在的名字，而 nonlocal 语句只能将它声明的名字关联到enclosing作用域中已经存在的绑定： # nonlocal 语句之前的eclosing作用域不存在spam 则报错 def scope_test (): def do_nonlocal (): # 父函数作用域要先定义spam，否则报错 nonlocal spam spam = \"nonlocal spam of do_nonlocal\" scope_test () File \"<ipython-input-1-e77162de9535>\", line 5 nonlocal spam ^ SyntaxError: no binding for nonlocal 'spam' found nonlocal 语句只能声明的名字会绑定到离 nonlocal 语句最近的enclosing 作用域（如果enclosing 作用域存在 nonlocal 语句声明的名字）： def scope_test (): spam = \"local spam of scope_test\" def do_local (): spam = \"local spam of do_local\" print ( \"After local assignment:\" , spam ) def do_nonlocal (): # 通过nonlocal声明将spam和最近的enclosing作用域的spam关联 # 所以关联的是do_local函数的spam nonlocal spam spam = \"nonlocal spam of do_nonlocal\" do_nonlocal () print ( \"After nonlocal assignment:\" , spam ) do_local () print ( \"After nonlocal assignment, scope_test's spam:\" , spam ) scope_test () After local assignment: local spam of do_local After nonlocal assignment: nonlocal spam of do_nonlocal After nonlocal assignment, scope_test's spam: local spam of scope_test 因此 nonlocal 语句重新绑定的name的真实作用域是不清楚的，这取决于已经存在的name本来位于那一层作用域。 nonlocal 语句和 global 语句有一个相同点： 当前作用域不能在 nonlocal 语句和 global 语句之前绑定两者声明的标识符： # global def scope_test (): spam = \"conflict\" global spam spam = \"nonlocal spam of do_nonlocal\" scope_test () # nonlocal def scope_test (): spam = \"local spam of scope_test\" def do_nonlocal (): spam = \"conflict\" nonlocal spam spam = \"nonlocal spam of do_nonlocal\" do_nonlocal () print ( \"After nonlocal assignment, scope_test's spam:\" , spam ) scope_test () File \"<ipython-input-1-d9548726e53c>\", line 5 global spam ^ SyntaxError: name 'spam' is assigned to before global declaration","text_tokens":["作用","很","assignment","for","不同点","应该","规则","赋值","它","却","到","如果","成形","不留","父","生存","完毕","不能","10","未来","痕迹","报错","后","最","存在","found","时","自然","2","里","'","}","该","是因为","名字","真实","还","很长","履行","滥用","根据","释放","重新","不","no","声明","scope","于","e77162de9535","通过","算符","legb","运算符","#","change","读取","它们","s","改变","模块","因为","所在","规定","再者","_","和","？","影响","before","修改","in","细节","这","看起","控制","ipython","同点","declaration","）","起到","前","中",">","两者","必须","写入","变量","可以","否则","{","binding","解析","对应","取决于","事情","并未","input","函数","当前","绑定","搜索","起来","是","加入","、","呢","改写","不会","让","当","；","一层","会","而","本来","出现","在","全部","你","内","其一","不同","类","程序","引用","这样","目标","开始","其实","此时","右边","意味","位于","不到","要","相同点","但","同名","只能","为","并","after","python","，","实现","过","存期","之后","例如","改变程序","容易","按照","子函数","name","对象","销毁","与","任何","也","列","namespace","正是","print","内部","访问","local","都","这种","^","命名","func","包括","来","运算","之所以","相同","取决","另","像是","看起来","两条","=",":","限制","-","左边","：","即使","上层","全局变量","is","含义","我们","直接","内层",")","同一","do","所以","import","生存期","cpython","语句","理解","。","块","to","时候","之前","最近","而父","创建","的","return","没","来自","因此","eclosing","就","以下","自由","nonlocal","版本","什么","line","相信","gv","of","作用域","参","离"," ","但是","意识","一个","循环","enclosing","syntaxerror","意味着","<","locals","1","代码","已经","处理","这个","下面","强制","定义","全局","标识","上面","\"","先","将","所有","将父","有",",","使用","则","标识符","file","空间","叙述","5","便","执行","关联","def","spam","从","inn","或者","可能","只是","conflict","即","想","完","需要","为什么","视作","时有","(","test","a","（","两个","其二","assigned","其后","局部","知道","随时","着","global","被","外层","var","d9548726e53c","清楚","lv","那"],"title":"global和 nonlocal","title_tokens":["nonlocal","和"," ","global"]},{"location":"Python基础/3.2.命名空间和作用域.html#_4","text":"类定义的作用域和函数定义的作用域都可以产生局部命名空间，但它们执行机制不一样，有不小的区别。 其一，函数初始化时不会被执行，类初始化时会被执行。 Python读入函数定义时，函数不会被执行： def func (): print ( \"executed\" ) Python读入类定义时，类作用域的代码会被执行： class A : print ( \"executed_A\" ) def A_func ( self ): print ( \"executed_A_func\" ) class B : print ( \"executed_B\" ) class C : print ( \"executed_C\" ) executed_A executed_B executed_C 这看起来感觉有点不可思议，大家都是定义，为什么类定义会被执行，难道不应该是定义被引用时才执行吗？ 其实这也是很自然的事情。Python解释器读入函数定义时，只需要在当前命名空间绑定函数名，不需要创建函数的局部命名空间，自然不需要执行函数作用域的代码。 命名空间的动态性：命名空间在作用域被执行时才产生。 而类定义实际上是类局部命名空间的包装，因此Python解释器读入类定义时，不仅需要在当前命名空间绑定类名，还需要创建类局部命名空间。而命名空间在作用域被执行时才会产生，因此类定义需要在读入的时候就被执行。注意：类方法内的作用域和函数一样，是不会被执行的。 为什么读入类定义就需要创建类局部命名空间？ 因为类具有属性和方法，创建类属性就必须执行代码（进行赋值）。那为什么在读入类定义就创建类属性呢？因为类是创建实例、生成其他类（涉及继承、重载等）的对象，必须在实例之前被创建，在代码加载时就被创建有助于提高效率和降低逻辑复杂度。 另外，类还有一个特点：类可以直接被调用，不一定要先创建实例。这个特点就要求类初始化时就创建类命名空间。例如，创建一个类用于统一管理某一类常量： class Math_Constant : pi = 3.1415926 e = 2.7182818 sqrt_2 = 1.4142135 rho = 1.3247195 如果 Math_Constant 的类属性需要创建一个实例才能被调用，那就太麻烦了，而且类方法、静态方法也就没了意义。 而方法本质是函数，不会在读入定义时被执行。 为什么读入函数定义时不需要创建函数局部命名空间？ 一般来说，函数的局部命名空间主要与参数有关，而参数在函数被调用时才传入，创建了命名空间也意义不大。另外函数不像类那么复杂，也就没必要读入定义时就创建局部命名空间。 其二，类的局部命名空间不在名字搜索路径中。 例如： class A : pi = 3.1415926 def print_pi ( self ): print ( pi ) A () . print_pi () NameError : name 'pi' is not defined 类 A 是 print_pi 方法的外层作用域，按照设想， print_pi 方法中找不到变量 pi ，应该会到上一层作用域中查找，但是 print_pi 方法并没有在类 A 的作用域中查找，而是直接抛出异常。 又例如： class A (): a = 1 b = [ a + i for i in range ( 3 )] #NameError: name 'a' is not defined 执行上段代码，我们可以发现在类 A 内列表推导式无法调取 a 的值。 列表推导式也会产生局部命名空间。 但在函数中，完全没问题： def func (): a = 1 b = [ a + i for i in range ( 3 )] print ( b ) func () # [ 1 , 2 , 3 ] 因此，类 A 中的 a 不同于函数 func 中的 a 在局部命名空间中可以被任意引用。之所以强调”不可以被任意读取”，原因在于在类 A 的局部空间内， a 在当前层级的作用域是可以被直接引用的： class A (): a = 1 c = a + 2 A . c # 3 3 因此，类内可以产生局部命名空间的代码（方法、推导式等）严格上不是作用域。","text_tokens":["作用","很","for","应该","赋值","参数","降低","如果","大","而是","self","原因","效率","完全","名","不可思议","一类","静态方法","实际","时","自然","2","'","动态","名字","生成","还","3.1415926","重载","不","严格","另外","必要","调用","#","它们","读取","初始化","因为","路径","_","和","？","包装","in","管理","这","看起","解释","还有","段","）","中","不是","必须","变量","可以","用于","无法","事情","同于","函数","当前","绑定","一般来说","是","起来","释器","搜索","、","呢","不会","b","来说","本质","会","一层","range","而","有关","在","其一","内","提高效率","方法","产生","一样","not","不同","解释器","类","只","引用","有助于","defined","属性","初始","其实","有点","上","太","[","推导","不到","读入","类名","要","值","但","大家","会到","并","python","，","发现","例如","不仅","进行","一般","3","按照","name","对象","与","]","也","e","i","constant","才能","调取","print","没有","都","命名","func","等","nameerror","c","之所以","在于","executed","看起来","难道","涉及","时才","=","1.3247195",":","机制","思议","复杂度","复杂","：","is","1.4142135","而且","我们","直接",")","所以","。","不像","统一","时候","之前","有助","静态","创建","的","没","感觉","因此","列表","不小","就","继承","问题","什么","了","传入",".","一定","异常","动态性","作用域"," ","但是","一个","逻辑","class","+","2.7182818","实际上","又","1","代码","不同于","层级","那么","rho","高效率","pi","设想","sqrt","这个","其他","加载","不可","math","主要","定义","先","\"","实例","常量","有","找","而类",",","高效","空间","注意","执行","区别","def","”","抛出","特点","要求","助于","类内","提高","麻烦","某","任意","需要","为什么","其二","(","a","（","意义","时会","局部","式","强调","外层","被","查找","具有","那","吗"],"title":"类的作用域和命名空间","title_tokens":["作用","命名","类","作用域","和","空间","的"]},{"location":"Python基础/3.2.命名空间和作用域.html#_5","text":"","text_tokens":[],"title":"脚注","title_tokens":["脚注"]},{"location":"Python基础/3.2.命名空间和作用域.html#_6","text":"python的嵌套函数中局部作用域问题? Python进阶 - 对象，名字以及绑定 即 {name:object} 。 ↩ 当前的CPython已经实现第一条限制，至少在0.29.14版本的CPython中已经实现。 ↩","text_tokens":["作用",".","中","对象","name","作用域"," ","{","函数","当前","绑定","第一","14","object","已经","}","进阶","名字","-",":","限制","在","0.29","↩","?","cpython","。","即","以及","嵌套","至少","的","一条","python","，","实现","局部","第一条","问题","版本"],"title":"参考","title_tokens":["参考"]},{"location":"Python基础/3.3.闭包.html","text":"闭包的概念 以下引用自维基百科中关于闭包的介绍： 在 计算机科学 中， 闭包 （英语：Closure），又称 词法闭包 （Lexical Closure）或 函数闭包 （function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 闭包的概念出现于60年代，最早实现闭包的程序语言是 Scheme 。之后，闭包被广泛使用于 函数式编程 语言如 ML语言 和 LISP 。很多命令式程序语言也开始支持闭包。 在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。运行时，一旦外部的函数被执行，一个闭包就形成了，闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。其中所引用的变量称作 上值 (upvalue)。 维基百科中对于闭包的介绍，应该还是比较直观的。简而言之：内嵌函数引用了外部函数的变量，这个内嵌函数被执行时，就形成一个闭包。例如： def outside ( a , b ): a = a b = b def inner (): y = a + b print ( locals ()) inner () # 调用outside函数 inner被执行 形成闭包 outside ( 1 , 2 ) {'y': 3, 'a': 1, 'b': 2} inner() 被执行时，创建的局部命名空间会包括其引用的外层函数的变量，这样的局部命名空间被称为闭包命名空间（enclosing namespace）。 注意，在Python中，内嵌函数可以被外层函数返回，也就是Python函数可以返回闭包。 理解什么是闭包不难，但问题在于闭包有什么作用呢？ 闭包的作用 闭包的独特之处在于它可以绑定外部函数的变量，即使生成闭包的环境（外层函数）已经释放，闭包仍然存在。 这个过程很像类生成实例，不同的是外部函数只在调用时生成命名空间，执行完毕后其命名空间就会释放，而类的命名空间在读入定义时创建，一般Python解释器退出才释放命名空间。因此对一些需要重用的功能且不足以定义为类的行为，使用闭包会比使用类占用更少的资源，且更轻巧灵活。 例如：假设我们仅仅想打印出各类动物的叫声，分别以类和闭包来实现： # 类实现 class Animal ( object ): def __init__ ( self , animal ): self . animal = animal def sound ( self , voice ): print ( self . animal , ':' , voice , \"...\" ) dog = Animal ( \"dog\" ) dog . sound ( \"wangwang\" ) dog . sound ( \"wowo\" ) dog : wangwang ... dog : wowo ... # 闭包实现 def voice ( animal ): def sound ( voc ): print ( animal , ':' , voc , \"...\" ) return sound dog = voice ( \"dog\" ) dog ( \"wangwang\" ) dog ( \"wowo\" ) dog : wangwang ... dog : wowo ... 输出结果是完全一样的，但显然类的实现相对繁琐，且这里只是想输出一下动物的叫声，定义一个 Animal 类未免小题大做，而且 voice 函数在执行完毕后，其命名空间就已经释放，但 Animal 类及其实例 dog 的相应属性却一直贮存在内存中。而这种内存占用是没有必要的。 除此之外，闭包还有其他作用。闭包可以减少函数参数的数目，因此可以用于封装。这对并行计算也非常有用，比如可以让每台电脑负责一个函数的计算。另外，闭包在Python中有一种重要的应用——装饰器。这个会在装饰器的文章讲述。 闭包作用域与命名空间 来看一个典型的 闭包 结构： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv = [ 'gv' ] + gv # UnboundLocalError:local variable 'gv' referenced before assignment lv = [] def inn_func (): lv = lv + [ v ] # UnboundLocalError:local variable 'lv' referenced before assignment gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 这段代码似乎没有问题，赋值操作从右到左执行，先从右边的 gv 、 lv 开始执行代码，此时局部作用域还没有 gv 变量，局部作用域也没有 lv 变量，Python应该会访问外层作用域的 gv 、 lv 变量。但实际调用 func() 函数时，上面两处对 gv 和 lv 进行赋值操作的地方都会触发 UnboundLocalError 。 这是因为 Python 在执行函数前，会首先生成各层命名空间和作用域 ，因此 Python 在执行赋值前会将 func 内的 'gv' 'lv' 写入局部命名空间和闭包命名空间： dict_局部命名空间.update({“gv”:['gv'] + gv}) dict_闭包命名空间.update({“lv”:['lv'] + lv}) 当 Python 执行赋值时，按照LEGB搜索规则，会先在局部作用域、闭包作用域内发现 gv 和 lv 标识符，但 gv 和 lv 在局部命名空间和闭包命名空间内都没有绑定对象，从而引发错误。 这段代码本意只是想让具有对象的全局变量 gv 和局部变量 lv 参与运算，而不是局部命名空间中的 gv 和闭包命名空间中的 lv 。为了避免类似的情况发生， Python 引入了 global 、 nonlocal 语句来说明所修饰的 gv 、 lv 分别来自全局命名空间和局部命名空间 ，声明之后，就可以在 func 和 inn_func 内直接改写上层命名空间内 gv 和 lv 的值： gv = [ 'a' , 'global' , 'var' ] print ( \"gv的内存地址\" , id ( gv )) def func ( v ): global gv print ( \"gv的内存地址\" , id ( gv )) gv = [ 'gv' ] + gv lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): nonlocal lv print ( \"lv的内存地址\" , id ( lv )) lv = lv + [ v ] gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () gv的内存地址 1484188467336 gv的内存地址 1484188467336 lv的内存地址 1484188467336 lv的内存地址 1484188467336 ['gv', 'is', 'a', 'global', 'var'] 如上，全局变量 gv 值被函数改写了， inn_func 修改的也确实是父函数 lv 的值 （依据内存地址判断）。 借壳 那么是不是不使用 global 和 nonlocal 就不能达到上面的目的呢？来看看下面这段代码： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv . insert ( 0 , 'gv' ) lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): lv . append ( v ) print ( \"lv的内存地址\" , id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () print ( gv ) lv的内存地址 1484150018632 lv的内存地址 1484150018632 ['gv', 'is', 'a', 'global', 'var'] 可以发现，执行结果同上面完全一致，问题自然来了：“为什么不用 global nonlocal 也可以改写全局变量 gv 和父函数变量 lv 的值？ 为了看清楚这个过程，我们将上面的 gv.insert(0, 'gv') 和 lv.append(v) 改写为 gv[0:0] = ['gv'] 和 lv[:] = [v] ： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv [ 0 : 0 ] = [ 'gv' ] lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): lv [:] = [ v ] print ( \"lv的内存地址\" , id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () print ( gv ) lv的内存地址 1484192557512 lv的内存地址 1484192557512 ['gv', 'is', 'a', 'global', 'var'] 执行结果完全一致，事实上两者之间的本质也是完全一样的。 .insert() 、 .append() 方法并没有修改 gv 和 lv ，而是修改 gv 和 lv 的元素 gv[0:0] 和 lv[:] ，因此 gv 和 lv 并没有被加入局部命名空间。因此，不需要 global 和 nonlocal 修饰就可以直接改写， 这就是“借壳”。 另外，也是借助了list对象的mutable性质。 在 nonlocal 尚未引入 Python 中，比如 Python 2.x 若要在子函数中改写父函数变量的值就得通过这种方法。","text_tokens":["assignment","赋值","inner","地方","父","还是","self","完毕","'","计算机科学","维基百科","dict","从而","不","必要","调用","支持","行为","...","修改","insert","对于","这","内存地址","还有","段","与其","不是","{","重用","减少","是","呢","当","本质","又称","看看","产生","程序","实体","这样","负责","function","从右到左","类似","灵活","右边","读入","闭包","update","错误","嵌套","并","介绍","实现","python","3","按照","namespace","结构","一同","访问","append","中有","包括","组合而成","相同","数目","并行计算","装饰","来","会先","wowo","上层","全局变量","is","性质",")","计算","。","打印","典型","资源","的","其","animal","mutable","因此","1484150018632","以下","nonlocal","了","内嵌","包来","作用域"," ","很多","closure","这里","+","仅仅","广泛","这个","先","全局","实例","将","各层","使用","则","ml","比","或","分别","比如","a","式","局部","被","元素","未免","很","维基百","它","而是","若要","外部","说明","每台","实际","显然","由","2","}","假设","还","同","目的","各类","释放","referenced","维基","legb","命令式","因为","_","和","before","足以","不用","1484188467336","本意","中","年代","写入","函数","释器","一种","b","v","关于","init","而","出现","其中","不同","解释器","只","首先","动物","，","事实","与","上值","]","print","没有","内部","独特","local","都","借壳","func","=","功能","即使","而且","我们","outside","局部变量","如","达到","就","而言","看清楚","小题大做","1","那么","运行","下面","标识","多个","有","注意","inn","包含","dog","一下","封装","为什么","(","应用","及其","参数","规则","如果","除此之外","形成","—","时","编程","引发","自然","两者之间","生成","需","才","voice","完全一致","于","通过","另外","科学","一些","有用","sound","？","最早","variable","60","所","地址","前","两者","变量","可以","搜索","“","加入","会","内","方法","一样","类","不难","为类","非常","更","属性","两处","开始","upvalue","[","相应","前会","之","值","命令","说法","为","称为","似乎","例如","一般","进行","词法","对","操作","命名","在于",":","自","情况","之间","算机","小题","为了","像","重要","1484192557512","创建","x","一旦","过程","来自","更少","文章","问题","什么","占用",".","gv","enclosing","一个","closures","例外","locals","class","看清","称作","代码","贮存","其他","\"","上面","scheme","叫声","0","而类","标识符","空间","def","只是","直观","想","并行","器","一致","英语","内存","需要","（","外层","global","清楚","lv","具有","相对","作用","发生","list","应该","环境","却","结果","认为","离开","不能","完全","轻巧","后","存在","之外","除此","是因为","得","声明","不足","#","来看","引入","闭包会","参与","id","解释","确实","以类","）","比较","事实上","一直","计算机","用于","繁琐","绑定","object","、","改写","让","unboundlocalerror","函数参数","在","借助","是不是","引用","程序语言","不足以","此时","上","组合","依据","但","以及","概念","发现","之后","子函数","对象","也","尚未","语言","wangwang","返回","闭","百科","创造","这种","y","运算","另","处","且","：","退出","直接","所以","就是","语句","理解","包被","voc","return","自由","相关","讲述","lexical","判断","简而言之","输出","已经","出","修饰","定义","避免","lisp",",","电脑","仍然","执行","”","从","可能","触发","var","__"],"title":"3.3.闭包","title_tokens":[".","3.3","闭包"]},{"location":"Python基础/3.3.闭包.html#_1","text":"以下引用自维基百科中关于闭包的介绍： 在 计算机科学 中， 闭包 （英语：Closure），又称 词法闭包 （Lexical Closure）或 函数闭包 （function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 闭包的概念出现于60年代，最早实现闭包的程序语言是 Scheme 。之后，闭包被广泛使用于 函数式编程 语言如 ML语言 和 LISP 。很多命令式程序语言也开始支持闭包。 在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。运行时，一旦外部的函数被执行，一个闭包就形成了，闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。其中所引用的变量称作 上值 (upvalue)。 维基百科中对于闭包的介绍，应该还是比较直观的。简而言之：内嵌函数引用了外部函数的变量，这个内嵌函数被执行时，就形成一个闭包。例如： def outside ( a , b ): a = a b = b def inner (): y = a + b print ( locals ()) inner () # 调用outside函数 inner被执行 形成闭包 outside ( 1 , 2 ) {'y': 3, 'a': 1, 'b': 2} inner() 被执行时，创建的局部命名空间会包括其引用的外层函数的变量，这样的局部命名空间被称为闭包命名空间（enclosing namespace）。 注意，在Python中，内嵌函数可以被外层函数返回，也就是Python函数可以返回闭包。 理解什么是闭包不难，但问题在于闭包有什么作用呢？","text_tokens":["作用","维基百","应该","inner","它","环境","如果","还是","认为","离开","形成","外部","存在","时","由","编程","2","'","}","需","计算机科学","维基百科","维基","不","于","科学","#","一些","调用","命令式","支持","和","？","最早","对于","60","所","与其","）","比较","中","年代","变量","计算机","可以","{","函数","是","一种","呢","b","关于","会","出现","在","又称","其中","产生","不同","引用","程序","实体","程序语言","这样","不难","function","开始","upvalue","组合","闭包","但","以及","命令","嵌套","概念","说法","介绍","，","实现","python","称为","之后","例如","3","上值","也","词法","namespace","语言","print","返回","闭","内部","一同","百科","创造","命名","y","组合而成","相同","包括","在于","另","=",":","自","：","即使","算机",")","所以","计算","outside","就是","理解","。","包被","如","创建","的","其","一旦","就","自由","以下","问题","而言","了","什么","相关","内嵌","lexical"," ","enclosing","很多","一个","closures","closure","例外","locals","简而言之","+","1","称作","代码","广泛","已经","这个","运行","定义","多个","实例","scheme","将","有","lisp",",","使用","则","ml","空间","或","注意","执行","def","包含","可能","直观","英语","(","（","a","式","局部","外层","被"],"title":"闭包的概念","title_tokens":["闭包","的","概念"]},{"location":"Python基础/3.3.闭包.html#_2","text":"闭包的独特之处在于它可以绑定外部函数的变量，即使生成闭包的环境（外层函数）已经释放，闭包仍然存在。 这个过程很像类生成实例，不同的是外部函数只在调用时生成命名空间，执行完毕后其命名空间就会释放，而类的命名空间在读入定义时创建，一般Python解释器退出才释放命名空间。因此对一些需要重用的功能且不足以定义为类的行为，使用闭包会比使用类占用更少的资源，且更轻巧灵活。 例如：假设我们仅仅想打印出各类动物的叫声，分别以类和闭包来实现： # 类实现 class Animal ( object ): def __init__ ( self , animal ): self . animal = animal def sound ( self , voice ): print ( self . animal , ':' , voice , \"...\" ) dog = Animal ( \"dog\" ) dog . sound ( \"wangwang\" ) dog . sound ( \"wowo\" ) dog : wangwang ... dog : wowo ... # 闭包实现 def voice ( animal ): def sound ( voc ): print ( animal , ':' , voc , \"...\" ) return sound dog = voice ( \"dog\" ) dog ( \"wangwang\" ) dog ( \"wowo\" ) dog : wangwang ... dog : wowo ... 输出结果是完全一样的，但显然类的实现相对繁琐，且这里只是想输出一下动物的叫声，定义一个 Animal 类未免小题大做，而且 voice 函数在执行完毕后，其命名空间就已经释放，但 Animal 类及其实例 dog 的相应属性却一直贮存在内存中。而这种内存占用是没有必要的。 除此之外，闭包还有其他作用。闭包可以减少函数参数的数目，因此可以用于封装。这对并行计算也非常有用，比如可以让每台电脑负责一个函数的计算。另外，闭包在Python中有一种重要的应用——装饰器。这个会在装饰器的文章讲述。","text_tokens":["作用","很","参数","它","环境","却","结果","除此之外","self","完毕","完全","轻巧","外部","后","—","每台","存在","之外","时","显然","除此","'","假设","生成","才","各类","释放","voice","另外","不足","#","调用","一些","必要","闭包会","有用","sound","行为","...","和","这","解释","足以","还有","以类","）","中","一直","变量","可以","用于","繁琐","重用","减少","函数","绑定","是","释器","object","一种","让","会","init","函数参数","而","在","一样","不同","解释器","类","只","为类","非常","更","属性","负责","灵活","不足以","相应","读入","闭包","之","但","动物","python","，","实现","例如","一般","也","对","print","wangwang","没有","闭","独特","这种","中有","命名","并行计算","数目","在于","装饰","功能","=","wowo","处","且",":","即使","退出","：","小题","而且","我们",")","计算","。","像","打印","重要","voc","创建","资源","的","其","animal","过程","因此","return","更少","就","文章",".","占用","讲述","包来"," ","一个","小题大做","这里","class","输出","仅仅","贮存","已经","出","这个","其他","定义","\"","实例","叫声","而类","使用",",","电脑","空间","仍然","比","执行","分别","def","dog","只是","器","想","一下","并行","内存","需要","封装","比如","(","（","应用","外层","及其","未免","__","相对"],"title":"闭包的作用","title_tokens":["作用","闭包","的"]},{"location":"Python基础/3.3.闭包.html#_3","text":"来看一个典型的 闭包 结构： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv = [ 'gv' ] + gv # UnboundLocalError:local variable 'gv' referenced before assignment lv = [] def inn_func (): lv = lv + [ v ] # UnboundLocalError:local variable 'lv' referenced before assignment gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 这段代码似乎没有问题，赋值操作从右到左执行，先从右边的 gv 、 lv 开始执行代码，此时局部作用域还没有 gv 变量，局部作用域也没有 lv 变量，Python应该会访问外层作用域的 gv 、 lv 变量。但实际调用 func() 函数时，上面两处对 gv 和 lv 进行赋值操作的地方都会触发 UnboundLocalError 。 这是因为 Python 在执行函数前，会首先生成各层命名空间和作用域 ，因此 Python 在执行赋值前会将 func 内的 'gv' 'lv' 写入局部命名空间和闭包命名空间： dict_局部命名空间.update({“gv”:['gv'] + gv}) dict_闭包命名空间.update({“lv”:['lv'] + lv}) 当 Python 执行赋值时，按照LEGB搜索规则，会先在局部作用域、闭包作用域内发现 gv 和 lv 标识符，但 gv 和 lv 在局部命名空间和闭包命名空间内都没有绑定对象，从而引发错误。 这段代码本意只是想让具有对象的全局变量 gv 和局部变量 lv 参与运算，而不是局部命名空间中的 gv 和闭包命名空间中的 lv 。为了避免类似的情况发生， Python 引入了 global 、 nonlocal 语句来说明所修饰的 gv 、 lv 分别来自全局命名空间和局部命名空间 ，声明之后，就可以在 func 和 inn_func 内直接改写上层命名空间内 gv 和 lv 的值： gv = [ 'a' , 'global' , 'var' ] print ( \"gv的内存地址\" , id ( gv )) def func ( v ): global gv print ( \"gv的内存地址\" , id ( gv )) gv = [ 'gv' ] + gv lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): nonlocal lv print ( \"lv的内存地址\" , id ( lv )) lv = lv + [ v ] gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () gv的内存地址 1484188467336 gv的内存地址 1484188467336 lv的内存地址 1484188467336 lv的内存地址 1484188467336 ['gv', 'is', 'a', 'global', 'var'] 如上，全局变量 gv 值被函数改写了， inn_func 修改的也确实是父函数 lv 的值 （依据内存地址判断）。","text_tokens":["作用","发生","assignment","赋值","应该","规则","地方","父","说明","被","实际","时","引发","'","}","是因为","生成","还","dict","从而","referenced","声明","legb","#","调用","来看","引入","因为","_","和","before","修改","variable","insert","参与","这","id","内存地址","段","1484188467336","所","地址","确实","本意","）","前","不是","中","写入","变量","可以","{","函数","绑定","搜索","“","是","、","改写","unboundlocalerror","当","让","v","会","而","在","内","首先","从右到左","两处","类似","开始","[","此时","上","右边","前会","依据","闭包","update","值","但","错误","python","，","发现","似乎","之后","进行","按照","对象","]","也","对","结构","print","没有","访问","local","操作","都","命名","func","来","运算","会先","=",":","：","情况","上层","全局变量","is","为了","直接",")","语句","。","局部变量","典型","如","的","return","因此","来自","就","问题","nonlocal",".","了","gv","作用域"," ","一个","判断","+","1","具有","代码","修饰","先","标识","全局","上面","\"","将","避免","各层","0",",","标识符","空间","inn","执行","def","”","从","分别","只是","想","内存","触发","(","a","（","局部","global","var","外层","lv"],"title":"闭包作用域与命名空间","title_tokens":["作用","命名","闭包","与","作用域","空间"]},{"location":"Python基础/3.3.闭包.html#_4","text":"那么是不是不使用 global 和 nonlocal 就不能达到上面的目的呢？来看看下面这段代码： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv . insert ( 0 , 'gv' ) lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): lv . append ( v ) print ( \"lv的内存地址\" , id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () print ( gv ) lv的内存地址 1484150018632 lv的内存地址 1484150018632 ['gv', 'is', 'a', 'global', 'var'] 可以发现，执行结果同上面完全一致，问题自然来了：“为什么不用 global nonlocal 也可以改写全局变量 gv 和父函数变量 lv 的值？ 为了看清楚这个过程，我们将上面的 gv.insert(0, 'gv') 和 lv.append(v) 改写为 gv[0:0] = ['gv'] 和 lv[:] = [v] ： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv [ 0 : 0 ] = [ 'gv' ] lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): lv [:] = [ v ] print ( \"lv的内存地址\" , id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () print ( gv ) lv的内存地址 1484192557512 lv的内存地址 1484192557512 ['gv', 'is', 'a', 'global', 'var'] 执行结果完全一致，事实上两者之间的本质也是完全一样的。 .insert() 、 .append() 方法并没有修改 gv 和 lv ，而是修改 gv 和 lv 的元素 gv[0:0] 和 lv[:] ，因此 gv 和 lv 并没有被加入局部命名空间。因此，不需要 global 和 nonlocal 修饰就可以直接改写， 这就是“借壳”。 另外，也是借助了list对象的mutable性质。 在 nonlocal 尚未引入 Python 中，比如 Python 2.x 若要在子函数中改写父函数变量的值就得通过这种方法。","text_tokens":["list","结果","父","而是","不能","完全","若要","被","两者之间","自然","2","'","得","同","目的","完全一致","不","通过","另外","引入","_","和","？","修改","insert","id","这","内存地址","不用","段","地址","事实上","不是","两者","中","变量","可以","函数","是","“","加入","、","呢","改写","v","本质","在","看看","借助","方法","一样","是不是","[","值","为","并","python","，","发现","事实","子函数","对象","]","也","尚未","print","没有","append","这种","借壳","命名","func","元素","来","=",":","：","之间","is","全局变量","为了","我们","直接","性质",")","就是","。","1484192557512","的","return","mutable","过程","因此","x","达到","1484150018632","就","问题","nonlocal",".","了","什么","gv","看清楚"," ","看清","1","代码","那么","这个","下面","修饰","全局","\"","上面","将","0",",","使用","空间","inn","执行","def","”","一致","内存","需要","为什么","比如","(","a","局部","global","var","清楚","lv"],"title":"借壳","title_tokens":["借壳"]},{"location":"Python基础/3.4.装饰器.html","text":"装饰器简述 有时候，我们需要给一个函数添加新功能。那么有一种做法就是修改原函数的代码，直接添加新功能。但这总做法有时未免太繁琐。在python中，直接给原函数套上装饰就可以实现这个需求。 假设有一个这样的函数： def hello (): return 'hello world' # hello函数的名字 print ( \"hello函数的名字：\" , hello . __name__ ) hello函数的名字： hello 现在我们想增强 hello() 函数的功能，希望给返回加上 HTML 标签，比如 <i>hello world</i> ，但有一个要求，不改变原来 hello() 函数的定义。 那么可以这样做： def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped 要注意的是，makeitalic函数的参数是一个函数，返回的结果是wrapped函数。 # 给hello函数套上makeitalic函数 # makeitalic函数返回wrapped函数 # 实际上此时hello变成了wrapped函数 hello = makeitalic ( hello ) 将 hello 函数作为参数传入 makeitalic 函数， makeitalic 函数返回wrapped函数，名字 hello 与 wrapped 函数绑定。此时名字 hello 代表了一个函数，也就是 wrapped 函数有了新的名字—— hello 。 # 可以看出hello函数的名字变了 print ( \"hello函数的名字：\" , hello . __name__ ) hello函数的名字： wrapped 总结一下：为了增强原函数 hello 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数。 事实上， makeitalic 就是一个装饰器（decorator），它『装饰』了函数 hello ，并返回一个函数，将其赋给 hello 。 像上面的情况，可以动态修改函数（或类）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 hello ）为参数，并返回一个包装后的函数（比如上面的 wrapped ）给被装饰函数（ hello ）。 装饰器的一般使用形式 在python中，装饰器一般这样用： @decorator def func (): pass 等价于下面的形式 ： def func (): pass func = decorator ( func ) 装饰器可以定义多个，离函数定义最近的装饰器先被调用，比如 @decorator_one @decorator_two def func (): pass 等价于： def func (): pass func = decorator_one ( decorator_two ( func )) 装饰器还可以带参数，比如： @decorator ( arg1 , arg2 ) def func (): pass 等价于： def func (): pass func = decorator ( arg1 , arg2 )( func ) 例子： def makeitalic2 ( func ): return \"<i>\" + func () + \"</i>\" @makeitalic def hello_2 (): return 'hello world' def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped hello_2 () ' <i> hello world </i> ' 如果返回的不是函数就会这样： @makeitalic def hello_3 (): return 'hello world' def makeitalic ( func ): return \"<i>\" + func () + \"</i>\" hello_3 <function __main__.makeitalic.<locals>.wrapped()> 对带参数的函数进行装饰 前面的例子中，被装饰的函数 hello() 是没有带参数的，我们看看被装饰函数带参数的情况。对前面例子中的 hello() 函数进行改写，使其带参数，如下： def makeitalic ( func ): def wrapped ( * args , ** kwargs ): ret = func ( * args , ** kwargs ) return '<i>' + ret + '</i>' return wrapped @makeitalic def hello ( name ): return 'hello %s ' % name @makeitalic def hello2 ( name1 , name2 ): return 'hello %s , %s ' % ( name1 , name2 ) hello ( 'Jack' ) hello2 ( 'Jack' , \"Lusis\" ) 由于函数 hello 带参数，因此内嵌包装函数 wrapped 需要改变。 带参数的装饰器 上面的例子，我们增强了函数 hello 的功能，给它的返回加上了标签 <i>...</i> ，现在，我们想改用标签 <b>...</b> 或 <p>...</p> 。是不是要像前面一样，再定义一个类似 makeitalic 的装饰器呢？其实，我们可以定义一个函数，将标签作为参数，返回一个装饰器，比如： def wrap_in_tag ( tag ): def decorator ( func ): def wrapped ( * args , ** kwargs ): ret = func ( * args , ** kwargs ) return '<' + tag + '>' + ret + '</' + tag + '>' return wrapped return decorator 生成想要的装饰器了： makebold = wrap_in_tag ( 'b' ) # 根据 'b' 返回 makebold 生成器 @makebold def hello ( name ): return 'hello %s ' % name hello ( 'world' ) ' <b> hello world </b> ' 上面的形式也可以写得更加简洁： @wrap_in_tag ( 'b' ) def hello ( name ): return 'hello %s ' % name 多个装饰器 现在，让我们来看看多个装饰器的例子，为了简单起见，下面的例子就不使用带参数的装饰器。 def makebold ( func ): def wrapped (): return '<b>' + func () + '</b>' return wrapped def makeitalic ( func ): def wrapped (): return '<i>' + func () + '</i>' return wrapped @makebold @makeitalic def hello (): return 'hello world' 上面定义了两个装饰器，对 hello 进行装饰，上面的最后几行代码相当于： def hello (): return 'hello world' hello = makebold ( makeitalic ( hello )) 调用函数 hello： hello () ' <b><i> hello world </i></b> ' 基于类的装饰器 前面的装饰器都是一个函数，其实也可以基于类定义装饰器，看下面的例子： class Bold ( object ): def __init__ ( self , func ): self . func = func def __call__ ( self , * args , ** kwargs ): return '<b>' + self . func ( * args , ** kwargs ) + '</b>' @Bold def hello ( name ): return 'hello %s ' % name hello ( 'world' ) 可以看到，类 Bold 有两个方法： __init__() ：它接收一个函数作为参数，也就是被装饰的函数 __call__() ：让类对象可调用，就像函数调用一样，在调用被装饰函数时被调用 还可以让类装饰器带参数： class Tag ( object ): def __init__ ( self , tag ): self . tag = tag def __call__ ( self , func ): def wrapped ( * args , ** kwargs ): return \"< {tag} > {res} </ {tag} >\" . format ( res = func ( * args , ** kwargs ), tag = self . tag ) return wrapped @Tag ( 'b' ) def hello ( name ): return 'hello %s ' % name 需要注意的是，如果类装饰器有参数， 则 __init__ 接收参数，而 __call__ 接收 func。 装饰器的副作用 前面提到，使用装饰器有一个瑕疵，就是被装饰的函数，它的函数名称已经不是原来的名称了，回到最开始的例子： def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped @makeitalic def hello (): return 'hello world' 函数 hello 被 makeitalic 装饰后，它的函数名称已经改变了： hello . __name__ 'wrapped' 为了消除这样的副作用，Python 中的 functools 包提供了一个 wraps 的装饰器： from functools import wraps def makeitalic ( func ): @wraps ( func ) # 加上 wraps 装饰器 def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped @makeitalic def hello (): return 'hello world' hello . __name__ 'hello' 事实上，装饰器就是闭包的一种应用，但它比较特别，接收被装饰函数为参数，并返回一个函数，赋给被装饰函数，闭包则没这种限制。","text_tokens":["例子","pass","作用","器先","名称","参数","s","它","如果","结果","makeitalic2","self","后","最","—","函数调用","实际","时","相当于","2","'","}","假设","动态","名字","生成","bold","two","还","有时候","见","根据","res","其带","不","呢","等价","于","原来","*","添加","jack","器有","#","调用","name2","改变","需求","包装","简述","_","hello2","...","修改","总","？","in","这","提供","原函数","写得","提到","瑕疵","tag","call","）","『","比较","事实上","中",">","不是","对带","可以","做","{","ret","繁琐","看出","函数","绑定","器带","是","object","一种","总结","形式","改写","未免太","加上","有时","b","本质","@","/","会","让","init","kwargs","而","在","看看","改用","简单","方法","一样","高阶","是不是","类","这样","function","args","类似","开始","其实","此时","上","要","arg1","闭包","但","赋给","并","为","python","，","实现","wrapped","3","一般","进行","起","相当","事实","成器","name","更加","对象","与","i","也","对","name1","print","返回","标签","没有","再","都","消除","这种","其赋","func","来","装饰","调用函数","功能","=",":","限制","变","：","html","情况","新","为了","接收","我们","直接","wraps",")","import","就是","希望","。","像","看到","main","时候","format","最近","简洁","functools","的","return","decorator","没","因此","one","就","最后","使",".","给","了","传入","可","内嵌","基于","如下","离","用","副作用"," ","』","一个","或类","world","回到","<","makeitalic","+","locals","实际上","class","做法","代码","当于","那么","看","已经","这个","几行","下面","定义","\"","上面","多个","想要","将","有","带","wrap","生成器",",","使用","则","__.","注意","或","def","makebold","hello","作为","%","以","现在","要求","代表","器","想","一下","arg2","p","前面","包","需要","比如","变成","两个","(","lusis","（","由于","特别","套上","from","应用","增强","被","未免","__"],"title":"3.4.装饰器","title_tokens":["装饰",".","器","3.4"]},{"location":"Python基础/3.4.装饰器.html#_1","text":"有时候，我们需要给一个函数添加新功能。那么有一种做法就是修改原函数的代码，直接添加新功能。但这总做法有时未免太繁琐。在python中，直接给原函数套上装饰就可以实现这个需求。 假设有一个这样的函数： def hello (): return 'hello world' # hello函数的名字 print ( \"hello函数的名字：\" , hello . __name__ ) hello函数的名字： hello 现在我们想增强 hello() 函数的功能，希望给返回加上 HTML 标签，比如 <i>hello world</i> ，但有一个要求，不改变原来 hello() 函数的定义。 那么可以这样做： def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped 要注意的是，makeitalic函数的参数是一个函数，返回的结果是wrapped函数。 # 给hello函数套上makeitalic函数 # makeitalic函数返回wrapped函数 # 实际上此时hello变成了wrapped函数 hello = makeitalic ( hello ) 将 hello 函数作为参数传入 makeitalic 函数， makeitalic 函数返回wrapped函数，名字 hello 与 wrapped 函数绑定。此时名字 hello 代表了一个函数，也就是 wrapped 函数有了新的名字—— hello 。 # 可以看出hello函数的名字变了 print ( \"hello函数的名字：\" , hello . __name__ ) hello函数的名字： wrapped 总结一下：为了增强原函数 hello 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数。 事实上， makeitalic 就是一个装饰器（decorator），它『装饰』了函数 hello ，并返回一个函数，将其赋给 hello 。 像上面的情况，可以动态修改函数（或类）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 hello ）为参数，并返回一个包装后的函数（比如上面的 wrapped ）给被装饰函数（ hello ）。","text_tokens":["参数","它","结果","后","—","实际","'","假设","动态","名字","有时候","不","原来","添加","#","改变","需求","包装","修改","总","这","原函数","）","『","事实上","中",">","可以","做","繁琐","看出","函数","绑定","是","一种","总结","未免太","加上","有时","本质","/","在","高阶","这样","此时","上","要","但","并","为","python","，","实现","wrapped","事实","name","与","i","也","print","返回","标签","其赋","func","装饰","功能","=",":","变","：","html","情况","新","为了","接收","我们","直接",")","就是","希望","。","像","时候","的","return","decorator","就",".","给","了","传入"," ","』","一个","或类","world","<","makeitalic","+","实际上","做法","代码","那么","这个","定义","\"","上面","将","有",",","注意","def","hello","作为","以","现在","要求","代表","器","想","一下","需要","比如","变成","(","（","套上","增强","被","未免","__"],"title":"装饰器简述","title_tokens":["装饰","简述","器"]},{"location":"Python基础/3.4.装饰器.html#_2","text":"在python中，装饰器一般这样用： @decorator def func (): pass 等价于下面的形式 ： def func (): pass func = decorator ( func ) 装饰器可以定义多个，离函数定义最近的装饰器先被调用，比如 @decorator_one @decorator_two def func (): pass 等价于： def func (): pass func = decorator_one ( decorator_two ( func )) 装饰器还可以带参数，比如： @decorator ( arg1 , arg2 ) def func (): pass 等价于： def func (): pass func = decorator ( arg1 , arg2 )( func ) 例子： def makeitalic2 ( func ): return \"<i>\" + func () + \"</i>\" @makeitalic def hello_2 (): return 'hello world' def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped hello_2 () ' <i> hello world </i> ' 如果返回的不是函数就会这样： @makeitalic def hello_3 (): return 'hello world' def makeitalic ( func ): return \"<i>\" + func () + \"</i>\" hello_3 <function __main__.makeitalic.<locals>.wrapped()>","text_tokens":["例子","pass",".","器先","中",">","不是","离","用","参数"," ","i","可以","如果","makeitalic2","world","返回","<","函数","+","makeitalic","locals","func","形式","装饰","2","'","@","下面","/","会","=","定义","two","还","多个","\"",":","在","__","：","带","等价","于",",","__.","这样",")","function","def","调用","hello","器","main","arg2","最近","arg1","比如","(","_","的","decorator","python","，","return","one","被","就","wrapped","3","一般"],"title":"装饰器的一般使用形式","title_tokens":["使用","形式","装饰","的","器","一般"]},{"location":"Python基础/3.4.装饰器.html#_3","text":"前面的例子中，被装饰的函数 hello() 是没有带参数的，我们看看被装饰函数带参数的情况。对前面例子中的 hello() 函数进行改写，使其带参数，如下： def makeitalic ( func ): def wrapped ( * args , ** kwargs ): ret = func ( * args , ** kwargs ) return '<i>' + ret + '</i>' return wrapped @makeitalic def hello ( name ): return 'hello %s ' % name @makeitalic def hello2 ( name1 , name2 ): return 'hello %s , %s ' % ( name1 , name2 ) hello ( 'Jack' ) hello2 ( 'Jack' , \"Lusis\" ) 由于函数 hello 带参数，因此内嵌包装函数 wrapped 需要改变。","text_tokens":["例子","使","中",">","如下","参数","name","i"," ","s","对","内嵌","name1","ret","没有","<","函数","makeitalic","+","是","func","改写","装饰","'","@","/","=","kwargs","\"",":","看看","：","其带","情况","带",",","我们","*",")","jack","args","def","hello","%","。","name2","改变","前面","需要","(","lusis","由于","hello2","的","return","包装","，","因此","被","wrapped","进行"],"title":"对带参数的函数进行装饰","title_tokens":["对带","装饰","参数","的","函数","进行"]},{"location":"Python基础/3.4.装饰器.html#_4","text":"上面的例子，我们增强了函数 hello 的功能，给它的返回加上了标签 <i>...</i> ，现在，我们想改用标签 <b>...</b> 或 <p>...</p> 。是不是要像前面一样，再定义一个类似 makeitalic 的装饰器呢？其实，我们可以定义一个函数，将标签作为参数，返回一个装饰器，比如： def wrap_in_tag ( tag ): def decorator ( func ): def wrapped ( * args , ** kwargs ): ret = func ( * args , ** kwargs ) return '<' + tag + '>' + ret + '</' + tag + '>' return wrapped return decorator 生成想要的装饰器了： makebold = wrap_in_tag ( 'b' ) # 根据 'b' 返回 makebold 生成器 @makebold def hello ( name ): return 'hello %s ' % name hello ( 'world' ) ' <b> hello world </b> ' 上面的形式也可以写得更加简洁： @wrap_in_tag ( 'b' ) def hello ( name ): return 'hello %s ' % name","text_tokens":["例子","参数","s","它","'","生成","根据","*","#","...","_","？","in","写得","tag","不是",">","可以","ret","函数","呢","形式","加上","b","@","/","kwargs","改用","一样","是不是","args","类似","其实","要","，","wrapped","成器","name","更加","i","也","返回","标签","再","func","装饰","功能","=",":","：","我们",")","。","像","简洁","的","decorator","return","了","给"," ","一个","world","<","makeitalic","+","定义","上面","想要","将","生成器","wrap",",","或","def","makebold","hello","作为","%","现在","器","想","p","前面","比如","(","增强"],"title":"带参数的装饰器","title_tokens":["带","装饰","参数","的","器"]},{"location":"Python基础/3.4.装饰器.html#_5","text":"现在，让我们来看看多个装饰器的例子，为了简单起见，下面的例子就不使用带参数的装饰器。 def makebold ( func ): def wrapped (): return '<b>' + func () + '</b>' return wrapped def makeitalic ( func ): def wrapped (): return '<i>' + func () + '</i>' return wrapped @makebold @makeitalic def hello (): return 'hello world' 上面定义了两个装饰器，对 hello 进行装饰，上面的最后几行代码相当于： def hello (): return 'hello world' hello = makebold ( makeitalic ( hello )) 调用函数 hello： hello () ' <b><i> hello world </i></b> '","text_tokens":["例子","最后","了","相当",">","参数","i"," ","对","world","<","makeitalic","+","函数","当于","代码","func","来","相当于","让","装饰","'","b","几行","@","下面","/","调用函数","=","定义","多个","上面",":","见","看看","简单","：","不","带","为了","使用","我们",")","def","makebold","hello","调用","。","现在","器","两个","(","的","return","，","就","wrapped","进行","起"],"title":"多个装饰器","title_tokens":["装饰","器","多个"]},{"location":"Python基础/3.4.装饰器.html#_6","text":"前面的装饰器都是一个函数，其实也可以基于类定义装饰器，看下面的例子： class Bold ( object ): def __init__ ( self , func ): self . func = func def __call__ ( self , * args , ** kwargs ): return '<b>' + self . func ( * args , ** kwargs ) + '</b>' @Bold def hello ( name ): return 'hello %s ' % name hello ( 'world' ) 可以看到，类 Bold 有两个方法： __init__() ：它接收一个函数作为参数，也就是被装饰的函数 __call__() ：让类对象可调用，就像函数调用一样，在调用被装饰函数时被调用 还可以让类装饰器带参数： class Tag ( object ): def __init__ ( self , tag ): self . tag = tag def __call__ ( self , func ): def wrapped ( * args , ** kwargs ): return \"< {tag} > {res} </ {tag} >\" . format ( res = func ( * args , ** kwargs ), tag = self . tag ) return wrapped @Tag ( 'b' ) def hello ( name ): return 'hello %s ' % name 需要注意的是，如果类装饰器有参数， 则 __init__ 接收参数，而 __call__ 接收 func。","text_tokens":["例子","参数","s","它","如果","self","函数调用","时","'","}","bold","还","res","*","器有","调用","tag","call",">","可以","{","函数","器带","是","object","看","让","b","@","init","/","kwargs","而","在","方法","一样","类","args","其实","，","wrapped","name","对象","也","都","func","装饰","=",":","：","接收",")","就是","看到","像","。","format","的","return","就",".","可","基于"," ","一个","world","<","class","+","下面","定义","\"","有",",","则","注意","def","hello","%","作为","器","前面","需要","两个","(","被","__"],"title":"基于类的装饰器","title_tokens":["类","基于","装饰","的","器"]},{"location":"Python基础/3.4.装饰器.html#_7","text":"前面提到，使用装饰器有一个瑕疵，就是被装饰的函数，它的函数名称已经不是原来的名称了，回到最开始的例子： def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped @makeitalic def hello (): return 'hello world' 函数 hello 被 makeitalic 装饰后，它的函数名称已经改变了： hello . __name__ 'wrapped' 为了消除这样的副作用，Python 中的 functools 包提供了一个 wraps 的装饰器： from functools import wraps def makeitalic ( func ): @wraps ( func ) # 加上 wraps 装饰器 def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped @makeitalic def hello (): return 'hello world' hello . __name__ 'hello' 事实上，装饰器就是闭包的一种应用，但它比较特别，接收被装饰函数为参数，并返回一个函数，赋给被装饰函数，闭包则没这种限制。","text_tokens":["例子","作用","名称","参数","它","后","最","'","原来","器有","#","改变","提供","瑕疵","提到","比较","事实上","不是",">","中","函数","一种","functools","加上","@","/","这样","开始","闭包","赋给","但","为","并","python","，","wrapped","事实","name","i","返回","消除","这种","func","装饰",":","限制","：","为了","接收","wraps",")","import","就是","。","的","return","没","了",".","副作用"," ","一个","world","回到","<","makeitalic","+","已经","\"","使用","则","def","hello","器","包","前面","特别","(","from","应用","被","__"],"title":"装饰器的副作用","title_tokens":["作用","装饰","副作用","的","器"]},{"location":"Python基础/4.1.类.html","text":"Windows 10 Python 3.7.3 @ MSC v.1915 64 bit (AMD64) 类提供了一种组合数据和功能的方法。类通常是以下部分组成的集合： 函数（称为方法，method），包括特殊方法、私有方法、实例方法、类方法、静态方法 变量（称为类变量，class variable）， 类变量 是在类的所有实例之间共享的值，不是单独分配给每个实例的 计算出的属性（称为特性，property） 创建一个新类意味着创建一个新类型的对象，从而允许创建一个该类型的新实例。每个类的实例可以拥有保存自己状态的属性。对象可以包含任意数量和类型的数据。和模块一样，类也拥有 Python 天然的动态特性：它们在运行时创建，可以在创建后修改。 在Python中，约定使用单数单词表示类名，其首字母大写。 Python 的类提供了面向对象编程的所有标准特性： 多态：可对不同类型的对象执行相同的操作，而这些操作就像“被施了魔法”一样能够正常运行。 封装：对外部隐藏有关对象工作原理的细节。 继承：可基于通用类创建出专用类。允许派生类继承多个基类，派生类可以覆盖它基类的任何方法，一个方法可以调用基类中相同名称的的方法。 类实例 类的实例是以函数形式调用类对象来创建的。 __new__ 方法将创建一个新实例，然后将该实例传递给类的 __init__() 方法。 __init__() 方法的参数包括新创建的实例 self 和在调用类对象时提供的参数。 在 __init__() 内，通过将属性分配给 self 来将其保存到实例中。例如， self.name = name 表示将 name 属性保存在实例中。其中，点 . 运算符用于属性绑定。在新创建的实例返回到用户之后，使用点 . 运算符即可访问这些属性以及类的属性。 访问属性时，结果值可能来自多个不同的地方。可能来自实例独有的属性，也可能来自类的属性。访问属性时，Python 首先会检查实例，如果不知道该属性的任何信息，则会对实例的类进行搜索。这是类与其所有实例共享其属性的底层机制。 继承 继承是一种创建新类的机制，目的是使用或修改现有类的行为。原始类称为 基类 或 超类 。新类称为 派生类 或 子类 。 通过继承创建类时，所创建的类将“继承”其基类定义的属性。==但是，==派生类可以重新定义任何这些属性并添加自己的新属性。 在class语句中用以逗号分隔的基类名称列表来指定继承。如果没有有效的基类，类将继承object。object是所有Python对象的根类，提供了一些常见方法（如 __str__() ，它可创建供打印函数使用的字符串）的默认实现。 继承通常用于重新定义现有方法的行为。 继承是用功能稍微增强的点 . 运算符实现的。具体来讲，如果搜索一个属性时未在实例或实例的类中找到匹配项，将会继续搜索基类。这个过程会一直继续下去，直到没有更多的基类可供搜索为止。 派生类重定义 __init__() 时，不会自动调用基类的 __init__() 方法。因此，如果派生类想重定义 __init__() ，还想调用基类的 __init__() 方法，那么要由派生类调用基类的 __init__() 方法来对它们进行恰当的初始化。如果基类未定义 __init__() ，就可以忽略这一步。如果不知道基类是否定义了 __init__() ，可在不提供任何参数的情况下调用它，因为始终存在一个不执行任何操作的默认 __init__() 实现。 # 定义一个人类 class Person : def __init__ ( self , name , age ): self . name = name self . age = age def get_name ( self ): return self . name def get_age ( self ): return self . age # 定义一个美国人类 ## 现在想给美国人在初始化的时候加上 性别 的属性 class American ( Person ): # 重新定义__init__()会覆盖Person的__init__()方法 def __init__ ( self , name , age , gender ): Person . __init__ ( self , name , age ) self . gender = gender def get_gender ( self ): return self . gender jackson = American ( name = \"Cesar T. Mauck\" , age = 14 , gender = \"male\" ) jackson . get_age () 14 jackson . get_gender () 'male' # 有时，派生类将重新实现方法，但是还想调用原始的实现。 为此，有一种方法可以显式地调用基类中的原始方法，将实例 self 作为第一个参数传递即可，如下所示： # 定义一个华盛顿人类 class Washington ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 age = American . get_age () age += 1 self . age = age print ( \"Washington people grow up one year old\" ) 这个例子的微妙之处在于，American这个类其实没有实现 get_age() 方法。该方法是在Person类中实现的。尽管这段代码能够运行，但它可能会引起一些混淆（例如，American是否应该实现 get_age() ? ）。因此，替代解决方案是用 super() 函数，如下所示： # 定义一个加利福尼亚人类 class California ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 ## 实际上，因为get_age()方法在Person中定义 ## 这里可以传入Person的任何一个派生类 age = super ( California , self ) . get_age () age += 1 self . age = age print ( \"Californians grow up one year old\" ) Terri = California ( \"Terri H. Booth\" , 25 , \"female\" ) Terri . growing_up () Californians grow up one year old super(cls, instance) 会返回一个特殊对象，该对象支持在基类上执行属性查找。如果使用该函数，Python将使用本来应该在基类上使用的正常搜索规则来搜索属性。有了这种方式，就无需写死方法位置，并且能更清晰地陈述你的意图（即你希望调用以前的实现，无论它是哪个基类定义的）。然而， super() 的语法尚有不足之处。如果使用Python 3，可以使用简化的语句 super().get_age() 来执行上面示例中的计算。 多重继承 Python支持多重继承。通过让一个类列出多个基类即可指定多重继承。例如，下面给出了一个类集合： # 定义一个圣拉蒙人类 class San_Ramon ( American , California , Washington ): def growing_up ( self ): pass Edwin = San_Ramon ( \"Edwin A. Marcotte\" , 37 , \"male\" ) Edwin . get_age () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-6c60ffbe4e5a> in <module> 1 # 定义一个圣拉蒙人类 ----> 2 class San_Ramon(American, California, Washington): 3 def growing_up(self): 4 pass 5 TypeError: Cannot create a consistent method resolution order (MRO) for bases American, California, Washington 使用多重继承时，属性的解析会变得非常复杂，因为可以使用很多搜索路径来绑定属性。 在查找使用了多重继承的属性时，会将所有基类按从“最特殊”的类到“最不特殊”的类这种顺序进行排列。然后在搜索属性时，就会按这个顺序搜索，直至找到该属性的第一个定义。对于任何给定的类，通过打印它的 mro 属性即可查看基类的顺序，例如： 在大多数情况下，这个列表基于“有意义”的规则排列得出。也就是说，始终先检查派生类，然后再检查其基类，如果一个类具有多个父类，那么始终按类定义中列出的父类顺序检查这些父类。但是，基类的准确顺序实际上非常复杂，不是基于任何“简单的”算法，如深度优先或广度优先搜索。实际上，基类的顺序由 C3 线性化算法确定，可以在论文“A Monotonic Superclass Linearization for Dylan”（K. Barrett 等，发表于 OOPSLA’96）中找到该算法的介绍。该算法的一个需要注意的地方是，某些类层次结构将被 Python 拒绝并会抛出 TypeError 错误，例如： 一般来说，在大多数程序中最好避免使用多重继承。但是，多重继承有时可用于定义所谓的混合（mixin）类。混合类通常定义了要“混合到”其他类中的一组方法，目的是添加更多的功能（这与宏很类似）。通常，混合类中的方法将假定其他方法存在，并将以这些方法为基础构建。 多态动态绑定和鸭子类型 动态绑定（在继承背景下使用时，有时也称为多态性）是指在不考虑实例类型的情况下使用实例只要以 obj.attr 的形式访问属性，就会按照一定的顺序搜索并定位 attr ： 首先是实例本身，接着是实例的类定义，然后是基类。 查找过程会返回第一个匹配项。 这种绑定过程的关键在于，它不受对象 obj 的类型影响。因此，如果执行像 obj.name 这样的查找，对所有拥有 name 属性的 obj 都是适用的。 polymorphism 源自希腊语，意思是“有多种形态”。这大致意味着即便你不知道变量指向的是哪种对象，也能够对其执行操作，且操作的行为将随对象所属的类型（类）而异。也就是同一种调用形式，但有不同的执行效果。 在Python中，多态也称为 鸭子类型 （duck typing）。这个术语源自 James Whitcomb Riley 在17世纪写下的一句诗： When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck. 真不知道谁想出这个术语的，如果用数学语言来类比，鸭子类型相当于数学的公理化定义。 Python 程序员经常编写利用这种行为的程序。例如，如果想编写现有对象的自定义版本，可以继承该对象，也可以创建一个外观和行为像它但与它无任何关系的全新对象。后一种方法通常用于保持程序组件的松散耦合。例如，可以编写代码来处理任何种类的对象，只要该对象拥有特定的方法集。最常见的例子就是利用标准库中定义的各种“类似文件”的对象。尽管这些对象的工作方式像文件，但它们并不是继承自内置文件对象的。 实例方法 类中最常用的方法是实例方法，即 将实例作为第一个参数传递给该方法。 根据约定，这个参数名称为self，尽管所有合法的标识符都可以使用。 self 参数指向对象本身。 self 参数很有用，甚至必不可少。如果没有它，所有的方法都无法访问对象本身（要操作的属性所属的对象）。 下面是以是实例方法的例子： class Kls ( object ): def __init__ ( self , data ): self . data = data def printd ( self ): print ( self . data ) ik1 = Kls ( 'arun' ) ik2 = Kls ( 'seema' ) ik1 . printd () ik2 . printd () arun seema 然后看一下代码和示例图片: 在1、2中，参数传递给方法。 在3中， self参数指向当前实例。 在4中，我们不需要给方法提供实例， Python解释器自己会做这些操作 。 静态方法 Note 以下两个代码示例介绍了静态方法的两个应用场景： 不需要访问实例对象或类对象的方法和属性，但与类有关的功能 创建构造函数 经常有一些跟类有关系的功能，但在运行时又不需要实例和类参与（比如更改环境变量或者修改其他类的属性），当然可以在类定义之外写一个函数实现这些功能，但这样会扩散类内部的代码，不利于代码的维护。比如这样： IND = 'ON' def checkind (): return ( IND == 'ON' ) class Kls ( object ): def __init__ ( self , data ): self . data = data def do_reset ( self ): if checkind (): print ( 'Reset done for:' , self . data ) def set_db ( self ): if checkind (): self . db = 'new db connection' print ( 'DB connection made for:' , self . data ) ik1 = Kls ( 12 ) do_reset ( ik1 ) # Reset done for: 12 set_db ( ik1 ) # DB connection made for: 12 如果使用 @staticmethod 就能把相关的代码放到对应的位置了。 IND = 'ON' class Kls ( object ): def __init__ ( self , data ): self . data = data @staticmethod def checkind (): return ( IND == 'ON' ) def do_reset ( self ): if self . checkind (): print ( 'Reset done for:' , self . data ) def set_db ( self ): if self . checkind (): self . db = 'New db connection' print ( 'DB connection made for: ' , self . data ) ik1 = Kls ( 12 ) ik1 . do_reset () ik1 . set_db () Reset done for: 12 DB connection made for: 12 实际上，静态方法是一种普通函数，只不过它们正好位于类定义的命名空间中， 因为它不会对任何实例类型进行操作 。 如果在编写类时需要采用很多不同的方式来创建新实例，则常常使用静态方法。因为类中只能有一个 __init__() 函数，所以替代的创建函数通常按如下方式定义： import time class Date ( object ): def __init__ ( self , year , month , day ): self . year = year self . month = month self . day = day @staticmethod def now (): t = time . localtime () return Date ( t . tm_year , t . tm_mon , t . tm_mday ) @staticmethod def tomorrow (): t = time . localtime ( time . time () + 86400 ) return Date ( t . tm_year , t . tm_mon , t . tm_mday ) # 创建日期的示例 a = Date ( 1967 , 4 , 9 ) b = Date . now () # 调用静态方法now() c = Date . tomorrow () # 调用静态方法tomorrow() 类方法 Note 以下两个代码示例介绍了类方法的两个应用场景： 创建构造函数 动态更新类 类方法是将类本身作为对象进行操作的方法。类方法使用 @classmethod 装饰器定义，与实例方法不同，Python解释器会将类本身传递给类方法的第一个参数（一般将该参数命名为 cls ）。例如： class Times ( object ): factor = 1 @classmethod def mul ( cls , x ): return cls . factor * x class TwoTimes ( Times ): factor = 2 x = TwoTimes . mul ( 4 ) # 调用Times.mul(TwoTimes, 4) -> 8 在这个例子中，请注意类 TwoTimes 是如何作为对象传递给 mul() 的。尽管这个例子有些深奥，但类方法还有一些实用且巧妙的用法。例如，你定义了一个类，它继承自前面给出的 Date 类并对其略加定制： class EuroDate ( Date ): # 修改字符串转换，以使用欧洲日期格式 def __str__ ( self ): return \" %02d / %02d / %4d \" % ( self . day , self . month , self . year ) 由于该类继承自 Date，所以它拥有 Date 的所有特性。但是 now() 和 tomorrow() 方法稍微有点不同。例如，如果调用 EuroDate.now()，则会返回 Date 对象，而不是 EuroDate 对象。类方法可以解决该问题： class Date ( object ): def __init__ ( self , year , month , day ): self . year = year self . month = month self . day = day @classmethod def now ( cls ): t = time . localtime () return cls ( t . tm_year , t . tm_mon , t . tm_mday ) @classmethod def tomorrow ( cls ): t = time . localtime ( time . time () + 86400 ) return cls ( t . tm_year , t . tm_mon , t . tm_mday ) class EuroDate ( Date ): # 修改字符串转换，以使用欧洲日期格式 def __str__ ( self ): return \" %02d / %02d / %4d \" % ( self . day , self . month , self . year ) a = Date . now () # 调用Date.now(Date)并返回Date b = EuroDate . now () # 调用Date.now(EuroDate)并返回EuroDate print ( type ( a )) print ( type ( b )) <class '__main__.Date'> <class '__main__.EuroDate'> 类方法除了用于创建构造函数，另一个例子是动态更新类。例如我们想动态更新一个类属性： class Kls ( object ): models = {} def __init__ ( self , model_name ): # 加载模型 pass @classmethod def load_model ( cls , model_name ): cls . models [ model_name ] = cls ( model_name ) @classmethod def get_model ( cls , model_name ): return cls . models . get ( model_name , None ) def predict ( self ): return \"预测结果为1\" model_name = \"svm\" Kls . load_model ( model_name ) model = Kls . get_model ( model_name ) model . predict () '预测结果为1' Kls . models {'svm': <__main__.Kls at 0x21aaefe5908>} 当然，除了使用类方法，也可以在实例方法中显式调用类属性，达到动态更新类的效果，例如我们要获取实例数： class Kls ( object ): no_inst = 0 def __init__ ( self ): Kls . no_inst = Kls . no_inst + 1 @classmethod def get_no_of_instance ( cls_obj ): return cls_obj . no_inst ik1 = Kls () ik2 = Kls () print ( ik1 . get_no_of_instance ()) print ( Kls . get_no_of_instance ()) 2 2 但是如果要用实例方法实现的话，就得创建一个实例对象，这意味着我们必须要给这个实例对象命名。在编程中，给过多的变量命名，有时是一个头疼的问题。 在类外面写一个函数也可以实现这样的效果，但不利于代码的维护。 def get_no_of_instances ( cls_obj ): return cls_obj . no_inst class Kls ( object ): no_inst = 0 def __init__ ( self ): Kls . no_inst = Kls . no_inst + 1 ik1 = Kls () ik2 = Kls () print ( get_no_of_instances ( Kls )) 2 实例方法、静态方法、类方法对比 在实例方法和类方法中，Python默认将当前实例或者类对象传给方法的第一个参数（非指定默认值的参数），如果方法不设置参数，便会报错： class Kls ( object ): def __init__ ( self , data ): self . data = data def imethod1 (): print ( \"不接收实例\" ) def imethod2 ( * arg ): print ( 'Instance:' , arg ) @staticmethod def smethod ( * arg ): print ( 'Static:' , arg ) @classmethod def cmethod1 (): print ( \"不接收类对象\" ) @classmethod def cmethod2 ( * arg ): print ( 'Class:' , arg ) ik3 = Kls ( 'arun' ) ik3 . imethod1 () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-82fbcd62768a> in <module> 1 ik3 = Kls('arun') ----> 2 ik3.imethod1() TypeError: imethod1() takes 0 positional arguments but 1 was given ik3 . cmethod1 () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-6055e1d64eee> in <module> ----> 1 ik3.cmethod1() TypeError: cmethod1() takes 0 positional arguments but 1 was given 实例方法、类方法必须设置参数接收类对象： ik3 . imethod2 () ik3 . cmethod2 () Instance: (<__main__.Kls object at 0x0000021AAEFF0390>,) Class: (<class '__main__.Kls'>,) 静态方法则不会传入实例或类对象： ik3 . smethod () Static: () 如果方法不设置参数，只能通过类去调用，应该避免这种用法，没参数的方法应该加上 @staticmethod 装饰器： Kls . imethod1 () 不接收实例 关于静态方法和类方法需要注意的一点是，Python 不会在与实例方法独立的命名空间中管理它们。因此，可以通过实例或类调用它们。例如： Kls . cmethod2 () Kls ( 'arun' ) . cmethod2 () Kls . smethod () Kls ( 'arun' ) . smethod () Class: (<class '__main__.Kls'>,) Class: (<class '__main__.Kls'>,) Static: () Static: () 这可能很容易引起混淆，因为对 Kls('arun').cmethod2() 的调用与实例 Kls('arun') 没有任何关系。 这种行为是 Python 对象系统与其他面向对象语言（如 Smalltalk 和 Ruby）对象系统的区别之一。在这些语言中，类方法与实例方法是严格分开的。 而实例方法必须通过实例调用，因为需要传入实例。 特性 @property ——把方法变为属性 通常，访问实例或类的属性时，返回的会是所存储的相关值。特性（property）是一种特殊的属性，访问它时会计算它的值。下面是一个简单的例子： import math class Circle ( object ): def __init__ ( self , radius ): self . radius = radius # Circle的一些附加特性 @property def area ( self ): return math . pi * self . radius ** 2 @property def preimeter ( self ): return 2 * math . pi * self . radius 得到的Circle对象的行为如下： c = Circle ( 4.0 ) c . radius 4.0 c . area 50.26548245743669 c . preimeter 25.132741228718345 c . area = 2 ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-0dac39a0c579> in <module> ----> 1 c.area = 2 AttributeError: can't set attribute 在这个例子中，Circle 实例存储了一个实例变量 c.radius 。 c.area 和 c.perimeter 是根据该值计算得来的。 @property 装饰器支持以简单属性的形式访问后面的方法，无需像平常一样添加额外的 () 来调用该方法。对象的使用者很难发现正在计算一个属性，除非在试图重新定义该属性时生成了错误消息（如上面的 AttributeError 异常所示）。 这种特性使用方式遵循所谓的统一访问原则。 实际上，如果定义一个类，尽可能保持编程接口的统一总是不错的。如果没有特性，将会以简单属性（如 c.radius ）的形式访问对象的某些属性，而其他属性将以方法（如 c.area() ）的形式访问。费力去了解何时添加额外的 () 会带来不必要的混淆。特性可以解决该问题。 Python 程序员很少认识到， 方法本身是被隐式地作为一类特性处理的。 考虑下面这个类： class Foo ( object ): def __init__ ( self , name ): self . name = name def spam ( self , x ): print ( \" %s , %s \" % ( self . name , x )) Foo ( \"d\" ) . spam <bound method Foo.spam of <__main__.Foo object at 0x0000021AAEFDC7B8>> 用户创建 f = Foo(\"Guido\") 这样的实例然后访问 f.spam 时，不会返回原始函数对象 spam ，而是会得到所谓的绑定方法（bound method），绑定方法是一个对象，代表将在对象上调用 () 运算符时执行的方法调用。绑定方法有点类似于已部分计算的函数，其中的self参数已经填入，但其他参数仍然需要在使用 () 调用该函数时提供。这种绑定方法对象是由在后台执行的特性函数静默地创建的。 使用 @staticmethod 和 @classmethod 定义静态方法和类方法时，实际上就指定了使用不同的特性函数，以不同的方式处理对这些方法的访问。 例如， @staticmethod 仅“按原样”返回方法函数，不会进行任何特殊的包装或处理。 特性还可以截获操作权，以设置和删除属性。这是通过向特性附加其他 setter 和 deleter 方法来实现的，如下所示： class Foo ( object ): def __init__ ( self , name ): self . __name = name @property def name ( self ): return self . __name @name . setter def name ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value @name . deleter def name ( self ): raise TypeError ( \"Can't delete name\" ) 在这个例子中，首先使用 @property 装饰器和相关方法将属性 name 定义为只读特性。后面的 @name.setter 和 @name.deleter 装饰器将其他方法与 name 属性上的设置和删除操作相关联。这些方法的名称必须与原始特性的名称完全匹配。在这些方法中，请注意实际的名称值存储在属性 __name 中。所存储属性的名称无需遵循任何约定，但它必须与特性名称不同，以便将它与特性的名称区分开。 在以前的代码中，通常会看到用 property(getf=None, setf=None, delf=None, doc=None) 函数来定义特性，往其中传入一组名称不同的方法，用于执行相关操作。例如： class Foo ( object ): def getname ( self ): return self . __name def setname ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value def delname ( self ): raise TypeError ( \"Can't delete name\" ) name = property ( getname , setname , delname ) 这种老方法仍然可以使用，但装饰器版本会让类看起来更整洁。 例如，如果使用装饰器，get、 set 和 delete 函数将不会显示为方法。 数据封装和私有属性 默认情况下，类的所有属性和方法都是“公共的”。这意味着对它们的访问没有任何限制。这还暗示着，在基类中定义的所有内容都会被派生类继承，并可从派生类内进行访问。在面向对象的应用程序中，通常我们不希望发生这种行为，因为它会暴露对象的内部实现，可能导致在派生类中定义的对象与在基类中定义的对象之间发生命名空间冲突。 Note 这意味着派生类可以覆盖基类的定义。 为了解决该问题， 类中所有以双下划线开头的名称（如 __Foo ）都会自动变形，形成具有 _Classname__Foo 形式的新名称。 这提供了一种在类中添加私有属性和方法的有效方式，因为派生类中使用的私有名称不会与基类中使用的相同私有名称发生冲突，如下所示： class A ( object ): def __init__ ( self ): self . __X = 3 # 变形为self._A__X def __spam ( self ): # 变形为_A__spam() print ( \"A\" ) def bar ( self ): self . __spam () # 只调用A.__spam() class B ( A ): def __init__ ( self ): A . __init__ ( self ) self . __X = 37 # 变形为self._B__X def __spam ( self ): # 变形为_B__spam() print ( \"B\" ) b = B () # 派生类的定义没有覆盖基类的定义 b . bar () A 尽管这种方案似乎隐藏了数据，但并没有严格的机制来实际阻止对类的“私有”属性进行访问。特别是如果已知类名称和相应私有属性的名称，则可以使用变形后的名称来访问它们。通过重定义 dir() 方法，类可以降低这些属性的可见性， dir() 方法提供了检查对象的 dir() 函数所返回的名称列表。 尽管这种名称变形似乎是一个额外的处理步骤，但变形过程实际上只在定义类时发生一次。它不会在方法执行期间发生，也不会为程序的执行添加额外的开销。而且要知道，名称变形不会在 getattr() 、 hasattr() 、 setattr() 或 delattr() 等函数中发生，在这些函数中，属性名被指定为字符串。对于这些函数，需要显式使用变形名称（如 __Classname__name ）来访问属性。 建议在定义可变属性时，通过特性来使用私有属性。这样，就可鼓励用户使用特性名称，而无需直接访问底层实例数据（如果你在实例开头添加了一个特性，可能不想采用这种访问方式）。 通过为方法提供私有名称，超类可以阻止派生类重新定义和更改方法的实现。 例如，示例中的 A.bar() 方法只调用 A.__spam() ，无论 self 具有何种类型，或者派生类中是否存在不同的 __spam() 方法都是如此。 最后，不要混淆私有类属性的命名和模块中“私有”定义的命名。一个常见的错误是，在定义类时，在属性名上使用单个前导下划线来隐藏属性值（如 _name ）。 在模块中，这种命名约定可以阻止通过 from module import * 语句导出名称。 这意味着单下划线开头的定义只能被类本身和其派生类访问。但是在类中，这种命名约定既不能隐藏属性，在某个类继承该类并使用相同名称定义一个新属性或方法时，也不能阻止出现名称冲突。 对象表示和属性绑定 从内部实现上看，实例是使用字典来实现的，可以通过实例的 __dict__ 属性访问该字典。这个字典包含的数据对每个实例而言都是唯一的，如下所示： class Account ( object ): def __init__ ( self , name , balance ): self . name = name self . balance = balance a = Account ( \"Guido\" , 1100.0 ) a . __dict__ {'name': 'Guido', 'balance': 1100.0} 可以在任何时候向实例添加新属性，例如： a . number = 123456 # 将属性'number'添加到 a.__dict__ 对实例的修改始终会反映到局部 __dict__ 属性中。同样，如果直接对 __dict__ 进行修改，所做的修改也会反映在实例的属性中。 实例通过特殊属性 __class__ 链接回它们的类。类本身也只是对字典的浅层包装，你可以在实例的 __dict__ 属性中找到这个字典。可以在类字典中找到各种方法。例如： a . __class__ __main__.Account Account . __dict__ . keys () dict_keys(['__module__', '__init__', '__dict__', '__weakref__', '__doc__']) 最后，通过特殊属性 __bases__ 中将类链接到它们的基类，该属性是一个基类元组。这种底层结构是获取、设置和删除对象属性的所有操作的基础。 只要使用 obj.name = value 设置了属性，特殊方法 obj.__setattr__(\"name\", value) 就会被调用。如果使用 del obj.name 删除了一个属性，就会调用特殊方法 obj.__delattr__(\"name\") 。 这些方法的默认行为是修改或删除 obj 的局部 __dict__ 的值，除非请求的属性正好是一个特性或描述符。在这种情况下，设置和删除操作将由与该特性相关联的设置和删除函数执行。 在查找属性（如 obj.name ）时，将调用特殊方法 obj.__getattrribute__(\"name\") 。该方法执行搜索来查找该属性，这通常涉及检查特性、查找局部 __dict__ 属性、检查类字典以及搜索基类。如果搜索过程失败，最终会尝试调用类的 __getattr__() 方法（如果已定义）来查找该属性。如果这也失败，就会抛出 AttributeError 异常。 如果有必要，用户定义的类可以实现其自己的属性访问函数。例如： import math class Circle ( object ): def __init__ ( self , radius ): self . radius = radius def __getattr__ ( self , name ): if name == 'area' : return math . pi * self . radius ** 2 elif name == 'perimeter' : return 2 * math . pi * self . radius else : return object . __getattr__ ( self , name ) def __setattr__ ( self , name , value ): if name in [ 'area' , 'perimeter' ]: raise TypeError ( \" %s is readonly\" % name ) from None object . __setattr__ ( self , name , value ) c = Circle ( 2 ) c . area 12.566370614359172 c . area = 10 ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-52599b4ddcfc> in <module> ----> 1 c.area = 10 <ipython-input-1-a1a0cdcb1eb3> in __setattr__(self, name, value) 13 def __setattr__(self,name,value): 14 if name in ['area','perimeter']: ---> 15 raise TypeError(\"%s is readonly\" % name) from None 16 object.__setattr__(self,name,value) TypeError: area is readonly 重新实现这些方法的类应该可以依靠 object 中的默认实现来执行实际的工作。这是因为默认实现能够处理类的更高级特性，如描述符和特性。 一般来讲，类很少重新定义属性访问运算符。但是，在编写通用的包装器和现有对象的代理时，通常会使用属性访问运算符。通过重新定义 __getattr__() 、 __setattr__() 和 __delattr__() ，代理可以捕获属性访问操作，并透明地将这些操作转发给另一个对象。 __slots__ 通过定义特殊变量 slots ，类可以限制对合法实例属性名称的设置，如下所示： class Account ( object ): def __init__ ( self , name , balance ): self . name = name self . balance = balance __slots__ = ( 'name' , 'balance' ) a = Account ( \"Guido\" , 1100.0 ) a . date = \"12-12\" ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-b978ca4ed4ad> in <module> 7 8 a = Account(\"Guido\", 1100.0) ----> 9 a.date = \"12-12\" AttributeError: 'Account' object has no attribute 'date' 定义 __slots__ 时，可以将实例上分配的属性名称限制为指定的名称，否则将引发 AttributeError 异常。这种限制可以阻止其他人向现有实例添加新属性，即便用户将属性名称写错，也不会创建出新的属性来。 在实际使用中， __slots__ 从未被当作一种安全的特性来实现。它实际上是对内存和执行速度的一种性能优化。 使用 __slots__ 的类的实例不再使用字典来存储实例数据，转而采用一种基于数组的更加紧凑的数据结构。在会创建大量对象的程序中，使用 __slots__ 可以显著减少减少内存占用和执行时间。 注意， __slots__ 与继承的配合使用需要一定的技巧。如果类继承自使用 __slots__ 的基类，那么它也需要定义 __slots__ 来存储自己的属性（即使它不会添加任何属性也是如此），这样才能利用 __slots__ 提供的优势。如果忘记了这一点，派生类的运行速度将更慢，占用的内存也更多，比完全不使用 __slots__ 时情况更糟。 __slots__ 的使用还会破坏期望实例具有底层 __dict__ 属性的代码。尽管这一点通常不适用于用户代码，但对于支持对象的实用库和其他工具，其代码可能要依靠 __dict__ 来调试、序列化对象以及执行其他操作。 最后，如果类中重新定义了 __getattribute__() 、 __getattr__() 和 __setattr__() 等方法， __slots__ 的存在不会对它们的调用产生任何影响。但是，这些方法的默认行为将考虑到 __slots__ 。此外应该强调一点，没有必要向 __slots__ 添加方法或特性名称，因为它们存储在类中，而不是存储在每个实例中。 参考 difference between staticmethod and classmethod in python","text_tokens":["多数","地方","made","self","123456","公理","平常","外观","紧凑","10","getf","描述符","代理","最","遵循","一类","接着","层次","female","ik3","'","巧妙","暗示","该","前导","数传","所属","转发","仅","从而","dict","唯一","male","growing","数学","set","此外","不","默认","即可","*","算符","链接","来讲","多种","调用","必要","字典","请","尼亚","分隔","grow","area","行为","支持","包装","信息","7","所示","修改","in","每个","即便","这","对于","管理","存储","附加","note","还有","段","分开","a1a0cdcb1eb3","64","method","与其","定制","比","不是","大致","new","models","否则","转换","{","bird","截获","对应","该值","特性","部分","减少","给出","子类","第一","线性","arg","是","基类","哪个","不会","理化","福尼亚","以便","为止","格式","typing","be","某个","列出","reset","twotimes","not","产生","面向对象编程","方式","程序","加利福尼亚","这样","polymorphism","额外","给定","类似","del","初始","写下","jackson","错误","一组","staticmethod","只能","1967","doc","并","暴露","查看","python","能够","实现","介绍","也就是说","用者","工具","3","清晰","13","相当","按照","图片","如何","相关联","甚至","结构","age","访问","再","washington","引起","and","等","利于","包括","相同","来","现有","工作","装饰","便会","集合","名上","----","语法","以双","month","实用","is","更改","elif","库","有效","程序员",")","计算","适用","大多数","。","看到","暗示着","中显式","打印","当然","统一","imethod1","得出","尝试","c3","的","其","特定","因此","得到","列表","线性化","以下","attributeerror","has","版本","了","ik1","希腊语"," ","普通","很多","h","放到","未定义","printd","这里","<","+","开","想重","公共","消息","字符串","首字母","pi","导出","weakref","25","处理","这个","不适","单个","先","getname","实例","将","尽可","直到","marcotte","考虑","52599b4ddcfc","背景","使用","则","按类","smalltalk","可变","或","5","鸭子","svm","but","!","诗","order","略加","加利福","%","匹配","重","性别","即","seema","person","拒绝","代表","建议","序列","构建","比如","time","对外部","特别","由于","a","大多","when","时会","应用程序","环境变","getattr","局部","被","at","尽可能","总是","cls","很","构造函数","未定","这是","天然","它","traceback","可见","day","而是","value","无法访问","中将","外部","last","实际","层次结构","除了","由","2","相当于","}","从未","动态","amd64","还","同","hasattr","mon","目的","大量","不利于","合法","他人","重新","大写","原理","获取","耦合","terri","传递","添加","死","slots","运算符","like","model","发给","论文","已知","定位","正在","因为","删除","_","和",".__","外面","位置","独有","提供","单独","加利","系统","术语","._","对比","super","状态","拉蒙","8","中","何种","多态","cannot","必须","做","解析","后台","共享","首字","示例","场景","函数","显式","世纪","当前","86400","walks","一般来说","不想","一般来讲","释器","一种","加上","b","oopsla","希腊","关于","init","而","本来","有关","出现","str","3.7","只读","简单","不必要","readonly","其中","year","出新","不同","typeerror","解释器","正好","attribute","只","某些","首先","isinstance","阻止","arguments","具体来讲","解决","san","算法","当作","陈述","位于","类名","##","更慢","方案","数组","失败","，","真不","difference","继续","但类","更加","与","深奥","]","使用者","6c60ffbe4e5a","随","谁","print","没有","attr","非常复杂","内部","时未","广度","都","环境变量","更糟","c","接口","划线","试图","集","string","perimeter","顺序","编写","看起来","涉及","替代","功能","=","就是说","限制","即使","consistent","---","keys","82fbcd62768a","接收","而且","我们","多","import","跟类","希望","delf","面向","底层","原则","不知","时候","恰当","并且","如","classname","ramon","达到","one","对类","up","就","数","面向对象","而言","delete","给","第一个","of","用","或类","按","that","1","分配","实际上","并会","类时","那么","设置","的话","运行","下面","不可","monotonic","none","标识","得来","多个","浅层","转发给","高级","美国","其他人","有","times","下划线","人","原样","注意","不要","区别","关联","包含","必不可少","resolution","常用","obj","一下","默认值","前面","自动","安全","封装","两个","带来","(","正常","12.566370614359172","应用","欧洲","setf","增强","查找","raise","用以","例子","名称","barrett","一步","参数","忽略","gender","到","如果","规则","4.0","s","一句","原始","而异","确定","形成","getattrribute","else","positional","—","静态方法","时","编程","根类","linearization","引发","隐藏","生成","data","类型","有些","6055e1d64eee","一次","序列化","no","严格","之处","于","通过","将会","字符","利用","msc","模型","预测","期间","一些","’","采用","1100.0","描述","变得","新类","冲突","很少","初始化","尽管","---------------------------------------------------------------------------","路径","派生","单词","mauck","只要","有用","之一","影响","还会","variable","细节","b978ca4ed4ad","ipython","简化","全新","所","call","种类","关键在于","arun","自己","变量","可以","radius","input","不错","库中","用法","搜索","“","create","cmethod1","看","数量","始终","来说","@","会","形态","can","02d","你","内","稍微","see","方法","日期","一样","技巧","k","类","约定","传给","解决方案","非常","更","属性","然后","意图","混合","开头","其实","checkind","有点","[","相应","回","t","要","值","之","mday","为","不过","american","数据结构","过","称为","自定","权","似乎","例如","tm","进行","一般","容易","circle","ruby","保持","tomorrow","类去","name","任何","破坏","对","扩散","不受","delattr","才能","转而","bound","windows","操作","4d","people","反映","命名","given","逗号","一点","在于","edwin","get","getattribute","4","must","常见","foo","性能","基础",":","9","是否","自","之间","情况","无需","bit","f","whitcomb","为了","james","多态性","调试","了解","覆盖","像","most","本身","最好","哪种","main","开销","父类","后面","创建","显示","宏","不再","点","各种","x","过程","来自","假定","华盛","意思","指向","12","继承","ik2","v.1915","问题","类比","最后","25.132741228718345",".","维护","通常","占用","可","一定","localtime","smethod","但是","一个","意味着","经常","class","项","微妙","booth","duck","当于","代码","now","填入","依靠","写错","bases","头疼","其他","供","cesar","math","\"","上面","显著","这些","if","所有","指","0","指定","无","找到","标识符","空间","下划","不利","专用","通用","def","spam","性","现在","只是","超类","器","想","配合","任意","bar","该类","内存","需要","源自","（","地","顺序搜索","文件","多重","知道","quacks","强调","已","速度","具有","delname","deleter","preimeter","pass","发生","for","应该","字母","环境","隐式","降低","结果","构造","允许","number","不能","完全","predict","cmethod2","对外","报错","不必","后","老","名","关系","存在","之外","标准","是因为","得","打印函数","d","根据","保存","mro","步骤","15","特殊","不足","发表","load","eurodate","期望","派生类","#","它们","californians","was","模块","on","把","去","static","优先","参与","account","看起","下去","解释","人类","深度","真不知道","db","inst","）","0dac39a0c579","认识","魔法","一直",">","instances","导致","新创","无法","关键","用于","何时","96","不足之处","常常","能","0x0000021aaeff0390","绑定","用户","module","object","起来","、","imethod2","形式","混淆","让","排列","california","有时","无论","/","被施","在","instance","忘记","参数传递","松散","拥有","继续下去","classmethod","?","优势","类中","0x21aaefe5908","准确","37","上","元组","riley","意味","组合","recent","但","以及","圣","setname","发现","connection","独立","尚有","直至","表示","之后","为此","同样","16","guido","对象","既","也","i","区分","语言","公理化","返回","property","除非","更新","优化","这种","内置","参考","setattr","运算","然而","另","17","处","且","-","机制","具体","复杂","：","效果","新","检查","50.26548245743669","直接","do","所以","捕获","发生冲突","就是","语句","费力","takes","静态","old","0x0000021aaefdc7b8","华盛顿","superclass","return","没","传入","请求","相关","异常","基于","如下","swims","type","date","between","鼓励","又","14","dylan","单","已经","出","factor","非","以前","mixin","私有","done","新创建","kls","加载","向","写","定义","数据","避免","最终","dir","内容","单数","自定义",",","__.","时间","仍然","执行","ind","”","作为","从","很难","以","可能","抛出","或者","下","setter","balance","往","静默","所谓","整洁","变为","意义","from","变形","只不过","透明","它会","如此","组件","mul","组成","__","years"],"title":"4.1.类","title_tokens":["4.1","类","."]},{"location":"Python基础/4.1.类.html#_1","text":"类的实例是以函数形式调用类对象来创建的。 __new__ 方法将创建一个新实例，然后将该实例传递给类的 __init__() 方法。 __init__() 方法的参数包括新创建的实例 self 和在调用类对象时提供的参数。 在 __init__() 内，通过将属性分配给 self 来将其保存到实例中。例如， self.name = name 表示将 name 属性保存在实例中。其中，点 . 运算符用于属性绑定。在新创建的实例返回到用户之后，使用点 . 运算符即可访问这些属性以及类的属性。 访问属性时，结果值可能来自多个不同的地方。可能来自实例独有的属性，也可能来自类的属性。访问属性时，Python 首先会检查实例，如果不知道该属性的任何信息，则会对实例的类进行搜索。这是类与其所有实例共享其属性的底层机制。","text_tokens":["参数","到","地方","结果","如果","self","时","该","保存","不","通过","即可","算符","传递","运算符","调用","和","信息","独有","这","提供","与其","中","new","新创","用于","共享","函数","绑定","用户","是","搜索","形式","会","init","在","内","方法","其中","不同","类","属性","然后","首先","值","以及","python","，","之后","表示","例如","进行","name","对象","任何","也","对","返回","访问","包括","来","运算","=","机制","新","检查",")","。","底层","创建","点","的","其","来自",".","给"," ","一个","分配","新创建","实例","多个","这些","将","所有","使用","则","以","可能","(","知道","__"],"title":"类实例","title_tokens":["实例","类"]},{"location":"Python基础/4.1.类.html#_2","text":"继承是一种创建新类的机制，目的是使用或修改现有类的行为。原始类称为 基类 或 超类 。新类称为 派生类 或 子类 。 通过继承创建类时，所创建的类将“继承”其基类定义的属性。==但是，==派生类可以重新定义任何这些属性并添加自己的新属性。 在class语句中用以逗号分隔的基类名称列表来指定继承。如果没有有效的基类，类将继承object。object是所有Python对象的根类，提供了一些常见方法（如 __str__() ，它可创建供打印函数使用的字符串）的默认实现。 继承通常用于重新定义现有方法的行为。 继承是用功能稍微增强的点 . 运算符实现的。具体来讲，如果搜索一个属性时未在实例或实例的类中找到匹配项，将会继续搜索基类。这个过程会一直继续下去，直到没有更多的基类可供搜索为止。 派生类重定义 __init__() 时，不会自动调用基类的 __init__() 方法。因此，如果派生类想重定义 __init__() ，还想调用基类的 __init__() 方法，那么要由派生类调用基类的 __init__() 方法来对它们进行恰当的初始化。如果基类未定义 __init__() ，就可以忽略这一步。如果不知道基类是否定义了 __init__() ，可在不提供任何参数的情况下调用它，因为始终存在一个不执行任何操作的默认 __init__() 实现。 # 定义一个人类 class Person : def __init__ ( self , name , age ): self . name = name self . age = age def get_name ( self ): return self . name def get_age ( self ): return self . age # 定义一个美国人类 ## 现在想给美国人在初始化的时候加上 性别 的属性 class American ( Person ): # 重新定义__init__()会覆盖Person的__init__()方法 def __init__ ( self , name , age , gender ): Person . __init__ ( self , name , age ) self . gender = gender def get_gender ( self ): return self . gender jackson = American ( name = \"Cesar T. Mauck\" , age = 14 , gender = \"male\" ) jackson . get_age () 14 jackson . get_gender () 'male' # 有时，派生类将重新实现方法，但是还想调用原始的实现。 为此，有一种方法可以显式地调用基类中的原始方法，将实例 self 作为第一个参数传递即可，如下所示： # 定义一个华盛顿人类 class Washington ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 age = American . get_age () age += 1 self . age = age print ( \"Washington people grow up one year old\" ) 这个例子的微妙之处在于，American这个类其实没有实现 get_age() 方法。该方法是在Person类中实现的。尽管这段代码能够运行，但它可能会引起一些混淆（例如，American是否应该实现 get_age() ? ）。因此，替代解决方案是用 super() 函数，如下所示： # 定义一个加利福尼亚人类 class California ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 ## 实际上，因为get_age()方法在Person中定义 ## 这里可以传入Person的任何一个派生类 age = super ( California , self ) . get_age () age += 1 self . age = age print ( \"Californians grow up one year old\" ) Terri = California ( \"Terri H. Booth\" , 25 , \"female\" ) Terri . growing_up () Californians grow up one year old super(cls, instance) 会返回一个特殊对象，该对象支持在基类上执行属性查找。如果使用该函数，Python将使用本来应该在基类上使用的正常搜索规则来搜索属性。有了这种方式，就无需写死方法位置，并且能更清晰地陈述你的意图（即你希望调用以前的实现，无论它是哪个基类定义的）。然而， super() 的语法尚有不足之处。如果使用Python 3，可以使用简化的语句 super().get_age() 来执行上面示例中的计算。","text_tokens":["例子","cls","名称","未定","一步","应该","忽略","参数","它","如果","gender","规则","self","原始","存在","实际","根类","时","由","'","}","female","该","数传","打印函数","还","目的","male","growing","重新","特殊","不","之处","默认","通过","将会","字符","即可","算符","传递","添加","terri","死","来讲","派生类","运算符","一些","调用","#","它们","新类","californians","尼亚","分隔","grow","不足","初始化","因为","尽管","派生","行为","mauck","_","支持","所示","修改","位置","这","提供","下去","人类","加利","段","简化","所","）","super","中","一直","自己","可以","用于","{","不足之处","示例","能","函数","显式","子类","第一","是","基类","“","object","搜索","一种","哪个","不会","混淆","加上","california","始终","有时","福尼亚","会","init","无论","为止","本来","在","str","你","稍微","instance","方法","参数传递","year","继续下去","类","?","方式","加利福尼亚","解决方案","类中","更","属性","意图","初始","其实","具体来讲","上","解决","jackson","陈述","t","要","之","但","##","并","方案","python","，","实现","american","能够","称为","尚有","为此","例如","进行","继续","清晰","3","name","对象","任何","对","print","没有","age","返回","时未","操作","washington","people","引起","这种","逗号","来","运算","现有","然而","在于","get","替代","=","功能","常见","处","语法",":","机制","具体","是否","：","情况","无需","新","f","有效",")","多","希望","计算","语句","覆盖","。","打印","时候","old","恰当","并且","如","创建","华盛顿","点","的","其","return","过程","因此","华盛","one","列表","up","继承","就","了",".","通常","给","可","第一个","传入","如下","用"," ","但是","一个","h","未定义","这里","class","项","+","1","微妙","14","想重","类时","代码","那么","实际上","booth","字符串","25","以前","这个","供","运行","cesar","写","定义","\"","实例","上面","这些","将","years","美国","所有","有","直到","指定",",","使用","人","找到","或","执行","def","”","作为","加利福","可能","匹配","重","超类","下","现在","想","person","性别","即","自动","(","正常","（","地","知道","增强","查找","__","用以"],"title":"继承","title_tokens":["继承"]},{"location":"Python基础/4.1.类.html#_3","text":"Python支持多重继承。通过让一个类列出多个基类即可指定多重继承。例如，下面给出了一个类集合： # 定义一个圣拉蒙人类 class San_Ramon ( American , California , Washington ): def growing_up ( self ): pass Edwin = San_Ramon ( \"Edwin A. Marcotte\" , 37 , \"male\" ) Edwin . get_age () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-6c60ffbe4e5a> in <module> 1 # 定义一个圣拉蒙人类 ----> 2 class San_Ramon(American, California, Washington): 3 def growing_up(self): 4 pass 5 TypeError: Cannot create a consistent method resolution order (MRO) for bases American, California, Washington 使用多重继承时，属性的解析会变得非常复杂，因为可以使用很多搜索路径来绑定属性。 在查找使用了多重继承的属性时，会将所有基类按从“最特殊”的类到“最不特殊”的类这种顺序进行排列。然后在搜索属性时，就会按这个顺序搜索，直至找到该属性的第一个定义。对于任何给定的类，通过打印它的 mro 属性即可查看基类的顺序，例如： 在大多数情况下，这个列表基于“有意义”的规则排列得出。也就是说，始终先检查派生类，然后再检查其基类，如果一个类具有多个父类，那么始终按类定义中列出的父类顺序检查这些父类。但是，基类的准确顺序实际上非常复杂，不是基于任何“简单的”算法，如深度优先或广度优先搜索。实际上，基类的顺序由 C3 线性化算法确定，可以在论文“A Monotonic Superclass Linearization for Dylan”（K. Barrett 等，发表于 OOPSLA’96）中找到该算法的介绍。该算法的一个需要注意的地方是，某些类层次结构将被 Python 拒绝并会抛出 TypeError 错误，例如： 一般来说，在大多数程序中最好避免使用多重继承。但是，多重继承有时可用于定义所谓的混合（mixin）类。混合类通常定义了要“混合到”其他类中的一组方法，目的是添加更多的功能（这与宏很类似）。通常，混合类中的方法将假定其他方法存在，并将以这些方法为基础构建。","text_tokens":["pass","很","barrett","for","规则","traceback","到","它","多数","如果","地方","self","确定","last","最","实际","层次结构","时","由","2","linearization","层次","存在","该","目的","growing","male","mro","特殊","不","于","通过","即可","发表","添加","派生类","#","’","论文","变得","路径","因为","---------------------------------------------------------------------------","派生","支持","_","优先","in","对于","这","ipython","人类","call","深度","method","）","拉蒙","中",">","不是","cannot","可以","用于","解析","96","input","给出","绑定","第一","线性","module","create","基类","搜索","“","是","一般来说","排列","让","california","始终","oopsla","来说","会","有时","在","列出","简单","方法","k","typeerror","类","程序","混合","非常","类中","属性","然后","某些","给定","准确","更","类似","37","算法","san","要","recent","错误","一组","圣","并","为","查看","python","，","american","介绍","也就是说","直至","3","例如","进行","一般","与","任何","6c60ffbe4e5a","结构","age","非常复杂","再","广度","washington","这种","等","来","edwin","get","集合","顺序","4","=","----","功能","基础",":","-","就是说","复杂","：","consistent","情况","检查",")","多","就是","大多数","。","most","最好","打印","父类","如","得出","superclass","c3","宏","的","ramon","其","假定","列表","up","继承","就","线性化","了",".","第一个","通常","可","基于"," ","但是","很多","一个","按","<","class","1","实际上","并会","那么","dylan","bases","mixin","这个","其他","下面","monotonic","定义","先","\"","多个","这些","将","避免","所有","有","marcotte","指定",",","使用","按类","找到","或","5","注意","def","order","从","”","抛出","以","resolution","下","拒绝","构建","需要","所谓","(","a","顺序搜索","意义","大多","多重","（","被","查找","具有"],"title":"多重继承","title_tokens":["继承","多重"]},{"location":"Python基础/4.1.类.html#_4","text":"动态绑定（在继承背景下使用时，有时也称为多态性）是指在不考虑实例类型的情况下使用实例只要以 obj.attr 的形式访问属性，就会按照一定的顺序搜索并定位 attr ： 首先是实例本身，接着是实例的类定义，然后是基类。 查找过程会返回第一个匹配项。 这种绑定过程的关键在于，它不受对象 obj 的类型影响。因此，如果执行像 obj.name 这样的查找，对所有拥有 name 属性的 obj 都是适用的。 polymorphism 源自希腊语，意思是“有多种形态”。这大致意味着即便你不知道变量指向的是哪种对象，也能够对其执行操作，且操作的行为将随对象所属的类型（类）而异。也就是同一种调用形式，但有不同的执行效果。 在Python中，多态也称为 鸭子类型 （duck typing）。这个术语源自 James Whitcomb Riley 在17世纪写下的一句诗： When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck. 真不知道谁想出这个术语的，如果用数学语言来类比，鸭子类型相当于数学的公理化定义。 Python 程序员经常编写利用这种行为的程序。例如，如果想编写现有对象的自定义版本，可以继承该对象，也可以创建一个外观和行为像它但与它无任何关系的全新对象。后一种方法通常用于保持程序组件的松散耦合。例如，可以编写代码来处理任何种类的对象，只要该对象拥有特定的方法集。最常见的例子就是利用标准库中定义的各种“类似文件”的对象。尽管这些对象的工作方式像文件，但它们并不是继承自内置文件对象的。","text_tokens":["例子","它","如果","一句","而异","公理","外观","后","最","关系","接着","时","相当于","标准","动态","该","所属","同","类型","数学","不","耦合","利用","多种","调用","like","它们","定位","尽管","只要","行为","和","影响","即便","这","全新","call","真不知道","术语","种类","）","关键在于","中","不是","大致","多态","变量","关键","可以","用于","bird","世纪","绑定","第一","walks","库中","是","搜索","基类","“","一种","形式","理化","有时","希腊","形态","会","在","typing","你","see","方法","松散","拥有","不同","类","polymorphism","程序","方式","这样","属性","然后","首先","类似","写下","riley","意味","但","并","python","，","能够","真不","称为","自定","例如","保持","相当","按照","name","对象","与","任何","也","i","对","不受","谁","随","语言","公理化","attr","返回","访问","都","这种","操作","and","内置","来","现有","工作","在于","集","顺序","编写","17","常见","且","自","：","效果","情况","whitcomb","程序员","james","多态性","适用","就是","本身","。","像","哪种","不知","创建","的","其","各种","过程","因此","特定","意思","指向","就","继承","类比","版本",".","第一个","通常","一定","希腊语","swims","用"," ","一个","意味着","经常","项","that","duck","当于","代码","出","处理","这个","定义","实例","这些","将","指","所有","有","考虑","自定义","背景","使用",",","无","鸭子","执行","诗","”","以","匹配","下","obj","想","源自","（","顺序搜索","a","when","文件","知道","quacks","组件","查找"],"title":"多态动态绑定和鸭子类型","title_tokens":["和","多态","动态","鸭子","类型","绑定"]},{"location":"Python基础/4.1.类.html#_5","text":"类中最常用的方法是实例方法，即 将实例作为第一个参数传递给该方法。 根据约定，这个参数名称为self，尽管所有合法的标识符都可以使用。 self 参数指向对象本身。 self 参数很有用，甚至必不可少。如果没有它，所有的方法都无法访问对象本身（要操作的属性所属的对象）。 下面是以是实例方法的例子： class Kls ( object ): def __init__ ( self , data ): self . data = data def printd ( self ): print ( self . data ) ik1 = Kls ( 'arun' ) ik2 = Kls ( 'seema' ) ik1 . printd () ik2 . printd () arun seema 然后看一下代码和示例图片: 在1、2中，参数传递给方法。 在3中， self参数指向当前实例。 在4中，我们不需要给方法提供实例， Python解释器自己会做这些操作 。","text_tokens":["例子","名称","很","参数","它","如果","self","无法访问","最","2","'","该","数传","所属","data","根据","合法","不","传递","有用","尽管","和","提供","解释","）","中","arun","自己","无法","可以","做","示例","当前","第一","是","object","释器","、","看","会","init","在","参数传递","方法","解释器","约定","类中","属性","然后","要","为","python","，","3","图片","对象","甚至","print","没有","访问","都","操作","4","=",":","：","我们",")","本身","。","的","指向","ik2",".","给","第一个","ik1"," ","一个","printd","class","1","代码","这个","kls","不可","下面","标识","实例","这些","将","所有",",","使用","标识符","def","作为","必不可少","以","seema","即","常用","一下","需要","(","（","__"],"title":"实例方法","title_tokens":["方法","实例"]},{"location":"Python基础/4.1.类.html#_6","text":"Note 以下两个代码示例介绍了静态方法的两个应用场景： 不需要访问实例对象或类对象的方法和属性，但与类有关的功能 创建构造函数 经常有一些跟类有关系的功能，但在运行时又不需要实例和类参与（比如更改环境变量或者修改其他类的属性），当然可以在类定义之外写一个函数实现这些功能，但这样会扩散类内部的代码，不利于代码的维护。比如这样： IND = 'ON' def checkind (): return ( IND == 'ON' ) class Kls ( object ): def __init__ ( self , data ): self . data = data def do_reset ( self ): if checkind (): print ( 'Reset done for:' , self . data ) def set_db ( self ): if checkind (): self . db = 'new db connection' print ( 'DB connection made for:' , self . data ) ik1 = Kls ( 12 ) do_reset ( ik1 ) # Reset done for: 12 set_db ( ik1 ) # DB connection made for: 12 如果使用 @staticmethod 就能把相关的代码放到对应的位置了。 IND = 'ON' class Kls ( object ): def __init__ ( self , data ): self . data = data @staticmethod def checkind (): return ( IND == 'ON' ) def do_reset ( self ): if self . checkind (): print ( 'Reset done for:' , self . data ) def set_db ( self ): if self . checkind (): self . db = 'New db connection' print ( 'DB connection made for: ' , self . data ) ik1 = Kls ( 12 ) ik1 . do_reset () ik1 . set_db () Reset done for: 12 DB connection made for: 12 实际上，静态方法是一种普通函数，只不过它们正好位于类定义的命名空间中， 因为它不会对任何实例类型进行操作 。 如果在编写类时需要采用很多不同的方式来创建新实例，则常常使用静态方法。因为类中只能有一个 __init__() 函数，所以替代的创建函数通常按如下方式定义： import time class Date ( object ): def __init__ ( self , year , month , day ): self . year = year self . month = month self . day = day @staticmethod def now (): t = time . localtime () return Date ( t . tm_year , t . tm_mon , t . tm_mday ) @staticmethod def tomorrow (): t = time . localtime ( time . time () + 86400 ) return Date ( t . tm_year , t . tm_mon , t . tm_mday ) # 创建日期的示例 a = Date ( 1967 , 4 , 9 ) b = Date . now () # 调用静态方法now() c = Date . tomorrow () # 调用静态方法tomorrow()","text_tokens":["构造函数","for","环境","made","如果","构造","它","day","self","关系","静态方法","之外","实际","时","'","data","类型","mon","不利于","set","不","#","一些","调用","采用","它们","on","把","因为","_","和","修改","位置","参与","note","db","）","中","new","变量","可以","对应","示例","场景","函数","能","常常","86400","object","是","一种","不会","b","@","会","init","有关","在","日期","方法","reset","year","正好","不同","类","方式","这样","类中","属性","checkind","位于","t","mday","但","staticmethod","只能","1967","介绍","，","实现","不过","connection","tm","进行","tomorrow","对象","与","任何","扩散","对","print","内部","访问","环境变量","操作","命名","利于","来","c","编写","替代","功能","=","4",":","9","：","month","新","更改",")","do","所以","import","跟类","。","当然","静态","创建","的","return","12","就","以下","了","维护",".","ik1","相关","通常","localtime","如下","date"," ","普通","或类","一个","很多","放到","按","经常","class","now","+","实际上","又","代码","类时","done","其他","kls","运行","写","定义","实例","这些","if","有",",","使用","则","空间","不利","ind","def","或者","需要","比如","两个","time","(","（","a","应用","只不过","环境变","__"],"title":"静态方法","title_tokens":["静态","静态方法","方法"]},{"location":"Python基础/4.1.类.html#_7","text":"Note 以下两个代码示例介绍了类方法的两个应用场景： 创建构造函数 动态更新类 类方法是将类本身作为对象进行操作的方法。类方法使用 @classmethod 装饰器定义，与实例方法不同，Python解释器会将类本身传递给类方法的第一个参数（一般将该参数命名为 cls ）。例如： class Times ( object ): factor = 1 @classmethod def mul ( cls , x ): return cls . factor * x class TwoTimes ( Times ): factor = 2 x = TwoTimes . mul ( 4 ) # 调用Times.mul(TwoTimes, 4) -> 8 在这个例子中，请注意类 TwoTimes 是如何作为对象传递给 mul() 的。尽管这个例子有些深奥，但类方法还有一些实用且巧妙的用法。例如，你定义了一个类，它继承自前面给出的 Date 类并对其略加定制： class EuroDate ( Date ): # 修改字符串转换，以使用欧洲日期格式 def __str__ ( self ): return \" %02d / %02d / %4d \" % ( self . day , self . month , self . year ) 由于该类继承自 Date，所以它拥有 Date 的所有特性。但是 now() 和 tomorrow() 方法稍微有点不同。例如，如果调用 EuroDate.now()，则会返回 Date 对象，而不是 EuroDate 对象。类方法可以解决该问题： class Date ( object ): def __init__ ( self , year , month , day ): self . year = year self . month = month self . day = day @classmethod def now ( cls ): t = time . localtime () return cls ( t . tm_year , t . tm_mon , t . tm_mday ) @classmethod def tomorrow ( cls ): t = time . localtime ( time . time () + 86400 ) return cls ( t . tm_year , t . tm_mon , t . tm_mday ) class EuroDate ( Date ): # 修改字符串转换，以使用欧洲日期格式 def __str__ ( self ): return \" %02d / %02d / %4d \" % ( self . day , self . month , self . year ) a = Date . now () # 调用Date.now(Date)并返回Date b = EuroDate . now () # 调用Date.now(EuroDate)并返回EuroDate print ( type ( a )) print ( type ( b )) <class '__main__.Date'> <class '__main__.EuroDate'> 类方法除了用于创建构造函数，另一个例子是动态更新类。例如我们想动态更新一个类属性： class Kls ( object ): models = {} def __init__ ( self , model_name ): # 加载模型 pass @classmethod def load_model ( cls , model_name ): cls . models [ model_name ] = cls ( model_name ) @classmethod def get_model ( cls , model_name ): return cls . models . get ( model_name , None ) def predict ( self ): return \"预测结果为1\" model_name = \"svm\" Kls . load_model ( model_name ) model = Kls . get_model ( model_name ) model . predict () '预测结果为1' Kls . models {'svm': <__main__.Kls at 0x21aaefe5908>} 当然，除了使用类方法，也可以在实例方法中显式调用类属性，达到动态更新类的效果，例如我们要获取实例数： class Kls ( object ): no_inst = 0 def __init__ ( self ): Kls . no_inst = Kls . no_inst + 1 @classmethod def get_no_of_instance ( cls_obj ): return cls_obj . no_inst ik1 = Kls () ik2 = Kls () print ( ik1 . get_no_of_instance ()) print ( Kls . get_no_of_instance ()) 2 2 但是如果要用实例方法实现的话，就得创建一个实例对象，这意味着我们必须要给这个实例对象命名。在编程中，给过多的变量命名，有时是一个头疼的问题。 在类外面写一个函数也可以实现这样的效果，但不利于代码的维护。 def get_no_of_instances ( cls_obj ): return cls_obj . no_inst class Kls ( object ): no_inst = 0 def __init__ ( self ): Kls . no_inst = Kls . no_inst + 1 ik1 = Kls () ik2 = Kls () print ( get_no_of_instances ( Kls )) 2","text_tokens":["cls","例子","pass","构造函数","参数","它","如果","构造","结果","day","self","predict","除了","编程","2","'","巧妙","}","动态","该","得","mon","有些","不利于","获取","no","*","字符","load","传递","eurodate","模型","预测","#","调用","一些","model","请","尽管","_","和","修改","外面","这","解释","note","还有","inst","）","8","定制","中",">","不是","instances","必须","models","变量","可以","转换","用于","{","示例","场景","函数","特性","给出","86400","第一","用法","是","释器","object","b","有时","@","会","/","init","而","格式","在","str","你","日期","02d","稍微","方法","instance","twotimes","year","classmethod","拥有","不同","解释器","类","这样","0x21aaefe5908","属性","[","有点","解决","意味","t","mday","要","但","为","并","介绍","，","python","实现","过","例如","tm","一般","进行","但类","tomorrow","name","对象","如何","与","深奥","]","也","对","print","返回","更新","操作","4d","命名","利于","装饰","get","另","4","=","且",":","-","自","：","month","效果","实用","我们",")","所以","多","本身","。","中显式","main","当然","创建","的","x","return","其","达到","继承","就","以下","ik2","数","问题","了","给","第一个",".","ik1","localtime","type","of","维护","用","date"," ","但是","一个","意味着","<","class","now","+","1","代码","字符串","factor","这个","加载","kls","none","的话","头疼","写","定义","\"","实例","将","所有","0","times",",","使用","则","__.","注意","svm","不利","def","略加","作为","%","以","器","想","obj","前面","该类","time","两个","(","由于","（","a","应用","欧洲","at","mul","__"],"title":"类方法","title_tokens":["方法","类"]},{"location":"Python基础/4.1.类.html#_8","text":"在实例方法和类方法中，Python默认将当前实例或者类对象传给方法的第一个参数（非指定默认值的参数），如果方法不设置参数，便会报错： class Kls ( object ): def __init__ ( self , data ): self . data = data def imethod1 (): print ( \"不接收实例\" ) def imethod2 ( * arg ): print ( 'Instance:' , arg ) @staticmethod def smethod ( * arg ): print ( 'Static:' , arg ) @classmethod def cmethod1 (): print ( \"不接收类对象\" ) @classmethod def cmethod2 ( * arg ): print ( 'Class:' , arg ) ik3 = Kls ( 'arun' ) ik3 . imethod1 () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-82fbcd62768a> in <module> 1 ik3 = Kls('arun') ----> 2 ik3.imethod1() TypeError: imethod1() takes 0 positional arguments but 1 was given ik3 . cmethod1 () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-6055e1d64eee> in <module> ----> 1 ik3.cmethod1() TypeError: cmethod1() takes 0 positional arguments but 1 was given 实例方法、类方法必须设置参数接收类对象： ik3 . imethod2 () ik3 . cmethod2 () Instance: (<__main__.Kls object at 0x0000021AAEFF0390>,) Class: (<class '__main__.Kls'>,) 静态方法则不会传入实例或类对象： ik3 . smethod () Static: () 如果方法不设置参数，只能通过类去调用，应该避免这种用法，没参数的方法应该加上 @staticmethod 装饰器： Kls . imethod1 () 不接收实例 关于静态方法和类方法需要注意的一点是，Python 不会在与实例方法独立的命名空间中管理它们。因此，可以通过实例或类调用它们。例如： Kls . cmethod2 () Kls ( 'arun' ) . cmethod2 () Kls . smethod () Kls ( 'arun' ) . smethod () Class: (<class '__main__.Kls'>,) Class: (<class '__main__.Kls'>,) Static: () Static: () 这可能很容易引起混淆，因为对 Kls('arun').cmethod2() 的调用与实例 Kls('arun') 没有任何关系。 这种行为是 Python 对象系统与其他面向对象语言（如 Smalltalk 和 Ruby）对象系统的区别之一。在这些语言中，类方法与实例方法是严格分开的。 而实例方法必须通过实例调用，因为需要传入实例。","text_tokens":["很","应该","参数","traceback","如果","self","cmethod2","报错","last","positional","关系","静态方法","ik3","2","'","data","6055e1d64eee","不","严格","默认","通过","*","调用","它们","was","因为","---------------------------------------------------------------------------","之一","行为","和","static","in","管理","这","ipython","系统","call","分开","）","中","arun",">","必须","可以","input","0x0000021aaeff0390","当前","第一","arg","object","cmethod1","module","用法","imethod2","、","是","不会","混淆","加上","@","关于","init","而","在","instance","方法","classmethod","typeerror","类","传给","arguments","recent","staticmethod","只能","python","，","独立","例如","容易","ruby","类去","对象","与","任何","对","语言","print","没有","这种","引起","given","一点","命名","便会","装饰","=","----",":","-","：","82fbcd62768a","接收",")","most","。","面向","takes","main","静态","imethod1","如","的","没","因此","面向对象",".","传入","第一个"," ","smethod","或类","一个","<","class","1","设置","非","其他","kls","\"","实例","这些","将","避免","0","指定",",","则","__.","空间","注意","smalltalk","but","区别","def","或者","可能","器","默认值","需要","(","（","at","__"],"title":"实例方法、静态方法、类方法对比","title_tokens":["静态","对比","静态方法","、","类","实例","方法"]},{"location":"Python基础/4.1.类.html#_9","text":"@property ——把方法变为属性 通常，访问实例或类的属性时，返回的会是所存储的相关值。特性（property）是一种特殊的属性，访问它时会计算它的值。下面是一个简单的例子： import math class Circle ( object ): def __init__ ( self , radius ): self . radius = radius # Circle的一些附加特性 @property def area ( self ): return math . pi * self . radius ** 2 @property def preimeter ( self ): return 2 * math . pi * self . radius 得到的Circle对象的行为如下： c = Circle ( 4.0 ) c . radius 4.0 c . area 50.26548245743669 c . preimeter 25.132741228718345 c . area = 2 ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-0dac39a0c579> in <module> ----> 1 c.area = 2 AttributeError: can't set attribute 在这个例子中，Circle 实例存储了一个实例变量 c.radius 。 c.area 和 c.perimeter 是根据该值计算得来的。 @property 装饰器支持以简单属性的形式访问后面的方法，无需像平常一样添加额外的 () 来调用该方法。对象的使用者很难发现正在计算一个属性，除非在试图重新定义该属性时生成了错误消息（如上面的 AttributeError 异常所示）。 这种特性使用方式遵循所谓的统一访问原则。 实际上，如果定义一个类，尽可能保持编程接口的统一总是不错的。如果没有特性，将会以简单属性（如 c.radius ）的形式访问对象的某些属性，而其他属性将以方法（如 c.area() ）的形式访问。费力去了解何时添加额外的 () 会带来不必要的混淆。特性可以解决该问题。 Python 程序员很少认识到， 方法本身是被隐式地作为一类特性处理的。 考虑下面这个类： class Foo ( object ): def __init__ ( self , name ): self . name = name def spam ( self , x ): print ( \" %s , %s \" % ( self . name , x )) Foo ( \"d\" ) . spam <bound method Foo.spam of <__main__.Foo object at 0x0000021AAEFDC7B8>> 用户创建 f = Foo(\"Guido\") 这样的实例然后访问 f.spam 时，不会返回原始函数对象 spam ，而是会得到所谓的绑定方法（bound method），绑定方法是一个对象，代表将在对象上调用 () 运算符时执行的方法调用。绑定方法有点类似于已部分计算的函数，其中的self参数已经填入，但其他参数仍然需要在使用 () 调用该函数时提供。这种绑定方法对象是由在后台执行的特性函数静默地创建的。 使用 @staticmethod 和 @classmethod 定义静态方法和类方法时，实际上就指定了使用不同的特性函数，以不同的方式处理对这些方法的访问。 例如， @staticmethod 仅“按原样”返回方法函数，不会进行任何特殊的包装或处理。 特性还可以截获操作权，以设置和删除属性。这是通过向特性附加其他 setter 和 deleter 方法来实现的，如下所示： class Foo ( object ): def __init__ ( self , name ): self . __name = name @property def name ( self ): return self . __name @name . setter def name ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value @name . deleter def name ( self ): raise TypeError ( \"Can't delete name\" ) 在这个例子中，首先使用 @property 装饰器和相关方法将属性 name 定义为只读特性。后面的 @name.setter 和 @name.deleter 装饰器将其他方法与 name 属性上的设置和删除操作相关联。这些方法的名称必须与原始特性的名称完全匹配。在这些方法中，请注意实际的名称值存储在属性 __name 中。所存储属性的名称无需遵循任何约定，但它必须与特性名称不同，以便将它与特性的名称区分开。 在以前的代码中，通常会看到用 property(getf=None, setf=None, delf=None, doc=None) 函数来定义特性，往其中传入一组名称不同的方法，用于执行相关操作。例如： class Foo ( object ): def getname ( self ): return self . __name def setname ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value def delname ( self ): raise TypeError ( \"Can't delete name\" ) name = property ( getname , setname , delname ) 这种老方法仍然可以使用，但装饰器版本会让类看起来更整洁。 例如，如果使用装饰器，get、 set 和 delete 函数将不会显示为方法。","text_tokens":["self","平常","getf","遵循","一类","'","该","仅","set","*","算符","必要","调用","请","area","行为","支持","包装","所示","存储","附加","in","method","截获","该值","特性","部分","是","不会","以便","be","not","额外","方式","程序","这样","类似","错误","一组","staticmethod","doc","python","实现","用者","相关联","访问","来","装饰","----","程序员",")","计算","。","看到","统一","的","得到","attributeerror","版本","了"," ","开","<","消息","pi","处理","这个","getname","实例","尽可","将","考虑","使用","或","!","%","匹配","代表","a","时会","at","总是","被","尽可能","这是","它","traceback","而是","value","last","实际","由","2","还","重新","添加","运算符","正在","删除","和","提供","中","必须","后台","函数","一种","init","而","str","只读","简单","不必要","其中","不同","typeerror","attribute","某些","isinstance","首先","解决","，","使用者","与","print","没有","c","接口","试图","string","perimeter","看起来","=","import","delf","原则","如","就","delete","of","用","或类","按","1","实际上","设置","下面","none","得来","原样","注意","关联","带来","(","setf","raise","例子","名称","参数","4.0","s","如果","到","原始","—","静态方法","时","编程","生成","于","通过","将会","一些","很少","---------------------------------------------------------------------------","ipython","call","所","变量","可以","radius","input","不错","“","@","会","can","方法","一样","类","约定","更","属性","然后","有点","t","值","为","权","circle","例如","进行","保持","name","任何","对","bound","操作","get","must","foo",":","无需","f","了解","本身","most","像","main","后面","创建","显示","x","问题","25.132741228718345",".","通常","一个","class","代码","填入","其他","math","\"","上面","这些","if","指定","def","spam","器","需要","（","地","已","delname","deleter","preimeter","隐式","完全","老","不必","d","根据","特殊","#","把","去","看起","）","0dac39a0c579","认识",">","何时","用于","绑定","用户","module","object","起来","、","形式","混淆","让","在","classmethod","上","recent","但","setname","发现","guido","对象","区分","返回","property","除非","这种","运算","-","：","50.26548245743669","费力","静态","0x0000021aaefdc7b8","return","传入","相关","异常","如下","已经","以前","向","定义",",","__.","仍然","执行","很难","作为","”","以","可能","setter","往","静默","所谓","整洁","变为","__"],"title":"特性","title_tokens":["特性"]},{"location":"Python基础/4.1.类.html#_10","text":"默认情况下，类的所有属性和方法都是“公共的”。这意味着对它们的访问没有任何限制。这还暗示着，在基类中定义的所有内容都会被派生类继承，并可从派生类内进行访问。在面向对象的应用程序中，通常我们不希望发生这种行为，因为它会暴露对象的内部实现，可能导致在派生类中定义的对象与在基类中定义的对象之间发生命名空间冲突。 Note 这意味着派生类可以覆盖基类的定义。 为了解决该问题， 类中所有以双下划线开头的名称（如 __Foo ）都会自动变形，形成具有 _Classname__Foo 形式的新名称。 这提供了一种在类中添加私有属性和方法的有效方式，因为派生类中使用的私有名称不会与基类中使用的相同私有名称发生冲突，如下所示： class A ( object ): def __init__ ( self ): self . __X = 3 # 变形为self._A__X def __spam ( self ): # 变形为_A__spam() print ( \"A\" ) def bar ( self ): self . __spam () # 只调用A.__spam() class B ( A ): def __init__ ( self ): A . __init__ ( self ) self . __X = 37 # 变形为self._B__X def __spam ( self ): # 变形为_B__spam() print ( \"B\" ) b = B () # 派生类的定义没有覆盖基类的定义 b . bar () A 尽管这种方案似乎隐藏了数据，但并没有严格的机制来实际阻止对类的“私有”属性进行访问。特别是如果已知类名称和相应私有属性的名称，则可以使用变形后的名称来访问它们。通过重定义 dir() 方法，类可以降低这些属性的可见性， dir() 方法提供了检查对象的 dir() 函数所返回的名称列表。 尽管这种名称变形似乎是一个额外的处理步骤，但变形过程实际上只在定义类时发生一次。它不会在方法执行期间发生，也不会为程序的执行添加额外的开销。而且要知道，名称变形不会在 getattr() 、 hasattr() 、 setattr() 或 delattr() 等函数中发生，在这些函数中，属性名被指定为字符串。对于这些函数，需要显式使用变形名称（如 __Classname__name ）来访问属性。 建议在定义可变属性时，通过特性来使用私有属性。这样，就可鼓励用户使用特性名称，而无需直接访问底层实例数据（如果你在实例开头添加了一个特性，可能不想采用这种访问方式）。 通过为方法提供私有名称，超类可以阻止派生类重新定义和更改方法的实现。 例如，示例中的 A.bar() 方法只调用 A.__spam() ，无论 self 具有何种类型，或者派生类中是否存在不同的 __spam() 方法都是如此。 最后，不要混淆私有类属性的命名和模块中“私有”定义的命名。一个常见的错误是，在定义类时，在属性名上使用单个前导下划线来隐藏属性值（如 _name ）。 在模块中，这种命名约定可以阻止通过 from module import * 语句导出名称。 这意味着单下划线开头的定义只能被类本身和其派生类访问。但是在类中，这种命名约定既不能隐藏属性，在某个类继承该类并使用相同名称定义一个新属性或方法时，也不能阻止出现名称冲突。","text_tokens":["发生","名称","它","如果","降低","可见","self","不能","形成","名","后","实际","暗示","时","存在","该","隐藏","前导","还","hasattr","类型","步骤","重新","不","严格","默认","通过","字符","*","添加","派生类","#","调用","期间","采用","它们","冲突","已知","模块","因为","尽管","派生","行为","_","和",".__","所示","这","提供","对于","note","所","._","）","何种","中","导致","可以","如此","示例","特性","函数","显式","不想","用户","module","是","“","基类","object","、","一种","形式","不会","混淆","无论","b","会","init","而","出现","在","某个","你","内","方法","不同","类","只","程序","方式","额外","这样","类中","开头","属性","约定","阻止","37","解决","意味","相应","要","值","但","错误","只能","暴露","并","为","方案","，","实现","似乎","3","例如","进行","name","对象","既","与","任何","也","对","delattr","print","没有","内部","返回","访问","都","这种","命名","setattr","等","相同","来","划线","名上","=","常见","以双","foo",":","限制","机制","是否","：","情况","之间","新","无需","更改","为了","有效","我们","检查","而且",")","直接","发生冲突","import","希望","语句","覆盖","。","面向","底层","暗示着","开销","本身","如","classname","的","x","其","过程","对类","列表","继承","就","问题","面向对象","最后","了",".","通常","可","如下"," ","但是","鼓励","一个","意味着","class","实际上","公共","类时","字符串","一次","导出","单","处理","私有","单个","定义","\"","数据","实例","这些","所有","dir","内容","下划线","指定","使用","则","可变","空间","或","下划","不要","执行","def","”","从","spam","可能","重","性","超类","下","或者","建议","bar","自动","该类","需要","特别","(","（","a","应用","变形","应用程序","知道","它会","getattr","from","被","具有","__"],"title":"数据封装和私有属性","title_tokens":["封装","和","属性","数据","私有"]},{"location":"Python基础/4.1.类.html#_11","text":"从内部实现上看，实例是使用字典来实现的，可以通过实例的 __dict__ 属性访问该字典。这个字典包含的数据对每个实例而言都是唯一的，如下所示： class Account ( object ): def __init__ ( self , name , balance ): self . name = name self . balance = balance a = Account ( \"Guido\" , 1100.0 ) a . __dict__ {'name': 'Guido', 'balance': 1100.0} 可以在任何时候向实例添加新属性，例如： a . number = 123456 # 将属性'number'添加到 a.__dict__ 对实例的修改始终会反映到局部 __dict__ 属性中。同样，如果直接对 __dict__ 进行修改，所做的修改也会反映在实例的属性中。 实例通过特殊属性 __class__ 链接回它们的类。类本身也只是对字典的浅层包装，你可以在实例的 __dict__ 属性中找到这个字典。可以在类字典中找到各种方法。例如： a . __class__ __main__.Account Account . __dict__ . keys () dict_keys(['__module__', '__init__', '__dict__', '__weakref__', '__doc__']) 最后，通过特殊属性 __bases__ 中将类链接到它们的基类，该属性是一个基类元组。这种底层结构是获取、设置和删除对象属性的所有操作的基础。 只要使用 obj.name = value 设置了属性，特殊方法 obj.__setattr__(\"name\", value) 就会被调用。如果使用 del obj.name 删除了一个属性，就会调用特殊方法 obj.__delattr__(\"name\") 。 这些方法的默认行为是修改或删除 obj 的局部 __dict__ 的值，除非请求的属性正好是一个特性或描述符。在这种情况下，设置和删除操作将由与该特性相关联的设置和删除函数执行。 在查找属性（如 obj.name ）时，将调用特殊方法 obj.__getattrribute__(\"name\") 。该方法执行搜索来查找该属性，这通常涉及检查特性、查找局部 __dict__ 属性、检查类字典以及搜索基类。如果搜索过程失败，最终会尝试调用类的 __getattr__() 方法（如果已定义）来查找该属性。如果这也失败，就会抛出 AttributeError 异常。 如果有必要，用户定义的类可以实现其自己的属性访问函数。例如： import math class Circle ( object ): def __init__ ( self , radius ): self . radius = radius def __getattr__ ( self , name ): if name == 'area' : return math . pi * self . radius ** 2 elif name == 'perimeter' : return 2 * math . pi * self . radius else : return object . __getattr__ ( self , name ) def __setattr__ ( self , name , value ): if name in [ 'area' , 'perimeter' ]: raise TypeError ( \" %s is readonly\" % name ) from None object . __setattr__ ( self , name , value ) c = Circle ( 2 ) c . area 12.566370614359172 c . area = 10 ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-52599b4ddcfc> in <module> ----> 1 c.area = 10 <ipython-input-1-a1a0cdcb1eb3> in __setattr__(self, name, value) 13 def __setattr__(self,name,value): 14 if name in ['area','perimeter']: ---> 15 raise TypeError(\"%s is readonly\" % name) from None 16 object.__setattr__(self,name,value) TypeError: area is readonly 重新实现这些方法的类应该可以依靠 object 中的默认实现来执行实际的工作。这是因为默认实现能够处理类的更高级特性，如描述符和特性。 一般来讲，类很少重新定义属性访问运算符。但是，在编写通用的包装器和现有对象的代理时，通常会使用属性访问运算符。通过重新定义 __getattr__() 、 __setattr__() 和 __delattr__() ，代理可以捕获属性访问操作，并透明地将这些操作转发给另一个对象。","text_tokens":["应该","s","traceback","到","如果","self","number","123456","中将","value","10","getattrribute","else","last","描述符","代理","实际","时","由","2","'","}","该","是因为","转发","dict","唯一","15","重新","特殊","获取","默认","通过","*","算符","添加","链接","来讲","#","1100.0","调用","必要","描述","它们","运算符","发给","字典","很少","因为","area","只要","---------------------------------------------------------------------------","删除","行为","包装","_","和",".__","所示","修改","in","每个","account","这","ipython","所","call","a1a0cdcb1eb3","）","中",">","自己","可以","做","{","radius","特性","函数","input","一般来讲","用户","module","是","object","基类","搜索","、","看","始终","会","init","在","你","方法","readonly","正好","typeerror","类","更","属性","del","[","上","元组","回","值","recent","以及","doc","并","失败","实现","，","能够","例如","同样","进行","circle","13","16","一般","已","guido","name","对象","与","任何","也","]","对","delattr","相关联","结构","除非","内部","访问","都","反映","这种","操作","setattr","来","c","运算","工作","现有","perimeter","另","涉及","编写","=","----","基础",":","-","：","---","情况","新","keys","is","elif","检查","直接",")","捕获","import","raise","本身","。","most","底层","main","时候","如","尝试","的","各种","其","过程","return","就","attributeerror","而言","最后",".","了","请求","相关","通常","异常","如下"," ","但是","一个","<","class","依靠","1","14","pi","weakref","设置","bases","处理","这个","向","math","none","浅层","定义","数据","实例","\"","转发给","这些","将","最终","if","所有","高级","有","52599b4ddcfc",",","使用","找到","__.","或","关联","执行","def","包含","从","%","通用","只是","抛出","下","器","obj","balance","12.566370614359172","(","a","（","地","from","透明","局部","getattr","被","查找","__"],"title":"对象表示和属性绑定","title_tokens":["对象","和","属性","表示","绑定"]},{"location":"Python基础/4.1.类.html#__slots__","text":"通过定义特殊变量 slots ，类可以限制对合法实例属性名称的设置，如下所示： class Account ( object ): def __init__ ( self , name , balance ): self . name = name self . balance = balance __slots__ = ( 'name' , 'balance' ) a = Account ( \"Guido\" , 1100.0 ) a . date = \"12-12\" ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-b978ca4ed4ad> in <module> 7 8 a = Account(\"Guido\", 1100.0) ----> 9 a.date = \"12-12\" AttributeError: 'Account' object has no attribute 'date' 定义 __slots__ 时，可以将实例上分配的属性名称限制为指定的名称，否则将引发 AttributeError 异常。这种限制可以阻止其他人向现有实例添加新属性，即便用户将属性名称写错，也不会创建出新的属性来。 在实际使用中， __slots__ 从未被当作一种安全的特性来实现。它实际上是对内存和执行速度的一种性能优化。 使用 __slots__ 的类的实例不再使用字典来存储实例数据，转而采用一种基于数组的更加紧凑的数据结构。在会创建大量对象的程序中，使用 __slots__ 可以显著减少减少内存占用和执行时间。 注意， __slots__ 与继承的配合使用需要一定的技巧。如果类继承自使用 __slots__ 的基类，那么它也需要定义 __slots__ 来存储自己的属性（即使它不会添加任何属性也是如此），这样才能利用 __slots__ 提供的优势。如果忘记了这一点，派生类的运行速度将更慢，占用的内存也更多，比完全不使用 __slots__ 时情况更糟。 __slots__ 的使用还会破坏期望实例具有底层 __dict__ 属性的代码。尽管这一点通常不适用于用户代码，但对于支持对象的实用库和其他工具，其代码可能要依靠 __dict__ 来调试、序列化对象以及执行其他操作。 最后，如果类中重新定义了 __getattribute__() 、 __getattr__() 和 __setattr__() 等方法， __slots__ 的存在不会对它们的调用产生任何影响。但是，这些方法的默认行为将考虑到 __slots__ 。此外应该强调一点，没有必要向 __slots__ 添加方法或特性名称，因为它们存储在类中，而不是存储在每个实例中。","text_tokens":["影响","名称","应该","traceback","它","如果","到","self","紧凑","完全","last","实际","存在","时","引发","'","从未","大量","dict","合法","序列化","此外","重新","特殊","no","不","默认","通过","利用","添加","slots","期望","派生类","必要","1100.0","调用","采用","它们","字典","尽管","---------------------------------------------------------------------------","因为","派生","支持","行为","7","和","还会","所示","存储","in","即便","account","这","提供","对于","b978ca4ed4ad","每个","ipython","call","）","8","中",">","自己","不是","变量","可以","否则","用于","如此","减少","input","特性","用户","module","object","是","基类","、","一种","不会","会","init","而","在","出新","忘记","方法","产生","技巧","类","attribute","程序","优势","这样","类中","更","属性","阻止","上","当作","要","recent","但","以及","更慢","为","数组","，","实现","数据结构","工具","guido","name","更加","对象","与","任何","也","破坏","对","才能","结构","转而","没有","优化","这种","操作","setattr","一点","等","更糟","来","现有","getattribute","=","----","性能",":","限制","-","9","自","：","即使","情况","实用","新","库",")","多","调试","most","。","底层","创建","不再","的","其","12","继承","attributeerror","has","最后",".","占用","了","异常","一定","通常","基于","如下","date"," ","但是","<","class","依靠","1","分配","实际上","代码","那么","写错","他人","设置","其他","不适","向","运行","定义","\"","实例","数据","显著","这些","将","其他人","考虑","指定",",","使用","时间","比","注意","或","执行","def","可能","配合","balance","序列","内存","安全","需要","(","a","（","getattr","强调","被","速度","具有","__"],"title":"__slots__","title_tokens":["__","slots"]},{"location":"Python基础/4.1.类.html#_12","text":"difference between staticmethod and classmethod in python","text_tokens":["and","classmethod","staticmethod","between"," ","in","python","difference"],"title":"参考","title_tokens":["参考"]},{"location":"Python基础/4.2.模块.html","text":"为什么需要模块 如果你想要编写一些更大的程序，肯定不想定义重复的函数、类，想让代码可以重复使用。随着程序变得越来越大，你可能想要将它分割成几个更易于维护的文件。为了满足这些需要，Python 提供了一个方法可以从文件中获取定义，在脚本或者解释器的一个交互式实例中使用。这样的文件被称为模块。 模块搜索路径 Python 怎样知道从何处找到模块文件？ 如果你熟悉命令行，那么这个问题对你来说就不难理解。在命令行中执行的任何命令，实际上背后都对应了一个可执行文件。命令行解释器（比如 cmd, bash）会从一个全局的环境变量 PATH 中读取一个有序的列表。这个列表包含了一系列的路径，而命令行解释器，会依次在这些路径里，搜索需要的可执行文件。 Python 搜寻模块文件，也遵循了类似的思路。比如，用户在 Python 中尝试导入 import foobar，那么 首先，Python 会在内建模块中搜寻 foobar； 若未找到，则 Python 会在当前工作路径（当前脚本所在路径，或者执行 Python 解释器的路径）中搜寻 foobar； 若仍未找到，则 Python 会在环境变量 PYTHONPATH 中指示的路径中搜寻 foobar； 若依旧未能找到，则 Python 会在安装时指定的路径中搜寻 foobar； 若仍旧失败，则 Python 会报错，提示找不到 foobar 这个模块。 添加搜索路径 当我们使用import加载自己编写的py代码时，必须放在python的默认路径下才可以import。 添加临时路径—— sys.path.append 在python中引入 sys ， sys 中的 path 是一个列表类型的对象，内容就是路径的列表，我们将sys引入后查看就可以清楚的知道了： import sys print ( type ( sys . path )) [ path for path in sys . path if \"Wiki\" not in path ] <class 'list'> ['C:\\\\Users\\\\Android\\\\Desktop', 'G:\\\\Installed\\\\Anaconda3\\\\python37.zip', 'G:\\\\Installed\\\\Anaconda3\\\\DLLs', 'G:\\\\Installed\\\\Anaconda3\\\\lib', 'G:\\\\Installed\\\\Anaconda3', 'C:\\\\Users\\\\Android\\\\AppData\\\\Roaming\\\\Python\\\\Python37\\\\site- packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site- packages\\\\xgboost-1.0.0_snapshot-py3.7.egg', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32\\\\lib', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\Pythonwin', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\IPython\\\\extensions', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop'] 既然是list对象，那么使用append可以向列表添加新的元素，假设我们要添加的路径是 \"C:\\Users\\Android\\Desktop\" ： import sys sys . path . append ( r \"C:\\Users\\Android\\Desktop\" ) 但这只是临时添加路径，如果重启编译器，添加的路径就会消失。 修改环境变量 在Windows10中，选择 ->控制面板\\系统和安全\\系统->高级系统设置->环境变量 ， # 找到path后选择编辑，添加新的路径。 但这种方法不能适用所有python的功能，因为这种方法并未将要查找的路径添加到python的Path系统环境中，在sys.path的列表中找不到相关路径的元素。也就是说这样做并没有将路径添加到python的搜索路径中。 添加永久搜索路径——增加.pth文件 在site-packages文件夹添加path文件，可以实现搜索路径的永久添加。方法如下： 先编辑一个扩展名为 .pth 的文本文件，在这个文本文件里面写上要添加的path就可以了，例如： 文本文件的文件名是：test.pth test.pth 文件的内容是： C:\\Users\\Android\\Desktop 接着获取python的site-packages文件夹的路径： import site site . getsitepackages () ['G:\\\\Installed\\\\Anaconda3', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site- packages'] 然后将 test.pth 文件放进 G:\\Installed\\Anaconda3\\lib\\site-packages 里面即可。 模块的导入 在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块(module)导入: 例如，我们要使用使用 sys 模块，那么首先要导入该模块： import sys 导入 sys 模块后，我们就有了 变量 sys 指向该模块，利用 sys 这个变量，就可以访问 sys 模块的所有功能。 也就是说导入整个模块的做法会导致命名空间的修改。 也可以一次性导入多个module： import os , sys , time 通过 as 关键字，可以在导入module的时候，给module定义别名： import sys as system 从某个模块中导入函数： 从某个模块中导入某个函数 from somemodule import somefunction 从某个模块中导入多个函数 from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入 from somemodule import * 一般而言，除了实验、排查，不推荐导入模块内的所有公开符号（没有前缀 _ 的那些）。因为导入模块会修改namespace，而通常你不知道模块定义了哪些符号、是否与当前的namespace有重名的符号。一旦有重名，那么，就会覆盖掉当前namespace的值。从而造成难以排查的错误 模块重载 出于性能考虑， 每个模块在每个解释器会话中只导入一遍。 因此，如果修改了的模块，需要重启解释器；如果想交互式地测试一个模块，则需要使用以下方法重新导入模块： 注意 只能重载模块，不能单独重载模块中的某个函数、类、变量。 Python 2.x： reload ( modulename ) Python 2.x 至 Python3.3： import imp imp . reload ( modulename ) Python3.4+： import importlib importlib . reload ( modulename ) 另外，spyder 的UMR(user module reloader)提供了自动重载模块的功能。 模块的识别 和 Python 中的其它对象一样，Python 也为模块定义了一些形如 __foo__ 的变量。对于模块来说，最重要的就是它的名字 __name__ 了。每当 Python 执行脚本，它就会为该脚本赋予一个名字： 对于「主程序」来说，这一脚本的 __name__ 被定义为 \"__main__\" 对于被 import 进主程序的模块来说，这一脚本的 __name__ 被定义为脚本的文件名（base filename） 因此，我们可以用如下的形式，在模块代码中定义一些测试代码： if __name__ == \"__main__\" : ··· 当脚本被直接运行时，测试代码就会被运行；当脚本作为模块被导入，测试代码不会被运行。 以下是一个完整的代码示例： 参考：(Python 中的黑暗角落（三）：模块与包)[https://liam0205.me/2017/07/23/modules-and-packages-of-python/] #!/usr/bin/env python3 # -*- coding: utf-8 -*- ' a test module ' __author__ = 'Michael Liao' import sys def test (): args = sys . argv if len ( args ) == 1 : print ( 'Hello, world!' ) elif len ( args ) == 2 : print ( 'Hello, %s !' % args [ 1 ]) else : print ( 'Too many arguments!' ) if __name__ == '__main__' : test () Hello, world! 作用域 在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用，在Python中，是通过 _ 前缀来实现的。 正常的函数和变量名是公开的（public），可以被直接引用，比如： abc ， x123 ， PI 等； 类似 __xxx__ 这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的 __author__ ， __name__ 就是特殊变量， hello 模块定义的文档注释也可以用特殊变量 __doc__ 访问，我们自己的变量一般不要用这种变量名； 类似 _xxx 和 __xxx 这样的函数或变量就是非公开的（private），不应该被直接引用，比如 _abc ， __abc 等； 之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。 private函数或变量不应该被别人引用，那它们有什么用呢？请看例子 def _private_1 ( name ): return 'Hello, %s ' % name def _private_2 ( name ): return 'Hi, %s ' % name def greeting ( name ): if len ( name ) > 3 : return _private_1 ( name ) else : return _private_2 ( name ) 我们在模块里公开 greeting() 函数，而把内部逻辑用private函数隐藏起来了，这样，调用 greeting() 函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即： 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。 作为脚本来执行模块 当你使用以下方式运行 Python 模块时，模块中的代码便会被执行: python fibo.py <arguments> 模块中的代码会被执行，就像导入它一样，不过 此时 __name__ 被设置为 \"__main__\" 。 这相当于，如果你在模块后加入如下代码: if __name__ == \"__main__\" : import sys fib ( int ( sys . argv [ 1 ])) 就可以让此文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为 “main” 文件执行时才被调用: $ python fibo . py 50 1 1 2 3 5 8 13 21 34 如果模块被导入，不会执行这段代码: >>> import fibo >>> 这通常用来为模块提供一个便于测试的用户接口（将模块作为脚本执行测试需求）。 “编译的” Python 文件—— pyc 文件 和 LaTeX 中遇到的问题一样：装载大量文本文件（ .py 文件）是很慢的。因此 Python 也采用了类似 LaTeX 的解决方案：将模块编译成容易装载的文件，并在 __pycache__ 目录下以 module.*version*.pyc 名字缓存这些文件。（相当于 LaTeX 中的 dump 格式文件 .fmt ）。 这里的版本编制了编译后文件的格式。它通常会包含 Python 的版本号。例如，在 CPython 3.3 版中，spam.py 编译后的版本将缓存为 __pycache__/spam.cpython-33.pyc 。这种命名约定允许由不同发布和不同版本的 Python 编译的模块同时存在。 当 Python 编译好模块之后，下次载入时，Python 就会读取相应的 .pyc 文件，而不是 .py 文件。而装载 .pyc 文件会比装载 .py 文件更快。 Python 会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。 这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。 Python 不检查在两个不同环境中的缓存。首先，它会永远重新编译而且不会存储直接从命令行加载的模块。其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源文件的模块。 部分高级技巧: 为了减少一个编译模块的大小，你可以在 Python 命令行中使用 -O 或者 -OO 。 -O 参数删除了断言语句， -OO 参数删除了断言语句和 doc 字符串。 因为某些程序依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。“优化的” 模块有一个 .pyo 后缀而不是 .pyc 后缀。未来的版本可能会改变优化的效果。 来自 .pyc 文件或 .pyo 文件中的程序不会比来自 .py 文件的运行更快； .pyc 或 .pyo 文件只是在它们加载的时候更快一些。 compileall 模块可以为指定目录中的所有模块创建 .pyc 文件（或者使用 -O 参数创建 .pyo 文件）。 在 PEP 3147 中有很多关这一部分内容的细节，并且包含了一个决策流程。","text_tokens":["pyo","版","最","遵循","别名","接着","'","该","pth","从而","大小","重载","不","默认","排查","即可","*","reloader","别人","bin","调用","读取","请","支持","...","3147","一遍","这一","版中","修改","in","每个","存储","这","符号","思路","对于","后缀","段","源目录","重复使用","既然","掉","不是","thirdfunc","对应","private","减少","部分","是","整个","呢","不会","当","格式","难以","某个","python3","跨平台","not","程序","方式","这样","类似","文本","译成","形","23","放进","不到","错误","只能","doc","并","角落","查看","python","仍旧","实现","也就是说","xxx","fmt","依赖","me","3","13","相当","many","latex","namespace","格式文件","append","访问","abc","过期","python3.3","and","等","中有","来","之所以","文本文件","工作","便会","somemodule","搜寻","elif","库",")","windows10","一次性","同一","赖于","适用","cpython","。","导入","何处","决策","文件名","anaconda3","尝试","至","怎样","的","抽象","因此","列表","以下","版本","识别","了","件夹","作用域"," ","很多","modules","<","这里","+","自动化","交互","仅仅","同一个","pi","字符串","这个","先","全局","实例","将","面板","考虑","源","使用","则","比","!","或","5","%","path","即","2017","比如","test","time","a","本文","环境变","元素","被","那","造成","很","这是","它","大","注释","外部","实际","除了","相当于","里","2","缓存","假设","由","系列","dlls","\\","大量","重新","获取","将要","添加","主程序","目录","改变","重复","android","因为","·","cmd","删除","_","和","流程","提供","单独","不用","系统","可用性","不难理解","8","中","消失","必须","做","共享","示例","函数","当前","不想","每当","增加","释器","；","一种","一般而言","oo","而","黑暗","不同","解释器","只","可执行文件","随着","fibo","某些","首先","测试代码","arguments","解决","重名","好","说","方案","失败","，","o","可用","用途","实验","与","]","编译成","print","编辑","没有","内部","33","都","环境变量","3.3","越来越","c","关键字","50","接口","编写","时才","功能","=","就是说","限制","文件夹","而且","我们","场合","import","扩展","希望","时候","并且","如","习惯","lib","pythonpath","就","」","而言","imp","给","of","用","实际上","1","那么","前缀","设置","运行","依旧","多个","几个","从文件","高级","「","有","找","在内","注意","不要","desktop","包含","py3.7","pyc","自动","安全","为什么","封装","两个","(","importlib","liao","正常","架构","里面","packages","发布","查找","hi","例子","python37","users","一部","赋予","用来","s","len","如果","到","参数","一部分","coding","成","确定","public","installed","else","那些","—","时","编程","名字","隐藏","类型","才","getsitepackages","公开","通过","另外","字符","利用","一些","采用","下以","变得","安装","路径","有用","？","07","此","细节","控制","推荐","ipython","编制","自己","变量","可以","并未","secondfunc","快","搜索","“","加入","看","34","$","其次","来说","无误","会","egg","控制面板","全部","你","内","日期","方法","一样","michael","技巧","类","约定","不难","解决方案","非常","更","然后","args","[","相应","要","值","命令","version","提示","为","21","不过","未能","称为","仍","例如","遇到","一般","容易","源文件","pythonwin","选择","name","任何","越来","对","依赖于","appdata","命名","只有","somefunction","spyder","filename","foo","性能","modulename","wiki",":","是否","便于","之间","python3.4","为了","env","umr","覆盖","x123","像","重要","main","哪些","创建","win32","base","x","system","一旦","过程","来自","指向","问题","什么","维护",".","os","通常","user","但是","一个","编译器","xgboost","逻辑","class","当于","代码","放在","\"","依次","上面","想要","这些","if","所有","文档","0","下次","指定","找到","空间","易于","def","spam","载入","分割","只是","想","编译","zip","需要","文件","（","地","肯定","知道","背后","清楚","作用","未找到","list","for","应该","环境","int","允许","当前工作","不能","慢","永远","完全","未来","报错","后","存在","是因为","pep","roaming","特殊","测试","#","它们","临时","若","引入","sys","熟悉","模块","需求","把","所在","会话","选项","解释","）","too",">","导致","关键","用户","r","module","起来","下才","、","reload","行文","制面","让","形式","compileall","/","在","脚本","变量名","引用","fib","dump","上","进","utf","此时","是非","g","重启","一系","但","关心","之后","满足","完整","对象","greeting","也","交互式","永久","出于","三","优化","这种","参考","-","更大","foobar","：","效果","新","平台","检查","直接","1.0","所以","就是","语句","理解","一系列","指示","其它","return","snapshot","命令行","相关","type","如下","pycache","有序","world","做法","装载","liam0205","一次","py","加载","argv","向","写","定义","bash","断言","版本号","内容","usr","author","同时",",","https","执行","site","关","”","从","作为","hello","可能","或者","以","建","下","包","名为","extensions","from","它会","as","__","firstfunc"],"title":"4.2.模块","title_tokens":[".","4.2","模块"]},{"location":"Python基础/4.2.模块.html#_1","text":"如果你想要编写一些更大的程序，肯定不想定义重复的函数、类，想让代码可以重复使用。随着程序变得越来越大，你可能想要将它分割成几个更易于维护的文件。为了满足这些需要，Python 提供了一个方法可以从文件中获取定义，在脚本或者解释器的一个交互式实例中使用。这样的文件被称为模块。","text_tokens":["重复使用","维护","了","中","越来","如果","它","可以","大"," ","一个","交互式","成","函数","不想","交互","代码","释器","、","越来越","让","编写","定义","实例","想要","更大","你","将","几个","这些","方法","从文件","在","脚本","获取","称为","解释器","类","使用","程序","为了","随着","这样","更","易于","一些","分割","。","可能","或者","变得","想","模块","重复","需要","文件","的","python","，","肯定","提供","解释","被","满足"],"title":"为什么需要模块","title_tokens":["什么","需要","为什么","模块"]},{"location":"Python基础/4.2.模块.html#_2","text":"Python 怎样知道从何处找到模块文件？ 如果你熟悉命令行，那么这个问题对你来说就不难理解。在命令行中执行的任何命令，实际上背后都对应了一个可执行文件。命令行解释器（比如 cmd, bash）会从一个全局的环境变量 PATH 中读取一个有序的列表。这个列表包含了一系列的路径，而命令行解释器，会依次在这些路径里，搜索需要的可执行文件。 Python 搜寻模块文件，也遵循了类似的思路。比如，用户在 Python 中尝试导入 import foobar，那么 首先，Python 会在内建模块中搜寻 foobar； 若未找到，则 Python 会在当前工作路径（当前脚本所在路径，或者执行 Python 解释器的路径）中搜寻 foobar； 若仍未找到，则 Python 会在环境变量 PYTHONPATH 中指示的路径中搜寻 foobar； 若依旧未能找到，则 Python 会在安装时指定的路径中搜寻 foobar； 若仍旧失败，则 Python 会报错，提示找不到 foobar 这个模块。","text_tokens":["未找到","环境","如果","当前工作","报错","遵循","实际","时","里","系列","读取","若","安装","熟悉","模块","路径","所在","cmd","？","思路","解释","）","不难理解","中","变量","对应","当前","用户","搜索","释器","；","行文","来说","会","而","在","你","脚本","解释器","不难","可执行文件","首先","类似","不到","一系","命令","提示","python","，","未能","仍旧","失败","仍","任何","也","对","都","环境变量","工作","搜寻","foobar","import","理解","。","导入","何处","一系列","指示","尝试","怎样","的","列表","pythonpath","就","命令行","问题","了"," ","有序","一个","实际上","那么","这个","bash","全局","依次","依旧","这些","找","指定",",","则","找到","在内","执行","包含","从","path","或者","建","比如","需要","文件","（","知道","背后","环境变"],"title":"模块搜索路径","title_tokens":["搜索","路径","模块"]},{"location":"Python基础/4.2.模块.html#_3","text":"当我们使用import加载自己编写的py代码时，必须放在python的默认路径下才可以import。","text_tokens":["自己","必须","可以","代码","下才","时","当","py","加载","编写","放在","默认","使用","我们","import","。","路径","的","python","，"],"title":"添加搜索路径","title_tokens":["搜索","路径","添加"]},{"location":"Python基础/4.2.模块.html#syspathappend","text":"在python中引入 sys ， sys 中的 path 是一个列表类型的对象，内容就是路径的列表，我们将sys引入后查看就可以清楚的知道了： import sys print ( type ( sys . path )) [ path for path in sys . path if \"Wiki\" not in path ] <class 'list'> ['C:\\\\Users\\\\Android\\\\Desktop', 'G:\\\\Installed\\\\Anaconda3\\\\python37.zip', 'G:\\\\Installed\\\\Anaconda3\\\\DLLs', 'G:\\\\Installed\\\\Anaconda3\\\\lib', 'G:\\\\Installed\\\\Anaconda3', 'C:\\\\Users\\\\Android\\\\AppData\\\\Roaming\\\\Python\\\\Python37\\\\site- packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site- packages\\\\xgboost-1.0.0_snapshot-py3.7.egg', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32\\\\lib', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\Pythonwin', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\IPython\\\\extensions', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop'] 既然是list对象，那么使用append可以向列表添加新的元素，假设我们要添加的路径是 \"C:\\Users\\Android\\Desktop\" ： import sys sys . path . append ( r \"C:\\Users\\Android\\Desktop\" ) 但这只是临时添加路径，如果重启编译器，添加的路径就会消失。","text_tokens":["python37","users","list","for","如果","installed","后","'","假设","dlls","\\","类型","roaming","添加","临时","引入","sys","android","路径","_","in","这","ipython","既然","中",">","消失","可以","r","是","会","egg","在","not","[","g","重启","要","但","查看","python","，","pythonwin","对象","]","print","append","appdata","c","wiki",":","-","：","新","我们",")","1.0","import","就是","。","anaconda3","win32","的","lib","snapshot","列表","就","了",".","type"," ","一个","编译器","xgboost","<","class","那么","向","\"","将","if","内容","0",",","使用","site","desktop","py3.7","path","只是","编译","zip","(","extensions","知道","packages","元素","清楚"],"title":"添加临时路径——sys.path.append","title_tokens":["路径","—",".","添加","path","临时","append","sys"]},{"location":"Python基础/4.2.模块.html#_4","text":"在Windows10中，选择 ->控制面板\\系统和安全\\系统->高级系统设置->环境变量 ， # 找到path后选择编辑，添加新的路径。 但这种方法不能适用所有python的功能，因为这种方法并未将要查找的路径添加到python的Path系统环境中，在sys.path的列表中找不到相关路径的元素。也就是说这样做并没有将路径添加到python的搜索路径中。","text_tokens":[".","相关","选择","中",">","环境"," ","变量","到","做","编辑","并未","不能","没有","环境变量","这种","后","搜索","制面","设置","功能","控制面板","\\","-","在","就是说","高级","面板","所有","方法","将","找","新","将要","找到","这样","windows10","添加","#","适用","就是","path","。","sys","不到","路径","因为","安全","但","和","并","的","python","，","环境变","控制","列表","也就是说","元素","查找","系统"],"title":"修改环境变量","title_tokens":["环境","变量","修改","环境变","环境变量"]},{"location":"Python基础/4.2.模块.html#pth","text":"在site-packages文件夹添加path文件，可以实现搜索路径的永久添加。方法如下： 先编辑一个扩展名为 .pth 的文本文件，在这个文本文件里面写上要添加的path就可以了，例如： 文本文件的文件名是：test.pth test.pth 文件的内容是： C:\\Users\\Android\\Desktop 接着获取python的site-packages文件夹的路径： import site site . getsitepackages () ['G:\\\\Installed\\\\Anaconda3', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site- packages'] 然后将 test.pth 文件放进 G:\\Installed\\Anaconda3\\lib\\site-packages 里面即可。","text_tokens":["件夹",".","了","users","如下","]"," ","可以","一个","永久","编辑","installed","搜索","是","c","接着","文本文件","'","这个","pth","写","先","\\","-","在",":","getsitepackages","将","：","方法","文件夹","内容","获取",",","即可",")","添加","然后","site","import","扩展","desktop","文本","。","path","上","[","g","放进","文件名","路径","要","android","anaconda3","test","(","文件","名为","的","本文","python","，","实现","里面","lib","packages","就","例如"],"title":"添加永久搜索路径——增加.pth文件","title_tokens":["搜索","路径","—","增加",".","文件","添加","pth","永久"]},{"location":"Python基础/4.2.模块.html#_5","text":"在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块(module)导入: 例如，我们要使用使用 sys 模块，那么首先要导入该模块： import sys 导入 sys 模块后，我们就有了 变量 sys 指向该模块，利用 sys 这个变量，就可以访问 sys 模块的所有功能。 也就是说导入整个模块的做法会导致命名空间的修改。 也可以一次性导入多个module： import os , sys , time 通过 as 关键字，可以在导入module的时候，给module定义别名： import sys as system 从某个模块中导入函数： 从某个模块中导入某个函数 from somemodule import somefunction 从某个模块中导入多个函数 from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入 from somemodule import * 一般而言，除了实验、排查，不推荐导入模块内的所有公开符号（没有前缀 _ 的那些）。因为导入模块会修改namespace，而通常你不知道模块定义了哪些符号、是否与当前的namespace有重名的符号。一旦有重名，那么，就会覆盖掉当前namespace的值。从而造成难以排查的错误","text_tokens":["造成","那些","后","别名","除了","该","从而","公开","不","通过","排查","*","利用","sys","模块","因为","...","_","修改","符号","推荐","）","掉","中","导致","thirdfunc","变量","可以","关键","secondfunc","函数","当前","module","、","整个","会","一般而言","而","难以","在","某个","全部","内","你","首先","相应","要","值","重名","错误","python","，","也就是说","例如","一般","实验","与","也","namespace","没有","访问","命名","来","关键字","somefunction","功能","somemodule",":","就是说","是否","：","我们",")","一次性","import","就是","覆盖","。","导入","哪些","时候","的","system","一旦","指向","就","而言","了","给","os","通常","用"," ","做法","那么","前缀","一次","这个","定义","多个","将","所有","有",",","使用","空间","从","或者","time","(","（","from","知道","as","firstfunc"],"title":"模块的导入","title_tokens":["的","导入","模块"]},{"location":"Python基础/4.2.模块.html#_6","text":"出于性能考虑， 每个模块在每个解释器会话中只导入一遍。 因此，如果修改了的模块，需要重启解释器；如果想交互式地测试一个模块，则需要使用以下方法重新导入模块： 注意 只能重载模块，不能单独重载模块中的某个函数、类、变量。 Python 2.x： reload ( modulename ) Python 2.x 至 Python3.3： import imp imp . reload ( modulename ) Python3.4+： import importlib importlib . reload ( modulename ) 另外，spyder 的UMR(user module reloader)提供了自动重载模块的功能。","text_tokens":["了",".","中","user"," ","如果","变量","一个","交互式","出于","不能","函数","+","交互","python3.3","module","释器","；","、","reload","2","importlib","spyder","功能","性能","modulename","在","某个","：","方法","python3.4","重新","重载","考虑","解释器","只","测试","则","使用","类",")","注意","另外","reloader","import","umr","。","导入","想","模块","重启","自动","需要","会话","至","只能","(","一遍","地","的","修改","python","，","每个","因此","x","提供","解释","单独","以下","imp"],"title":"模块重载","title_tokens":["重载","模块"]},{"location":"Python基础/4.2.模块.html#_7","text":"和 Python 中的其它对象一样，Python 也为模块定义了一些形如 __foo__ 的变量。对于模块来说，最重要的就是它的名字 __name__ 了。每当 Python 执行脚本，它就会为该脚本赋予一个名字： 对于「主程序」来说，这一脚本的 __name__ 被定义为 \"__main__\" 对于被 import 进主程序的模块来说，这一脚本的 __name__ 被定义为脚本的文件名（base filename） 因此，我们可以用如下的形式，在模块代码中定义一些测试代码： if __name__ == \"__main__\" : ··· 当脚本被直接运行时，测试代码就会被运行；当脚本作为模块被导入，测试代码不会被运行。 以下是一个完整的代码示例： 参考：(Python 中的黑暗角落（三）：模块与包)[https://liam0205.me/2017/07/23/modules-and-packages-of-python/] #!/usr/bin/env python3 # -*- coding: utf-8 -*- ' a test module ' __author__ = 'Michael Liao' import sys def test (): args = sys . argv if len ( args ) == 1 : print ( 'Hello, world!' ) elif len ( args ) == 2 : print ( 'Hello, %s !' % args [ 1 ]) else : print ( 'Too many arguments!' ) if __name__ == '__main__' : test () Hello, world!","text_tokens":["赋予","s","它","len","coding","else","最","时","2","'","该","名字","测试","*","#","一些","主程序","bin","sys","模块","·","和","这一","07","对于","）","8","too","中","变量","可以","示例","每当","module","是","；","形式","不会","当","来说","会","/","在","黑暗","python3","一样","脚本","michael","程序","args","测试代码","arguments","形","[","进","utf","23","为","角落","python","，","me","完整","name","对象","与","]","也","many","三","print","参考","and","filename","=","foo",":","-","：","elif","我们","直接",")","env","import","就是","。","导入","重要","main","文件名","其它","如","base","的","因此","就","以下","」","了",".","如下","of","用"," ","一个","world","modules","1","代码","liam0205","argv","运行","定义","\"","if","「","usr","author",",","https","!","执行","def","作为","hello","%","包","2017","test","(","liao","文件","（","a","packages","被","__"],"title":"模块的识别","title_tokens":["识别","的","模块"]},{"location":"Python基础/4.2.模块.html#_8","text":"在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用，在Python中，是通过 _ 前缀来实现的。 正常的函数和变量名是公开的（public），可以被直接引用，比如： abc ， x123 ， PI 等； 类似 __xxx__ 这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的 __author__ ， __name__ 就是特殊变量， hello 模块定义的文档注释也可以用特殊变量 __doc__ 访问，我们自己的变量一般不要用这种变量名； 类似 _xxx 和 __xxx 这样的函数或变量就是非公开的（private），不应该被直接引用，比如 _abc ， __abc 等； 之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。 private函数或变量不应该被别人引用，那它们有什么用呢？请看例子 def _private_1 ( name ): return 'Hello, %s ' % name def _private_2 ( name ): return 'Hi, %s ' % name def greeting ( name ): if len ( name ) > 3 : return _private_1 ( name ) else : return _private_2 ( name ) 我们在模块里公开 greeting() 函数，而把内部逻辑用private函数隐藏起来了，这样，调用 greeting() 函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即： 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。","text_tokens":["例子","应该","s","len","成","public","注释","不能","完全","else","外部","编程","2","'","里","是因为","隐藏","才","公开","特殊","不","别人","通过","调用","它们","请","模块","把","因为","有用","_","和","？","细节","这","不用","）","中","不是","自己",">","变量","可以","private","函数","是","“","；","起来","一种","呢","看","会","而","在","全部","方法","那","变量名","引用","这样","非常","类似","上","是非","但","说","doc","并","为","python","，","实现","关心","xxx","用途","3","一般","name","greeting","也","没有","内部","abc","访问","这种","等","来","之所以","只有",":","限制","：","我们","直接",")","所以","希望","就是","。","x123","习惯","的","return","抽象","就","什么","给","了","用"," ","但是","很多","一个","逻辑","1","代码","仅仅","前缀","pi","定义","上面","if","文档","有","author",",","使用","或","不要","def","”","hello","从","%","可能","即","比如","封装","需要","正常","(","（","被","__","hi"],"title":"作用域","title_tokens":["作用","作用域"]},{"location":"Python基础/4.2.模块.html#_9","text":"当你使用以下方式运行 Python 模块时，模块中的代码便会被执行: python fibo.py <arguments> 模块中的代码会被执行，就像导入它一样，不过 此时 __name__ 被设置为 \"__main__\" 。 这相当于，如果你在模块后加入如下代码: if __name__ == \"__main__\" : import sys fib ( int ( sys . argv [ 1 ])) 就可以让此文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为 “main” 文件执行时才被调用: $ python fibo . py 50 1 1 2 3 5 8 13 21 34 如果模块被导入，不会执行这段代码: >>> import fibo >>> 这通常用来为模块提供一个便于测试的用户接口（将模块作为脚本执行测试需求）。","text_tokens":["用来","它","如果","int","后","时","相当于","2","测试","调用","sys","模块","需求","此","这","提供","段","）","8","中",">","可以","用户","“","加入","34","不会","让","当","$","会","在","你","一样","脚本","方式","fibo","arguments","fib","[","此时","21","为","python","，","不过","3","13","相当","name","]","50","便会","只有","接口","时才","=",":","便于",")","import","像","导入","。","main","的","就","以下",".","通常","如下"," ","一个","<","1","当于","代码","设置","py","argv","运行","\"","将","if","使用","5","执行","”","作为","(","文件","（","被","__"],"title":"作为脚本来执行模块","title_tokens":["脚本","来","执行","作为","模块"]},{"location":"Python基础/4.2.模块.html#python-pyc","text":"和 LaTeX 中遇到的问题一样：装载大量文本文件（ .py 文件）是很慢的。因此 Python 也采用了类似 LaTeX 的解决方案：将模块编译成容易装载的文件，并在 __pycache__ 目录下以 module.*version*.pyc 名字缓存这些文件。（相当于 LaTeX 中的 dump 格式文件 .fmt ）。 这里的版本编制了编译后文件的格式。它通常会包含 Python 的版本号。例如，在 CPython 3.3 版中，spam.py 编译后的版本将缓存为 __pycache__/spam.cpython-33.pyc 。这种命名约定允许由不同发布和不同版本的 Python 编译的模块同时存在。 当 Python 编译好模块之后，下次载入时，Python 就会读取相应的 .pyc 文件，而不是 .py 文件。而装载 .pyc 文件会比装载 .py 文件更快。 Python 会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。 这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。 Python 不检查在两个不同环境中的缓存。首先，它会永远重新编译而且不会存储直接从命令行加载的模块。其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源文件的模块。 部分高级技巧: 为了减少一个编译模块的大小，你可以在 Python 命令行中使用 -O 或者 -OO 。 -O 参数删除了断言语句， -OO 参数删除了断言语句和 doc 字符串。 因为某些程序依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。“优化的” 模块有一个 .pyo 后缀而不是 .pyc 后缀。未来的版本可能会改变优化的效果。 来自 .pyc 文件或 .pyo 文件中的程序不会比来自 .py 文件的运行更快； .pyc 或 .pyo 文件只是在它们加载的时候更快一些。 compileall 模块可以为指定目录中的所有模块创建 .pyc 文件（或者使用 -O 参数创建 .pyo 文件）。 在 PEP 3147 中有很多关这一部分内容的细节，并且包含了一个决策流程。","text_tokens":["很","这是","一部","应该","参数","一部分","它","环境","如果","允许","确定","慢","永远","pyo","完全","未来","版","后","存在","时","缓存","相当于","由","名字","大量","大小","pep","重新","不","*","字符","一些","采用","下以","读取","它们","若","目录","模块","改变","因为","支持","删除","3147","和","版中","这一","选项","修改","存储","流程","细节","这","后缀","编制","系统","源目录","）","可用性","中","不是","必须","变量","可以","共享","减少","部分","module","是","快","“","；","compileall","不会","当","其次","无误","会","/","oo","而","格式","在","日期","跨平台","你","一样","技巧","不同","约定","只","程序","解决方案","更","某些","首先","类似","文本","译成","dump","关","解决","相应","要","好","命令","version","doc","方案","并","为","python","，","o","可用","fmt","依赖","之后","例如","遇到","容易","源文件","相当","与","也","编译成","latex","33","没有","格式文件","依赖于","过期","这种","优化","中有","命名","3.3","只有","文本文件","-",":","是否","：","效果","之间","平台","库","为了","检查","而且","直接","场合","同一","所以","赖于","cpython","语句","。","决策","时候","并且","创建","的","过程","因此","来自","就","命令行","问题","版本",".","了","通常","pycache"," ","很多","一个","这里","自动化","当于","装载","同一个","字符串","py","加载","运行","断言","这些","将","高级","版本号","所有","有","内容","同时","下次","源","指定","使用","比","或","spam","包含","载入","从","”","以","或者","可能","只是","下","pyc","编译","自动","需要","两个","文件","本文","（","架构","它会","发布","__"],"title":"“编译的” Python 文件——pyc 文件","title_tokens":["pyc","“","编译","—","文件"," ","的","python","”"]},{"location":"Python基础/4.3.魔术方法.html","text":"构造和初始化 每个人都知道一个最基本的魔术方法， __init__ 。通过此方法我们可以定义一个对象的初始操作。但很多博客和个别书籍中都把 __init__ 当作类似于C++的构造方法，其实是错误的。 __init__ 并不是第一个被调用的方法。实际上，还有一个叫做 __new__ 的方法，来构造这个实例。然后给在开始创建时候的初始化函数来传递参数。在对象生命周期的另一端，也有一个 __del__ 方法。 __new__(cls, [...) __new__ 是在一个对象实例化的时候所调用的第一个方法。它的第一个参数是这个类，其他的参数是用来直接传递给 __init__ 方法。 __new__ 方法相当不常用，也不是很有用处，但是它有自己的特性，特别是当继承一个不可变的类型（比如一个tuple或者string）： class inch ( float ): \"Convert from inch to meter\" def __new__ ( cls , arg = 0.0 ): return float . __new__ ( cls , arg * 0.0254 ) print ( inch ( 12 )) 0.30479999999999996 这个类可能不是很有用，但是它显示了如何扩展不可变类型的构造函数。如果我们尝试替代 __init__ 而不是 __new__ ，那么它将不起作用： class inch ( float ): \"THIS DOESN'T WORK!!!\" def __init__ ( self , arg = 0.0 ): float . __init__ ( self , arg * 0.0254 ) try : print ( inch ( 12 )) except TypeError as e : print ( e ) object.__init__() takes exactly one argument (the instance to initialize) 重写初始值的版本不起作用，因为浮点类型的初始值是一个不可变对象。另一个 __new__ 的例子是单例模式。 class A : pass new1 = A () new2 = A () print ( new1 ) print ( new2 ) <__main__.A object at 0x0000021AA9651AC8> <__main__.A object at 0x0000021AA9651B00> class A ( object ): _singleton = None def __new__ ( cls , * args , ** kwargs ): if not cls . _singleton : cls . _singleton = object . __new__ ( cls , * args , ** kwargs ) return cls . _singleton new1 = A () new2 = A () print ( new1 ) print ( new2 ) <__main__.A object at 0x0000021AA86752E8> <__main__.A object at 0x0000021AA86752E8> 关于 __new__ 的一些规则： __new__ 是一个静态方法，但在重定义 __new__ 时，不需要加上 @staticmethod ，因为它的名字已经暗示了这一点。 __new__ 的第一个参数必须是一个类；其余参数是构造函数调用所看到的参数。 __new__ 方法必须返回一个实例，如果返回None，则不会调用 __init__ 方法。 __init__(self, […) 此方法为类的初始化方法。当构造函数被调用的时候的任何参数都将会传给它。(比如如果我们调用 x = SomeClass(10, 'foo') )，那么 __init__ 将会得到两个参数10和foo。 __init__ 在Python的类定义中被广泛用到。 __del__(self) 如果 __new__ 和 __init__ 是对象的构造器的话，那么 __del__ 就是析构器。它不实现语句 del x (以上代码将不会翻译为 x.__del__() )。它定义的是当一个对象进行垃圾回收时候的行为。当一个对象在删除的时需要更多的清洁工作的时候此方法会很有用，比如套接字对象或者是文件对象。注意，如果解释器退出的时候对象还存存在，就不能保证 __del__ 能够被执行。 class A : def __del__ ( self ): print ( \"我被删除了\" ) a = A () del a 我被删除了 用于比较的魔术方法 魔术方法 调用方式 描述 __eq__(self, other) self == other __nq__(self, other) self != other __le__(self, other) self <= other __ge__(self, other) self >= other __lt__(self, other) self < other __gt__(self, other) self > other class A : def __init__ ( self , num = 2 ): self . num = num def __repr__ ( self ): return str ( self . num ) def __eq__ ( self , other ): return self . num == other def __ne__ ( self , other ): return self . num != other def __le__ ( self , other ): return self . num <= other def __ge__ ( self , other ): return self . num >= other def __lt__ ( self , other ): return self . num < other def __gt__ ( self , other ): return self . num > other a = A ( 5 ) print ( a == 5 ) print ( a != 5 ) print ( a > 4 ) print ( a < 6 ) print ( a >= 5 ) print ( a <= 6 ) True False True True True True 数值处理的魔术方法 一元运算符和内置函数 魔术方法 调用方式 描述 __pos__(self) +self __neg__(self) -self __abs__(self) abs(self) __invert__(self) ~self class A : def __init__ ( self , num = 2 ): self . num = num def __repr__ ( self ): return str ( self . num ) def __pos__ ( self ): new_num = 0 + self . num return A ( new_num ) def __neg__ ( self ): new_num = 0 - self . num return A ( new_num ) def __abs__ ( self ): new_num = abs ( self . num ) return A ( new_num ) a = A ( - 5 ) print ( + a ) print ( - a ) print ( abs ( a )) -5 5 5 算术运算符 魔术方法 调用方式 描述 __add__(self, other) self + other __sub_(self, other) self - other __mul__(self, other) self * other __truediv__(self, other) self / other __pow__(self, other) self ** other __floordiv__(self, other) self // other __mod__(self, other) self % other class A : def __init__ ( self , num = 2 ): self . num = num def __repr__ ( self ): return str ( self . num ) def __add__ ( self , other ): new_num = self . num + other return A ( new_num ) def __sub__ ( self , other ): new_num = self . num - other return A ( new_num ) def __mul__ ( self , other ): new_num = self . num * other return A ( new_num ) def __truediv__ ( self , other ): new_num = self . num / other return A ( new_num ) def __pow__ ( self , other ): new_num = self . num ** other return A ( new_num ) def __floordiv__ ( self , other ): new_num = self . num // other return A ( new_num ) def __mod__ ( self , other ): new_num = self . num % other return A ( new_num ) a = A ( 5 ) print ( \"a + 2 =\" , a + 2 ) print ( \"a - 2 =\" , a - 2 ) print ( \"a * 2 =\" , a * 2 ) print ( \"a / 2 =\" , a / 2 ) print ( \"a ** 2 =\" , a ** 2 ) print ( \"a // 2 =\" , a // 2 ) print ( \"a % 2 =\" , a % 2 ) a + 2 = 7 a - 2 = 3 a * 2 = 10 a / 2 = 2.5 a ** 2 = 25 a // 2 = 2 a % 2 = 1 反运算 以下是一个普通的加法运算的例子: # __add__ some_object + other 反运算是相同的，只是把操作数调换了位置: # __radd__ other + some_object 所以，除了当与其他对象操作的时候自己会成为第二个操作数之外，所有的这些魔术方法都与普通的操作是相同的。大多数情况下，反运算的结果是与普通运算相同的。所以你可以你可以将 __radd__ 与 __add__ 等价。 魔术方法 调用方式 描述 __radd__(self, other) other + self __rsub_(self, other) other - self __rmul__(self, other) other * self __rtruediv__(self, other) other / self __rpow__(self, other) other ** self __rfloordiv__(self, other) other // self __rmod__(self, other) other % self 增强赋值 魔术方法 调用方式 描述 __iadd__(self, other) self += other __isub_(self, other) self -= other __imul__(self, other) self *= other __itruediv__(self, other) self /= other __ipow__(self, other) self **= other __ifloordiv__(self, other) self //= other __imod__(self, other) self %= other 表现你的类 如果有一个字符串来表示一个类将会非常有用，例如： a = [ 1 , 2 , 3 ] a [1, 2, 3] 在Python中，有很多方法可以实现类定义内置的一些函数的返回值。 __str__(self) 定义当 str() 调用的时候的返回值。 __repr__(self) 定义 repr() 被调用的时候的返回值。 str() 和 repr() 的主要区别在于 repr() 返回的是机器可读的输出，而 str() 返回的是人类可读的。 __unicode__(self) 定义当 unicode() 调用的时候的返回值。 unicode() 和 str() 很相似，但是返回的是unicode字符串。注意，如果对你的类调用 str() 然而你只定义了 __unicode__() ，那么将不会工作。你应该定义 __str__() 来确保调用时能返回正确的值。 __hash__(self) 定义当 hash() 调用的时候的返回值，它返回一个整数值，用来在字典中进行快速比较 __nonzero__(self) 定义当 bool() 调用的时候的返回值。本方法应该返回True或者False，取决于你想让它返回的值。 创建定制的序列 有很多方法让你的Python类行为可以像内置的序列(dict, tuple,list, string等等)。 现在我们开始讲如何在Python中创建定制的序列，这个时候该讲一讲协议。协议(Protocols)与其他语言中的接口很相似。它给你很多你必须定义的方法。然而在Python中的协议是很不正式的，不需要明确声明实现。事实上，他们更像一种指南。 我们为什么现在讨论协议？因为如果要定制容器类型的话需要用到这些协议： 实现不变容器的话有一个协议：实现不可变容器，你只能定义 __len__ 和 __getitem__ (一会会讲更多)。 可变容器协议则需要所有不可变容器的所有另外还需要 __setitem__ 和 __delitem__ 。 最终，如果你希望你的对象是可迭代的话，你需要定义 __iter__ 会返回一个迭代器。迭代器必须遵循迭代器协议，需要有 __iter__ (返回它本身) 和 next 。 容器的魔法 魔法方法 调用方法 描述 __len__(self) len(self) __index__(self) x[self] 对象被作为索引使用的时候 __getitem__(self, key) self[key] 使用索引访问元素时 __setitem__(self, key, val) self[key] = val 对某个索引值赋值时 __delitem__(self, key) del self[key] 删除某个索引值时 __iter__(self) for x in self 迭代时 __contains__(self, value) value in self, value not in self 使用 in 操作测试关系时 __concat__(self, value) self + other 连接两个对象时 __reversed__(self) reversed(self) 实现当 reversed() 被调用时的行为 可以调用的对象 在Python中，方法也是一种高等的对象。这意味着他们也可以被传递到方法中就像其他对象一样。这是一个非常惊人的特性。 在Python中，一个特殊的魔术方法可以让类的实例的行为表现的像函数一样，你可以调用他们，将一个函数当做一个参数传到另外一个函数中等等。这是一个非常强大的特性让Python编程更加舒适甜美。 __call__(self, [args...]) 允许一个类的实例像函数一样被调用。实质上说，这意味着 x() 与 x.__call__() 是相同的。注意 __call__ 参数可变。这意味着你可以定义 __call__ 为其他你想要的函数，无论有多少个参数。 __call__ 在那些类的实例经常改变状态的时候会非常有效。调用这个实例是一种改变这个对象状态的直接和优雅的做法。用一个实例来表达最好不过了。 会话管理 在Python 2.5中，为了代码利用定义了一个新的关键词 with 语句。会话控制在Python中不罕见(之前是作为库的一部分被实现)，直到 PEP343 被添加后。它被成为一级语言结构。你也许之前看到这样的语句: with open('foo.txt') as bar: # perform some action with bar 回话控制器通过包装一个 with 语句来设置和清理行为。回话控制器的行为通过两个魔术方法来定义: __enter__(self) 定义当使用 with 语句的时候会话管理器应该初始块被创建的时候的行为。注意 __enter__ 的返回值被 with 语句的目标或者 as 后的名字绑定。 __exit__(self, exception_type,exception_value, traceback) 定义当一个代码块被执行或者终止后会话管理器应该做什么。它可以被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作。如果代码块执行成功， exception_type , exception_value , 和 traceback 将会是 None 。否则的话你可以选择处理这个异常或者是直接交给用户处理。如果你想处理这个异常的话，确认 __exit__ 在所有结束之后会返回 True 。如果你想让异常被会话管理器处理的话，那么就这样处理。 __enter 和 __exit__ 对于明确有定义好的和日常行为的设置和清洁工作的类很有帮助。你也可以使用这些方法来创建一般的可以包装其他对象的会话管理器。以下是一个例子： class Closer : '''通过with语句和一个close方法来关闭一个对象的会话管理器''' def __init__ ( self , obj ): self . obj = obj def __enter__ ( self ): return self . obj # bound to target def __exit__ ( self , exception_type , exception_val , trace ): try : self . obj . close () except AttributeError : # obj isn't closable print ( 'Not closable.' ) return True # exception handled successfully with Closer ( int ( 5 )) as i : i += 1 Not closable. 参考 文章","text_tokens":["生命","浮点","赋值","多数","self","完毕","10","最","遵循","暗示","'","该","控制器","dict","target","表现","不","初始值","*","rfloordiv","算符","帮助","nq","2.5","调用","套","字典","行为","...","7","包装","tuple","invert","in","每个","化","这","他们","管理","对于","还有","abs","定制","接字","0.0254","不是","交给","new","否则","正确","特性","部分","第一","arg","是","next","不会","当","成为","val","某个","not","方式","这样","del","类似","初始","叫做","ipow","错误","staticmethod","只能","并","python","实现","能够","作数","3","话","关闭","相当","如何","结构","访问","一级","来","相同","工作","取决","closable","imod","库","有效",")","块","大多数","。","看到","txt","to","基本","关键词","清除","尝试","操作数","的","iadd","得到","优雅","以下","meter","attributeerror","讲","版本","了","保证"," ","用处","很多","普通","<","+","广泛","字符串","处理","25","这个","perform","主要","unicode","实例","将","直到","exception","周期","则","可变","使用","close","!","5","eq","action","%","重","序列","比如","neg","特别","a","大多","at","被","元素","inch","cls","isn","很","构造函数","setitem","这是","析","它","traceback","value","0x0000021aa9651b00","实际","除了","2","hash","还","pow","快速","清洁","…","传递","添加","运算符","try","改变","radd","等等","因为","反","删除","_","和",".__","位置","后会话","构造方法","回话","状态","中","必须","做","魔术","取决于","函数","释器","；","一种","加上","关于","init","sub","而","false","str","舒适","rsub","work","typeerror","解释器","只","行为表现","delitem","机器","当作","讨论","好","说","其余","，","事实","更加","与","]","e","index","print","都","接口","string","getitem","替代","=","相似","变","closer","我们","多","指南","另一端","扩展","希望","理器","nonzero","日常行为","时候","之前","one","第二","就","rpow","给","第一个","惊人","用","the","实际上","1","重写","那么","设置","的话","不可","none","有","人","someclass","正式","注意","iter","区别","except","常用","convert","obj","c++","为什么","两个","(","增强","用到","例子","0.0","一部","用来","参数","规则","len","如果","isub","到","一部分","迭代","传到","那些","rtruediv","静态方法","时","编程","itruediv","结束","名字","类型","于","通过","将会","gt","垃圾","字符","另外","利用","一些","rmod","描述","初始化","有用","？","此","0x0000021aa86752e8","控制","协议","ifloordiv","甜美","所","call","自己","数值","other","可以","repr","key","exit","new1","单例","@","会","kwargs","pos","你","我","方法","一样","生命周期","类","传给","为类","还存","非常","更","然后","args","目标","开始","其实","[","t","要","值","表达","为","不过","lt","例如","进行","一般","以上","bool","选择","float","任何","一端","对","concat","bound","操作","一点","在于","trace","4","foo",":","contains","情况","为了","mod","罕见","本","本身","像","最好","main","显示","创建","x","个别","12","继承","强大","文章",".","什么","时能","可","但是","书籍","一个","floordiv","实质","意味着","经常","class","代码","protocols","其他","确保","索引","\"","想要","这些","handled","if","所有","0","第二个","返回值","def","容器","只是","现在","清理","器","6","想","bar","可读","singleton","需要","（","文件","知道","num","作用","pass","list","回收","for","应该","构造","结果","允许","int","管理器","不能","成功","后","关系","函数调用","存在","之外","也许","后会","exactly","个","特殊","~","测试","等价","声明","true","算术","#","把","会话","rmul","不变","日常","解释","人类","）","比较","事实上","魔法",">","argument","关键","用于","明确","连接","绑定","用户","object","imul","le","让","无论","博客","/","new2","add","在","二个","instance","ge","doesn","open","确认","上","意味","但","with","构器","0x0000021aa9651ac8","表示","之后","翻译","successfully","当做","对象","也","i","initialize","语言","返回","内置","参考","一元","运算","然而","一会","另","-","：","退出","新","直接","所以","就是","语句","takes","ne","静态","调换","return","高等","enter","异常","加法","type","truediv","一个整","输出","做法","多少","已经","some","定义","最终","值时","一",",","__.","执行","pep343","终止","作为","或者","可能","下","this","不起作用","0.30479999999999996","from","as","reversed","mul","模式","__"],"title":"4.3.魔术方法","title_tokens":[".","方法","4.3","魔术"]},{"location":"Python基础/4.3.魔术方法.html#_1","text":"每个人都知道一个最基本的魔术方法， __init__ 。通过此方法我们可以定义一个对象的初始操作。但很多博客和个别书籍中都把 __init__ 当作类似于C++的构造方法，其实是错误的。 __init__ 并不是第一个被调用的方法。实际上，还有一个叫做 __new__ 的方法，来构造这个实例。然后给在开始创建时候的初始化函数来传递参数。在对象生命周期的另一端，也有一个 __del__ 方法。 __new__(cls, [...) __new__ 是在一个对象实例化的时候所调用的第一个方法。它的第一个参数是这个类，其他的参数是用来直接传递给 __init__ 方法。 __new__ 方法相当不常用，也不是很有用处，但是它有自己的特性，特别是当继承一个不可变的类型（比如一个tuple或者string）： class inch ( float ): \"Convert from inch to meter\" def __new__ ( cls , arg = 0.0 ): return float . __new__ ( cls , arg * 0.0254 ) print ( inch ( 12 )) 0.30479999999999996 这个类可能不是很有用，但是它显示了如何扩展不可变类型的构造函数。如果我们尝试替代 __init__ 而不是 __new__ ，那么它将不起作用： class inch ( float ): \"THIS DOESN'T WORK!!!\" def __init__ ( self , arg = 0.0 ): float . __init__ ( self , arg * 0.0254 ) try : print ( inch ( 12 )) except TypeError as e : print ( e ) object.__init__() takes exactly one argument (the instance to initialize) 重写初始值的版本不起作用，因为浮点类型的初始值是一个不可变对象。另一个 __new__ 的例子是单例模式。 class A : pass new1 = A () new2 = A () print ( new1 ) print ( new2 ) <__main__.A object at 0x0000021AA9651AC8> <__main__.A object at 0x0000021AA9651B00> class A ( object ): _singleton = None def __new__ ( cls , * args , ** kwargs ): if not cls . _singleton : cls . _singleton = object . __new__ ( cls , * args , ** kwargs ) return cls . _singleton new1 = A () new2 = A () print ( new1 ) print ( new2 ) <__main__.A object at 0x0000021AA86752E8> <__main__.A object at 0x0000021AA86752E8> 关于 __new__ 的一些规则： __new__ 是一个静态方法，但在重定义 __new__ 时，不需要加上 @staticmethod ，因为它的名字已经暗示了这一点。 __new__ 的第一个参数必须是一个类；其余参数是构造函数调用所看到的参数。 __new__ 方法必须返回一个实例，如果返回None，则不会调用 __init__ 方法。 __init__(self, […) 此方法为类的初始化方法。当构造函数被调用的时候的任何参数都将会传给它。(比如如果我们调用 x = SomeClass(10, 'foo') )，那么 __init__ 将会得到两个参数10和foo。 __init__ 在Python的类定义中被广泛用到。 __del__(self) 如果 __new__ 和 __init__ 是对象的构造器的话，那么 __del__ 就是析构器。它不实现语句 del x (以上代码将不会翻译为 x.__del__() )。它定义的是当一个对象进行垃圾回收时候的行为。当一个对象在删除的时需要更多的清洁工作的时候此方法会很有用，比如套接字对象或者是文件对象。注意，如果解释器退出的时候对象还存存在，就不能保证 __del__ 能够被执行。 class A : def __del__ ( self ): print ( \"我被删除了\" ) a = A () del a 我被删除了","text_tokens":["cls","0.0","作用","很","生命","构造函数","浮点","例子","pass","用来","参数","规则","它","如果","析","构造","self","不能","10","最","0x0000021aa9651b00","实际","静态方法","时","暗示","函数调用","'","存在","名字","exactly","类型","不","清洁","于","通过","初始值","*","…","将会","传递","垃圾","调用","一些","try","套","把","初始化","有用","因为","行为","删除","...","和","_","tuple",".__","每个","此","构造方法","化","0x0000021aa86752e8","这","解释","还有","所","）","接字","0.0254","中","不是","自己",">","argument","new","必须","可以","魔术","特性","函数","第一","arg","是","object","；","释器","不会","当","加上","博客","单例","init","new1","new2","关于","而","kwargs","@","会","在","instance","我","方法","not","生命周期","work","typeerror","解释器","类","传给","doesn","为类","还存","更","然后","args","del","类似","初始","开始","其实","[","当作","t","叫做","但","错误","staticmethod","其余","并","为","python","，","构器","实现","能够","0x0000021aa9651ac8","进行","翻译","以上","相当","对象","float","如何","任何","也","一端","e","initialize","print","返回","都","操作","一点","来","工作","string","另","替代","=","foo",":","变","：","退出","用到","我们","直接",")","多","另一端","扩展","就是","语句","。","看到","to","takes","main","基本","时候","静态","at","显示","创建","尝试","的","return","x","one","得到","个别","12","继承","就","meter","版本",".","给","第一个","了","保证"," ","用处","很多","一个","书籍","但是","the","class","<","实际上","代码","重写","那么","广泛","已经","这个","其他","的话","不可","none","定义","\"","实例","将","if","有","周期","人",",","则","someclass","回收","__.","!","注意","执行","def","或者","可能","except","重","常用","convert","器","c++","this","不起作用","singleton","比如","0.30479999999999996","需要","特别","(","两个","（","a","文件","from","知道","as","被","inch","模式","__"],"title":"构造和初始化","title_tokens":["和","初始","初始化","构造"]},{"location":"Python基础/4.3.魔术方法.html#_2","text":"魔术方法 调用方式 描述 __eq__(self, other) self == other __nq__(self, other) self != other __le__(self, other) self <= other __ge__(self, other) self >= other __lt__(self, other) self < other __gt__(self, other) self > other class A : def __init__ ( self , num = 2 ): self . num = num def __repr__ ( self ): return str ( self . num ) def __eq__ ( self , other ): return self . num == other def __ne__ ( self , other ): return self . num != other def __le__ ( self , other ): return self . num <= other def __ge__ ( self , other ): return self . num >= other def __lt__ ( self , other ): return self . num < other def __gt__ ( self , other ): return self . num > other a = A ( 5 ) print ( a == 5 ) print ( a != 5 ) print ( a > 4 ) print ( a < 6 ) print ( a >= 5 ) print ( a <= 6 ) True False True True True True","text_tokens":[".",">"," ","other","魔术","self","print","<","class","repr","le","2","init","4","=","false",":","str","方法","ge",",","gt","方式","true",")","!","nq","eq","5","def","调用","描述","ne","6","(","a","return","lt","num","__"],"title":"用于比较的魔术方法","title_tokens":["比较","的","用于","魔术","方法"]},{"location":"Python基础/4.3.魔术方法.html#_3","text":"","text_tokens":[],"title":"数值处理的魔术方法","title_tokens":["处理","数值","的","魔术","方法"]},{"location":"Python基础/4.3.魔术方法.html#_4","text":"魔术方法 调用方式 描述 __pos__(self) +self __neg__(self) -self __abs__(self) abs(self) __invert__(self) ~self class A : def __init__ ( self , num = 2 ): self . num = num def __repr__ ( self ): return str ( self . num ) def __pos__ ( self ): new_num = 0 + self . num return A ( new_num ) def __neg__ ( self ): new_num = 0 - self . num return A ( new_num ) def __abs__ ( self ): new_num = abs ( self . num ) return A ( new_num ) a = A ( - 5 ) print ( + a ) print ( - a ) print ( abs ( a )) -5 5 5","text_tokens":[".","new"," ","魔术","self","print","class","+","repr","2","init","=","pos","-",":","str","方法","0","~",",","方式",")","5","def","调用","描述","neg","(","_","a","invert","return","abs","num","__"],"title":"一元运算符和内置函数","title_tokens":["一元","运算","和","算符","运算符","函数","内置"]},{"location":"Python基础/4.3.魔术方法.html#_5","text":"魔术方法 调用方式 描述 __add__(self, other) self + other __sub_(self, other) self - other __mul__(self, other) self * other __truediv__(self, other) self / other __pow__(self, other) self ** other __floordiv__(self, other) self // other __mod__(self, other) self % other class A : def __init__ ( self , num = 2 ): self . num = num def __repr__ ( self ): return str ( self . num ) def __add__ ( self , other ): new_num = self . num + other return A ( new_num ) def __sub__ ( self , other ): new_num = self . num - other return A ( new_num ) def __mul__ ( self , other ): new_num = self . num * other return A ( new_num ) def __truediv__ ( self , other ): new_num = self . num / other return A ( new_num ) def __pow__ ( self , other ): new_num = self . num ** other return A ( new_num ) def __floordiv__ ( self , other ): new_num = self . num // other return A ( new_num ) def __mod__ ( self , other ): new_num = self . num % other return A ( new_num ) a = A ( 5 ) print ( \"a + 2 =\" , a + 2 ) print ( \"a - 2 =\" , a - 2 ) print ( \"a * 2 =\" , a * 2 ) print ( \"a / 2 =\" , a / 2 ) print ( \"a ** 2 =\" , a ** 2 ) print ( \"a // 2 =\" , a // 2 ) print ( \"a % 2 =\" , a % 2 ) a + 2 = 7 a - 2 = 3 a * 2 = 10 a / 2 = 2.5 a ** 2 = 25 a // 2 = 2 a % 2 = 1","text_tokens":[".","new"," ","other","floordiv","魔术","self","truediv","print","class","+","10","1","repr","2","25","/","add","sub","init","=","\"","-",":","pow","str","方法",",","方式","*",")","mod","5","2.5","def","调用","%","描述","(","_","a","7","return","3","mul","num","__"],"title":"算术运算符","title_tokens":["运算","运算符","算符","算术"]},{"location":"Python基础/4.3.魔术方法.html#_6","text":"以下是一个普通的加法运算的例子: # __add__ some_object + other 反运算是相同的，只是把操作数调换了位置: # __radd__ other + some_object 所以，除了当与其他对象操作的时候自己会成为第二个操作数之外，所有的这些魔术方法都与普通的操作是相同的。大多数情况下，反运算的结果是与普通运算相同的。所以你可以你可以将 __radd__ 与 __add__ 等价。 魔术方法 调用方式 描述 __radd__(self, other) other + self __rsub_(self, other) other - self __rmul__(self, other) other * self __rtruediv__(self, other) other / self __rpow__(self, other) other ** self __rfloordiv__(self, other) other // self __rmod__(self, other) other % self","text_tokens":["例子","多数","结果","self","rtruediv","除了","之外","等价","rfloordiv","*","#","调用","rmod","描述","radd","把","反","_","rmul","位置","自己","other","可以","魔术","是","object","当","成为","会","/","add","二个","你","方法","rsub","方式","作数","，","对象","与","操作","都","相同","运算","-",":","情况",")","所以","大多数","。","时候","调换","操作数","的","第二","以下","rpow","了","加法"," ","普通","一个","+","some","其他","这些","将","所有","第二个",",","%","只是","下","(","大多","__"],"title":"反运算","title_tokens":["运算","反"]},{"location":"Python基础/4.3.魔术方法.html#_7","text":"魔术方法 调用方式 描述 __iadd__(self, other) self += other __isub_(self, other) self -= other __imul__(self, other) self *= other __itruediv__(self, other) self /= other __ipow__(self, other) self **= other __ifloordiv__(self, other) self //= other __imod__(self, other) self %= other","text_tokens":[" ","other","isub","魔术","self","+","imul","itruediv","/","=","-","方法","imod",",","方式","*",")","调用","%","描述","ipow","(","_","iadd","ifloordiv","__"],"title":"增强赋值","title_tokens":["赋值","增强"]},{"location":"Python基础/4.3.魔术方法.html#_8","text":"如果有一个字符串来表示一个类将会非常有用，例如： a = [ 1 , 2 , 3 ] a [1, 2, 3] 在Python中，有很多方法可以实现类定义内置的一些函数的返回值。 __str__(self) 定义当 str() 调用的时候的返回值。 __repr__(self) 定义 repr() 被调用的时候的返回值。 str() 和 repr() 的主要区别在于 repr() 返回的是机器可读的输出，而 str() 返回的是人类可读的。 __unicode__(self) 定义当 unicode() 调用的时候的返回值。 unicode() 和 str() 很相似，但是返回的是unicode字符串。注意，如果对你的类调用 str() 然而你只定义了 __unicode__() ，那么将不会工作。你应该定义 __str__() 来确保调用时能返回正确的值。 __hash__(self) 定义当 hash() 调用的时候的返回值，它返回一个整数值，用来在字典中进行快速比较 __nonzero__(self) 定义当 bool() 调用的时候的返回值。本方法应该返回True或者False，取决于你想让它返回的值。","text_tokens":["很","应该","用来","它","如果","self","2","hash","快速","true","字符","一些","调用","字典","有用","和","人类","比较","中","数值","可以","正确","取决于","函数","repr","是","不会","让","当","会","而","false","在","str","你","方法","类","只","非常","机器","[","值","python","，","实现","表示","3","例如","进行","bool","]","对","返回","内置","来","然而","工作","在于","取决","=","相似","：",")","本","。","nonzero","时候","的","了","时能"," ","但是","很多","一个","一个整","1","输出","那么","字符串","主要","确保","定义","unicode","将","有","返回值",",","注意","区别","或者","想","可读","(","a","被","__"],"title":"表现你的类","title_tokens":["你","的","类","表现"]},{"location":"Python基础/4.3.魔术方法.html#_9","text":"有很多方法让你的Python类行为可以像内置的序列(dict, tuple,list, string等等)。 现在我们开始讲如何在Python中创建定制的序列，这个时候该讲一讲协议。协议(Protocols)与其他语言中的接口很相似。它给你很多你必须定义的方法。然而在Python中的协议是很不正式的，不需要明确声明实现。事实上，他们更像一种指南。 我们为什么现在讨论协议？因为如果要定制容器类型的话需要用到这些协议： 实现不变容器的话有一个协议：实现不可变容器，你只能定义 __len__ 和 __getitem__ (一会会讲更多)。 可变容器协议则需要所有不可变容器的所有另外还需要 __setitem__ 和 __delitem__ 。 最终，如果你希望你的对象是可迭代的话，你需要定义 __iter__ 会返回一个迭代器。迭代器必须遵循迭代器协议，需要有 __iter__ (返回它本身) 和 next 。","text_tokens":["list","很","setitem","它","如果","len","迭代","遵循","该","还","类型","dict","不","声明","另外","等等","因为","行为","和","？","tuple","不变","他们","协议","定制","事实上","中","必须","可以","明确","是","next","一种","让","会","在","你","方法","类","更","delitem","开始","讨论","要","只能","python","，","实现","事实","对象","如何","与","语言","返回","内置","接口","然而","一会","string","getitem","相似","变","：","我们",")","指南","多","希望","本身","像","。","时候","创建","的","讲","什么","给","可"," ","很多","一个","protocols","这个","其他","的话","不可","定义","这些","最终","一","所有","有",",","则","正式","可变","iter","容器","现在","器","序列","需要","为什么","(","用到","__"],"title":"创建定制的序列","title_tokens":["创建","序列","定制","的"]},{"location":"Python基础/4.3.魔术方法.html#_10","text":"魔法方法 调用方法 描述 __len__(self) len(self) __index__(self) x[self] 对象被作为索引使用的时候 __getitem__(self, key) self[key] 使用索引访问元素时 __setitem__(self, key, val) self[key] = val 对某个索引值赋值时 __delitem__(self, key) del self[key] 删除某个索引值时 __iter__(self) for x in self 迭代时 __contains__(self, value) value in self, value not in self 使用 in 操作测试关系时 __concat__(self, value) self + other 连接两个对象时 __reversed__(self) reversed(self) 实现当 reversed() 被调用时的行为","text_tokens":["setitem","for","魔法","对象","赋值","]","len"," ","other","index","对","self","value","concat","迭代","访问","+","连接","操作","key","元素","关系","时","当","getitem","=","索引","val","某个","contains","值时","方法","not","测试",",","使用",")","iter","delitem","del","调用","作为","描述","[","时候","值","删除","两个","(","行为","x","的","in","实现","被","reversed","__"],"title":"容器的魔法","title_tokens":["容器","的","魔法"]},{"location":"Python基础/4.3.魔术方法.html#_11","text":"在Python中，方法也是一种高等的对象。这意味着他们也可以被传递到方法中就像其他对象一样。这是一个非常惊人的特性。 在Python中，一个特殊的魔术方法可以让类的实例的行为表现的像函数一样，你可以调用他们，将一个函数当做一个参数传到另外一个函数中等等。这是一个非常强大的特性让Python编程更加舒适甜美。 __call__(self, [args...]) 允许一个类的实例像函数一样被调用。实质上说，这意味着 x() 与 x.__call__() 是相同的。注意 __call__ 参数可变。这意味着你可以定义 __call__ 为其他你想要的函数，无论有多少个参数。 __call__ 在那些类的实例经常改变状态的时候会非常有效。调用这个实例是一种改变这个对象状态的直接和优雅的做法。用一个实例来表达最好不过了。","text_tokens":["这是","参数","到","允许","self","传到","那些","编程","个","表现","特殊","另外","传递","调用","改变","等等","行为","...","和",".__","这","他们","甜美","call","状态","中","可以","魔术","特性","函数","是","一种","让","无论","会","在","舒适","你","方法","一样","类","行为表现","非常","args","[","上","意味","说","表达","为","python","，","不过","当做","对象","更加","与","]","也","相同","来","有效","直接",")","。","像","最好","时候","的","x","高等","就","优雅","强大","了","惊人","用"," ","一个","实质","意味着","经常","做法","多少","这个","其他","定义","实例","想要","将","有",",","可变","注意","(","被","__"],"title":"可以调用的对象","title_tokens":["对象","调用","的","可以"]},{"location":"Python基础/4.3.魔术方法.html#_12","text":"在Python 2.5中，为了代码利用定义了一个新的关键词 with 语句。会话控制在Python中不罕见(之前是作为库的一部分被实现)，直到 PEP343 被添加后。它被成为一级语言结构。你也许之前看到这样的语句: with open('foo.txt') as bar: # perform some action with bar 回话控制器通过包装一个 with 语句来设置和清理行为。回话控制器的行为通过两个魔术方法来定义: __enter__(self) 定义当使用 with 语句的时候会话管理器应该初始块被创建的时候的行为。注意 __enter__ 的返回值被 with 语句的目标或者 as 后的名字绑定。 __exit__(self, exception_type,exception_value, traceback) 定义当一个代码块被执行或者终止后会话管理器应该做什么。它可以被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作。如果代码块执行成功， exception_type , exception_value , 和 traceback 将会是 None 。否则的话你可以选择处理这个异常或者是直接交给用户处理。如果你想处理这个异常的话，确认 __exit__ 在所有结束之后会返回 True 。如果你想让异常被会话管理器处理的话，那么就这样处理。 __enter 和 __exit__ 对于明确有定义好的和日常行为的设置和清洁工作的类很有帮助。你也可以使用这些方法来创建一般的可以包装其他对象的会话管理器。以下是一个例子： class Closer : '''通过with语句和一个close方法来关闭一个对象的会话管理器''' def __init__ ( self , obj ): self . obj = obj def __enter__ ( self ): return self . obj # bound to target def __exit__ ( self , exception_type , exception_val , trace ): try : self . obj . close () except AttributeError : # obj isn't closable print ( 'Not closable.' ) return True # exception handled successfully with Closer ( int ( 5 )) as i : i += 1 Not closable.","text_tokens":["例子","isn","很","一部","应该","用来","一部分","它","traceback","如果","int","self","管理器","value","完毕","成功","后","'","结束","名字","也许","后会","控制器","target","不","清洁","通过","将会","true","利用","帮助","添加","2.5","#","一些","try","会话","行为","包装","和","_","管理","后会话","日常","控制","对于","回话","中","交给","关键","做","可以","魔术","否则","明确","部分","绑定","用户","是","exit","让","当","成为","会","init","在","val","你","方法","not","类","这样","open","目标","初始","确认","t","好","with","python","，","实现","之后","一般","话","关闭","successfully","选择","对象","也","i","语言","结构","print","返回","bound","一级","来","工作","trace","=","foo",":","closable","：","新","closer","库","为了","直接",")","罕见","语句","块","。","看到","txt","理器","to","日常行为","时候","关键词","之前","清除","创建","的","return","就","attributeerror","以下","enter","了",".","什么","异常","type"," ","一个","class","+","1","代码","那么","some","设置","处理","perform","这个","的话","none","其他","定义","这些","handled","所有","有","直到","返回值","exception",",","使用","close","注意","5","执行","pep343","终止","action","作为","def","或者","except","清理","想","obj","bar","两个","(","as","被","__"],"title":"会话管理","title_tokens":["管理","会话"]},{"location":"Python基础/4.3.魔术方法.html#_13","text":"文章","text_tokens":["文章"],"title":"参考","title_tokens":["参考"]},{"location":"numpy笔记/6.1.创建数组.html","text":"import numpy as np 共同的参数 这里有几个共同的参数： a ：一个 array-like 类型的实例，它不一定是数组，可以为 list 、 tuple 、 list of tuple 、 list of list 、 tuple of list 、 tuple of tuple 等等。 dtype ：数组的值类型，默认为 float 。你可以指定Python的标准数值类型，也可以使用 numpy 的数值类型如： numpy.int32 或者 numpy.float64 等等。 order ：指定存储多维数据的方式。 - 'C' ，表示按行优先存储（C风格）； - 'F' ，表示按列优先存储（Fortran风格）。 - 对于 **_like() 函数， order 可以为： 'C' ， 'F' ， 'A' （表示结果的order与a相同）， 'K' （表示结果的 order 与 a 尽可能相似） subok ： bool 值。如果为 True 则：如果 a 为 ndarray 的子类（如 matrix 类），则结果类型与 a 类型相同。如果为 False 则：结果类型始终为 ndarray 。默认为True。 从现有的数据创建 1 np.array(object[, dtype, copy, order, subok, ndmin]) :从 object 创建。 - object 可以是一个 ndarray ，也可以是一个 array_like 的对象，也可以是一个含有返回一个序列或者 ndarray 的 __array__ 方法的对象，或者一个序列。 - `copy` ：默认为 `True` ，表示拷贝对象 - `order` 可以为 `'C'、'F'、'A'` 。默认为 `'K'` 。 - `subok` 默认为 `False` - `ndmin` ：指定结果 `ndarray` 最少有多少个维度。 2 np.asarray(a[, dtype, order]) ：将 a 转换成一个 ndarray 。其中 a 是 array_like 的对象， 可以是 list 、 list of tuple 、 tuple 、 tuple of list 、 ndarray 类型。 order 默认为 C 。 3 np.asanyarray(a[, dtype, order]) ：将 a 转换成 ndarray 。 4 np.ascontiguousarray(a[, dtype]) ：返回C风格的连续 ndarray 。 5 np.copy(a[, order]) ：返回 ndarray 的一份深拷贝。 以上5个方法实际上都是调用了 array() 的接口。 np . asarray () # array(a, dtype, copy=False, order=order) np . asanyarray () # array(a, dtype, copy=False, order=order, subok=True) np . ascontiguousarray () # array(a, dtype, copy=False, order='C', ndmin=1) np . copy () # array(a, order=order, copy=True) 6 np.asmatrix(data[, dtype]) ：返回 matrix 。 7 np.frombuffer(buffer[, dtype, count, offset]) ：从输入数据中返回一维 ndarray 。 count 指定读取的数量， -1 表示全部读取； offset 指定从哪里开始读取，默认为0。 创建的数组与 buffer 共享内存。 buffer 是一个提供了 buffer 接口的对象（ 内置的 bytes/bytearray/array.array 类型提供了该接口 ）。 from array import array # array.array 提供了类似list对象的内存机制 a = array ( \"d\" , [ 1 , 2 , 3 , 4 ]) # 创建一个array数组 na = np . frombuffer ( a , dtype = np . float ) # 通过np.frombuffer()创建一个和a共享内存的NumPy数组 print ( \"a:\" , a ) print ( \"na:\" , na ) na [ 1 ] = 20 # 修改NumPy数组中的第一个元素 a # array数组中的第一个元素也同时改变 a : array ( 'd' , [ 1.0 , 2.0 , 3.0 , 4.0 ]) na : [ 1 . 2 . 3 . 4 .] array('d', [1.0, 20.0, 3.0, 4.0]) 8 np.fromfile(file[, dtype, count, sep]) ：从二进制文件或者文本文件中读取数据返回 ndarray 。 sep ：当从文本文件中读取时，数值之间的分隔字符串，如果 sep 是空字符串则表示文件应该作为二进制文件读取；如果 sep 为 \" \" 表示可以匹配0个或者多个空白字符。 9 np.fromfunction(function, shape, \\**kwargs) ：返回一个 ndarray 。function会获取每一个坐标点的数据，作为输入参数。假设 shape 的维度为N，那么 function 带有 N 个参数， fn(x1,x2,...x_N) ，其返回值就是该坐标点的值。 def fun ( x , y ): return x + y np . fromfunction ( fun , shape = ( 3 , 3 )) array([[0., 1., 2.], [1., 2., 3.], [2., 3., 4.]]) 10 np.fromiter(iterable, dtype[, count]) ：从可迭代对象中迭代获取数据创建一维 ndarray 。 np . fromiter ( \"123\" , dtype = \"int64\" ) array([1, 2, 3], dtype=int64) 11 np.fromstring(string[, dtype, count, sep]) ：从字符串或者 raw binary 中创建一维 ndarray 。如果 sep 为空字符串则 string 将按照二进制数据解释（即每个字符作为 ASCII 码值对待）。创建的数组有自己的数据存储区。 a = \"abcdefg\" a = np . fromstring ( a , dtype = np . int8 ) # 将每个字符的ASCII编码解释为整数 print ( a ) a = \"1;2;3;4;5\" a = np . fromstring ( a , dtype = np . int8 , sep = \";\" ) print ( a ) [ 97 98 99 100 101 102 103] [1 2 3 4 5] .\\setup_m.py:2: DeprecationWarning: The binary mode of fromstring is deprecated, as it behaves surprisingly on unicode inputs. Use frombuffer instead from datetime import datetime 12 np.loadtxt(fname[, dtype, comments, delimiter, ...]) :从文本文件中加载数据创建 ndarray ，要求文本文件每一行都有相同数量的数值。 comments ：指示注释行的起始字符，可以为单个字符或者字符列表（默认为 # ）。 delimiter :指定数值之间的分隔字符串，默认为空白符。 converters ：将指定列号(0,1,2...)的列数据执行转换，是一个 map ，如 {0:func1} 表示对第一列数据执行 func1(val_0) 。 skiprows ：指定跳过开头的多少行。 usecols ：指定读取那些列（0表示第一列）。 从数值区间创建 1 np.arange([start,] stop[, step,][, dtype]) :返回均匀间隔的值组成的一维 ndarray 。区间是半闭半开的 [start,stop) ，其采样行为类似Python的 range 函数。 start 为开始点， stop 为终止点， step 为步长，默认为1。这几个数可以为整数可以为浮点数。 注意如果 step 为浮点数，则结果可能有误差，因为浮点数相等比较不准确（计算机精度有限）。 2 np.linspace(start, stop[, num, endpoint, ...]) ：返回 num 个均匀采样的数值组成的一维 ndarray （默认为50）。区间是闭区间 [start,stop] 。 endpoint 为布尔值，如果为真则表示 stop 是最后采样的值（默认为 True ），否则结果不包含 stop 。 retstep 如果为 True 则返回结果包含采样步长 step ，默认为 True 。 3 np.logspace(start, stop[, num, endpoint, base, ...]) ：返回对数级别上均匀采样的数值组成的一维 ndarray 。采样点开始于 base^start ，结束于 base^stop 。 base 为对数的基，默认为 10。 它逻辑上相当于先执行 arange 获取数组 array ，然后再执行 base^array[i] 获取采样点 - 它没有 retstep 关键字参数 以填充的方式创建 1 np.empty(shape[,dtype,order]) ：返回一个新的 ndarray ，指定了 shape 和 dtype ，但是没有初始化元素。因此其内容是随机的。 2 np.empty_like(a[,dtype,order,subok]) ：返回一个新的 ndarray ， shape 与 a 相同，但是没有初始化元素。因此其内容是随机的。 # 内存未初始化 a = np . empty (( 3 , 2 ), order = \"C\" ) # 内存未初始化 np . empty_like ( a ) array([[0., 0.], [0., 0.], [0., 0.]]) 3 np.eye(N[, M, k, dtype]) ：返回一个==二维数组==，对角线元素为1，其余元素为0。 M 默认等于 N 。 k 默认为0表示对角线元素为1，如为正数则表示对角线上方一格的元素为1，如为负数表示对角线下方一格的元素为1。 4 np.identity(n[, dtype]) ：返回一个单位矩阵。 np . eye ( N = 2 , M = 3 ) np . eye ( N = 2 , M = 3 , k = 0 ) # 参数k是可以超出范围的 np . eye ( N = 2 , M = 3 , k = 1 ) # 返回n阶单位矩阵 np . identity ( n = 4 ) array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) 5 np.ones(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为1. 6 np.ones_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为1。 7 np.zeros(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为0. 8 np.zeros_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a （另一个数组）相同，每个元素初始化为0。 9 np.full(shape, fill_value[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为 fill_value 。 10 np.full_like(a, fill_value[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为 fill_value 。 np . full (( 2 , 3 ), fill_value = 2 ) array([[2, 2, 2], [2, 2, 2]])","text_tokens":["ascontiguousarray","浮点","读取数据","asanyarray","99","10","'","该","基","不","默认","retstep","*","步长","usecols","真则","调用","读取","含有","copy","分隔","行为","...","7","tuple","存储","修改","每个","对于","这","一行","buffer","否则","转换","{","空","共同","子类","第一","是","当","range","val",";","拷贝","101","方式","function","类似","初始","文本","100","python","3","如为","相当","按照","fill","再","对角线","相同","现有","文本文件","is","n",")","相等","计算","。","m","的","其","空白","因此","fromfile","列表","一列","了"," ","func1","这里","+","start","2.0","字符串","sep","单个","先","unicode","实例","尽可","将","换成","deprecationwarning","使用","则","delimiter","5","order","按列","匹配","int64","要求","即","序列","surprisingly","二进制","a","本文","20.0","元素","尽可能","按行","offset","loadtxt","它","value","注释","comments","实际","相当于","2","}","假设","\\","98","iterable","获取","输入","like","未","abcdefg","改变","等等","因为","_","和","logspace","提供","8","中","对角","单位矩阵","共享","共享内存","函数","x2","fn","；","false","其中","setup","填充","count","级别","其余","区","数组","连续","，","ndarray","asarray","一格","与","]","一份","frombuffer","超出范围","列","print","没有","都","ndmin","c","接口","50","关键字","string","=","相似","随机","半开","import","矩阵","int32","如","ascii","整数","坐标","数","第一个","of","对数","the","1","实际上","点数","那么","采样","风格","范围","间隔","多个","int8","几个","有","注意","包含","第一列","linspace","(","获取数据","shape","列号","参数","4.0","如果","迭代","mode","instead","那些","正数","时","array","结束","data","fromstring","误差","类型","inputs","converters","fromfunction","于","通过","字符","na","均匀","布尔值","use","stop","多维","初始化","转换成","上方","负数","自己","数值","fortran","可以","dtype","数量","始终","会","kwargs","全部","半闭","你","二维","方法","k","fromiter","step","类","开头","然后","endpoint","开始","[","asmatrix","超出","值","跳过","为","11","以上","bool","float","it","对","^","4",":","9","之间","算机","f","arange","精度","subok","97","创建","base","点","x","12","最后",".","一定","可","但是","一个","逻辑","浮点数","当于","zeros","\"","0","返回值","behaves","指定","def","6","内存","布尔","x1","（","文件","num","empty","list","fname","应该","结果","skiprows","一维","binary","full","标准","deprecated","raw","个","d","空白符","true","#","numpy","on","有限","最少","优先","解释","bytearray","）","bytes","对待","深","起始","比较","计算机","关键","eye","object","、","103","/","123","20","准确","上","编码","哪里","表示","3.0","维度","对象","也","区间","i","返回","闭","内置","datetime","y","另","-","机制","：","新","1.0","就是","指示","return","带有","行","fun","ones","码值","进制","type","为空","多少","`","py","map","加载","单位","阶","数据","matrix","identity","np","内容","同时","102",",","file","下方","执行","终止","从","作为","或者","可能","以","float64","等于","每","from","as","组成","__"],"title":"6.1.创建数组","title_tokens":["创建","6.1",".","数组"]},{"location":"numpy笔记/6.1.创建数组.html#_1","text":"这里有几个共同的参数： a ：一个 array-like 类型的实例，它不一定是数组，可以为 list 、 tuple 、 list of tuple 、 list of list 、 tuple of list 、 tuple of tuple 等等。 dtype ：数组的值类型，默认为 float 。你可以指定Python的标准数值类型，也可以使用 numpy 的数值类型如： numpy.int32 或者 numpy.float64 等等。 order ：指定存储多维数据的方式。 - 'C' ，表示按行优先存储（C风格）； - 'F' ，表示按列优先存储（Fortran风格）。 - 对于 **_like() 函数， order 可以为： 'C' ， 'F' ， 'A' （表示结果的order与a相同）， 'K' （表示结果的 order 与 a 尽可能相似） subok ： bool 值。如果为 True 则：如果 a 为 ndarray 的子类（如 matrix 类），则结果类型与 a 类型相同。如果为 False 则：结果类型始终为 ndarray 。默认为True。","text_tokens":["list","参数","它","如果","结果","标准","array","'","类型","不","默认","true","*","like","numpy","多维","等等","_","tuple","优先","存储","对于","）","数值","fortran","可以","共同","dtype","函数","子类","是","；","、","始终","false","你","k","类","方式","值","按行","数组","为","python","，","ndarray","表示","bool","float","与","也","c","相同","-","相似","：","f",")","。","int32","subok","如","的",".","一定","of"," ","一个","这里","风格","数据","实例","matrix","几个","尽可","有","指定","使用","则","order","按列","或者","可能","float64","(","a","（","尽可能"],"title":"共同的参数","title_tokens":["参数","共同","的"]},{"location":"numpy笔记/6.1.创建数组.html#_2","text":"1 np.array(object[, dtype, copy, order, subok, ndmin]) :从 object 创建。 - object 可以是一个 ndarray ，也可以是一个 array_like 的对象，也可以是一个含有返回一个序列或者 ndarray 的 __array__ 方法的对象，或者一个序列。 - `copy` ：默认为 `True` ，表示拷贝对象 - `order` 可以为 `'C'、'F'、'A'` 。默认为 `'K'` 。 - `subok` 默认为 `False` - `ndmin` ：指定结果 `ndarray` 最少有多少个维度。 2 np.asarray(a[, dtype, order]) ：将 a 转换成一个 ndarray 。其中 a 是 array_like 的对象， 可以是 list 、 list of tuple 、 tuple 、 tuple of list 、 ndarray 类型。 order 默认为 C 。 3 np.asanyarray(a[, dtype, order]) ：将 a 转换成 ndarray 。 4 np.ascontiguousarray(a[, dtype]) ：返回C风格的连续 ndarray 。 5 np.copy(a[, order]) ：返回 ndarray 的一份深拷贝。 以上5个方法实际上都是调用了 array() 的接口。 np . asarray () # array(a, dtype, copy=False, order=order) np . asanyarray () # array(a, dtype, copy=False, order=order, subok=True) np . ascontiguousarray () # array(a, dtype, copy=False, order='C', ndmin=1) np . copy () # array(a, order=order, copy=True) 6 np.asmatrix(data[, dtype]) ：返回 matrix 。 7 np.frombuffer(buffer[, dtype, count, offset]) ：从输入数据中返回一维 ndarray 。 count 指定读取的数量， -1 表示全部读取； offset 指定从哪里开始读取，默认为0。 创建的数组与 buffer 共享内存。 buffer 是一个提供了 buffer 接口的对象（ 内置的 bytes/bytearray/array.array 类型提供了该接口 ）。 from array import array # array.array 提供了类似list对象的内存机制 a = array ( \"d\" , [ 1 , 2 , 3 , 4 ]) # 创建一个array数组 na = np . frombuffer ( a , dtype = np . float ) # 通过np.frombuffer()创建一个和a共享内存的NumPy数组 print ( \"a:\" , a ) print ( \"na:\" , na ) na [ 1 ] = 20 # 修改NumPy数组中的第一个元素 a # array数组中的第一个元素也同时改变 a : array ( 'd' , [ 1.0 , 2.0 , 3.0 , 4.0 ]) na : [ 1 . 2 . 3 . 4 .] array('d', [1.0, 20.0, 3.0, 4.0]) 8 np.fromfile(file[, dtype, count, sep]) ：从二进制文件或者文本文件中读取数据返回 ndarray 。 sep ：当从文本文件中读取时，数值之间的分隔字符串，如果 sep 是空字符串则表示文件应该作为二进制文件读取；如果 sep 为 \" \" 表示可以匹配0个或者多个空白字符。 9 np.fromfunction(function, shape, \\**kwargs) ：返回一个 ndarray 。function会获取每一个坐标点的数据，作为输入参数。假设 shape 的维度为N，那么 function 带有 N 个参数， fn(x1,x2,...x_N) ，其返回值就是该坐标点的值。 def fun ( x , y ): return x + y np . fromfunction ( fun , shape = ( 3 , 3 )) array([[0., 1., 2.], [1., 2., 3.], [2., 3., 4.]]) 10 np.fromiter(iterable, dtype[, count]) ：从可迭代对象中迭代获取数据创建一维 ndarray 。 np . fromiter ( \"123\" , dtype = \"int64\" ) array([1, 2, 3], dtype=int64) 11 np.fromstring(string[, dtype, count, sep]) ：从字符串或者 raw binary 中创建一维 ndarray 。如果 sep 为空字符串则 string 将按照二进制数据解释（即每个字符作为 ASCII 码值对待）。创建的数组有自己的数据存储区。 a = \"abcdefg\" a = np . fromstring ( a , dtype = np . int8 ) # 将每个字符的ASCII编码解释为整数 print ( a ) a = \"1;2;3;4;5\" a = np . fromstring ( a , dtype = np . int8 , sep = \";\" ) print ( a ) [ 97 98 99 100 101 102 103] [1 2 3 4 5] .\\setup_m.py:2: DeprecationWarning: The binary mode of fromstring is deprecated, as it behaves surprisingly on unicode inputs. Use frombuffer instead from datetime import datetime 12 np.loadtxt(fname[, dtype, comments, delimiter, ...]) :从文本文件中加载数据创建 ndarray ，要求文本文件每一行都有相同数量的数值。 comments ：指示注释行的起始字符，可以为单个字符或者字符列表（默认为 # ）。 delimiter :指定数值之间的分隔字符串，默认为空白符。 converters ：将指定列号(0,1,2...)的列数据执行转换，是一个 map ，如 {0:func1} 表示对第一列数据执行 func1(val_0) 。 skiprows ：指定跳过开头的多少行。 usecols ：指定读取那些列（0表示第一列）。","text_tokens":["list","ascontiguousarray","列号","offset","fname","应该","读取数据","4.0","参数","如果","loadtxt","结果","asanyarray","skiprows","一维","99","迭代","注释","10","mode","instead","binary","comments","那些","实际","时","2","array","'","假设","该","}","deprecated","raw","data","个","\\","fromstring","类型","98","d","inputs","converters","fromfunction","iterable","获取","输入","默认","通过","true","字符","*","空白符","na","usecols","#","like","调用","numpy","use","读取","含有","copy","abcdefg","改变","分隔","on","_","最少","转换成","tuple","7","和","修改","...","每个","存储","提供","解释","bytearray","一行","bytes","）","8","深","对待","中","起始","buffer","数值","自己","可以","转换","{","空","共享","dtype","共享内存","x2","第一","fn","object","是","；","、","当","数量","会","/","103","kwargs","false","全部","val",";","方法","其中","setup","拷贝","k","fromiter","101","123","20","开头","function","类似","开始","文本","[","count","编码","asmatrix","值","跳过","哪里","100","区","为","数组","连续","ndarray","，","11","表示","3","3.0","asarray","维度","以上","按照","对象","float","一份","]","也","frombuffer","与","it","列","对","print","返回","都","内置","ndmin","datetime","y","c","接口","文本文件","相同","string","4","=",":","-","机制","9","：","之间","is","f","n",")","1.0","import","就是","。","subok","97","指示","ascii","如","创建","整数","m","点","的","x","空白","其","return","带有","fromfile","12","行","fun","坐标","列表","一列","码值",".","了","第一个","可","进制","of","为空"," ","一个","func1","the","+","1","实际上","多少","那么","2.0","`","字符串","风格","py","map","加载","sep","单个","数据","matrix","\"","多个","int8","将","unicode","np","有","0","换成","返回值","同时","102","指定",",","file","则","deprecationwarning","behaves","delimiter","5","执行","def","order","从","作为","或者","匹配","int64","要求","即","6","第一列","序列","内存","surprisingly","(","二进制","a","（","20.0","文件","from","本文","每","x1","as","元素","获取数据","shape","__"],"title":"从现有的数据创建","title_tokens":["现有","创建","的","从","数据"]},{"location":"numpy笔记/6.1.创建数组.html#_3","text":"1 np.arange([start,] stop[, step,][, dtype]) :返回均匀间隔的值组成的一维 ndarray 。区间是半闭半开的 [start,stop) ，其采样行为类似Python的 range 函数。 start 为开始点， stop 为终止点， step 为步长，默认为1。这几个数可以为整数可以为浮点数。 注意如果 step 为浮点数，则结果可能有误差，因为浮点数相等比较不准确（计算机精度有限）。 2 np.linspace(start, stop[, num, endpoint, ...]) ：返回 num 个均匀采样的数值组成的一维 ndarray （默认为50）。区间是闭区间 [start,stop] 。 endpoint 为布尔值，如果为真则表示 stop 是最后采样的值（默认为 True ），否则结果不包含 stop 。 retstep 如果为 True 则返回结果包含采样步长 step ，默认为 True 。 3 np.logspace(start, stop[, num, endpoint, base, ...]) ：返回对数级别上均匀采样的数值组成的一维 ndarray 。采样点开始于 base^start ，结束于 base^stop 。 base 为对数的基，默认为 10。 它逻辑上相当于先执行 arange 获取数组 array ，然后再执行 base^array[i] 获取采样点 - 它没有 retstep 关键字参数","text_tokens":["浮点","参数","它","如果","结果","一维","10","相当于","2","array","结束","基","个","误差","获取","不","默认","于","true","retstep","步长","真则","均匀","布尔值","stop","因为","有限","行为","...","logspace","这","）","比较","数值","可以","计算机","否则","关键","dtype","函数","是","range","半闭","step","然后","endpoint","类似","准确","开始","[","上","值","级别","为","数组","python","ndarray","，","表示","3","相当","]","区间","i","返回","闭","没有","再","^","50","关键字",":","-","：","半开","算机","arange",")","相等","精度","计算","。","整数","base","点","的","其","数","最后","."," ","对数","逻辑","浮点数","1","点数","当于","start","采样","间隔","先","几个","np","有",",","则","注意","执行","终止","包含","可能","linspace","布尔","(","（","num","组成"],"title":"从数值区间创建","title_tokens":["创建","数值","从","区间"]},{"location":"numpy笔记/6.1.创建数组.html#_4","text":"1 np.empty(shape[,dtype,order]) ：返回一个新的 ndarray ，指定了 shape 和 dtype ，但是没有初始化元素。因此其内容是随机的。 2 np.empty_like(a[,dtype,order,subok]) ：返回一个新的 ndarray ， shape 与 a 相同，但是没有初始化元素。因此其内容是随机的。 # 内存未初始化 a = np . empty (( 3 , 2 ), order = \"C\" ) # 内存未初始化 np . empty_like ( a ) array([[0., 0.], [0., 0.], [0., 0.]]) 3 np.eye(N[, M, k, dtype]) ：返回一个==二维数组==，对角线元素为1，其余元素为0。 M 默认等于 N 。 k 默认为0表示对角线元素为1，如为正数则表示对角线上方一格的元素为1，如为负数表示对角线下方一格的元素为1。 4 np.identity(n[, dtype]) ：返回一个单位矩阵。 np . eye ( N = 2 , M = 3 ) np . eye ( N = 2 , M = 3 , k = 0 ) # 参数k是可以超出范围的 np . eye ( N = 2 , M = 3 , k = 1 ) # 返回n阶单位矩阵 np . identity ( n = 4 ) array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) 5 np.ones(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为1. 6 np.ones_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为1。 7 np.zeros(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为0. 8 np.zeros_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a （另一个数组）相同，每个元素初始化为0。 9 np.full(shape, fill_value[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为 fill_value 。 10 np.full_like(a, fill_value[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为 fill_value 。 np . full (( 2 , 3 ), fill_value = 2 ) array([[2, 2, 2], [2, 2, 2]])","text_tokens":["参数","value","10","full","正数","2","array","默认","#","like","未","初始化","_","和","7","上方","每个","）","负数","8","对角","单位矩阵","可以","dtype","eye","是","二维","k","初始","[","超出","其余","数组","为","ndarray","，","表示","3","如为","一格","与","]","超出范围","fill","返回","没有","对角线","相同","c","另","4","=","随机","9","：","新","n",")","。","矩阵","subok","m","的","其","因此","ones",".","了","type"," ","但是","一个","1","单位","范围","阶","zeros","\"","identity","np","内容","0","指定",",","则","5","下方","order","6","内存","等于","(","a","（","元素","shape","empty"],"title":"以填充的方式创建","title_tokens":["创建","方式","的","填充","以"]},{"location":"numpy笔记/6.10.函数库.html","text":"import numpy as np 随机数库","text_tokens":["库","机数","随机数"," ","import","numpy","as","随机","np"],"title":"6.10.函数库","title_tokens":["6.10",".","函数","函数库"]},{"location":"numpy笔记/6.10.函数库.html#_1","text":"","text_tokens":[],"title":"随机数库","title_tokens":["随机","随机数","库","机数"]},{"location":"numpy笔记/6.12.结构化数组.html","text":"结构化数组常用操作 import numpy as np import pprint x = np . array ([( 'Rex' , 9 , 81.0 ), ( 'Fido' , 3 , 27.0 )], dtype = [( 'name' , 'U10' ), ( 'age' , 'i4' ), ( 'weight' , 'f4' )]) pprint . pprint ( x ) array([('Rex', 9, 81.), ('Fido', 3, 27.)], dtype=[('name', '<U10'), ('age', '<i4'), ('weight', '<f4')]) 通过索引，可以获得一个结构 pprint . pprint ( x [ 0 ]) # 可以通过使用 字段名称 建立索引来访问和修改结构化数组的各个 字段： pprint . pprint ( x [ \"name\" ]) pprint . pprint ( x [[ \"age\" , \"name\" ]]) # 根据 字段名称 做过滤 pprint . pprint ( x [ x [ \"age\" ] > 5 ][ \"name\" ]) # 修改全部数组的age字段 x [ \"age\" ] = 20 pprint . pprint ( x ) ('Rex', 9, 81.) array(['Rex', 'Fido'], dtype='<U10') array([(9, 'Rex'), (3, 'Fido')], dtype={'names':['age','name'], 'formats':['<i4','<U10'], 'offsets':[40,0], 'itemsize':48}) array(['Rex'], dtype='<U10') array([('Rex', 20, 81.), ('Fido', 20, 27.)], dtype=[('name', '<U10'), ('age', '<i4'), ('weight', '<f4')]) 创建结构化数组 可以通过 a list of tuple 的形式创建结构化数组。 \"\"\" # the tupe is (fieldname, datatype, Shape) # fieldname、Shape可以省略 # fieldname 是字符串，如果使用 title，则为元组 # 如果fieldname省略，则用 f# 的默认名称代替 # shape 如果省略，则默认为(1,) \"\"\" np . dtype ([( 'x' , 'f4' ), ( 'y' , np . float32 ), ( 'z' , 'f4' , ( 2 , 2 ))]) \"\"\" 如果 fieldname 是空字符串 '' ，则将为字段指定格式为 f# 的默认名称， 其中 # 是字段的整数索引，从左侧开始从0开始计数： \"\"\" np . dtype ([( 'x' , 'f4' ), ( '' , 'i4' ), ( 'z' , 'i8' )]) dtype([('x', '<f4'), ('f1', '<i4'), ('z', '<i8')]) 可以通过“逗号分割的字符串”创建结构化数组。字符串要符合规范。 np . dtype ( 'i8, f4, S3' ) np . dtype ( '3int8, float32, (2, 3)float64' ) dtype([('f0', 'i1', (3,)), ('f1', '<f4'), ('f2', '<f8', (2, 3))]) 通过“字段参数组字典”创建结构化数组。 这是最灵活的规范形式，因为它允许控制字段的字节偏移和结构的项目大小。 dict有两个必需键 names 和 format ，以及四个可选键 offsets 、 itemsize 、 Aligned 和 title ： names 和 format 的值应该分别是相同长度的字段名列表和dtype规范列表。 可选的 offsets 值应该是整数字节偏移量的列表，结构中的每个字段都有一个偏移量。如果未给出 offsets ，则自动确定偏移量。 可选的 itemsize 值应该是一个整数， 描述 dtype 的总大小（以字节为单位），它必须足够大以包含所有字段。 可选的 Aligned 值可以设置为True，以使自动偏移计算使用对齐的偏移量（ 请参阅自动字节偏移量和对齐 ）。 可选的 titles 值应该是长度与 names 相同的标题列表。 np . dtype ({ 'names' : [ 'col1' , 'col2' ], 'formats' : [ 'i4' , 'f4' ]}) np . dtype ({ 'names' : [ 'col1' , 'col2' ], 'formats' : [ 'i4' , 'f4' ], 'offsets' : [ 0 , 4 ], 'itemsize' : 12 }) dtype({'names':['col1','col2'], 'formats':['<i4','<f4'], 'offsets':[0,4], 'itemsize':12}) 通过 dict of fieldname 创建结构化数组。不鼓励使用这种形式，因为Python字典在Python 3.6之前的Python版本中不保留顺序，但结构化dtype中字段的顺序有意义。 字典的关键字是字段名称，值是指定类型和偏移量的元组： np . dtype ({ 'col1' : ( 'i1' , 0 ), 'col2' : ( 'f4' , 1 )}) dtype([('col1', 'i1'), ('col2', '<f4')]) 操作和显示结构化数据类型 d = np . dtype ([( 'x' , 'i8' ), ( 'y' , 'f4' )]) d . names d . fields mappingproxy({'x': (dtype('int64'), 0), 'y': (dtype('float32'), 8)}) 为什么需要结构化数组 numpy结构化数组中的用法好像类似于Python的dict of list，那为什么还要用numpy结构化数组呢？ 因为numpy的结构化数组底层是类似C语言的结构，占用一块连续的内存区域，并且numpy底层是C实现，numpy数组中的类型都是静态类型的，性能好于Python的的字典列表。 可以来做一下性能比较。 import time ### 定义计时器 def timer ( func ): def wrapper ( self , * args , ** kwargs ): start = time . process_time () something = func ( self , * args , ** kwargs ) end = time . process_time () type_str = func . __repr__ () print ( \"当前函数：\" , type_str , \" \\n \" , \"用时：\" , end - start , \"秒\" , sep = \"\" ) return something return wrapper # numpy版本长一岁 @timer def addage_numpy ( data , loop ): for i in range ( loop ): data [ 'age' ] += 1 # python循环长一岁 @timer def addage_python ( data , loop ): for j in range ( loop ): for i in range ( 4 ): data [ i ][ \"age\" ] += 1 # 创建结构化数组 names = [ 'Lin' , 'Pan' , 'Shen' , 'Zhou' ] ages = [ 28 , 33 , 34 , 29 ] grades = [ 25 , 26 , 27 , 24 ] data_np = np . zeros ( 4 , dtype = { 'names' :( 'name' , 'age' , 'grade' ), 'formats' :( 'U10' , 'i4' , 'i4' ) }) data_np [ 'name' ] = names data_np [ 'age' ] = ages data_np [ 'grade' ] = grades data_py = [] for i in range ( 4 ): person = { \"name\" : names [ i ], \"age\" : ages [ i ], \"grade\" : grades [ i ]} data_py . append ( person ) addage_numpy ( data_np , loop = 1000000 ) addage_python ( data_py , loop = 1000000 ) 当前函数：<function addage_numpy at 0x000001198F1ECC80> 用时：5.53125秒 当前函数：<function addage_python at 0x000001198F1ECD90> 用时：1.796875秒 记录数组 记录数组和结构数组没有太大区别，它们所使用的场景也是类似的，只不过记录数组可以通过属性的方式访问数据。 创建记录数组的最简单方法是 numpy.rec.array 。 recordarr = np . rec . array ([( 1 , 2. , 'Hello' ), ( 2 , 3. , \"World\" )], dtype = [( 'foo' , 'i4' ),( 'bar' , 'f4' ), ( 'baz' , 'S10' )]) print ( type ( recordarr )) # 通过属性访问数据 recordarr . foo <class 'numpy.recarray'> array([1, 2]) numpy.rec.array 可以将各种参数转换为记录数组，包括结构化数组： arr = np . array ([( 1 , 2. , 'Hello' ), ( 2 , 3. , \"World\" )], dtype = [( 'foo' , 'i4' ), ( 'bar' , 'f4' ), ( 'baz' , 'S10' )]) recordarr = np . rec . array ( arr ) pprint . pprint ( recordarr ) rec.array([(1, 2., b'Hello'), (2, 3., b'World')], dtype=[('foo', '<i4'), ('bar', '<f4'), ('baz', 'S10')]) numpy.rec 模块提供了多个便利的函数来创建记录数组，请参阅 记录数组创建方法列表 。 注意： numpy.rec 是 numpy.core.records 的首选别名。 core.records.array(obj[, dtype, shape, …]) ：从各种各样的对象构造一个记录数组。 core.records.fromarrays(arrayList[, dtype, …]) ：从一维的list或array创建记录数组。 core.records.fromrecords(recList[, dtype, …]) ：从文本格式的list创建一个记录数组。 core.records.fromstring(datastring[, dtype, …]) ：从二进制字符串数据创建（只读）记录数组。 core.records.fromfile(fd[, dtype, shape, …]) ：从二进制文件数据创建记录数组。 参考 一文彻底搞懂numpy的结构化数组——structured array Numpy的结构化数组 结构化数组","text_tokens":["字","self","字段","最","别名","f2","'","代替","长度","dict","大小","不","各个","默认","*","float32","秒","首选","字典","计数","一文","i1","中字","fromrecords","tuple","修改","总","每个","in","这","段","标题","addage","转换","{","空","给出","grades","是","呢","range","格式","对齐","四个","fieldname","方式","function","类似","灵活","文本","python","实现","3","规范","左侧","请参阅","结构","age","访问","append","27","title","s3","来","相同","包括","is","文本格式","n",")","一岁","0x000001198f1ecc80","计算","。","的","timer","列表","fromfile","29","版本","了","loop"," ","循环","something","<","+","weight","start","字符串","25","tupe","sep","将","使用","则","26","end","或","5","分别","int64","recarray","person","rex","time","二进制","a","at","那","mappingproxy","它","大","f0","用时","fd","2","}","reclist","\\","fields","符合","…","未","因为","_","和","参阅","提供","c语言","8","0x000001198f1ecd90","中","必须","做","场景","函数","当前","b","str","只读","简单","其中","z","还要","formats","###","数组","连续","，","计时器","28","81","与","]","建立","print","33","没有","structured","都","func","关键字","c","顺序","=","names","import","itemsize","底层","format","之前","col2","并且","整数","aligned","区域","使","of","i8","用","the","1","设置","27.0","多个","有","注意","区别","包含","j","常用","obj","偏移","一下","自动","为什么","两个","(","足够","结构化","shape","f4","名称","参数","ages","如果","确定","fido","—","array","1000000","data","fromstring","类型","arr","rec","于","通过","字符","描述","长","数据类型","？","控制","zhou","所","符合规范","可以","dtype","repr","48","用法","“","34","3.6","@","偏移量","f8","kwargs","全部","可选键","方法","属性","args","开始","[","太","要","值","为","不过","name","操作","逗号","4","foo","性能",":","9","字段名","i4","datatype","合规","f","u10","项目","显示","创建","x","称","各种","12","datastring","搞懂",".","81.0","大以","什么","占用","一个","class","24","索引","\"","zeros","grade","所有","0","指定","各种各样","def","分割","pan","彻底","offsets","bar","内存","需要","（","文件","可选","titles","好像","baz","计时","process","list","recordarr","for","应该","构造","允许","一维","组","col1","core","d","根据","true","arraylist","5.53125","#","numpy","它们","模块","s10","省略","pprint","）","比较","40",">","字节","关键","shen","、","形式","在","20","元组","但","以及","对象","i","也","便利","语言","这种","参考","获得","y","一块","记录","各样","键","-","：","f1","静态","fromarrays","return","wrapper","进制","type","鼓励","3int8","world","records","好于","保留","py","单位","定义","数据","np","过滤",",","”","从","hello","以","float64","1.796875","必需","意义","只不过","as","lin","__"],"title":"6.12.结构化数组","title_tokens":["6.12",".","数组","结构","结构化"]},{"location":"numpy笔记/6.12.结构化数组.html#_1","text":"import numpy as np import pprint x = np . array ([( 'Rex' , 9 , 81.0 ), ( 'Fido' , 3 , 27.0 )], dtype = [( 'name' , 'U10' ), ( 'age' , 'i4' ), ( 'weight' , 'f4' )]) pprint . pprint ( x ) array([('Rex', 9, 81.), ('Fido', 3, 27.)], dtype=[('name', '<U10'), ('age', '<i4'), ('weight', '<f4')]) 通过索引，可以获得一个结构 pprint . pprint ( x [ 0 ]) # 可以通过使用 字段名称 建立索引来访问和修改结构化数组的各个 字段： pprint . pprint ( x [ \"name\" ]) pprint . pprint ( x [[ \"age\" , \"name\" ]]) # 根据 字段名称 做过滤 pprint . pprint ( x [ x [ \"age\" ] > 5 ][ \"name\" ]) # 修改全部数组的age字段 x [ \"age\" ] = 20 pprint . pprint ( x ) ('Rex', 9, 81.) array(['Rex', 'Fido'], dtype='<U10') array([(9, 'Rex'), (3, 'Fido')], dtype={'names':['age','name'], 'formats':['<i4','<U10'], 'offsets':[40,0], 'itemsize':48}) array(['Rex'], dtype='<U10') array([('Rex', 20, 81.), ('Fido', 20, 27.)], dtype=[('name', '<U10'), ('age', '<i4'), ('weight', '<f4')])","text_tokens":["pprint","f4",".","81.0","40","name","81",">","]","字"," ","可以","一个","建立","做","{","结构","dtype","age","<","访问","weight","fido","字段","48","获得","27","来","array","'","27.0","}","=","索引","\"","全部",":","9","根据","字段名","np","i4","0","：","过滤","names","各个","u10",",","通过","使用",")","5","20","import","#","numpy","formats","itemsize","[","offsets","rex","(","和","数组","x","称","修改","，","的","as","结构化","段","3"],"title":"结构化数组常用操作","title_tokens":["数组","结构","结构化","常用","操作"]},{"location":"numpy笔记/6.12.结构化数组.html#_2","text":"可以通过 a list of tuple 的形式创建结构化数组。 \"\"\" # the tupe is (fieldname, datatype, Shape) # fieldname、Shape可以省略 # fieldname 是字符串，如果使用 title，则为元组 # 如果fieldname省略，则用 f# 的默认名称代替 # shape 如果省略，则默认为(1,) \"\"\" np . dtype ([( 'x' , 'f4' ), ( 'y' , np . float32 ), ( 'z' , 'f4' , ( 2 , 2 ))]) \"\"\" 如果 fieldname 是空字符串 '' ，则将为字段指定格式为 f# 的默认名称， 其中 # 是字段的整数索引，从左侧开始从0开始计数： \"\"\" np . dtype ([( 'x' , 'f4' ), ( '' , 'i4' ), ( 'z' , 'i8' )]) dtype([('x', '<f4'), ('f1', '<i4'), ('z', '<i8')]) 可以通过“逗号分割的字符串”创建结构化数组。字符串要符合规范。 np . dtype ( 'i8, f4, S3' ) np . dtype ( '3int8, float32, (2, 3)float64' ) dtype([('f0', 'i1', (3,)), ('f1', '<f4'), ('f2', '<f8', (2, 3))]) 通过“字段参数组字典”创建结构化数组。 这是最灵活的规范形式，因为它允许控制字段的字节偏移和结构的项目大小。 dict有两个必需键 names 和 format ，以及四个可选键 offsets 、 itemsize 、 Aligned 和 title ： names 和 format 的值应该分别是相同长度的字段名列表和dtype规范列表。 可选的 offsets 值应该是整数字节偏移量的列表，结构中的每个字段都有一个偏移量。如果未给出 offsets ，则自动确定偏移量。 可选的 itemsize 值应该是一个整数， 描述 dtype 的总大小（以字节为单位），它必须足够大以包含所有字段。 可选的 Aligned 值可以设置为True，以使自动偏移计算使用对齐的偏移量（ 请参阅自动字节偏移量和对齐 ）。 可选的 titles 值应该是长度与 names 相同的标题列表。 np . dtype ({ 'names' : [ 'col1' , 'col2' ], 'formats' : [ 'i4' , 'f4' ]}) np . dtype ({ 'names' : [ 'col1' , 'col2' ], 'formats' : [ 'i4' , 'f4' ], 'offsets' : [ 0 , 4 ], 'itemsize' : 12 }) dtype({'names':['col1','col2'], 'formats':['<i4','<f4'], 'offsets':[0,4], 'itemsize':12}) 通过 dict of fieldname 创建结构化数组。不鼓励使用这种形式，因为Python字典在Python 3.6之前的Python版本中不保留顺序，但结构化dtype中字段的顺序有意义。 字典的关键字是字段名称，值是指定类型和偏移量的元组： np . dtype ({ 'col1' : ( 'i1' , 0 ), 'col2' : ( 'f4' , 1 )}) dtype([('col1', 'i1'), ('col2', '<f4')])","text_tokens":["f4","list","名称","应该","参数","字","如果","它","f0","允许","确定","组","字段","最","col1","f2","2","'","}","代替","长度","类型","dict","符合","大小","不","默认","通过","true","字符","float32","#","描述","未","字典","计数","因为","i1","和","中字","tuple","省略","总","每个","参阅","这","控制","段","）","标题","中","符合规范","必须","字节","可以","关键","{","空","dtype","给出","是","“","、","形式","3.6","偏移量","f8","格式","在","可选键","其中","对齐","四个","fieldname","z","开始","灵活","formats","[","元组","要","值","但","以及","数组","为","python","，","3","规范","左侧","与","]","请参阅","结构","都","这种","s3","title","y","逗号","相同","关键字","顺序","4",":","：","i4","datatype","names","字段名","is","合规","f",")","itemsize","f1","计算","。","项目","format","之前","col2","创建","整数","的","x","aligned","称","列表","12","版本","使",".","大以","of","i8","用"," ","鼓励","3int8","一个","the","<","1","字符串","保留","设置","tupe","单位","索引","\"","将","所有","np","有","0","指定",",","使用","则","分别","”","从","分割","包含","以","float64","offsets","偏移","自动","两个","(","a","（","必需","意义","可选","足够","titles","结构化","shape","键"],"title":"创建结构化数组","title_tokens":["创建","数组","结构","结构化"]},{"location":"numpy笔记/6.12.结构化数组.html#_3","text":"d = np . dtype ([( 'x' , 'i8' ), ( 'y' , 'f4' )]) d . names d . fields mappingproxy({'x': (dtype('int64'), 0), 'y': (dtype('float32'), 8)})","text_tokens":["f4",".","mappingproxy","8","i8","]"," ","{","dtype","y","'","}","=","fields","d",":","np","names","0",",","float32",")","[","int64","(","x"],"title":"操作和显示结构化数据类型","title_tokens":["显示","和","结构","数据","结构化","类型","操作","数据类型"]},{"location":"numpy笔记/6.12.结构化数组.html#_4","text":"numpy结构化数组中的用法好像类似于Python的dict of list，那为什么还要用numpy结构化数组呢？ 因为numpy的结构化数组底层是类似C语言的结构，占用一块连续的内存区域，并且numpy底层是C实现，numpy数组中的类型都是静态类型的，性能好于Python的的字典列表。 可以来做一下性能比较。 import time ### 定义计时器 def timer ( func ): def wrapper ( self , * args , ** kwargs ): start = time . process_time () something = func ( self , * args , ** kwargs ) end = time . process_time () type_str = func . __repr__ () print ( \"当前函数：\" , type_str , \" \\n \" , \"用时：\" , end - start , \"秒\" , sep = \"\" ) return something return wrapper # numpy版本长一岁 @timer def addage_numpy ( data , loop ): for i in range ( loop ): data [ 'age' ] += 1 # python循环长一岁 @timer def addage_python ( data , loop ): for j in range ( loop ): for i in range ( 4 ): data [ i ][ \"age\" ] += 1 # 创建结构化数组 names = [ 'Lin' , 'Pan' , 'Shen' , 'Zhou' ] ages = [ 28 , 33 , 34 , 29 ] grades = [ 25 , 26 , 27 , 24 ] data_np = np . zeros ( 4 , dtype = { 'names' :( 'name' , 'age' , 'grade' ), 'formats' :( 'U10' , 'i4' , 'i4' ) }) data_np [ 'name' ] = names data_np [ 'age' ] = ages data_np [ 'grade' ] = grades data_py = [] for i in range ( 4 ): person = { \"name\" : names [ i ], \"age\" : ages [ i ], \"grade\" : grades [ i ]} data_py . append ( person ) addage_numpy ( data_np , loop = 1000000 ) addage_python ( data_py , loop = 1000000 ) 当前函数：<function addage_numpy at 0x000001198F1ECC80> 用时：5.53125秒 当前函数：<function addage_python at 0x000001198F1ECD90> 用时：1.796875秒","text_tokens":["list","for","ages","用时","self","'","}","1000000","data","\\","类型","dict","于","*","5.53125","#","numpy","秒","字典","长","因为","_","？","in","zhou","c语言","比较","0x000001198f1ecd90","addage","中",">","可以","做","{","shen","dtype","函数","当前","repr","用法","是","grades","呢","34","@","range","kwargs","str","那","args","function","还要","类似","formats","[","###","数组","连续","python","，","实现","计时器","28","name","]","i","语言","结构","print","age","33","append","都","func","27","一块","c","来","4","=","性能",":","-","：","i4","names","u10","n",")","一岁","0x000001198f1ecc80","import","。","底层","静态","at","并且","创建","的","wrapper","return","timer","列表","29","区域","版本","什么","占用",".","loop","type","of","用"," ","循环","something","<","+","1","24","start","好于","25","py","sep","定义","zeros","\"","grade","np",",","26","end","def","pan","j","person","一下","内存","为什么","time","1.796875","(","好像","结构化","计时","lin","__","process"],"title":"为什么需要结构化数组","title_tokens":["什么","需要","为什么","数组","结构","结构化"]},{"location":"numpy笔记/6.12.结构化数组.html#_5","text":"记录数组和结构数组没有太大区别，它们所使用的场景也是类似的，只不过记录数组可以通过属性的方式访问数据。 创建记录数组的最简单方法是 numpy.rec.array 。 recordarr = np . rec . array ([( 1 , 2. , 'Hello' ), ( 2 , 3. , \"World\" )], dtype = [( 'foo' , 'i4' ),( 'bar' , 'f4' ), ( 'baz' , 'S10' )]) print ( type ( recordarr )) # 通过属性访问数据 recordarr . foo <class 'numpy.recarray'> array([1, 2]) numpy.rec.array 可以将各种参数转换为记录数组，包括结构化数组： arr = np . array ([( 1 , 2. , 'Hello' ), ( 2 , 3. , \"World\" )], dtype = [( 'foo' , 'i4' ), ( 'bar' , 'f4' ), ( 'baz' , 'S10' )]) recordarr = np . rec . array ( arr ) pprint . pprint ( recordarr ) rec.array([(1, 2., b'Hello'), (2, 3., b'World')], dtype=[('foo', '<i4'), ('bar', '<f4'), ('baz', 'S10')]) numpy.rec 模块提供了多个便利的函数来创建记录数组，请参阅 记录数组创建方法列表 。 注意： numpy.rec 是 numpy.core.records 的首选别名。 core.records.array(obj[, dtype, shape, …]) ：从各种各样的对象构造一个记录数组。 core.records.fromarrays(arrayList[, dtype, …]) ：从一维的list或array创建记录数组。 core.records.fromrecords(recList[, dtype, …]) ：从文本格式的list创建一个记录数组。 core.records.fromstring(datastring[, dtype, …]) ：从二进制字符串数据创建（只读）记录数组。 core.records.fromfile(fd[, dtype, shape, …]) ：从二进制文件数据创建记录数组。","text_tokens":["f4","list","recordarr","参数","构造","大","一维","fd","最","别名","2","array","'","fromstring","reclist","core","arr","rec","…","通过","字符","arraylist","#","numpy","首选","它们","模块","s10","和","fromrecords","参阅","提供","所","pprint","）",">","可以","转换","dtype","场景","函数","是","b","格式","只读","简单","方法","方式","属性","类似","文本","[","太","数组","为","不过","，","3","对象","]","也","便利","请参阅","结构","print","没有","访问","包括","来","记录","各样","=","foo","：","i4","文本格式",")","。","创建","fromarrays","的","各种","列表","fromfile","datastring",".","了","进制","type"," ","一个","world","<","class","1","records","字符串","数据","\"","多个","将","np",",","使用","注意","或","区别","各种各样","hello","从","recarray","obj","bar","(","二进制","（","文件","只不过","baz","结构化","shape"],"title":"记录数组","title_tokens":["记录","数组"]},{"location":"numpy笔记/6.12.结构化数组.html#_6","text":"一文彻底搞懂numpy的结构化数组——structured array Numpy的结构化数组 结构化数组","text_tokens":["一文","—","array","数组","的"," ","numpy","结构","彻底","结构化","structured","搞懂"],"title":"参考","title_tokens":["参考"]},{"location":"numpy笔记/6.2.索引.html","text":"import numpy as np import copy ndarrays 可以使用标准 Python x[obj] 语法对其进行索引 ，其中 x 是数组， obj 是索引。有三种可用的索引：字段访问，基本切片，高级索引。哪一个发生取决于 obj 。 在 Python 中， x[(exp1，exp2，.，EXPN)] 等同于 x[exp1，exp2，.，EXPN] 。后者只是前者的语法糖。 # 创建一个一维数组 a = np . arange ( 100 ) # 创建一个二维数组 b = copy . deepcopy ( np . reshape ( a , ( 20 , 5 ))) # 创建一个三维数组 c = copy . deepcopy ( np . arange ( 90 ) . reshape (( 10 , 3 , 3 ))) 一维数组的索引 一维数组的索引和列表相同。假设 a1 是一维数组，那么有以下5种使用索引的情况： 可以指定一个 整数 i 作为索引下标，如 a1[i] 。 可以指定一个 切片 作为索引下标，如 a1[i:j] ，等价于 a1[slice(j,j)] 。 可以指定一个 整数list 对数组进行存取，如 a1[[i1,i2,i3]] 。此时会将列表中的每个整数作为下标 (i1/i2/i3) ，使用列表作为下标得到的数组为 np.array([a1[i1],a1[i2],a1[i3]]) ，它不和原始数组共享内存。 可以指定一个 整数数组 作为数组下标，如 a1[a2] 此时会得到一个形状和下标数组 a2 相同的新数组。新数组的每个元素都是下标数组中对应位置的值作为下标从原始数组中获得的值。新数组不和原始数组共享数据。 可以指定一个 布尔数组 作为数组下标，如a1[b]。此时将获得数组a1中与数组b中的True对应的元素。新数组不和原始数组共享数据。 # 指定一个整数 a [ 1 ] # OWNDATA : True ## 等价于 a [( 1 )] # OWNDATA : True # 指定切片 a [ 0 : 20 : 2 ] # 返回视图 a [ slice ( 0 , 20 , 2 )] # 返回视图 # 指定一个整数列表 a [[ 1 , 2 , 3 , 4 ]] # OWNDATA : True # 指定一个整数数组 ## index是一维数组 index = np . array ([ 0 , 1 , 2 , 3 , 4 ]) a [ index ] # OWNDATA : True ## index是二维数组 index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) a [ index ] # OWNDATA : True # 指定一个布尔数组 ## 布尔数组的ndim需要和原数组相同 bool_a = a > 50 bool_a = list ( bool_a ) 多维数组的索引 多维数组使用 元组 作为数组的下标，如 a[1,2] ，当然你也可以添加圆括号为 a[(1,2)] 。实际上，一维数组也是如此，只是一维数组只有第 0 轴。 下标元组 中每个元素和数组的每个轴对应。下标元组的第 0 个元素对应数组第 0 轴，第 1 个元素对应数组第 1 轴，第 2 个元素对应数组第 2 轴··· 多维数组的下标必须是一个长度和数组的维度ndim相等的元组。 如果下标元组的长度大于数组的维度ndim，则IndexError 如果下标元组的长度小于数组的维度ndim，则自动在元组的后面补 : ，使得下标元组的长度等于数组维度ndim。 如果下标对象不是元组，则Numpy会首先将其转换为元组。 有以下7种使用索引的情况： 整数元组 切片 整数元组搭配切片 整数list 整数数组 布尔数组 整数数组、切片、整数元组混搭 # 指定一个整数元组 b [( 1 , 2 )] # OWNDATA : Trues ## 等价于 b [ 1 , 2 ] # OWNDATA : Trues ## 元组的维度超过多维数组的维度:IndexError ''' b[(1,2,3)] ''' ## 元组的维度超少于维数组的维度 b [ 1 ] # 返回视图 等价于 b[1,:] # 切片 b [ 0 , 0 : 5 : 2 ] # 返回视图 b [ 0 , 0 :: 2 ] # 返回视图 b [ 0 , slice ( 0 , None , 2 )] # 返回视图 ## SyntaxError b[0,slice(0,,2)] b [ 0 : 10 : 2 , 0 : 5 : 2 ] # 返回视图 ## 第二列 b [:, 1 ] # 返回视图 b [ ... , 1 ] # 返回视图 ## IndexError: an index can only have a single ellipsis ('...') ''' b[...,...] IndexError ''' b [ ... ,:] # 返回视图 b [:,:] # 返回视图 # 整数数组 ## arrays used as indices must be of integer (or boolean) type index = np . array ([ 0 , 1 , 2 , 3 ]) b [ index ] # OWNDATA : True index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) b [ index ] # OWNDATA : True ## 如果下标整数数组的维度不一致，会进行广播 rows = np . array ([[ 0 , 1 , 2 ]]) columns = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 4 ]]) index = ( rows , columns ) b [ index ] array([[ 0, 6, 12], [ 3, 9, 14]]) 多维数组的下标是布尔数组或者下标元组中包含了布尔数组，则相当于将布尔数组通过 np.nonzero() 将布尔数组转换成一个整数数组的元组，然后使用整数数组进行下标运行。 np.nonzero(a) 返回数组 a 中，值非零的元素的 下标 。它返回值是一个长度为 a.ndim 的元组，元组的每个元素都是一个一维的整数数组，其值为非零元素的下标在对应轴上的值。如：第 0 个元素为a中的非零值元素在0轴的下标、第 1 个元素为a中的非零值元素在1轴的下标... np . nonzero ( bool_a ) (array([51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], dtype=int64),) 进阶说明 使用切片返回视图的原因： 当下标使用切片时，所取得的数据在数据存储区域中是等间隔分布的。因为只需要修改数组的ndim/shape/strides等属性以及指向数据存储区域的data指针就能够实现整数和切片下标的索引。所以新数组和原始数组能够共享数据存储区域。 当使用整数数组（整数元组，整数列表页转换成整数数组），布尔数组时，不能保证所取得的数据在数据存储区中是等间隔的，因此无法和原始数组共享数据，只能对数据进行复制。 通过整数元组获取的数组元素的类型为数组的dtype类型 。如果你想获取标准python类型，可以使用数组的item()方法。 索引的维度变换 索引的下标元组中： 如果下标元组都是切片，则索引结果的数组与原始数组的维度相同（轴的数量相等） 每多一个整数下标，则索引结果的数组就少一个维度（少一个轴） 如果所有的下标都是整数，则索引结果的维度为 0 如果下标元组中存在数组，则还需要考虑该下标数组广播后的维度 多维数组的下标必须是一个长度和数组的维度 ndim 相等的元组。但是如果下标中包含None，则可以突破这一限制。每多一个None，则索引结构维度升 1 。 当数组的下标元组的长度小于等于数组的维度ndim时，元组中出现的None等价于切片: 当数组的下标元组的长度大于数组的维度ndim时，元组中哪里出现None，索引结果就在哪里创建一个新轴，该轴长度为 1。 b [ 1 , 2 ] b [ 1 , 2 , None ] b [ 1 , 2 , np . newaxis ] array([7])","text_tokens":["exp1","字","超","99","strides","10","'","该","长度","不","integer","copy","零","i1","7","...","这一","存储","修改","每个","段","64","使得","不是","indices","转换","对应","同于","是","当","be","后者","61","100","ndarrays","只能","python","能够","实现","复制","原","3","90","trues","相当","结构","访问","等","相同","取决","进阶","语法","85","70",")","相等","。","当然","基本","存取","一个三维","newaxis","56","其","的","因此","得到","列表","哪","以下","二列","了","58","页","保证"," ","62","item","i3","将","93","换成","考虑","使用","则","77","5","75","分布","int64","a","元素","86","它","标","说明","少于","实际","相当于","2","假设","还","98","66","获取","boolean","添加","92","三种","广播","因为","·","_","和","位置","中","必须","exp2","切片","如此","取决于","共享","共享内存","b","种","an","出现","其中","少","只","首先","reshape","非零值","##","数组","，","54","可用","前者","ndim","81","与","]","index","95","都","c","50","only","轴","=","其值","限制","or","53","新轴","import","nonzero","视图","如","整数","第二","就","区域","of","1","实际上","那么","87","区中","83","none","运行","间隔","小于","高级","有","包含","columns","j","obj","自动","68","(","每多","shape","owndata","如果","原因","原始","三维","等同","时","array","升","data","类型","超过","突破","slice","于","通过","等同于","多维","转换成","expn","60","55","当下","所","88","搭","可以","a1","dtype","数量","会","can","二维","你","方法","rows","轴上","属性","然后","91","[","72","值","为","进行","bool","对","deepcopy","59","63","只有","4","must",":","9","情况","arange","形状","指针","97","后面","创建","x","指向","12","71","94",".","73","但是","取得","一个","第","当于","第二列","索引","所有","84","0","返回值","79","指定","只是","一致","6","74","想","内存","搭配","需要","布尔","（","圆括号","糖","发生","list","结果","一维","不能","后","下标","存在","标准","个","括号","等价","ellipsis","true","#","numpy","维","值非","i2","混","used","）",">","无法","arrays","96","67","、","/","在","一个二维","52","20","大于","此时","元组","以及","single","哪里","中是","have","57","indexerror","维度","对象","i","也","a2","返回","补","51","获得","76","69","标的","：","89","新","所以","65","78","type","syntaxerror","82","14","非","80","数据","np",",","作为","从","或者","变换","下","等于","as"],"title":"6.2.索引","title_tokens":["6.2",".","索引"]},{"location":"numpy笔记/6.2.索引.html#_1","text":"一维数组的索引和列表相同。假设 a1 是一维数组，那么有以下5种使用索引的情况： 可以指定一个 整数 i 作为索引下标，如 a1[i] 。 可以指定一个 切片 作为索引下标，如 a1[i:j] ，等价于 a1[slice(j,j)] 。 可以指定一个 整数list 对数组进行存取，如 a1[[i1,i2,i3]] 。此时会将列表中的每个整数作为下标 (i1/i2/i3) ，使用列表作为下标得到的数组为 np.array([a1[i1],a1[i2],a1[i3]]) ，它不和原始数组共享内存。 可以指定一个 整数数组 作为数组下标，如 a1[a2] 此时会得到一个形状和下标数组 a2 相同的新数组。新数组的每个元素都是下标数组中对应位置的值作为下标从原始数组中获得的值。新数组不和原始数组共享数据。 可以指定一个 布尔数组 作为数组下标，如a1[b]。此时将获得数组a1中与数组b中的True对应的元素。新数组不和原始数组共享数据。 # 指定一个整数 a [ 1 ] # OWNDATA : True ## 等价于 a [( 1 )] # OWNDATA : True # 指定切片 a [ 0 : 20 : 2 ] # 返回视图 a [ slice ( 0 , 20 , 2 )] # 返回视图 # 指定一个整数列表 a [[ 1 , 2 , 3 , 4 ]] # OWNDATA : True # 指定一个整数数组 ## index是一维数组 index = np . array ([ 0 , 1 , 2 , 3 , 4 ]) a [ index ] # OWNDATA : True ## index是二维数组 index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) a [ index ] # OWNDATA : True # 指定一个布尔数组 ## 布尔数组的ndim需要和原数组相同 bool_a = a > 50 bool_a = list ( bool_a )","text_tokens":["list","owndata","它","一维","原始","下标","2","array","假设","slice","不","等价","于","true","#","i1","和","_","i2","每个","位置","中",">","a1","可以","切片","对应","共享","共享内存","是","b","会","种","/","二维","20","[","此时","值","##","数组","为","，","原","3","进行","bool","ndim","与","]","i","对","a2","index","返回","都","获得","相同","50","4","=",":","：","情况","新",")","形状","。","视图","存取","如","整数","的","得到","列表","以下","."," ","一个","1","那么","i3","索引","数据","将","np","有","0","指定",",","使用","5","作为","从","j","内存","需要","布尔","(","a","元素"],"title":"一维数组的索引","title_tokens":["一维","数组","的","索引"]},{"location":"numpy笔记/6.2.索引.html#_2","text":"多维数组使用 元组 作为数组的下标，如 a[1,2] ，当然你也可以添加圆括号为 a[(1,2)] 。实际上，一维数组也是如此，只是一维数组只有第 0 轴。 下标元组 中每个元素和数组的每个轴对应。下标元组的第 0 个元素对应数组第 0 轴，第 1 个元素对应数组第 1 轴，第 2 个元素对应数组第 2 轴··· 多维数组的下标必须是一个长度和数组的维度ndim相等的元组。 如果下标元组的长度大于数组的维度ndim，则IndexError 如果下标元组的长度小于数组的维度ndim，则自动在元组的后面补 : ，使得下标元组的长度等于数组维度ndim。 如果下标对象不是元组，则Numpy会首先将其转换为元组。 有以下7种使用索引的情况： 整数元组 切片 整数元组搭配切片 整数list 整数数组 布尔数组 整数数组、切片、整数元组混搭 # 指定一个整数元组 b [( 1 , 2 )] # OWNDATA : Trues ## 等价于 b [ 1 , 2 ] # OWNDATA : Trues ## 元组的维度超过多维数组的维度:IndexError ''' b[(1,2,3)] ''' ## 元组的维度超少于维数组的维度 b [ 1 ] # 返回视图 等价于 b[1,:] # 切片 b [ 0 , 0 : 5 : 2 ] # 返回视图 b [ 0 , 0 :: 2 ] # 返回视图 b [ 0 , slice ( 0 , None , 2 )] # 返回视图 ## SyntaxError b[0,slice(0,,2)] b [ 0 : 10 : 2 , 0 : 5 : 2 ] # 返回视图 ## 第二列 b [:, 1 ] # 返回视图 b [ ... , 1 ] # 返回视图 ## IndexError: an index can only have a single ellipsis ('...') ''' b[...,...] IndexError ''' b [ ... ,:] # 返回视图 b [:,:] # 返回视图 # 整数数组 ## arrays used as indices must be of integer (or boolean) type index = np . array ([ 0 , 1 , 2 , 3 ]) b [ index ] # OWNDATA : True index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) b [ index ] # OWNDATA : True ## 如果下标整数数组的维度不一致，会进行广播 rows = np . array ([[ 0 , 1 , 2 ]]) columns = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 4 ]]) index = ( rows , columns ) b [ index ] array([[ 0, 6, 12], [ 3, 9, 14]]) 多维数组的下标是布尔数组或者下标元组中包含了布尔数组，则相当于将布尔数组通过 np.nonzero() 将布尔数组转换成一个整数数组的元组，然后使用整数数组进行下标运行。 np.nonzero(a) 返回数组 a 中，值非零的元素的 下标 。它返回值是一个长度为 a.ndim 的元组，元组的每个元素都是一个一维的整数数组，其值为非零元素的下标在对应轴上的值。如：第 0 个元素为a中的非零值元素在0轴的下标、第 1 个元素为a中的非零值元素在1轴的下标... np . nonzero ( bool_a ) (array([51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], dtype=int64),)","text_tokens":["list","86","owndata","它","如果","超","一维","99","10","下标","少于","实际","相当于","2","'","array","个","长度","超过","98","66","括号","slice","不","等价","于","ellipsis","boolean","true","通过","添加","#","numpy","维","integer","值非","多维","92","零","广播","·","...","7","和","转换成","_","每个","60","混","used","55","64","88","使得","中","不是","必须","搭","indices","可以","转换","arrays","切片","如此","对应","96","dtype","是","67","、","b","会","种","can","an","在","你","be","52","rows","轴上","然后","首先","大于","91","[","元组","非零值","61","72","值","##","single","数组","为","，","54","have","3","57","indexerror","进行","trues","90","维度","bool","相当","ndim","对象","81","]","也","index","返回","59","补","51","95","都","63","只有","only","轴","4","=","must","其值","69","76",":","85","9","or","：","情况","70","89",")","相等","53","。","65","当然","nonzero","视图","97","如","后面","整数","56","的","其","第二","12","以下","71","二列","94",".","了","78","58","type","of","73"," ","syntaxerror","一个","82","第","1","实际上","14","当于","62","87","第二列","非","83","none","运行","80","索引","小于","将","93","np","有","0","换成","返回值","79","84","指定",",","使用","则","77","5","75","包含","作为","columns","只是","或者","int64","一致","6","74","自动","搭配","布尔","68","(","等于","a","圆括号","as","元素"],"title":"多维数组的索引","title_tokens":["索引","多维","数组","的"]},{"location":"numpy笔记/6.2.索引.html#_3","text":"使用切片返回视图的原因： 当下标使用切片时，所取得的数据在数据存储区域中是等间隔分布的。因为只需要修改数组的ndim/shape/strides等属性以及指向数据存储区域的data指针就能够实现整数和切片下标的索引。所以新数组和原始数组能够共享数据存储区域。 当使用整数数组（整数元组，整数列表页转换成整数数组），布尔数组时，不能保证所取得的数据在数据存储区中是等间隔的，因此无法和原始数组共享数据，只能对数据进行复制。 通过整数元组获取的数组元素的类型为数组的dtype类型 。如果你想获取标准python类型，可以使用数组的item()方法。","text_tokens":["如果","原因","原始","strides","不能","标","时","标准","data","类型","获取","通过","因为","转换成","和","存储","修改","当下","所","）","无法","可以","转换","切片","共享","dtype","是","当","/","在","你","方法","只","属性","元组","以及","只能","为","数组","复制","，","中是","能够","实现","python","进行","ndim","对","返回","等","标的","：","新",")","所以","指针","。","视图","整数","的","因此","指向","列表","就","区域","页","保证"," ","取得","item","区中","间隔","索引","数据","换成","使用","分布","下","想","需要","布尔","(","（","元素","shape"],"title":"进阶说明","title_tokens":["说明","进阶"]},{"location":"numpy笔记/6.2.索引.html#_4","text":"索引的下标元组中： 如果下标元组都是切片，则索引结果的数组与原始数组的维度相同（轴的数量相等） 每多一个整数下标，则索引结果的数组就少一个维度（少一个轴） 如果所有的下标都是整数，则索引结果的维度为 0 如果下标元组中存在数组，则还需要考虑该下标数组广播后的维度 多维数组的下标必须是一个长度和数组的维度 ndim 相等的元组。但是如果下标中包含None，则可以突破这一限制。每多一个None，则索引结构维度升 1 。 当数组的下标元组的长度小于等于数组的维度ndim时，元组中出现的None等价于切片: 当数组的下标元组的长度大于数组的维度ndim时，元组中哪里出现None，索引结果就在哪里创建一个新轴，该轴长度为 1。 b [ 1 , 2 ] b [ 1 , 2 , None ] b [ 1 , 2 , np . newaxis ] array([7])","text_tokens":["如果","结果","原始","后","下标","存在","时","2","array","该","升","还","长度","突破","等价","于","多维","广播","和","这一","7","）","中","必须","可以","切片","是","当","数量","b","出现","在","少","大于","[","元组","哪里","数组","为","，","维度","ndim","与","]","结构","都","相同","轴",":","限制","：",")","相等","新轴","。","newaxis","整数","创建","的","就","."," ","但是","一个","1","none","索引","小于","所有","np","0","考虑",",","则","包含","需要","等于","(","（","每多"],"title":"索引的维度变换","title_tokens":["变换","维度","索引","的"]},{"location":"numpy笔记/6.3.内存布局.html","text":"import numpy as np import pprint import copy ndarray对象 NumPy提供了一个N维数组对象ndarray，它描述了同一类型的元素的集合。可以使用N个整数对元素进行索引。 ndarray中所有元素都是 同质的 ：每个元素占用相同大小的内存块，并且所有内存块的解释方式完全相同。数组中各元素的解释方式由一个的 data-type 对象（dtype）指定。 图中显示了用于描述数组中数据的三个基本对象之间的关系： ndarray本身 描述数组中单个固定大小元素的内存布局的data-type对象 访问数组的单个元素时返回的数组标量（Python对象） ndarray类的实例由一个 连续的 一维计算机内存块（由数组或其他对象拥有）和一个索引方案组合而成，该索引方案将N个整数分别映射到内存块中N个元素的位置。索引可以变化的范围被数组的shape限制。 ndarray看上去似乎可以是多维的，但在内存中，ndarray是一维储存的。有许多方案将N维数组以一维数组的形式储存在内存中。其中numpy有两种储存方式： 元素按行顺序储存（C语言风格） 或者按列顺序储存（Fortran语言风格） 因此，如果要对一个ndarray以行为单位进行操作，最好以C-type的方式创建ndarray；如果要对一个ndarray以列为单位进行操作，则用Fortran方式。 内存布局 A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) pprint . pprint ( A ) array([[0, 1, 2], [3, 4, 5], [6, 7, 8]], dtype=int16) 属性（与数组内存布局有关） A的属性值 描述 A.dtype dtype('int16') 元素数据类型。A的每个元素是16bit大小的int型数据。 A.ndim 2 轴（维度）的个数。A有两个轴：0轴、1轴。 A.shape (3, 3) 各个轴的大小。0轴有3个元素，1轴有3个元素。 A.size 9 数组的大小，有多少个元素。 A.data <memory at 0x000001B17A238A68> 指向数组的数据的存储区。 A.itemsize 2 一个元素的长度，以字节为单位。16bit等于2字节。 A.nbytes 18 数组元素占据的总字节数。 A.base None 如果内存来自其他对象，则以此为基础对象。 A.flags 有关数组内存布局的信息。 A.strides (6, 2) 一个整数元组，每个元素保存着每个轴上相邻两个元素的地址差。 即当某个轴的下标增加1 时，数据存储区中的指针增加的字节数。 可以从不同的角度(即布局)观察该array： shape [ 1 ] ( = 3 ) ┌───────────┐ ┌ ┌───┬───┬───┐ ┐ │ │ 0 │ 1 │ 2 │ │ │ ├───┼───┼───┤ │ shape [ 0 ] │ │ 3 │ 4 │ 5 │ │ len ( Z ) ( = 3 ) │ ├───┼───┼───┤ │ ( = 3 ) │ │ 6 │ 7 │ 8 │ │ └ └───┴───┴───┘ ┘ 展开的item layout ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ └───┴───┴───┴───┴───┴───┴───┴───┴───┘ └───────────────────────────────────┘ A . size ( = 9 ) 内存布局(C顺序) strides [ 1 ] ( = 2 ) ┌─────────────────────┐ ┌ ┌──────────┬──────────┐ ┐ │ p + 00 : │ 00000000 │ 00000000 │ │ │ ├──────────┼──────────┤ │ │ p + 02 : │ 00000000 │ 00000001 │ │ strides [ 0 ] │ ├──────────┼──────────┤ │ ( = 2 x3 ) │ p + 04 │ 00000000 │ 00000010 │ │ │ ├──────────┼──────────┤ ┘ │ p + 06 │ 00000000 │ 00000011 │ │ ├──────────┼──────────┤ A . nbytes │ p + 08 : │ 00000000 │ 00000100 │ ( = 3 x3x2 ) │ ├──────────┼──────────┤ │ p + 10 : │ 00000000 │ 00000101 │ │ ├──────────┼──────────┤ │ p + 12 : │ 00000000 │ 00000110 │ │ ├──────────┼──────────┤ │ p + 14 : │ 00000000 │ 00000111 │ │ ├──────────┼──────────┤ │ p + 16 : │ 00000000 │ 00001000 │ └ └──────────┴──────────┘ └─────────────────────┘ A . itemsize A . dtype . itemsize ( = 2 ) 如果我们现在取一A的切片，结果是A的基本数组的一个视图： V = A[::2,::2] 这样的视图是由shape，dtype 和 strides 指定的，因为仅凭dtype和shape不能推断出strides: 如果我们现在取一A的切片，结果是A的基本数组的一个视图： V = A[::2,::2] 这样的视图是由shape，dtype 和 strides 指定的，因为仅凭dtype和shape不能推断出strides: Item layout shape [ 1 ] ( = 2 ) ┌───────────┐ ┌ ┌───┬───┬───┐ ┐ │ │ 0 │ │ 2 │ │ ┌───┬───┐ │ ├───┼───┼───┤ │ | 0 │ 2 │ shape [ 0 ] │ │ │ │ │ │ len ( A ) → ├───┼───┤ ( = 2 ) │ ├───┼───┼───┤ │ ( = 2 ) | 6 │ 8 │ │ │ 6 │ │ 8 │ │ └───┴───┘ └ └───┴───┴───┘ ┘ 展开的item layout ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐ ┌───┬───┬───┬───┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ → │ 0 │ 2 │ 6 │ 8 │ └───┴───┴───┴───┴───┴───┴───┴───┴───┘ └───┴───┴───┴───┘ └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘ └───┬───┘ └───┬───┘ └───────────┬───────────┘ A.size (=4) 内存布局(C顺序，大端序) ┌ ┌──────────┬──────────┐ ┐ ┐ ┌─┤ p + 00 : │ 00000000 │ 00000000 │ │ │ │ └ ├──────────┼──────────┤ │ strides [ 1 ] │ ┌─┤ p + 02 : │ │ │ │ ( = 4 ) │ │ │ ┌ ├──────────┼──────────┤ ┘ │ │ └─┤ p + 04 │ 00000000 │ 00000010 │ │ │ └ ├──────────┼──────────┤ │ strides [ 0 ] │ p + 06 : │ │ │ │ ( = 12 ) │ ├──────────┼──────────┤ │ A . nbytes ─┤ p + 08 : │ │ │ │ ( = 8 ) │ ├──────────┼──────────┤ │ │ p + 10 : │ │ │ │ │ ┌ ├──────────┼──────────┤ ┘ │ ┌─┤ p + 12 : │ 00000000 │ 00000110 │ │ │ └ ├──────────┼──────────┤ └─┤ p + 14 : │ │ │ │ ┌ ├──────────┼──────────┤ └─┤ p + 16 : │ 00000000 │ 00001000 │ └ └──────────┴──────────┘ └─────────────────────┘ A . itemsize A . dtype . itemsize ( = 2 ) 可以直接修改 ndarray 对象的 strides 属性，改变 ndarray 的内存布局，但此时会修改原数组。 A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) A . strides = ( 2 , 4 ) pprint . pprint ( A ) array([[0, 2, 4], [1, 3, 5], [2, 4, 6]], dtype=int16) 视图和副本 视图和副本是优化数值计算的重要概念。 在numpy中，可以用切片和 花式索引 （整数数组索引）来索引数据。切片将始终返回视图，而整数数组索引将返回一个副本。这种差异很重要，因为在切片情况下，修改视图会修改原数组，而在整数数组索引情况下则不是这样： Z = np . zeros ( 9 ) Z_view = Z [: 3 ] Z_view [ ... ] = 1 print ( Z ) [1. 1. 1. 0. 0. 0. 0. 0. 0.] Z = np . zeros ( 9 ) Z_copy = Z [[ 0 , 1 , 2 ]] Z_copy [ ... ] = 1 print ( Z ) [0. 0. 0. 0. 0. 0. 0. 0. 0.] 因此，如果你需要反复用到某个花式索引，最好保留它的副本（特别是如果计算它很复杂）。如果您不确定索引的结果是视图还是副本，则可以检查base的结果。如果是None，那么结果就是副本： Z = np . random . uniform ( 0 , 1 ,( 5 , 5 )) Z1 = Z [: 3 ,:] Z2 = Z [[ 0 , 1 , 2 ], :] print ( np . allclose ( Z1 , Z2 )) True print ( Z1 . base is Z ) True print ( Z2 . base is Z ) False print ( Z2 . base is None ) True 请注意，一些numpy函数在可能的情况下返回视图(例如， ravel )，而另一些函数总是返回副本(例如， flatten ): Z = np . zeros (( 5 , 5 )) print ( Z . ravel () . base is Z ) True print ( Z [:: 2 ,:: 2 ] . ravel () . base is Z ) False print ( Z . flatten () . base is Z ) False 可以通过 ndarray.view() 方法，从同一块内存区（储存着numpy数组的内存区）创建不同的dtype数组。 即用不同的数值类型查看同一段内存中的二进制数据。 它们使用的是同一块内存。 实际上， ndarray.view() 方法是创建了一个视图。 A = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ],[ 6 , 7 , 8 ]]) A_view = A . view ( np . int32 ) # A_view 是视图 A_view . flags C_CONTIGUOUS : True F_CONTIGUOUS : False OWNDATA : False WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False 如果我们直接修改原始数组的 dtype ，会达到同样的效果， 但此时直接修改原始数组。 A . dtype = np . float32 Caution 通常应避免改变由切片、transposes、fortran排序等定义的数组的 dtype 的大小，如下： A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) A_view = A . view ( np . int32 ) ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-7b8b7375e3ff> in <module> 1 A = copy.deepcopy(np.arange(9, dtype=np.int16).reshape(3,3)) ----> 2 A_view = A.view(np.int32) ValueError: When changing to a larger dtype, its size must be a divisor of the total size in bytes of the last axis of the array.","text_tokens":["还是","strides","节数","10","'","该","长度","大小","不","各个","00000001","└","float32","uniform","copy","花式","请","行为","...","7","信息","存储","总","每个","修改","in","不是","列为","占据","是","┬","某个","be","方式","这样","查看","python","原","3","两种","divisor","轴有","z2","即用","访问","等","相同","组合而成","来","allclose","集合","----","三个","is","n",")","同一","计算","16bit","块","。","to","基本","的","因此","推断出","00000110","int16","了"," ","caution","<","layout","+","映射","item","以此","单个","实例","将","使用","则","或","5","分别","按列","即","特别","二进制","a","when","┘","被","at","元素","按行","总是","很","它","traceback","一段","差","last","实际","由","2","同","大端","its","updateifcopy","changing","改变","因为","_","和","许多","位置","larger","提供","c语言","8","中","切片","┐","函数","增加","；","v","ravel","而","有关","false","同质","其中","不同","z","reshape","00000111","区","数组","方案","连续","00","ndarray","，","00000000","ndim","与","]","型","print","都","反复","c","顺序","轴","=","限制","我们","import","itemsize","int32","视图","并且","您","整数","aligned","达到","18","of","用","大端序","the","┤","1","实际上","那么","区中","风格","none","范围","├","x3x2","有","transposes","注意","相邻","00000100","变化","┌","两个","(","用到","shape","owndata","len","到","如果","→","原始","确定","布局","时","array","data","类型","储存","差异","通过","一些","描述","多维","数据类型","---------------------------------------------------------------------------","各","看上去","ipython","地址","call","数值","fortran","可以","dtype","input","推断","始终","会","下则","你","06","方法","axis","类","轴上","属性","展开","│","[","┴","|","仅凭","要","值","nbytes","为","似乎","例如","进行","固定","random","上去","view","对","deepcopy","标量","total","操作","4","x3","个数","must","基础",":","9","之间","情况","算机","7b8b7375e3ff","f","arange","指针","writebackifcopy","本身","most","最好","重要","显示","创建","base","来自","指向","12","─",".","占用","00000011","通常","一个","┼","看上","其他","索引","zeros","所有","0","指定","现在","6","size","p","应","内存","需要","（","08","int","结果","一维","00000010","不能","字节数","04","完全","下标","关系","00001000","个","保存","writeable","true","维","numpy","#","它们","角度","完全相同","解释","pprint","）","bytes",">","即当","字节","计算机","用于","module","、","形式","在","拥有","此时","元组","flatten","组合","recent","但","概念","02","同样","16","flags","维度","对象","语言","返回","观察","排序","优化","这种","另","-","复杂","：","效果","检查","直接","图中","就是","z1","进制","type","如下","副本","00000101","contiguous","14","多少","保留","单位","定义","数据","避免","np","0x000001b17a238a68",",","从","以","或者","可能","下","memory","取一","块内存","等于","valueerror","as","着"],"title":"6.3.内存布局","title_tokens":["6.3","布局",".","内存"]},{"location":"numpy笔记/6.3.内存布局.html#ndarray","text":"NumPy提供了一个N维数组对象ndarray，它描述了同一类型的元素的集合。可以使用N个整数对元素进行索引。 ndarray中所有元素都是 同质的 ：每个元素占用相同大小的内存块，并且所有内存块的解释方式完全相同。数组中各元素的解释方式由一个的 data-type 对象（dtype）指定。 图中显示了用于描述数组中数据的三个基本对象之间的关系： ndarray本身 描述数组中单个固定大小元素的内存布局的data-type对象 访问数组的单个元素时返回的数组标量（Python对象） ndarray类的实例由一个 连续的 一维计算机内存块（由数组或其他对象拥有）和一个索引方案组合而成，该索引方案将N个整数分别映射到内存块中N个元素的位置。索引可以变化的范围被数组的shape限制。 ndarray看上去似乎可以是多维的，但在内存中，ndarray是一维储存的。有许多方案将N维数组以一维数组的形式储存在内存中。其中numpy有两种储存方式： 元素按行顺序储存（C语言风格） 或者按列顺序储存（Fortran语言风格） 因此，如果要对一个ndarray以行为单位进行操作，最好以C-type的方式创建ndarray；如果要对一个ndarray以列为单位进行操作，则用Fortran方式。","text_tokens":["它","到","如果","一维","完全","关系","布局","被","时","由","该","data","个","类型","储存","大小","维","numpy","描述","多维","完全相同","行为","各","和","许多","位置","每个","提供","看上去","解释","）","c语言","中","列为","fortran","可以","用于","计算机","dtype","是","；","形式","在","同质","其中","拥有","类","方式","组合","要","但","数组","方案","连续","python","ndarray","，","似乎","进行","固定","上去","两种","对象","对","标量","语言","返回","访问","都","操作","相同","组合而成","c","集合","顺序","三个","-","限制","：","之间","算机","n","同一","图中","计算","块","本身","。","最好","基本","并且","显示","创建","整数","的","因此","了","占用","type","用"," ","一个","映射","看上","风格","其他","单位","范围","单个","索引","数据","实例","将","所有","有","指定","使用","则","或","分别","按列","以","或者","变化","内存","（","元素","按行","shape"],"title":"ndarray对象","title_tokens":["ndarray","对象"]},{"location":"numpy笔记/6.3.内存布局.html#_1","text":"A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) pprint . pprint ( A ) array([[0, 1, 2], [3, 4, 5], [6, 7, 8]], dtype=int16) 属性（与数组内存布局有关） A的属性值 描述 A.dtype dtype('int16') 元素数据类型。A的每个元素是16bit大小的int型数据。 A.ndim 2 轴（维度）的个数。A有两个轴：0轴、1轴。 A.shape (3, 3) 各个轴的大小。0轴有3个元素，1轴有3个元素。 A.size 9 数组的大小，有多少个元素。 A.data <memory at 0x000001B17A238A68> 指向数组的数据的存储区。 A.itemsize 2 一个元素的长度，以字节为单位。16bit等于2字节。 A.nbytes 18 数组元素占据的总字节数。 A.base None 如果内存来自其他对象，则以此为基础对象。 A.flags 有关数组内存布局的信息。 A.strides (6, 2) 一个整数元组，每个元素保存着每个轴上相邻两个元素的地址差。 即当某个轴的下标增加1 时，数据存储区中的指针增加的字节数。 可以从不同的角度(即布局)观察该array： shape [ 1 ] ( = 3 ) ┌───────────┐ ┌ ┌───┬───┬───┐ ┐ │ │ 0 │ 1 │ 2 │ │ │ ├───┼───┼───┤ │ shape [ 0 ] │ │ 3 │ 4 │ 5 │ │ len ( Z ) ( = 3 ) │ ├───┼───┼───┤ │ ( = 3 ) │ │ 6 │ 7 │ 8 │ │ └ └───┴───┴───┘ ┘ 展开的item layout ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ └───┴───┴───┴───┴───┴───┴───┴───┴───┘ └───────────────────────────────────┘ A . size ( = 9 ) 内存布局(C顺序) strides [ 1 ] ( = 2 ) ┌─────────────────────┐ ┌ ┌──────────┬──────────┐ ┐ │ p + 00 : │ 00000000 │ 00000000 │ │ │ ├──────────┼──────────┤ │ │ p + 02 : │ 00000000 │ 00000001 │ │ strides [ 0 ] │ ├──────────┼──────────┤ │ ( = 2 x3 ) │ p + 04 │ 00000000 │ 00000010 │ │ │ ├──────────┼──────────┤ ┘ │ p + 06 │ 00000000 │ 00000011 │ │ ├──────────┼──────────┤ A . nbytes │ p + 08 : │ 00000000 │ 00000100 │ ( = 3 x3x2 ) │ ├──────────┼──────────┤ │ p + 10 : │ 00000000 │ 00000101 │ │ ├──────────┼──────────┤ │ p + 12 : │ 00000000 │ 00000110 │ │ ├──────────┼──────────┤ │ p + 14 : │ 00000000 │ 00000111 │ │ ├──────────┼──────────┤ │ p + 16 : │ 00000000 │ 00001000 │ └ └──────────┴──────────┘ └─────────────────────┘ A . itemsize A . dtype . itemsize ( = 2 ) 如果我们现在取一A的切片，结果是A的基本数组的一个视图： V = A[::2,::2] 这样的视图是由shape，dtype 和 strides 指定的，因为仅凭dtype和shape不能推断出strides: 如果我们现在取一A的切片，结果是A的基本数组的一个视图： V = A[::2,::2] 这样的视图是由shape，dtype 和 strides 指定的，因为仅凭dtype和shape不能推断出strides: Item layout shape [ 1 ] ( = 2 ) ┌───────────┐ ┌ ┌───┬───┬───┐ ┐ │ │ 0 │ │ 2 │ │ ┌───┬───┐ │ ├───┼───┼───┤ │ | 0 │ 2 │ shape [ 0 ] │ │ │ │ │ │ len ( A ) → ├───┼───┤ ( = 2 ) │ ├───┼───┼───┤ │ ( = 2 ) | 6 │ 8 │ │ │ 6 │ │ 8 │ │ └───┴───┘ └ └───┴───┴───┘ ┘ 展开的item layout ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐ ┌───┬───┬───┬───┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ → │ 0 │ 2 │ 6 │ 8 │ └───┴───┴───┴───┴───┴───┴───┴───┴───┘ └───┴───┴───┴───┘ └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘ └───┬───┘ └───┬───┘ └───────────┬───────────┘ A.size (=4) 内存布局(C顺序，大端序) ┌ ┌──────────┬──────────┐ ┐ ┐ ┌─┤ p + 00 : │ 00000000 │ 00000000 │ │ │ │ └ ├──────────┼──────────┤ │ strides [ 1 ] │ ┌─┤ p + 02 : │ │ │ │ ( = 4 ) │ │ │ ┌ ├──────────┼──────────┤ ┘ │ │ └─┤ p + 04 │ 00000000 │ 00000010 │ │ │ └ ├──────────┼──────────┤ │ strides [ 0 ] │ p + 06 : │ │ │ │ ( = 12 ) │ ├──────────┼──────────┤ │ A . nbytes ─┤ p + 08 : │ │ │ │ ( = 8 ) │ ├──────────┼──────────┤ │ │ p + 10 : │ │ │ │ │ ┌ ├──────────┼──────────┤ ┘ │ ┌─┤ p + 12 : │ 00000000 │ 00000110 │ │ │ └ ├──────────┼──────────┤ └─┤ p + 14 : │ │ │ │ ┌ ├──────────┼──────────┤ └─┤ p + 16 : │ 00000000 │ 00001000 │ └ └──────────┴──────────┘ └─────────────────────┘ A . itemsize A . dtype . itemsize ( = 2 ) 可以直接修改 ndarray 对象的 strides 属性，改变 ndarray 的内存布局，但此时会修改原数组。 A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) A . strides = ( 2 , 4 ) pprint . pprint ( A ) array([[0, 2, 4], [1, 3, 5], [2, 4, 6]], dtype=int16)","text_tokens":["len","如果","int","结果","→","00000010","差","strides","节数","字节数","04","10","不能","下标","布局","时","由","2","array","'","00001000","该","data","个","大端","长度","类型","大小","保存","各个","00000001","└","描述","copy","数据类型","角度","改变","因为","7","信息","和","存储","总","每个","修改","地址","pprint","）","8",">","即当","字节","可以","切片","┐","dtype","占据","是","增加","┬","、","推断","v","会","有关","某个","06","不同","轴上","z","这样","属性","展开","reshape","│","[","此时","┴","元组","00000111","仅凭","|","值","nbytes","但","区","数组","为","00000000","00","，","02","ndarray","原","3","16","flags","维度","ndim","对象","与","]","轴有","型","deepcopy","观察","元素","c","轴","顺序","4","=","个数","x3","基础",":","9","：","我们","直接","arange",")","itemsize","指针","16bit","。","视图","基本","整数","base","的","来自","指向","推断出","12","18","00000110","int16",".","─","00000011"," ","大端序","一个","<","┤","layout","+","1","00000101","14","多少","┼","item","区中","其他","以此","单位","none","├","x3x2","数据","np","有","0","0x000001b17a238a68","指定",",","则","5","相邻","从","以","00000100","现在","即","6","size","memory","p","内存","┌","两个","取一","(","等于","a","（","08","着","┘","at","shape"],"title":"内存布局","title_tokens":["布局","内存"]},{"location":"numpy笔记/6.3.内存布局.html#_2","text":"视图和副本是优化数值计算的重要概念。 在numpy中，可以用切片和 花式索引 （整数数组索引）来索引数据。切片将始终返回视图，而整数数组索引将返回一个副本。这种差异很重要，因为在切片情况下，修改视图会修改原数组，而在整数数组索引情况下则不是这样： Z = np . zeros ( 9 ) Z_view = Z [: 3 ] Z_view [ ... ] = 1 print ( Z ) [1. 1. 1. 0. 0. 0. 0. 0. 0.] Z = np . zeros ( 9 ) Z_copy = Z [[ 0 , 1 , 2 ]] Z_copy [ ... ] = 1 print ( Z ) [0. 0. 0. 0. 0. 0. 0. 0. 0.] 因此，如果你需要反复用到某个花式索引，最好保留它的副本（特别是如果计算它很复杂）。如果您不确定索引的结果是视图还是副本，则可以检查base的结果。如果是None，那么结果就是副本： Z = np . random . uniform ( 0 , 1 ,( 5 , 5 )) Z1 = Z [: 3 ,:] Z2 = Z [[ 0 , 1 , 2 ], :] print ( np . allclose ( Z1 , Z2 )) True print ( Z1 . base is Z ) True print ( Z2 . base is Z ) False print ( Z2 . base is None ) True 请注意，一些numpy函数在可能的情况下返回视图(例如， ravel )，而另一些函数总是返回副本(例如， flatten ): Z = np . zeros (( 5 , 5 )) print ( Z . ravel () . base is Z ) True print ( Z [:: 2 ,:: 2 ] . ravel () . base is Z ) False print ( Z . flatten () . base is Z ) False 可以通过 ndarray.view() 方法，从同一块内存区（储存着numpy数组的内存区）创建不同的dtype数组。 即用不同的数值类型查看同一段内存中的二进制数据。 它们使用的是同一块内存。 实际上， ndarray.view() 方法是创建了一个视图。 A = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ],[ 6 , 7 , 8 ]]) A_view = A . view ( np . int32 ) # A_view 是视图 A_view . flags C_CONTIGUOUS : True F_CONTIGUOUS : False OWNDATA : False WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False 如果我们直接修改原始数组的 dtype ，会达到同样的效果， 但此时直接修改原始数组。 A . dtype = np . float32 Caution 通常应避免改变由切片、transposes、fortran排序等定义的数组的 dtype 的大小，如下： A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) A_view = A . view ( np . int32 ) ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-7b8b7375e3ff> in <module> 1 A = copy.deepcopy(np.arange(9, dtype=np.int16).reshape(3,3)) ----> 2 A_view = A.view(np.int32) ValueError: When changing to a larger dtype, its size must be a divisor of the total size in bytes of the last axis of the array.","text_tokens":["很","owndata","它","如果","traceback","结果","一段","还是","原始","确定","last","实际","由","2","array","同","类型","储存","大小","its","不","writeable","差异","true","通过","updateifcopy","float32","changing","#","numpy","一些","它们","uniform","花式","copy","请","改变","因为","---------------------------------------------------------------------------","...","和","_","7","修改","in","larger","ipython","call","）","8","bytes","中","不是",">","数值","fortran","可以","切片","dtype","input","函数","module","是","、","始终","会","ravel","而","false","在","某个","下则","你","be","方法","axis","不同","这样","z","reshape","[","此时","flatten","recent","但","区","概念","数组","查看","，","ndarray","原","3","例如","同样","random","view","flags","divisor","]","z2","deepcopy","print","total","返回","即用","排序","优化","这种","反复","等","来","c","allclose","另","4","=","----","must",":","-","9","复杂","：","效果","情况","7b8b7375e3ff","is","f","检查","我们","直接","arange",")","同一","计算","就是","writebackifcopy","。","most","最好","to","重要","int32","视图","您","创建","整数","base","的","aligned","因此","达到","z1","int16",".","了","通常","进制","如下","of","用"," ","一个","caution","副本","<","the","contiguous","1","实际上","那么","保留","none","定义","索引","数据","zeros","将","避免","np","0","transposes",",","则","使用","注意","5","从","可能","下","6","size","应","内存","需要","特别","(","块内存","（","二进制","a","valueerror","when","着","总是","用到"],"title":"视图和副本","title_tokens":["和","视图","副本"]},{"location":"numpy笔记/6.4.广播.html","text":"广播 当使用ufunc函数对两个数组进行计算时，ufunc函数会对这两个数组的对应元素进行计算。这要求这两个数组的形状相同。如果这两个数组的形状不同，就通过广播broadcasting进行处理： 首先让所有输入数组都向其中维度最高的数组看齐。看齐方式为：在shape属性的左侧插入数字1 最后输出数组的shape属性是输入数组的shape属性的各轴上的最大值 如果输入数组的某个轴的长度为 1，或者与输出数组的各对应轴的长度相同，该数组能正确广播。否则计算出错 当输入数组的某个轴的长度为 1时，沿着此轴运算时都用此轴上的第一组值。 \"\"\" numpy.broadcast_arrays() 查看广播之后的数组 np.broadcast_to(array, shape, subok=False) 将array广播为指定的shape，如果指定的shape不满足广播要求，则报错 ndarray.repeat(repeats, axis=None) 重复某个轴上的值. repeats为重复次数 axis指定被重复的轴，即沿着哪一轴重复。如果未指定，则将数组展平然后重复。返回的也是一个展平的数组 \"\"\" a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = np . arange ( 5 ) c = b [:, None ] d = np . ones (( 5 , 3 )) np . broadcast_arrays ( d , c ) [array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]), array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]])] np . broadcast_to ( b [:, None ], ( 5 , 2 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) a . repeat ( 3 , axis = 1 ) array([[0, 0, 0, 1, 1, 1], [2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5], [6, 6, 6, 7, 7, 7], [8, 8, 8, 9, 9, 9]]) 广播示意图 The code to produce the figures is part of the AstroML book","text_tokens":["如果","10","沿着","报错","被","时","2","array","该","长度","d","不","输入","通过","插入","此轴上","shape","numpy","copy","重复","produce","广播","_","各","7","这","part","最大值","8","否则","arrays","对应","正确","最大","能","函数","第一","是","展平","让","当","b","code","会","false","在","某个","repeats","axis","其中","repeat","示意","不同","方式","轴上","意图","属性","然后","首先","reshape","[","次数","此轴","值","一组","数组","为","查看","，","ndarray","之后","满足","3","进行","figures","维度","左侧","与","大值","也","]","对","deepcopy","返回","都","哪一轴","相同","运算","c","轴","astroml","最高","4","=","数字",":","9","：","is","arange",")","形状","计算","。","看齐","to","subok","的","ufunc","第一组","就","ones","未指定","最后",".","of","用"," ","一个","broadcasting","示意图","the","1","输出","处理","向","none","\"","将","所有","np","0","指定",",","使用","则","5","或者","要求","即","6","两个","(","a","出错","元素","book","各轴上","broadcast"],"title":"6.4.广播","title_tokens":[".","6.4","广播"]},{"location":"numpy笔记/6.4.广播.html#_1","text":"当使用ufunc函数对两个数组进行计算时，ufunc函数会对这两个数组的对应元素进行计算。这要求这两个数组的形状相同。如果这两个数组的形状不同，就通过广播broadcasting进行处理： 首先让所有输入数组都向其中维度最高的数组看齐。看齐方式为：在shape属性的左侧插入数字1 最后输出数组的shape属性是输入数组的shape属性的各轴上的最大值 如果输入数组的某个轴的长度为 1，或者与输出数组的各对应轴的长度相同，该数组能正确广播。否则计算出错 当输入数组的某个轴的长度为 1时，沿着此轴运算时都用此轴上的第一组值。 \"\"\" numpy.broadcast_arrays() 查看广播之后的数组 np.broadcast_to(array, shape, subok=False) 将array广播为指定的shape，如果指定的shape不满足广播要求，则报错 ndarray.repeat(repeats, axis=None) 重复某个轴上的值. repeats为重复次数 axis指定被重复的轴，即沿着哪一轴重复。如果未指定，则将数组展平然后重复。返回的也是一个展平的数组 \"\"\" a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = np . arange ( 5 ) c = b [:, None ] d = np . ones (( 5 , 3 )) np . broadcast_arrays ( d , c ) [array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]), array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]])] np . broadcast_to ( b [:, None ], ( 5 , 2 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) a . repeat ( 3 , axis = 1 ) array([[0, 0, 0, 1, 1, 1], [2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5], [6, 6, 6, 7, 7, 7], [8, 8, 8, 9, 9, 9]])","text_tokens":["如果","10","沿着","报错","被","时","2","array","该","长度","d","不","输入","通过","插入","此轴上","shape","numpy","copy","重复","广播","_","各","7","这","最大值","8","否则","arrays","对应","正确","最大","能","函数","第一","是","展平","让","当","b","会","false","在","某个","repeats","axis","其中","repeat","不同","方式","轴上","属性","然后","首先","reshape","[","次数","此轴","值","一组","数组","为","查看","，","ndarray","之后","满足","3","进行","维度","左侧","与","大值","也","]","对","deepcopy","返回","都","哪一轴","相同","运算","c","轴","最高","4","=","数字",":","9","：","arange",")","形状","计算","。","看齐","to","subok","的","ufunc","第一组","就","ones","未指定","最后",".","用"," ","一个","broadcasting","1","输出","处理","向","none","\"","将","所有","np","0","指定",",","使用","则","5","或者","要求","即","6","两个","(","a","出错","元素","各轴上","broadcast"],"title":"广播","title_tokens":["广播"]},{"location":"numpy笔记/6.4.广播.html#_2","text":"The code to produce the figures is part of the AstroML book","text_tokens":["produce","is","of","code"," ","astroml","part","book","the","to","figures"],"title":"广播示意图","title_tokens":["示意图","示意","广播","意图"]},{"location":"numpy笔记/6.5.常量.html","text":"import numpy as np NumPy定义了几个常量（都是IEEE 754 浮点表示）： （正）无穷大 # 使用`inf`是因为`Inf`、`Infinity`、`PINF`和`infty`是`inf`的别名。 np . inf np . Infinity np . PINF np . Inf np . infty inf 负无穷大 np . NINF -inf 非数字 NaN # `NaN`和`NAN`是`nan`的等价定义。请使用`nan而不是`NAN`。 np . nan np . NAN np . NaN nan 负零 np . NZERO -0.0 正零 np . PZERO 0.0 自然对数的基础，纳皮尔的常数 np . e 2.718281828459045 欧拉常数 γ = 0.5772156649015328606065120900824024310421... 参考 np . euler_gamma 0.5772156649015329 None的便捷别名 对索引数组很有用 np . newaxis 圆周率 np . pi 3.141592653589793","text_tokens":["0.0","很","浮点","infty","别名","inf","自然","是因为","等价","正零","gamma","#","numpy","请","有用","因为","nan","...","和","_","自然对数","γ","3.141592653589793","）","2.718281828459045","不是","圆周率","是","、","正","而","754","欧拉","数组","，","表示","常数","e","对","pinf","都","参考","=","数字","-","基础","：","import","。","无穷大","euler","newaxis","无穷","的","了",".","0.5772156649015329"," ","nzero","对数","ninf","`","infinity","pi","非","圆周","none","定义","0.5772156649015328606065120900824024310421","索引","几个","常量","np","使用","pzero","便捷","负","ieee","负零","（","as","纳皮尔"],"title":"6.5.常量","title_tokens":[".","6.5","常量"]},{"location":"numpy笔记/6.6.打印数组.html","text":"import numpy import numpy as np 打印数组 当打印ndarray时，numpy按照Python的嵌套list的格式打印输出，但是按照以下顺序打印： 最底层的axis按照从左到右的顺序输出 次底层的axis按照从上到下的顺序输出 其他层的axis也是按照从上到下的顺序输出，但是每个slice中间间隔一条空行 如： 一维的ndarray按行打印；二维的ndarray按照矩阵打印；三维的ndarray按照矩阵的list打印 如果ndarray太大，那么numpy默认跳过中间部分的数据而只是输出四个角落的数据。 要想任何时候都打印全部数据，可以在print(array)之前设置选项 numpy . set_printoptions ( threshold = None ) 这样后续的打印ndarray就不会省略中间数据。 np . set_printoptions ( threshold = 5 ) np . arange ( 200 ) array([ 0, 1, 2, ..., 197, 198, 199])","text_tokens":["list","上到","如果","一维","三维","时","空行","2","array","set","slice","默认","numpy","_","...","选项","省略","每个","可以","最底层","部分","从上到下","是","；","次","不会","当","太大","层","而","格式","二维","全部","在","axis","四个","这样","[","要","跳过","嵌套","数组","角落","python","ndarray","，","200","按照","任何","也","]","print","都","顺序","=","printoptions","：","199","打印输出",")","arange","import","。","底层","矩阵","打印","时候","之前","如","的","从左到右","就","以下",".","threshold"," ","但是","197","中间","198","1","输出","那么","设置","其他","none","间隔","数据","np","0",",","5","只是","想","(","一条","后续","as","按行"],"title":"6.6.打印数组","title_tokens":["数组",".","6.6","打印"]},{"location":"numpy笔记/6.6.打印数组.html#_1","text":"当打印ndarray时，numpy按照Python的嵌套list的格式打印输出，但是按照以下顺序打印： 最底层的axis按照从左到右的顺序输出 次底层的axis按照从上到下的顺序输出 其他层的axis也是按照从上到下的顺序输出，但是每个slice中间间隔一条空行 如： 一维的ndarray按行打印；二维的ndarray按照矩阵打印；三维的ndarray按照矩阵的list打印 如果ndarray太大，那么numpy默认跳过中间部分的数据而只是输出四个角落的数据。 要想任何时候都打印全部数据，可以在print(array)之前设置选项 numpy . set_printoptions ( threshold = None ) 这样后续的打印ndarray就不会省略中间数据。 np . set_printoptions ( threshold = 5 ) np . arange ( 200 ) array([ 0, 1, 2, ..., 197, 198, 199])","text_tokens":["list","上到","如果","一维","三维","时","空行","2","array","set","slice","默认","numpy","_","...","选项","省略","每个","可以","最底层","部分","从上到下","是","；","次","不会","当","太大","层","而","格式","二维","全部","在","axis","四个","这样","[","要","跳过","嵌套","角落","python","ndarray","，","200","按照","任何","也","]","print","都","顺序","=","printoptions","：","199","打印输出",")","arange","。","底层","矩阵","打印","时候","之前","如","的","从左到右","就","以下",".","threshold"," ","但是","197","中间","198","1","输出","那么","设置","其他","none","间隔","数据","np","0",",","5","只是","想","(","一条","后续","按行"],"title":"打印数组","title_tokens":["数组","打印"]},{"location":"numpy笔记/6.7.添加和删除.html","text":"import numpy as np 添加和删除数组元素 方法 描述 delete (arr, obj[, axis]) 沿指定轴删除指定的元素，返回未删除的数组 insert (arr, obj, values[, axis]) 沿指定轴在指定索引之前插入值 append (arr, values[, axis]) 将值附加到数组的末尾 trim_zeros s(filt[, trim]) 修剪一维数组或序列中的前导、尾随的零 unique (ar[, return_index, return_inverse, …]) 返回没有重复元素的数组 # append a = np . arange ( 4 ) . reshape (( 2 , 2 )) np . append ( a , [[ 1 , 2 ],[ 3 , 4 ]], axis = 0 ) array([[0, 1], [2, 3], [1, 2], [3, 4]]) # insert a = np . arange ( 4 ) . reshape (( 2 , 2 )) # obj 是索引 np . insert ( a , obj = 1 , values = [ 10 , 11 ], axis = 0 ) array([[ 0, 1], [10, 11], [ 2, 3]]) # delete 删除指定数据，返回未删除的数据 a = np . arange ( 4 ) . reshape (( 2 , 2 )) np . delete ( a , 1 , axis = 0 ) array([[0, 1]]) # 默认返回一维数组 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = False , axis = None ) array([1, 2, 3]) # 设置axis参数 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = False , axis = 0 ) array([[1, 2], [2, 3]]) # 同时返回unique数组元素在原数组中的索引index a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = True , return_inverse = False , return_counts = False , axis = 0 ) (array([[1, 2], [2, 3]]), array([0, 2], dtype=int64)) # 同时返回原数组元素在unique数组中的索引index # 可用于重建原数组 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = True , return_counts = False , axis = 0 ) (array([[1, 2], [2, 3]]), array([0, 0, 1], dtype=int64)) # 同时返回 计数 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = True , axis = 0 ) (array([[1, 2], [2, 3]]), array([2, 1], dtype=int64)) a = np . array ([ 0 , 0 , 1 , 2 , 3 , 0 , 0 ]) # 删除一维数组开头和结尾的0元素 # trim='f' 从前面裁剪 # trim='b' 从后面裁剪 # 默认为 trim='fb' np . trim_zeros ( a , trim = 'fb' ) array([1, 2, 3])","text_tokens":["参数","s","到","结尾","修剪","一维","10","unique","2","array","'","前导","arr","…","默认","插入","true","添加","#","numpy","描述","未","计数","零","重复","删除","_","和","附加","insert","裁剪","中","用于","dtype","是","、","b","false","在","方法","axis","开头","reshape","[","值","数组","为","，","11","原","3","]","index","返回","没有","append","重建","轴","4","=","将值","values","f","arange",")","filt","inverse","import","末尾","之前","后面","的","return","fb","ar","delete",".","可"," ","尾随","1","设置","none","索引","zeros","数据","np","0","同时","指定",",","或","从","int64","obj","序列","前面","(","counts","a","as","元素","trim","沿"],"title":"6.7.添加和删除","title_tokens":[".","6.7","删除","和","添加"]},{"location":"numpy笔记/6.7.添加和删除.html#_1","text":"方法 描述 delete (arr, obj[, axis]) 沿指定轴删除指定的元素，返回未删除的数组 insert (arr, obj, values[, axis]) 沿指定轴在指定索引之前插入值 append (arr, values[, axis]) 将值附加到数组的末尾 trim_zeros s(filt[, trim]) 修剪一维数组或序列中的前导、尾随的零 unique (ar[, return_index, return_inverse, …]) 返回没有重复元素的数组 # append a = np . arange ( 4 ) . reshape (( 2 , 2 )) np . append ( a , [[ 1 , 2 ],[ 3 , 4 ]], axis = 0 ) array([[0, 1], [2, 3], [1, 2], [3, 4]]) # insert a = np . arange ( 4 ) . reshape (( 2 , 2 )) # obj 是索引 np . insert ( a , obj = 1 , values = [ 10 , 11 ], axis = 0 ) array([[ 0, 1], [10, 11], [ 2, 3]]) # delete 删除指定数据，返回未删除的数据 a = np . arange ( 4 ) . reshape (( 2 , 2 )) np . delete ( a , 1 , axis = 0 ) array([[0, 1]]) # 默认返回一维数组 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = False , axis = None ) array([1, 2, 3]) # 设置axis参数 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = False , axis = 0 ) array([[1, 2], [2, 3]]) # 同时返回unique数组元素在原数组中的索引index a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = True , return_inverse = False , return_counts = False , axis = 0 ) (array([[1, 2], [2, 3]]), array([0, 2], dtype=int64)) # 同时返回原数组元素在unique数组中的索引index # 可用于重建原数组 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = True , return_counts = False , axis = 0 ) (array([[1, 2], [2, 3]]), array([0, 0, 1], dtype=int64)) # 同时返回 计数 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = True , axis = 0 ) (array([[1, 2], [2, 3]]), array([2, 1], dtype=int64)) a = np . array ([ 0 , 0 , 1 , 2 , 3 , 0 , 0 ]) # 删除一维数组开头和结尾的0元素 # trim='f' 从前面裁剪 # trim='b' 从后面裁剪 # 默认为 trim='fb' np . trim_zeros ( a , trim = 'fb' ) array([1, 2, 3])","text_tokens":["参数","s","到","结尾","修剪","一维","10","unique","2","array","'","前导","arr","…","默认","插入","true","#","描述","未","计数","零","重复","删除","_","和","附加","insert","裁剪","中","用于","dtype","是","、","b","false","在","方法","axis","开头","reshape","[","值","数组","为","，","11","原","3","]","index","返回","没有","append","重建","轴","4","=","将值","values","f","arange",")","filt","inverse","末尾","之前","后面","的","return","fb","ar","delete",".","可"," ","尾随","1","设置","none","索引","zeros","数据","np","0","同时","指定",",","或","从","int64","obj","序列","前面","(","counts","a","元素","trim","沿"],"title":"添加和删除数组元素","title_tokens":["删除","和","数组","添加","元素"]},{"location":"numpy笔记/6.8.形状操纵.html","text":"import numpy as np import copy 形状操作( shape ) .shape .reshape() .resize() reshape resize 区别： reshape不会修改原数据 resize会修改原数据 # 创建示例数据 a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) # 会直接修改原始数组 a . shape = ( 5 , 10 ) a . flags # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . shape = ( 25 , - 1 ) # 不会直接修改原始数组 a . reshape ( 5 , 10 ) # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . reshape ( 5 , - 1 ) # 会直接修改原始数组 a . resize (( 25 , 2 )) 形状操作( ndim ) .flatten() ：多维数组转为一维数组 .reval() ：多维数组转为一维数组 .squeeze() ：将大小等于1的轴删除 .swapaxes(a, axis1, axis2)) ：交换指定的两个轴axis1/axis2。它获得是原数组的视图。 .transpose(a, axes=None) ：重置轴序。如果 axes=None ，则默认重置为逆序的轴序，如原来的 shape=(1,2,3) ，逆序之后为 (3,2,1） 如果 axes!=None ，则要给出重置后的轴序。它获得的是原数组的视图。 .atleast_1d(*arys) ：将输入转换为至少一维的数组 .atleast_2d(*arys) ：将输入转换为至少二维的数组 .atleast_3d(*arys) ：将输入转换为至少三维的数组 .expand_dims() ：在指定位置插入大小为1的新轴 .moveaxis(a, source, destination) ：将a中的source轴移动到位置destination，source、destination可以是int of list，一次性移动多个轴 # 多维数组转为一维数组 a . flatten () # 返回副本 a . ravel () # 一般返回视图 ## flatten ravel 区别 ## ravel()：如果没有必要，不会产生源数据的副本 ## flatten()：返回源数据的副本 b = np . arange ( 10 ) # 创建示例数据 b . flatten () . flags [ \"OWNDATA\" ] True b . ravel () . flags [ \"OWNDATA\" ] False a . ravel ( order = \"F\" ) . flags [ \"OWNDATA\" ] True # 对维数为1的维度降维,返回副本 b = copy . deepcopy ( np . arange ( 20 ) . reshape ( 20 , 1 )) b [: 6 ] array([[0], [1], [2], [3], [4], [5]]) b . squeeze ( 1 ) array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) # 返回数组的视图，其中axis1和axis2互换。 ## ndarray.swapaxes(axis1, axis2) a = copy . deepcopy ( np . arange ( 20 ) . reshape ( 10 , 2 )) a . swapaxes ( 0 , 1 ) # 视图 array([[ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18], [ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]]) # 返回轴转置的数组视图。 b = copy . deepcopy ( np . arange ( 60 ) . reshape ( 3 , 2 , 10 )) b . transpose () array ([[[ 0 , 20 , 40 ], [ 10 , 30 , 50 ]], [[ 1 , 21 , 41 ], [ 11 , 31 , 51 ]], [[ 2 , 22 , 42 ], [ 12 , 32 , 52 ]], [[ 3 , 23 , 43 ], [ 13 , 33 , 53 ]], [[ 4 , 24 , 44 ], [ 14 , 34 , 54 ]], [[ 5 , 25 , 45 ], [ 15 , 35 , 55 ]], [[ 6 , 26 , 46 ], [ 16 , 36 , 56 ]], [[ 7 , 27 , 47 ], [ 17 , 37 , 57 ]], [[ 8 , 28 , 48 ], [ 18 , 38 , 58 ]], [[ 9 , 29 , 49 ], [ 19 , 39 , 59 ]]]) # atleast_nd np . atleast_1d ( 1 ) array([1]) np . atleast_2d ([ 1 , 2 , 3 , 4 ]) array([[1, 2, 3, 4]]) np . atleast_3d ([[ 1 , 2 ],[ 3 , 4 ]]) array ([[[ 1 ], [ 2 ]], [[ 3 ], [ 4 ]]]) a = np . arange ( 4 ) . reshape ( 2 , 2 ) np . expand_dims ( a , 1 ) . shape (2, 1, 2) x = np . zeros (( 3 , 4 , 5 )) print ( np . moveaxis ( x , 0 , - 1 ) . shape ) print ( np . moveaxis ( x , - 1 , 0 ) . shape ) (4, 5, 3) (5, 3, 4) \"以下代码的效果一样\" x = np . zeros (( 3 , 4 , 5 )) np . transpose ( x ) . shape np . swapaxes ( x , 0 , - 1 ) . shape np . moveaxis ( x , [ 0 , 2 ], [ - 1 , - 2 ]) . shape np . moveaxis ( x , [ 0 , 1 , 2 ], [ - 1 , - 2 , - 3 ]) . shape 数组拼接 .concatenate((a1, a2, ...), axis=0) ：连接多个数组。其中 (a1,a2,...) 为数组的序列，给出了待连接的数组，它们沿着 axis 指定的已存在的轴连接。所有的这些数组的形状，除了 axis 轴之外都相同。 .vstack(tup) ：沿0轴拼接（垂直拼接），增加行。 .hstack(tup) ：沿1轴拼接（水平拼接），增加列。 .dstack(tup) ： numpy.concatenate((a1, a2, ...), axis=3) 。沿着3轴堆叠数组。 .column_stack(tup) ：类似于 hstack ，但是如果被拼接的数组是一维的，则将其形状修改为二维的$(N,1)$。 .c_ ： .c_ 对象的 [] 方法也可以用于按列连接数组。但是如果被拼接的数组是一维的，则将其形状修改为二维的$(N,1)$。沿列方向拼接，增加列。 a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) # 横向拼接、拼接 1 轴（第二个轴，即列） np . concatenate (( a , b ), axis = 1 ) np . hstack (( a , b )) np . c_ [ a , b ] array([[0, 1, 0, 1], [2, 3, 2, 3], [4, 5, 4, 5], [6, 7, 6, 7], [8, 9, 8, 9]]) # column_stack hstack np.c_区别 a1 = np . arange ( 5 ) np . column_stack (( a1 , a1 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) np . hstack (( a1 , a1 )) array([0, 1, 2, 3, 4, 0, 1, 2, 3, 4]) np . c_ [ a1 , a1 ] array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) 数组拆分 1. .split(ary, indices_or_sections, axis=0) ：用于沿着指定的轴拆分数组ary。 indices_or_sections指定了拆分点： 如果为整数N，则表示平均拆分成N份。如果不能平均拆分，则报错 如果为序列，则该序列指定了划分区间（无需指定最开始的0起点和终点）。如 [1,3] 指定了区间： [0,1],[1,3],[3:] 2. .array_split(ary, indices_or_sections, axis=0) ：作用与 .split() 类似。唯一的区别在于：当indices_or_sections为整数，且无法平均拆分时，并不报错，而是尽可能的维持平均拆分。 3. .dsplit(ary, indices_or_sections) ：沿第3轴将数组拆分为多个子数组。 4. .hsplit(ary, indices_or_sections) ：水平（按列）将一个数组拆分为多个子数组。 5. .vsplit(ary, indices_or_sections) ：垂直（行）将数组拆分为多个子数组。 a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) np . split ( a , 2 , axis = 0 ) [array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]]), array([[25, 26, 27, 28, 29], [30, 31, 32, 33, 34], [35, 36, 37, 38, 39], [40, 41, 42, 43, 44], [45, 46, 47, 48, 49]])] # [0,1) [1,3) [3:] np . split ( a ,[ 1 , 3 ], axis = 1 ) [array([[ 0], [ 5], [10], [15], [20], [25], [30], [35], [40], [45]]), array([[ 1, 2], [ 6, 7], [11, 12], [16, 17], [21, 22], [26, 27], [31, 32], [36, 37], [41, 42], [46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], [18, 19], [23, 24], [28, 29], [33, 34], [38, 39], [43, 44], [48, 49]])] np . array_split ( a , 2 , axis = 1 ) [array([[ 0, 1, 2], [ 5, 6, 7], [10, 11, 12], [15, 16, 17], [20, 21, 22], [25, 26, 27], [30, 31, 32], [35, 36, 37], [40, 41, 42], [45, 46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], [18, 19], [23, 24], [28, 29], [33, 34], [38, 39], [43, 44], [48, 49]])]","text_tokens":["42","10","concatenate","最","该","vsplit","长度","唯一","大小","不","默认","45","*","必要","copy","...","7","修改","tup","indices","转换","44","给出","是","30","不会","当","某个","产生","类似","23","并","原","3","13","交换","27","相同","移动","n",")","一次性","待","计算","。","方向","56","其","的","以下","29","了","58"," ","25","moveaxis","将","尽可","43","源","则","26","!","5","重置","order","按列","序列","split","a","平均","被","尽可能","沿","atleast","38","它","而是","沿着","除了","2","输入","原来","插入","arys","squeeze","删除","_","和","位置","8","中","示例","维持","增加","b","1d","ravel","false","其中","reshape","41","##","数组","，","ndarray","54","ndim","28","与","]","列","堆叠","print","33","没有","都","互换","50","c","轴","=","or","53","import","视图","如","整数","第二","18","sections","of","1","设置","none","多个","份","垂直","区别","47","自动","两个","(","shape","分成","expand","ary","owndata","如果","到","原始","三维","31","时","array","于","多维","60","55","拆分","可以","a1","48","34","$","会","vstack","二维","方法","axis","一样","分为","swapaxes","转置","resize","开始","[","要","至少","21","为","11","axis1","一般","轴序","deepcopy","column","59","操作","横向","逆序","在于","4",":","9","无需","22","f","arange","46","形状","终点","dstack","创建","点","x","12","对维数",".","但是","沿第","一个","hstack","24","代码","降维","起点","nd","zeros","\"","即列","这些","所有","0","第二个","指定","6","（","已","reval","作用","32","list","39","int","transpose","一维","不能","35","报错","后","存在","之外","水平","划分","15","true","#","numpy","它们","子","stack","沿列","dims","）","40","axes","无法","用于","连接","、","36","/","在","二个","52","20","dsplit","37","此时","flatten","3d","之后","表示","57","16","flags","维度","source","拆","对象","也","区间","a2","返回","51","获得","转为","17","且","-","：","效果","新","直接","19","destination","拼接","行","hsplit","副本","2d","14","49","一次","数据","np",",","可能","等于","as","axis2"],"title":"6.8.形状操纵","title_tokens":["形状","6.8",".","操纵"]},{"location":"numpy笔记/6.8.形状操纵.html#shape","text":".shape .reshape() .resize() reshape resize 区别： reshape不会修改原数据 resize会修改原数据 # 创建示例数据 a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) # 会直接修改原始数组 a . shape = ( 5 , 10 ) a . flags # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . shape = ( 25 , - 1 ) # 不会直接修改原始数组 a . reshape ( 5 , 10 ) # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . reshape ( 5 , - 1 ) # 会直接修改原始数组 a . resize (( 25 , 2 ))","text_tokens":["flags",".","维度"," ","可以","deepcopy","原始","示例","10","1","50","不会","设置","25","2","该","会","=","数据","长度","在","某个","-","：","np",",","直接","arange",")","5","区别","reshape","resize","#","计算","此时","copy","自动","创建","(","a","数组","其","修改","为","，","的","被","原","shape"],"title":"形状操作(shape)","title_tokens":["(",")","形状","shape","操作"]},{"location":"numpy笔记/6.8.形状操纵.html#ndim","text":".flatten() ：多维数组转为一维数组 .reval() ：多维数组转为一维数组 .squeeze() ：将大小等于1的轴删除 .swapaxes(a, axis1, axis2)) ：交换指定的两个轴axis1/axis2。它获得是原数组的视图。 .transpose(a, axes=None) ：重置轴序。如果 axes=None ，则默认重置为逆序的轴序，如原来的 shape=(1,2,3) ，逆序之后为 (3,2,1） 如果 axes!=None ，则要给出重置后的轴序。它获得的是原数组的视图。 .atleast_1d(*arys) ：将输入转换为至少一维的数组 .atleast_2d(*arys) ：将输入转换为至少二维的数组 .atleast_3d(*arys) ：将输入转换为至少三维的数组 .expand_dims() ：在指定位置插入大小为1的新轴 .moveaxis(a, source, destination) ：将a中的source轴移动到位置destination，source、destination可以是int of list，一次性移动多个轴 # 多维数组转为一维数组 a . flatten () # 返回副本 a . ravel () # 一般返回视图 ## flatten ravel 区别 ## ravel()：如果没有必要，不会产生源数据的副本 ## flatten()：返回源数据的副本 b = np . arange ( 10 ) # 创建示例数据 b . flatten () . flags [ \"OWNDATA\" ] True b . ravel () . flags [ \"OWNDATA\" ] False a . ravel ( order = \"F\" ) . flags [ \"OWNDATA\" ] True # 对维数为1的维度降维,返回副本 b = copy . deepcopy ( np . arange ( 20 ) . reshape ( 20 , 1 )) b [: 6 ] array([[0], [1], [2], [3], [4], [5]]) b . squeeze ( 1 ) array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) # 返回数组的视图，其中axis1和axis2互换。 ## ndarray.swapaxes(axis1, axis2) a = copy . deepcopy ( np . arange ( 20 ) . reshape ( 10 , 2 )) a . swapaxes ( 0 , 1 ) # 视图 array([[ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18], [ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]]) # 返回轴转置的数组视图。 b = copy . deepcopy ( np . arange ( 60 ) . reshape ( 3 , 2 , 10 )) b . transpose () array ([[[ 0 , 20 , 40 ], [ 10 , 30 , 50 ]], [[ 1 , 21 , 41 ], [ 11 , 31 , 51 ]], [[ 2 , 22 , 42 ], [ 12 , 32 , 52 ]], [[ 3 , 23 , 43 ], [ 13 , 33 , 53 ]], [[ 4 , 24 , 44 ], [ 14 , 34 , 54 ]], [[ 5 , 25 , 45 ], [ 15 , 35 , 55 ]], [[ 6 , 26 , 46 ], [ 16 , 36 , 56 ]], [[ 7 , 27 , 47 ], [ 17 , 37 , 57 ]], [[ 8 , 28 , 48 ], [ 18 , 38 , 58 ]], [[ 9 , 29 , 49 ], [ 19 , 39 , 59 ]]]) # atleast_nd np . atleast_1d ( 1 ) array([1]) np . atleast_2d ([ 1 , 2 , 3 , 4 ]) array([[1, 2, 3, 4]]) np . atleast_3d ([[ 1 , 2 ],[ 3 , 4 ]]) array ([[[ 1 ], [ 2 ]], [[ 3 ], [ 4 ]]]) a = np . arange ( 4 ) . reshape ( 2 , 2 ) np . expand_dims ( a , 1 ) . shape (2, 1, 2) x = np . zeros (( 3 , 4 , 5 )) print ( np . moveaxis ( x , 0 , - 1 ) . shape ) print ( np . moveaxis ( x , - 1 , 0 ) . shape ) (4, 5, 3) (5, 3, 4) \"以下代码的效果一样\" x = np . zeros (( 3 , 4 , 5 )) np . transpose ( x ) . shape np . swapaxes ( x , 0 , - 1 ) . shape np . moveaxis ( x , [ 0 , 2 ], [ - 1 , - 2 ]) . shape np . moveaxis ( x , [ 0 , 1 , 2 ], [ - 1 , - 2 , - 3 ]) . shape","text_tokens":["32","atleast","list","38","owndata","它","如果","到","int","transpose","42","一维","39","三维","10","31","35","后","2","array","大小","15","输入","默认","原来","插入","*","arys","true","45","#","必要","squeeze","多维","copy","删除","_","7","和","位置","60","55","dims","）","8","40","中","axes","可以","转换","44","示例","给出","48","是","30","、","34","不会","b","36","1d","/","ravel","false","二维","在","52","其中","产生","一样","swapaxes","转置","20","reshape","41","[","37","flatten","3d","23","要","##","至少","21","数组","为","，","ndarray","54","11","之后","原","3","axis1","一般","13","16","flags","source","轴序","维度","28","]","deepcopy","print","33","返回","没有","59","51","交换","获得","互换","27","50","转为","逆序","轴","4","=","17",":","移动","9","-","：","效果","新","22","f","arange",")","一次性","46","53","。","19","视图","如","创建","56","axis2","的","x","destination","12","以下","29","18","对维数",".","58","of"," ","副本","1","2d","14","24","49","代码","降维","一次","25","none","moveaxis","nd","zeros","数据","多个","\"","将","np","43","0","指定",",","则","源","26","!","5","重置","区别","order","47","6","57","两个","(","等于","a","shape","reval","expand"],"title":"形状操作(ndim)","title_tokens":["ndim","(",")","形状","操作"]},{"location":"numpy笔记/6.8.形状操纵.html#_1","text":".concatenate((a1, a2, ...), axis=0) ：连接多个数组。其中 (a1,a2,...) 为数组的序列，给出了待连接的数组，它们沿着 axis 指定的已存在的轴连接。所有的这些数组的形状，除了 axis 轴之外都相同。 .vstack(tup) ：沿0轴拼接（垂直拼接），增加行。 .hstack(tup) ：沿1轴拼接（水平拼接），增加列。 .dstack(tup) ： numpy.concatenate((a1, a2, ...), axis=3) 。沿着3轴堆叠数组。 .column_stack(tup) ：类似于 hstack ，但是如果被拼接的数组是一维的，则将其形状修改为二维的$(N,1)$。 .c_ ： .c_ 对象的 [] 方法也可以用于按列连接数组。但是如果被拼接的数组是一维的，则将其形状修改为二维的$(N,1)$。沿列方向拼接，增加列。 a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) # 横向拼接、拼接 1 轴（第二个轴，即列） np . concatenate (( a , b ), axis = 1 ) np . hstack (( a , b )) np . c_ [ a , b ] array([[0, 1, 0, 1], [2, 3, 2, 3], [4, 5, 4, 5], [6, 7, 6, 7], [8, 9, 8, 9]]) # column_stack hstack np.c_区别 a1 = np . arange ( 5 ) np . column_stack (( a1 , a1 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) np . hstack (( a1 , a1 )) array([0, 1, 2, 3, 4, 0, 1, 2, 3, 4]) np . c_ [ a1 , a1 ] array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]])","text_tokens":["如果","一维","concatenate","10","沿着","存在","除了","之外","2","array","水平","于","#","numpy","它们","copy","stack","...","_","7","沿列","修改","tup","）","8","a1","可以","用于","连接","给出","增加","是","、","$","b","vstack","二维","二个","方法","axis","其中","类似","reshape","[","数组","为","，","3","已","对象","]","也","列","a2","deepcopy","堆叠","column","都","相同","c","横向","轴","4","=","9","：","n","arange",")","待","形状","。","dstack","方向","的","其","拼接","行","第二",".","了"," ","但是","hstack","1","多个","即列","这些","将","所有","np","0","第二个","指定",",","则","垂直","5","区别","按列","6","序列","(","（","a","被","沿"],"title":"数组拼接","title_tokens":["数组","拼接"]},{"location":"numpy笔记/6.8.形状操纵.html#_2","text":"1. .split(ary, indices_or_sections, axis=0) ：用于沿着指定的轴拆分数组ary。 indices_or_sections指定了拆分点： 如果为整数N，则表示平均拆分成N份。如果不能平均拆分，则报错 如果为序列，则该序列指定了划分区间（无需指定最开始的0起点和终点）。如 [1,3] 指定了区间： [0,1],[1,3],[3:] 2. .array_split(ary, indices_or_sections, axis=0) ：作用与 .split() 类似。唯一的区别在于：当indices_or_sections为整数，且无法平均拆分时，并不报错，而是尽可能的维持平均拆分。 3. .dsplit(ary, indices_or_sections) ：沿第3轴将数组拆分为多个子数组。 4. .hsplit(ary, indices_or_sections) ：水平（按列）将一个数组拆分为多个子数组。 5. .vsplit(ary, indices_or_sections) ：垂直（行）将数组拆分为多个子数组。 a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) np . split ( a , 2 , axis = 0 ) [array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]]), array([[25, 26, 27, 28, 29], [30, 31, 32, 33, 34], [35, 36, 37, 38, 39], [40, 41, 42, 43, 44], [45, 46, 47, 48, 49]])] # [0,1) [1,3) [3:] np . split ( a ,[ 1 , 3 ], axis = 1 ) [array([[ 0], [ 5], [10], [15], [20], [25], [30], [35], [40], [45]]), array([[ 1, 2], [ 6, 7], [11, 12], [16, 17], [21, 22], [26, 27], [31, 32], [36, 37], [41, 42], [46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], [18, 19], [23, 24], [28, 29], [33, 34], [38, 39], [43, 44], [48, 49]])] np . array_split ( a , 2 , axis = 1 ) [array([[ 0, 1, 2], [ 5, 6, 7], [10, 11, 12], [15, 16, 17], [20, 21, 22], [25, 26, 27], [30, 31, 32], [35, 36, 37], [40, 41, 42], [45, 46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], [18, 19], [23, 24], [28, 29], [33, 34], [38, 39], [43, 44], [48, 49]])]","text_tokens":["作用","ary","32","38","如果","39","42","而是","不能","10","31","35","沿着","报错","最","时","2","array","水平","该","划分","vsplit","唯一","15","不","45","#","copy","子","_","和","7","）","拆分","8","40","indices","无法","用于","44","维持","48","30","34","当","36","axis","分为","20","dsplit","类似","reshape","开始","41","[","37","23","21","数组","为","并","，","11","表示","3","13","16","拆","28","与","]","区间","deepcopy","33","27","50","在于","轴","4","=","17","且",":","9","or","：","无需","22","n","arange",")","46","终点","。","19","如","整数","点","的","行","12","29","hsplit","18","sections",".","了"," ","沿第","一个","1","14","24","49","起点","25","多个","尽可","将","份","np","43","0","指定",",","则","26","垂直","5","区别","按列","47","可能","6","split","序列","(","（","a","平均","尽可能","分成"],"title":"数组拆分","title_tokens":["拆分","数组"]},{"location":"numpy笔记/6.9.ufunc函数.html","text":"import numpy as np np . set_printoptions ( threshold = 40 ) 四则运算 a = np . arange ( 1 , 6 ) # 表达式形式 a + a a - a a * a a / a # ufunc函数形式 np . add ( a , a ) np . subtract ( a , a ) np . multiply ( a , a ) np . true_divide ( a , a ) array([1., 1., 1., 1., 1.]) 比较运算 a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 表达式形式 a == b a != b a < b a <= b a > b a >= b # ufunc函数形式 np . equal ( a , b ) np . not_equal ( a , b ) np . less ( a , b ) np . less_equal ( a , b ) np . greater ( a , b ) np . greater_equal ( a , b ) array([[False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False]]) 逻辑运算 a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 与 np . logical_and ( a , b ) # 或 np . logical_or ( a , b ) # 非 np . logical_not ( a , b ) # 异或 np . logical_xor ( a , b ) # 任意一个元素 np . any ( a ) # 全部元素 np . all ( a ) False 位运算 a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) a & b a | b ~ a a ^ b # 按位与 np . bitwise_and ( a , b ) # 按位或 np . bitwise_or ( a , b ) # 按位取反 np . bitwise_not ( a ) # 按位异或 np . bitwise_xor ( a , b ) array([[10, 10, 14, 14, 10, 10, 22, 22, 26, 26], [30, 30, 26, 26, 22, 22, 10, 10, 14, 14]], dtype=int32) 自定义 ufunc 函数 可以通过 frompyfunc() 将计算单个元素的函数转换成ufunc函数。调用格式为如下： numpy . frompyfunc ( func , nin , nout ) # func：计算单个元素的函数 # nin：func的输入参数的个数 The number of input # nout：func返回值的个数 The number of output def my_add ( x , y ): z = x + y + 1 return z myufunc = np . frompyfunc ( my_add , 2 , 1 ) a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) myufunc ( a , b ) array([6, 8, 10, 12, 14], dtype=object) 也可以通过 vectorize() 函数来实现 frompyfunc() 的功能。 np . vectorize ( func , otypes = '' , doc = None , excluded = None ) 。 # func：计算单个元素的函数 # otypes：可以是一个表示结果数组元素类型的字符串，也可以是一个类型列表。如果使用类型列表，可以描述多个返回数组的元素类型 # doc：函数的描述字符串。若未给定，则使用func.__doc__ # excluded：指定func中哪些参数未被向量化。你可以指定一个字符串和整数的集合，其中字符串代表关键字参数，整数代表位置参数。 a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) def my_add ( x , num ): z = x + num return z myufunc = np . vectorize ( my_add , doc = \"每一个元素加上一个指定的数\" ) print ( myufunc . __doc__ ) myufunc ( a , 1 ) 每一个元素加上一个指定的数 array([1, 2, 3, 4, 5]) def my_add ( x , y , list_num ): z = x + y for i in list_num : z = z + i return z myufunc = np . vectorize ( my_add , excluded = [ 2 ]) myufunc ( a , b , [ 1 , 2 , 3 ]) # list_num 作为一个list，而不是向量化成一个个元素 array([11, 13, 15, 17, 19]) def my_add ( x , num ): z = x + num return z , z myufunc = np . vectorize ( my_add , otypes = [ np . float , int ]) myufunc ( a , 1 ) (array([1., 2., 3., 4., 5.]), array([1, 2, 3, 4, 5])) ufunc 对象的方法 ufunc函数对象本身还有一些方法。 这些方法只对于两个输入、一个输出的ufunc函数函数有效。对于其他的ufunc函数对象调用这些方法时，会抛出 ValueError 异常。 ufunc.reduce() ufunc.reduce 方法：类似于Python的 reduce 函数，它==沿着== axis 参数指定的轴，对数组进行操作。经过一次reduce，结果数组的维度降低一维。 假设 <op> 是一个ufunc函数， ufunc.reduce 用法如下： < op >. reduce ( array , axis = 0 , dtype = None ) a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . reduce ( a , axis = 1 ) # 沿着 列方向 array([ 6, 22, 38, 54, 70]) np . add . reduce ( a , axis = 0 ) # 沿着 行方向 array([40, 45, 50, 55]) 相当于将 运算符插入到沿着axis轴的所有元素之间： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) def fun ( a , b ): z = a + b + 1 return z fun2 = np . frompyfunc ( fun , 2 , 1 ) fun2 . reduce ( a , axis = 1 ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] array([9, 25, 41, 57, 73], dtype=object) ufunc.accumulate() ufunc.accumulate 方法：它类似于reduce()的计算过程，但是它会保存所有的中间计算结果，从而使得返回数组的形状和输入数组的形状相同： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . accumulate ( a , axis = 1 ) array([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38], [12, 25, 39, 54], [16, 33, 51, 70]], dtype=int32) ufunc.outer() ufunc.outer 方法：相当于将 运算符对输入数组A和输入数组B的每一对元素对(a,b)起作用。设A的shape=(4,5)，B的shape为(4,)，则结果数组的shape=(4,5,4) 一维数组和一维数组的outer操作为二维数组 a = np . arange ( 1 , 6 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array([[2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7], [5, 6, 7, 8], [6, 7, 8, 9]]) 多维数组的outer拆分成各自的一维操作 a = np . arange ( 1 , 7 ) . reshape ( 2 , 3 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array ([[[ 2 , 3 , 4 , 5 ], [ 3 , 4 , 5 , 6 ], [ 4 , 5 , 6 , 7 ]], [[ 5 , 6 , 7 , 8 ], [ 6 , 7 , 8 , 9 ], [ 7 , 8 , 9 , 10 ]]]) 数学函数 下面是一元的数学函数： abs/fabs ：计算整数、浮点数或者复数的绝对值。对于非复数值，可以使用更快的fabs sqrt ：计算平方根，相当于$a^{0.5}$ square ：计算平方，相当于$a^2$ exp ：计算指数$e^x$ log/log10/log2/log1p ：分别为$log_{e}(a), log_{10}(a), log_2(a), log_e(1+x)$ sign ：计算$sign(a)$ ceil ：计算各元素的ceiling值：大于等于该值的最小整数 floor ：计算个元素的floor值：小于等于该值的最大整数 rint ：将各元素四舍五入到最接近的整数，保留 dtype modf ：将数组的小数和整数部分以两个独立数组的形式返回 cos/cosh/sin/sinh/tan/tanh ：普通和双曲型三角函数 arccos/arcsosh/arcsin/arcsinh/arctan/arctanh :反三角函数 isnan ：返回一个布尔数组，该数组指示那些是 NaN isfinite/isinf ：返回一个布尔数组，该数组指示哪些是有限的/无限数","text_tokens":["浮点","10","量化","bitwise","四则运算","最","'","该","从而","数学","set","arcsin","45","*","算符","调用","7","指数","in","对于","还有","abs","使得","不是","转换","{","方根","该值","部分","是","30","格式","not","cos","给定","类似","表达式","doc","python","实现","3","13","相当","三角函数","myufunc","arcsosh","and","27","arctan","来","相同","集合","70","有效",")","计算","。","方向","的","&","列表","threshold"," ","普通","中间","<","+","字符串","25","单个","将","all","换成","使用","则","26","四舍五入","!","或","5","分别","代表","a","被","元素","log10","38","它","绝对","沿着","三角","相当于","2","}","假设","输入","插入","isinf","logical","运算符","greater","未","nan","反","_","和",".__","subtract","位置","8","中","最大","函数","log1p","加上","b","而","false","其中","只","z","reshape","41","nin","arccos","数组","，","54","设","与","]","e","列","型","print","33","func","关键字","50","轴","=","功能","or","tanh","import","经过","int32","excluded","复数","整数","按位","数","18","any","of","the","1","点数","异或","sqrt","none","下面","多个","小于","arctanh","exp","两个","(","shape","分成","output","更快","参数","如果","到","四则","那些","计算结果","时","array","类型","平方","向量","于","通过","字符","nout","一些","描述","多维","转换成","各","cosh","55","数值","可以","dtype","input","ceiling","isnan","用法","sinh","$","会","全部","二维","你","方法","axis","个个","modf","[","接近","|","位","值","ceil","表达","为","frompyfunc","自定","11","进行","op","起","float","otypes","对","fun2","操作","^","arcsinh","outer","4","个数",":","9","printoptions","之间","22","arange","形状","本身","哪些","x","过程","12","一对",".","取反","multiply","floor","73","但是","一个","逻辑","浮点数","当于","逻辑运算","其他","\"","绝对值","这些","所有","0","返回值","指定","def","sin","6","任意","my","布尔","最小","xor","rint","num","作用","list","for","降低","39","结果","int","number","一维","个","accumulate","保存","15","~","reduce","true","#","numpy","若","有限","比较","40",">","关键","各自","object","、","形式","square","log","/","add","无限","20","大于","双曲","vectorize","sign","独立","表示","57","16","维度","拆","对象","也","i","0.5","返回","equal","isfinite","51","一元","y","运算","divide","17","-","平方根","：","小数","19","非复","指示","return","ufunc","行","fun","异常","如下","14","输出","一次","保留","非","向","定义","tan","log2","np","less",",","自定义","fabs","化成","作为","抛出","或者","以","等于","每","valueerror","一个个","它会","as","达式","__"],"title":"6.9.ufunc函数","title_tokens":["6.9","函数",".","ufunc"]},{"location":"numpy笔记/6.9.ufunc函数.html#_1","text":"a = np . arange ( 1 , 6 ) # 表达式形式 a + a a - a a * a a / a # ufunc函数形式 np . add ( a , a ) np . subtract ( a , a ) np . multiply ( a , a ) np . true_divide ( a , a ) array([1., 1., 1., 1., 1.])","text_tokens":[".","multiply","]"," ","函数","+","1","divide","形式","array","/","add","=","-","np",",","true","*","arange",")","#","[","6","表达式","(","表达","a","_","subtract","ufunc","达式"],"title":"四则运算","title_tokens":["四则运算","运算","四则"]},{"location":"numpy笔记/6.9.ufunc函数.html#_2","text":"a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 表达式形式 a == b a != b a < b a <= b a > b a >= b # ufunc函数形式 np . equal ( a , b ) np . not_equal ( a , b ) np . less ( a , b ) np . less_equal ( a , b ) np . greater ( a , b ) np . greater_equal ( a , b ) array([[False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False]])","text_tokens":[".",">","]"," ","<","10","函数","equal","30","形式","2","array","b","=","false","np","not","less",",","arange",")","!","20","reshape","#","[","greater","表达式","(","表达","a","_","ufunc","达式"],"title":"比较运算","title_tokens":["比较","运算"]},{"location":"numpy笔记/6.9.ufunc函数.html#_3","text":"a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 与 np . logical_and ( a , b ) # 或 np . logical_or ( a , b ) # 非 np . logical_not ( a , b ) # 异或 np . logical_xor ( a , b ) # 任意一个元素 np . any ( a ) # 全部元素 np . all ( a ) False","text_tokens":[".","any","与"," ","一个","10","and","30","2","非","异或","b","=","false","全部","or","np","not","all",",","arange",")","或","20","reshape","#","logical","任意","_","(","a","xor","元素"],"title":"逻辑运算","title_tokens":["逻辑","逻辑运算","运算"]},{"location":"numpy笔记/6.9.ufunc函数.html#_4","text":"a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) a & b a | b ~ a a ^ b # 按位与 np . bitwise_and ( a , b ) # 按位或 np . bitwise_or ( a , b ) # 按位取反 np . bitwise_not ( a ) # 按位异或 np . bitwise_xor ( a , b ) array([[10, 10, 14, 14, 10, 10, 22, 22, 26, 26], [30, 30, 26, 26, 22, 22, 10, 10, 14, 14]], dtype=int32)","text_tokens":[".","取反","与","]"," ","dtype","10","^","bitwise","and","14","30","2","异或","array","b","=","or","np","not","22","~",",","26","arange",")","或","20","reshape","#","[","|","int32","(","_","a","&","xor","按位"],"title":"位运算","title_tokens":["位","运算"]},{"location":"numpy笔记/6.9.ufunc函数.html#ufunc","text":"可以通过 frompyfunc() 将计算单个元素的函数转换成ufunc函数。调用格式为如下： numpy . frompyfunc ( func , nin , nout ) # func：计算单个元素的函数 # nin：func的输入参数的个数 The number of input # nout：func返回值的个数 The number of output def my_add ( x , y ): z = x + y + 1 return z myufunc = np . frompyfunc ( my_add , 2 , 1 ) a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) myufunc ( a , b ) array([6, 8, 10, 12, 14], dtype=object) 也可以通过 vectorize() 函数来实现 frompyfunc() 的功能。 np . vectorize ( func , otypes = '' , doc = None , excluded = None ) 。 # func：计算单个元素的函数 # otypes：可以是一个表示结果数组元素类型的字符串，也可以是一个类型列表。如果使用类型列表，可以描述多个返回数组的元素类型 # doc：函数的描述字符串。若未给定，则使用func.__doc__ # excluded：指定func中哪些参数未被向量化。你可以指定一个字符串和整数的集合，其中字符串代表关键字参数，整数代表位置参数。 a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) def my_add ( x , num ): z = x + num return z myufunc = np . vectorize ( my_add , doc = \"每一个元素加上一个指定的数\" ) print ( myufunc . __doc__ ) myufunc ( a , 1 ) 每一个元素加上一个指定的数 array([1, 2, 3, 4, 5]) def my_add ( x , y , list_num ): z = x + y for i in list_num : z = z + i return z myufunc = np . vectorize ( my_add , excluded = [ 2 ]) myufunc ( a , b , [ 1 , 2 , 3 ]) # list_num 作为一个list，而不是向量化成一个个元素 array([11, 13, 15, 17, 19]) def my_add ( x , num ): z = x + num return z , z myufunc = np . vectorize ( my_add , otypes = [ np . float , int ]) myufunc ( a , 1 ) (array([1., 2., 3., 4., 5.]), array([1, 2, 3, 4, 5]))","text_tokens":["output","list","for","参数","如果","结果","int","number","10","量化","被","2","array","'","类型","向量","15","输入","通过","字符","nout","#","调用","numpy","描述","未","若","转换成","_","和",".__","位置","in","8","中","不是","可以","转换","关键","dtype","input","函数","object","是","加上","b","add","而","格式","你","其中","z","给定","个个","[","vectorize","nin","doc","为","数组","实现","，","frompyfunc","11","表示","3","13","float","myufunc","]","也","i","otypes","print","返回","func","y","来","关键字","集合","4","=","个数","功能","17",":","：","arange",")","计算","。","excluded","哪些","19","整数","的","x","return","ufunc","列表","12","数",".","如下","of"," ","一个","the","+","1","14","字符串","none","向","单个","\"","多个","将","np","换成","返回值","指定",",","使用","则","5","def","化成","作为","代表","6","my","(","a","每","一个个","元素","num","__"],"title":"自定义 ufunc 函数","title_tokens":["自定义"," ","ufunc","定义","自定","函数"]},{"location":"numpy笔记/6.9.ufunc函数.html#ufunc_1","text":"ufunc函数对象本身还有一些方法。 这些方法只对于两个输入、一个输出的ufunc函数函数有效。对于其他的ufunc函数对象调用这些方法时，会抛出 ValueError 异常。","text_tokens":["异常","对象"," ","一个","函数","输出","、","时","其他","会","这些","方法","输入","只","有效","一些","调用","本身","。","抛出","两个","valueerror","的","ufunc","，","对于","还有"],"title":"ufunc 对象的方法","title_tokens":["对象"," ","的","ufunc","方法"]},{"location":"numpy笔记/6.9.ufunc函数.html#ufuncreduce","text":"ufunc.reduce 方法：类似于Python的 reduce 函数，它==沿着== axis 参数指定的轴，对数组进行操作。经过一次reduce，结果数组的维度降低一维。 假设 <op> 是一个ufunc函数， ufunc.reduce 用法如下： < op >. reduce ( array , axis = 0 , dtype = None ) a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . reduce ( a , axis = 1 ) # 沿着 列方向 array([ 6, 22, 38, 54, 70]) np . add . reduce ( a , axis = 0 ) # 沿着 行方向 array([40, 45, 50, 55]) 相当于将 运算符插入到沿着axis轴的所有元素之间： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) def fun ( a , b ): z = a + b + 1 return z fun2 = np . frompyfunc ( fun , 2 , 1 ) fun2 . reduce ( a , axis = 1 ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] array([9, 25, 41, 57, 73], dtype=object)","text_tokens":["38","参数","它","降低","到","结果","一维","10","沿着","相当于","2","array","假设","15","reduce","于","45","插入","算符","#","运算符","7","55","8","40",">","dtype","函数","用法","是","object","b","add","方法","axis","z","20","类似","reshape","41","[","数组","python","，","54","frompyfunc","11","13","3","进行","16","op","57","维度","相当","]","对","列","print","fun2","操作","50","运算","轴","4","=","17",":","9","：","70","之间","22","arange",")","经过","。","19","方向","的","return","ufunc","12","行","fun","18",".","如下","73"," ","一个","<","+","1","14","当于","一次","25","none","将","所有","np","0","指定",",","5","def","6","(","a","元素"],"title":"ufunc.reduce()","title_tokens":[".","reduce","(",")","ufunc"]},{"location":"numpy笔记/6.9.ufunc函数.html#ufuncaccumulate","text":"ufunc.accumulate 方法：它类似于reduce()的计算过程，但是它会保存所有的中间计算结果，从而使得返回数组的形状和输入数组的形状相同： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . accumulate ( a , axis = 1 ) array([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38], [12, 25, 39, 54], [16, 33, 51, 70]], dtype=int32)","text_tokens":[".","8","使得","38","]","它"," ","但是","结果","39","中间","print","33","返回","dtype","10","51","1","14","27","相同","计算结果","2","array","25","13","4","=","17","add","从而","9","：","accumulate","保存","方法","所有","np","0","reduce","输入","于",",","15","22","arange",")","70","20","5","形状","类似","计算","reshape","[","6","19","int32","axis","(","和","a","数组","的","7","ufunc","过程","，","它会","54","12","11","3","18","16"],"title":"ufunc.accumulate()","title_tokens":[".","(",")","ufunc","accumulate"]},{"location":"numpy笔记/6.9.ufunc函数.html#ufuncouter","text":"ufunc.outer 方法：相当于将 运算符对输入数组A和输入数组B的每一对元素对(a,b)起作用。设A的shape=(4,5)，B的shape为(4,)，则结果数组的shape=(4,5,4) 一维数组和一维数组的outer操作为二维数组 a = np . arange ( 1 , 6 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array([[2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7], [5, 6, 7, 8], [6, 7, 8, 9]]) 多维数组的outer拆分成各自的一维操作 a = np . arange ( 1 , 7 ) . reshape ( 2 , 3 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array ([[[ 2 , 3 , 4 , 5 ], [ 3 , 4 , 5 , 6 ], [ 4 , 5 , 6 , 7 ]], [[ 5 , 6 , 7 , 8 ], [ 6 , 7 , 8 , 9 ], [ 7 , 8 , 9 , 10 ]]])","text_tokens":["作用","一对",".","8","相当","拆","]"," ","对","结果","一维","10","各自","1","操作","当于","运算","相当于","2","array","outer","b","4","=","add","二维","将","9","：","方法","np","输入",",","则","arange","算符",")","5","运算符","reshape","。","[","多维","6","(","和","a","数组","的","每","为","ufunc","，","7","元素","设","3","shape","分成","起"],"title":"ufunc.outer()","title_tokens":[".","(","outer",")","ufunc"]},{"location":"numpy笔记/6.9.ufunc函数.html#_5","text":"下面是一元的数学函数： abs/fabs ：计算整数、浮点数或者复数的绝对值。对于非复数值，可以使用更快的fabs sqrt ：计算平方根，相当于$a^{0.5}$ square ：计算平方，相当于$a^2$ exp ：计算指数$e^x$ log/log10/log2/log1p ：分别为$log_{e}(a), log_{10}(a), log_2(a), log_e(1+x)$ sign ：计算$sign(a)$ ceil ：计算各元素的ceiling值：大于等于该值的最小整数 floor ：计算个元素的floor值：小于等于该值的最大整数 rint ：将各元素四舍五入到最接近的整数，保留 dtype modf ：将数组的小数和整数部分以两个独立数组的形式返回 cos/cosh/sin/sinh/tan/tanh ：普通和双曲型三角函数 arccos/arcsosh/arcsin/arcsinh/arctan/arctanh :反三角函数 isnan ：返回一个布尔数组，该数组指示那些是 NaN isfinite/isinf ：返回一个布尔数组，该数组指示哪些是有限的/无限数","text_tokens":["浮点","更快","log10","到","绝对","10","三角","那些","最","相当于","2","}","该","个","平方","数学","arcsin","isinf","nan","反","有限","_","各","指数","和","对于","cosh","abs","数值","可以","{","dtype","最大","方根","该值","函数","log1p","部分","ceiling","isnan","是","、","sinh","形式","square","$","log","/","无限","cos","大于","modf","双曲","接近","arccos","值","ceil","为","sign","数组","，","独立","相当","三角函数","e","型","arcsosh","0.5","返回","isfinite","^","arctan","一元","arcsinh",":","平方根","：","tanh",")","计算","。","小数","复数","哪些","非复","指示","整数","的","x","数","floor"," ","普通","一个","+","浮点数","点数","1","当于","保留","sqrt","下面","绝对值","小于","tan","将","log2","arctanh",",","使用","四舍五入","exp","fabs","分别","或者","以","sin","布尔","两个","等于","最小","a","(","rint","元素"],"title":"数学函数","title_tokens":["函数","数学"]},{"location":"pandas笔记/7.1.Series.html","text":"import pandas as pd from pandas import Series Series是能够保存任何类型的数据的一维数组。 Series类似numpy的一维ndarray，但是和ndarray又不同，ndarray的所有元素的类型或结构必须相同 1 ，而Series能保存不同类型、结构的数据；另外Series的元素带有索引。Series像一个有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中。 可以通过以下方式创建Series数据结构： 字典 一维NumPy数组 单个标量：数值标量、字符串 list、tuple（可以是多层嵌套的list、tuple） Series类 class pandas.Series(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False) 参数： data ： dict 、 array-like 、 list 、 scalar 。如果是序列或数组，则必须是一维的 如果是字典，则字典的键指定了 label 。如果同时使用了 index ，则以 index 为准。 如果是标量，则结果为：该标量扩充为 index 长度相同的列表。 index ：一个 array-like 或者一个 Index 对象。它指定了 label 。其值要求 hashable ，但不要求惟一，长度与 data 一致。如果未提供，则使用 RangeIndex (0, 1, 2, ..., n) 。 name ： str ， Series 的名字。 dtype ：指定数据类型。如果为 None ，则数据类型被自动推断 copy ：一个布尔值。如果为 True ，则拷贝输入数据 data 还可以通过类方法创建 Series ： Series.from_array(arr, index=None, name=None, dtype=None, copy=False, fastpath=False) 但 from_array 类方法会在未来的版本中被移除。 从 dict 来创建 如果只传入一个字典，则结果Series中的索引就是原字典的键： sdata = { 'Ohio' : 35000 , 'Texas' : 71000 , 'Oregon' : 16000 , 'Utah' : 5000 } # dict的key是无序的，但series的index是有序的 Series ( sdata ) Ohio 35000 Texas 71000 Oregon 16000 Utah 5000 dtype: int64 也可以指定原字典的key的排列顺序： 注意 如果传入dict和并指定index，index需要和dict的键匹配，若index不在dict的key中，对应的series值则为NaN。 sdata = { 'Ohio' : 35000 , 'Texas' : 71000 , 'Oregon' : 16000 , 'Utah' : 5000 } states = [ 'California' , 'Ohio' , 'Oregon' , 'Texas' ] Series ( sdata , index = states ) California NaN Ohio 35000.0 Oregon 16000.0 Texas 71000.0 dtype: float64 从NumPy数组来创建 数组必须是一维的： import numpy as np a = np . array ([ 1 , 2 , 3 ]) Series ( a ) 0 1 1 2 2 3 dtype: int32 从标量创建 如果提供索引，将重复标量值以匹配索引的长度。 Series ( 5 , index = [ 0 , 1 , 2 , 3 ]) 0 5 1 5 2 5 3 5 dtype: int64 实际上numpy可以定义储存不同类型数据的结构数组。 ↩","text_tokens":["list","states","参数","它","如果","结果","一维","多层","未来","被","实际","2","array","'","}","该","名字","data","还","长度","类型","dict","储存","arr","保存","不","输入","通过","另外","字符","true","布尔值","numpy","like","#","未","字典","copy","若","数据类型","重复","因为","nan","35000.0","71000","...","和","_","tuple","许多","提供","移除","）","中","数值","必须","series","惟一","可以","{","71000.0","对应","dtype","能","函数","是","；","key","、","推断","排列","fastpath","为准","california","会","pandas","5000","而","false","在","str","方法","texas","拷贝","值则","不同","类","只","方式","oregon","类似","[","值以","label","值","但","嵌套","原本","数组","为","并","能够","ndarray","，","数据结构","原","3","sdata","name","对象","与","任何","也","]","index","标量","结构","16000","16000.0","相同","来","rangeindex","无序","顺序","=","其值","-",":","：","n",")","import","就是","scalar","扩充","。","像","int32","创建","pd","的","带有","列表","以下","版本",".","了","传入","ohio","用"," ","但是","有序","一个","35000","class","1","又","实际上","映射","字符串","none","单个","定义","索引","数据","将","所有","np","0","↩","同时","utah","指定",",","则","使用","hashable","或","注意","5","从","以","或者","int64","要求","匹配","一致","float64","序列","自动","需要","布尔","(","（","a","from","as","值到","元素","键"],"title":"7.1.Series","title_tokens":[".","7.1","series"]},{"location":"pandas笔记/7.1.Series.html#series","text":"class pandas.Series(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False) 参数： data ： dict 、 array-like 、 list 、 scalar 。如果是序列或数组，则必须是一维的 如果是字典，则字典的键指定了 label 。如果同时使用了 index ，则以 index 为准。 如果是标量，则结果为：该标量扩充为 index 长度相同的列表。 index ：一个 array-like 或者一个 Index 对象。它指定了 label 。其值要求 hashable ，但不要求惟一，长度与 data 一致。如果未提供，则使用 RangeIndex (0, 1, 2, ..., n) 。 name ： str ， Series 的名字。 dtype ：指定数据类型。如果为 None ，则数据类型被自动推断 copy ：一个布尔值。如果为 True ，则拷贝输入数据 data 还可以通过类方法创建 Series ： Series.from_array(arr, index=None, name=None, dtype=None, copy=False, fastpath=False) 但 from_array 类方法会在未来的版本中被移除。","text_tokens":["list","参数","它","如果","结果","一维","未来","2","array","该","名字","data","还","长度","类型","dict","arr","不","输入","通过","true","布尔值","like","未","copy","字典","数据类型","...","_","提供","移除","中","必须","series","惟一","可以","dtype","是","、","推断","fastpath","为准","会","pandas","false","str","在","方法","拷贝","类","label","但","数组","为","，","name","对象","与","index","标量","相同","rangeindex","=","其值","-","：","n",")","scalar","扩充","。","创建","的","列表","版本",".","了"," ","一个","class","1","none","数据","0","同时","指定",",","则","使用","hashable","或","以","或者","要求","一致","序列","自动","布尔","(","from","被","键"],"title":"Series类","title_tokens":["series","类"]},{"location":"pandas笔记/7.1.Series.html#dict","text":"如果只传入一个字典，则结果Series中的索引就是原字典的键： sdata = { 'Ohio' : 35000 , 'Texas' : 71000 , 'Oregon' : 16000 , 'Utah' : 5000 } # dict的key是无序的，但series的index是有序的 Series ( sdata ) Ohio 35000 Texas 71000 Oregon 16000 Utah 5000 dtype: int64 也可以指定原字典的key的排列顺序： 注意 如果传入dict和并指定index，index需要和dict的键匹配，若index不在dict的key中，对应的series值则为NaN。 sdata = { 'Ohio' : 35000 , 'Texas' : 71000 , 'Oregon' : 16000 , 'Utah' : 5000 } states = [ 'California' , 'Ohio' , 'Oregon' , 'Texas' ] Series ( sdata , index = states ) California NaN Ohio 35000.0 Oregon 16000.0 Texas 71000.0 dtype: float64","text_tokens":["传入","sdata","states","中","ohio","]","也","如果","series","结果","一个"," ","{","35000","index","有序","dtype","可以","对应","71000.0","16000","是","key","16000.0","排列","'","}","无序","顺序","california","=","5000","索引","dict",":","在","：","texas","utah","不","指定","只","则",",","值则",")","注意","oregon","#","就是","。","匹配","int64","[","字典","若","float64","nan","需要","但","35000.0","71000","(","和","并","的","为","，","原","键"],"title":"从dict来创建","title_tokens":["创建","从","来","dict"]},{"location":"pandas笔记/7.1.Series.html#numpy","text":"数组必须是一维的： import numpy as np a = np . array ([ 1 , 2 , 3 ]) Series ( a ) 0 1 1 2 2 3 dtype: int32","text_tokens":[".","]","必须"," ","series","一维","dtype","1","是","2","array","=",":","：","np","0",",",")","import","numpy","[","int32","(","a","数组","的","as","3"],"title":"从NumPy数组来创建","title_tokens":["来","创建","数组","numpy","从"]},{"location":"pandas笔记/7.1.Series.html#_1","text":"如果提供索引，将重复标量值以匹配索引的长度。 Series ( 5 , index = [ 0 , 1 , 2 , 3 ]) 0 5 1 5 2 5 3 5 dtype: int64 实际上numpy可以定义储存不同类型数据的结构数组。 ↩","text_tokens":["]","如果"," ","index","series","可以","标量","结构","dtype","1","实际上","实际","2","=","定义","索引","长度","类型","数据",":","储存","将","0","↩","不同",",",")","5","numpy","。","匹配","值以","[","int64","重复","(","数组","的","，","提供","3"],"title":"从标量创建","title_tokens":["创建","标量","从"]},{"location":"pandas笔记/7.2.DataFrame.html","text":"from pandas import DataFrame from pandas import Series import numpy as np DataFrame类 DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型 1 （数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做是Series的容器。 pandas中的 DataFrame 可以使用以下构造函数创建 - pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) data ：数据可以是各种形式，如: ndarray ， series ， map ， lists ， dict ， constant 和另一个 DataFrame 。 index ：行标签。默认为 np.arrange(n) 。 columns ：列标签。默认为 np.arrange(n) 。 dtype ：数据类型。 copy ：是否复制数据。 可以输入给DataFrame构造器的数据： 类型 说明 二维ndarray 由数组、列表或元组组成的字典 每个序列作为DataFrame的一列。 所有序列的长度必须相同 。 NumPy的结构化/记录数组 类似于“由数组组成的字典” 由Series组成的字典 每个Series会成为一列。如果没有显式指定index，则 各Series的index会被合并成结果的行索引。 每个Series的长度不要求必须相同 ，DataFrame会以NaN填充。 由字典组成的字典 各内层字典会成为一列。键会被合并成结果的行索 弓丨，跟由“Series组成的字典”的情况一样 字典或Series的列表 各项将会成为DataFrame的一行。字典键或Series索引 的并集将会成为DataFrame的列标 由list或tuple组成的list 类似于“二维ndarray” 另—个DataFrame 该DataFrame的索引将会被沿用，除非显式指定了其他索引 NumPy 的 Masked Array 类似于“二维ndarray”的情况，只是掩码值在结果 DataFrame会变成NA/缺失值 总的来说，支持输入的数据类型是： dict 、 list 、 ndarray 、 DataFrame 。 从列表创建 可以使用 单个列表 或 列表内嵌列表 来创建DataFrame。 单个列表的例子： data = [ 1 , 2 , 3 , 4 , 5 ] DataFrame ( data ) 0 0 1 1 2 2 3 3 4 4 5 列表内嵌列表的例子： data = [[ 'Alex' , 10 ],[ 'Bob' , 12 ],[ 'Clarke' , 13 ]] DataFrame ( data , columns = [ 'Name' , 'Age' ]) Name Age 0 Alex 10 1 Bob 12 2 Clarke 13 从包含ndarrays/Lists的字典创建 传入一个由等长list或ndarray组成的字典： 结果DataFrame会自动加上索引（跟Series一样），且全部列 会被有序排列。 data = { 'state' : [ 'Ohio' , 'Ohio' , 'Ohio' , 'Nevada' , 'Nevada' ], 'year' : [ 2000 , 2001 , 2002 , 2001 , 2002 ], 'pop' : [ 1.5 , 1.7 , 3.6 , 2.4 , 2.9 ]} DataFrame ( data ) state year pop 0 Ohio 2000 1.5 1 Ohio 2001 1.7 2 Ohio 2002 3.6 3 Nevada 2001 2.4 4 Nevada 2002 2.9 如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列： DataFrame ( data , columns = [ 'year' , 'state' , 'pop' ]) year state pop 0 2000 Ohio 1.5 1 2001 Ohio 1.7 2 2002 Ohio 3.6 3 2001 Nevada 2.4 4 2002 Nevada 2.9 从字典列表创建 data = [{ 'a' : 1 , 'b' : 2 },{ 'a' : 5 , 'b' : 10 , 'c' : 20 }] DataFrame ( data , index = [ 'first' , 'second' ]) a b c first 1 2 NaN second 5 10 20.0 从Series的字典创建 d = { 'one' : Series ([ 1 , 2 , 3 ], index = [ 'a' , 'b' , 'c' ]), 'two' : Series ([ 1 , 2 , 3 , 4 ], index = [ 'a' , 'b' , 'c' , 'd' ])} df = DataFrame ( d ) df [[ \"two\" , \"two\" ]] two two a 1 1 b 2 2 c 3 3 d 4 4 替代构造函数 DataFrame.from_dict DataFrame.from_dict(data, orient=\"columns\", dtype=None, columns=None) DataFrame.from_dict 接受dict或类似数组的序列的dict并返回DataFrame。 DataFrame . from_dict ( dict ([( 'A' , [ 1 , 2 , 3 ]), ( 'B' , [ 4 , 5 , 6 ])])) DataFrame . from_dict ( dict ([( 'A' , [ 1 , 2 , 3 ]), ( 'B' , [ 4 , 5 , 6 ])]), orient = 'index' , columns = [ 'one' , 'two' , 'three' ]) one two three A 1 2 3 B 4 5 6 DataFrame.from_records DataFrame.from_records( data, index=None, exclude=None, columns=None, coerce_float=False, nrows=None, ) DataFrame.from_records 接受具有结构化dtype的元组或ndarray的列表。它与普通的 DataFrame 构造函数相似，除了所得的DataFrame索引可能是结构化dtype的特定字段。例如： data = np . array ([( 1 , 2. , b 'Hello' ), ( 2 , 3. , b 'World' )], dtype = [( 'A' , '<i4' ), ( 'B' , '<f4' ), ( 'C' , 'S10' )]) DataFrame . from_records ( data , index = 'C' ) A B C b'Hello' 1 2.0 b'World' 2 3.0 DataFrame.from_items DataFrame . from_items ( items , columns = None , orient = 'columns' ) # items ：为元组序列，元组格式为： ( key , value ) # 当 orient = 'index' 时必须传入（此时 key 指定的是行的 label ），且长度不能大于 DataFrame的列数 。 # 当 orient = ' columns时 ， key就是列的label ，此时 columns关键字参数指定的列label必须等于某个key ；否则抛出异常。 从元组序列中创建 DataFrame 。 实际上，DataFrame每一个值都可以是不同的数据类型。 ↩","text_tokens":["例子","f4","list","构造函数","dataframe","参数","它","如果","字","构造","结果","value","成","不能","10","exclude","说明","—","除了","实际","时","由","2","array","'","}","每列","该","first","data","个","two","长度","类型","dict","d","2000","不","alex","输入","默认","于","将会","字符","second","合并","na","three","布尔值","numpy","#","缺失","含有","copy","字典","长","数据类型","s10","nan","支持","_","和","各","tuple","掩码","看做","每个","lists","段","一行","）","各项","中","数值","必须","series","可以","总的来说","{","关键","bob","否则","dtype","函数","显式","所得","2002","是","“","key","；","、","形式","排列","加上","当","b","来说","成为","会","pandas","/","3.6","格式","false","二维","在","全部","某个","一样","year","2001","不同","类","20","填充","类似","大于","[","nrows","此时","元组","label","值","1.5","一组","ndarrays","为","数组","并","复制","，","ndarray","数据结构","3.0","3","13","进行","例如","按照","name","float","与","]","也","型","列","index","constant","列数","结构","有列","没有","标签","除非","age","返回","都","列标","等","相同","来","c","记录","关键字","集","另","pop","顺序","4","=","替代","且","-",":","相似","2.9","是否","：","i4","情况","全部列","n","masked",")","内层","丨","import","就是","。","clarke","如","创建","的","各种","nevada","特定","结构化","one","列表","行","行索","12","就","以下","接受","一列","2.4","表格",".","给","了","传入","内嵌","ohio","异常"," ","有序","普通","一个","弓","world","items","<","1.7","orient","1","会以","具有","实际上","既有","records","hello","字符串","2.0","map","其他","none","单个","索引","数据","\"","将","所有","np","沿用","0","↩","指定",",","使用","则","跟","state","或","5","”","容器","columns","作为","只是","从","包含","要求","df","器","6","可能","抛出","coerce","序列","自动","变成","布尔","(","等于","（","arrange","a","20.0","from","每","as","键会","被","组成","键"],"title":"7.2.DataFrame","title_tokens":["7.2",".","dataframe"]},{"location":"pandas笔记/7.2.DataFrame.html#dataframe","text":"DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型 1 （数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做是Series的容器。 pandas中的 DataFrame 可以使用以下构造函数创建 - pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) data ：数据可以是各种形式，如: ndarray ， series ， map ， lists ， dict ， constant 和另一个 DataFrame 。 index ：行标签。默认为 np.arrange(n) 。 columns ：列标签。默认为 np.arrange(n) 。 dtype ：数据类型。 copy ：是否复制数据。 可以输入给DataFrame构造器的数据： 类型 说明 二维ndarray 由数组、列表或元组组成的字典 每个序列作为DataFrame的一列。 所有序列的长度必须相同 。 NumPy的结构化/记录数组 类似于“由数组组成的字典” 由Series组成的字典 每个Series会成为一列。如果没有显式指定index，则 各Series的index会被合并成结果的行索引。 每个Series的长度不要求必须相同 ，DataFrame会以NaN填充。 由字典组成的字典 各内层字典会成为一列。键会被合并成结果的行索 弓丨，跟由“Series组成的字典”的情况一样 字典或Series的列表 各项将会成为DataFrame的一行。字典键或Series索引 的并集将会成为DataFrame的列标 由list或tuple组成的list 类似于“二维ndarray” 另—个DataFrame 该DataFrame的索引将会被沿用，除非显式指定了其他索引 NumPy 的 Masked Array 类似于“二维ndarray”的情况，只是掩码值在结果 DataFrame会变成NA/缺失值 总的来说，支持输入的数据类型是： dict 、 list 、 ndarray 、 DataFrame 。","text_tokens":["list","构造函数","dataframe","它","如果","构造","结果","成","说明","—","由","array","每列","该","data","个","长度","类型","dict","不","输入","默认","于","将会","字符","合并","na","布尔值","numpy","缺失","含有","copy","字典","数据类型","nan","支持","和","各","tuple","掩码","看做","每个","lists","一行","）","各项","中","数值","必须","series","可以","总的来说","dtype","函数","显式","是","“","、","形式","来说","成为","会","pandas","/","false","二维","在","一样","不同","填充","类似","元组","值","一组","为","数组","并","复制","，","ndarray","数据结构","也","型","列","index","constant","结构","有列","没有","标签","除非","列标","等","相同","记录","集","另","=","-",":","是否","：","情况","n","masked",")","内层","丨","。","如","创建","的","各种","结构化","列表","行","行索","以下","一列","表格",".","给","了","有序"," ","一个","弓","1","会以","既有","字符串","map","其他","none","索引","数据","将","所有","np","沿用","指定",",","使用","则","跟","或","”","容器","columns","作为","只是","要求","器","序列","变成","布尔","(","（","arrange","键会","被","组成","键"],"title":"DataFrame类","title_tokens":["dataframe","类"]},{"location":"pandas笔记/7.2.DataFrame.html#_1","text":"可以使用 单个列表 或 列表内嵌列表 来创建DataFrame。 单个列表的例子： data = [ 1 , 2 , 3 , 4 , 5 ] DataFrame ( data ) 0 0 1 1 2 2 3 3 4 4 5 列表内嵌列表的例子： data = [[ 'Alex' , 10 ],[ 'Bob' , 12 ],[ 'Clarke' , 13 ]] DataFrame ( data , columns = [ 'Name' , 'Age' ]) Name Age 0 Alex 10 1 Bob 12 2 Clarke 13","text_tokens":["例子","dataframe","内嵌","name","]"," ","可以","bob","age","10","1","来","2","'","13","单个","data","=","4","：","0","alex",",","使用",")","或","5","columns","。","[","clarke","创建","(","的","列表","12","3"],"title":"从列表创建","title_tokens":["创建","从","列表"]},{"location":"pandas笔记/7.2.DataFrame.html#ndarrayslists","text":"传入一个由等长list或ndarray组成的字典： 结果DataFrame会自动加上索引（跟Series一样），且全部列 会被有序排列。 data = { 'state' : [ 'Ohio' , 'Ohio' , 'Ohio' , 'Nevada' , 'Nevada' ], 'year' : [ 2000 , 2001 , 2002 , 2001 , 2002 ], 'pop' : [ 1.5 , 1.7 , 3.6 , 2.4 , 2.9 ]} DataFrame ( data ) state year pop 0 Ohio 2000 1.5 1 Ohio 2001 1.7 2 Ohio 2002 3.6 3 Nevada 2001 2.4 4 Nevada 2002 2.9 如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列： DataFrame ( data , columns = [ 'year' , 'state' , 'pop' ]) year state pop 0 2000 Ohio 1.5 1 2001 Ohio 1.7 2 2002 Ohio 3.6 3 2001 Nevada 2.4 4 2002 Nevada 2.9","text_tokens":["传入","list","）","dataframe","了","按照","ohio","]"," ","series","结果","一个","有序","{","如果","列","1.7","1","2002","等","由","排列","加上","'","pop","3.6","}","会","2","4","data","=","索引","且","顺序","全部",":","2.9","：","2000","0","一样","year","全部列","2001","state",",","指定","则","跟",")","或","columns","。","[","字典","长","序列","自动","1.5","(","（","的","nevada","ndarray","，","被","就","3","组成","进行","2.4"],"title":"从包含ndarrays/Lists的字典创建","title_tokens":["创建","ndarrays","的","/","包含","从","lists","字典"]},{"location":"pandas笔记/7.2.DataFrame.html#_2","text":"data = [{ 'a' : 1 , 'b' : 2 },{ 'a' : 5 , 'b' : 10 , 'c' : 20 }] DataFrame ( data , index = [ 'first' , 'second' ]) a b c first 1 2 NaN second 5 10 20.0","text_tokens":["dataframe","]"," ","index","{","10","1","c","first","2","'","}","b","data","=",":",",","second",")","5","20","[","nan","(","a","20.0"],"title":"从字典列表创建","title_tokens":["创建","字典","从","列表"]},{"location":"pandas笔记/7.2.DataFrame.html#series","text":"d = { 'one' : Series ([ 1 , 2 , 3 ], index = [ 'a' , 'b' , 'c' ]), 'two' : Series ([ 1 , 2 , 3 , 4 ], index = [ 'a' , 'b' , 'c' , 'd' ])} df = DataFrame ( d ) df [[ \"two\" , \"two\" ]] two two a 1 1 b 2 2 c 3 3 d 4 4","text_tokens":["dataframe","]"," ","series","index","{","1","c","2","'","}","b","4","=","two","\"",":","d",",",")","[","df","(","a","one","3"],"title":"从Series的字典创建","title_tokens":["创建","series","的","从","字典"]},{"location":"pandas笔记/7.2.DataFrame.html#_3","text":"","text_tokens":[],"title":"替代构造函数","title_tokens":["替代","函数","构造函数","构造"]},{"location":"pandas笔记/7.2.DataFrame.html#dataframefrom_dict","text":"DataFrame.from_dict(data, orient=\"columns\", dtype=None, columns=None) DataFrame.from_dict 接受dict或类似数组的序列的dict并返回DataFrame。 DataFrame . from_dict ( dict ([( 'A' , [ 1 , 2 , 3 ]), ( 'B' , [ 4 , 5 , 6 ])])) DataFrame . from_dict ( dict ([( 'A' , [ 1 , 2 , 3 ]), ( 'B' , [ 4 , 5 , 6 ])]), orient = 'index' , columns = [ 'one' , 'two' , 'three' ]) one two three A 1 2 3 B 4 5 6","text_tokens":[".","dataframe","]"," ","index","dtype","返回","orient","1","2","'","b","none","4","data","=","two","\"","dict",",",")","或","5","three","类似","columns","。","[","6","序列","_","(","a","数组","的","并","from","接受","one","3"],"title":"DataFrame.from_dict","title_tokens":[".","dataframe","_","from","dict"]},{"location":"pandas笔记/7.2.DataFrame.html#dataframefrom_records","text":"DataFrame.from_records( data, index=None, exclude=None, columns=None, coerce_float=False, nrows=None, ) DataFrame.from_records 接受具有结构化dtype的元组或ndarray的列表。它与普通的 DataFrame 构造函数相似，除了所得的DataFrame索引可能是结构化dtype的特定字段。例如： data = np . array ([( 1 , 2. , b 'Hello' ), ( 2 , 3. , b 'World' )], dtype = [( 'A' , '<i4' ), ( 'B' , '<f4' ), ( 'C' , 'S10' )]) DataFrame . from_records ( data , index = 'C' ) A B C b'Hello' 1 2.0 b'World' 2 3.0","text_tokens":["f4",".","构造函数","dataframe","float","与","]","它"," ","普通","index","构造","字","结构","dtype","world","<","函数","exclude","1","所得","是","records","2.0","除了","c","2","array","'","b","none","data","=","索引","false","相似","：","np","i4",",",")","或","columns","hello","。","nrows","可能","[","元组","3.0","coerce","s10","_","(","a","的","from","ndarray","，","特定","3","接受","列表","结构化","段","例如","具有"],"title":"DataFrame.from_records","title_tokens":[".","records","dataframe","_","from"]},{"location":"pandas笔记/7.2.DataFrame.html#dataframefrom_items","text":"DataFrame . from_items ( items , columns = None , orient = 'columns' ) # items ：为元组序列，元组格式为： ( key , value ) # 当 orient = 'index' 时必须传入（此时 key 指定的是行的 label ），且长度不能大于 DataFrame的列数 。 # 当 orient = ' columns时 ， key就是列的label ，此时 columns关键字参数指定的列label必须等于某个key ；否则抛出异常。 从元组序列中创建 DataFrame 。 实际上，DataFrame每一个值都可以是不同的数据类型。 ↩","text_tokens":[".","传入","）","dataframe","异常","中","参数","必须"," ","index","列","列数","value","关键","否则","一个","items","不能","可以","orient","实际上","都","是","key","；","关键字","实际","时","'","当","none","=","格式","且","长度","数据","某个","类型","：","↩","不同","指定",",",")","#","大于","columns","就是","从","。","抛出","此时","元组","数据类型","序列","label","值","创建","_","(","（","为","的","等于","from","，","每","行"],"title":"DataFrame.from_items","title_tokens":[".","dataframe","_","from","items"]},{"location":"pandas笔记/7.3.索引.html","text":"Windows 10 Python 3.7.3 @ MSC v.1915 64 bit (AMD64) from tools import Help as H import numpy as np import pandas as pd Series和DataFrame的索引方式很相似： 都可以通过 .loc[] 使用 标签 选择行 都可以通过 .iloc[] 使用 整数 选择行 都可以通过 [] 使用 切片 选择行 但他们的索引方式也有一些不同点： Series可以通过 属性访问 的方式，使用 标签 选择行 .row_index ；DataFrame通过属性访问的方式选择列 .column_index Series可以通过 [] 使用 整数 、 标签 选择行 [row_index] ；DataFrame只能通过 [column_index] 使用 列标签 选择列 创建示例Series和DataFrame： ser = pd . Series ([ 4.5 , 7.2 , - 5.3 , 3.6 , 6.1 ], index = [ 'd' , 'b' , 'a' , 'c' , 'b' ]) print ( ser ) d 4.5 b 7.2 a -5.3 c 3.6 b 6.1 dtype: float64 d = { 'one' : pd . Series ([ 1 , 2 , 3 , 5 ], index = [ 'a' , 'b' , 'c' , 'e' ]), 'two' : pd . Series ([ 1 , 2 , 3 , 4 , 5 ], index = [ 'a' , 'b' , 'c' , 'd' , 'e' ])} df = pd . DataFrame ( d ) print ( df ) one two a 1.0 1 b 2.0 2 c 3.0 3 d NaN 4 e 5.0 5 通过行标签选择行 # Series print ( ser . b ) print ( ser [ \"b\" ]) print ( ser . loc [ \"b\" ]) b 7.2 b 6.1 dtype: float64 b 7.2 b 6.1 dtype: float64 b 7.2 b 6.1 dtype: float64 # DataFrame df . loc [ \"a\" ] one 1.0 two 1.0 Name: a, dtype: float64 通过行标签选择多行 # Series ser [[ \"b\" , \"a\" ]] ser . loc [[ \"b\" , \"a\" ]] b 7.2 b 6.1 a -5.3 dtype: float64 # DataFrame df . loc [[ \"a\" , \"b\" ]] one two a 1.0 1 b 2.0 2 不能使用 () ser . loc [( \"b\" , \"a\" )] ---------------------------------------------------------------------------IndexingError Traceback (most recent call last)<ipython-input-1-36ce192f3c34> in <module> ----> 1 ser.loc[(\"b\", \"a\")] G:\\Installed\\Anaconda3\\lib\\site-packages\\pandas\\core\\indexing.py in __getitem__(self, key) 1416 except (KeyError, IndexError, AttributeError): 1417 pass -> 1418 return self._getitem_tuple(key) 1419 else: 1420 # we by definition only have the 0th axis G:\\Installed\\Anaconda3\\lib\\site-packages\\pandas\\core\\indexing.py in _getitem_tuple(self, tup) 808 809 # no multi-index, so validate all of the indexers --> 810 self._has_valid_tuple(tup) 811 812 # ugly hack for GH #836 G:\\Installed\\Anaconda3\\lib\\site-packages\\pandas\\core\\indexing.py in _has_valid_tuple(self, key) 231 for i, k in enumerate(key): 232 if i >= self.obj.ndim: --> 233 raise IndexingError(\"Too many indexers\") 234 try: 235 self._validate_key(k, i) IndexingError: Too many indexers 通过整数选择行 # Series ser [ 1 ] ser . iloc [ 1 ] 7.2 # DataFrame df . iloc [ 0 ] one 1.0 two 1.0 Name: a, dtype: float64 通过整数选择多行 # Series ser [[ 1 , 0 ]] ser . iloc [[ 1 , 0 ]] b 7.2 d 4.5 dtype: float64 # DataFrame df . iloc [[ 0 , 1 ]] one two a 1.0 1 b 2.0 2 通过切片选择多行 切片包括 整数切片 和 标签切片 。 # Series ser [ 1 : 3 ] ser . iloc [ 1 : 3 ] b 7.2 a -5.3 dtype: float64 # DataFrame print ( df [ 0 : 3 : 2 ]) print ( df [ 0 : 2 ]) one two a 1.0 1 c 3.0 3 one two a 1.0 1 b 2.0 2 切片有整数值的普通切片和标签切片。 利用标签的切片运算与普通的Python切片运算不同，其末端是包含的（inclusive），即封闭区间。 # Series print ( ser [ 0 : 2 ]) print ( ser [ \"d\" : \"a\" ]) d 4.5 b 7.2 dtype: float64 d 4.5 b 7.2 a -5.3 dtype: float64 # DataFrame print ( df [ \"a\" : \"c\" ]) print ( df . iloc [ 0 : 3 : 2 ]) one two a 1.0 1 b 2.0 2 c 3.0 3 one two a 1.0 1 c 3.0 3 通过列标签选择列 与Series不同的是，DataFrame还有列选择。但是DataFrame的列选择和行选择不同。 DataFrame的行可以同时有 整数索引 和 标签索引 ，如果没有给标签赋值，则只有整数值索引。 DataFrame的列在标签赋值后，只能使用标签索引。 选取DataFrame的列，实际上是获取了一个Series，返回的Series拥有原DataFrame相同的行索引。 print ( df . one ) print ( df [ \"one\" ]) a 1.0 b 2.0 c 3.0 d NaN e 5.0 Name: one, dtype: float64 a 1.0 b 2.0 c 3.0 d NaN e 5.0 Name: one, dtype: float64 通过列标签选择多列 df [[ \"one\" , \"two\" ]] one two a 1.0 1 b 2.0 2 c 3.0 3 d NaN 4 e 5.0 5 注意： 通过索引方式返回的列只是相应数据的视图而已， 并不是副本。因此，对返回的Series所做的任何修改全都会反映到原DataFrame上。通过Series的copy方法即可显式地复制列。 df [ \"one\" ][ \"a\" ] = np . nan df . \\ setup_m . py : 1 : SettingWithCopyWarning : A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation : http : // pandas . pydata . org / pandas - docs / stable / user_guide / indexing . html #returning-a-view-versus-a-copy import os one two a NaN 1 b 2.0 2 c 3.0 3 d NaN 4 e 5.0 5 行列同时索引 df . loc [ \"c\" , \"one\" ] df . iloc [ 2 , 0 ] df . loc [ \"c\" , [ \"one\" , \"two\" ]] df . iloc [ 2 , [ 0 , 1 ]] one 3.0 two 3.0 Name: c, dtype: float64 先选择列，在选择行 df [ \"one\" ][ \"c\" ] 3.0 关于索引的其它 对Series进行运算（布尔索引过滤、标量乘法、数学函数等），都会保留标签和值之间的链接。 Series的标签可以通过赋值的方式进行修改： s = pd . Series ([ 1 , 2 , 3 , 4 , 5 ], index = [ 'a' , 'b' , 'c' , 'd' , 'e' ]) s . index = [ 'f' , 'b' , 'c' , 'd' , 'e' ] s f 1 b 2 c 3 d 4 e 5 dtype: int64 虽然很多时候都强调轴标签（索引值）要唯一，但这并不是强制性的。来看看下面这个简单的带有重复索引值的Series： obj = pd . Series ( range ( 5 ), index = [ 'a' , 'a' , 'b' , 'b' , 'c' ]) obj a 0 a 1 b 2 b 3 c 4 dtype: int64 索引的is_unique属性可以告诉你它的值是否是唯一的 obj . index . is_unique False 对于带有重复值的索引，数据选取的行为将会有些不同。如果某个索引对应多个值，则返回一个Series；而对应单个值的，则返回一个标量值。对DataFrame的行进行索引时也是如此。 get 方法 Series或DataFrame中的每一个都有一个 get 可以返回默认值的方法。 ser . get ( \"a\" ) -5.3 df . get ( \"onef\" , 5 ) 5 lookup 方法 给定一系列行标签和列标签的情况下提取一组值： # 返回 ('c','one') 和 ('b','two') df . lookup ([ \"c\" , \"b\" ], [ \"one\" , \"two\" ]) array([3., 2.]) 索引方式总结表 类型 df[val] 从DataFrame选取单列或一组列； 在特殊情况下比较便利：布尔型数组（过滤行）、切片（行切片）、或布尔型DataFrame (根据条件设置值） df.loc[val] 通过标签，选取DataFrame的单个行或一组行 df.loc[:, val] 通过标签，选取单列或列子集 df.loc[val1, val2] 通过标签，同时选取行和列 df.iloc[where] 通过整数位置，从DataFrame选取单个行或行子集 df.iloc[:, where] 通过整数位置，从DataFrame选取单个列或列子集 df.iloc[where_i, where_j] 通过整数位置，同时选取行和列 df.at [label_i, label_j] 通过行和列标签，选取单一的标量 df.iat[i, j] 通过行和列的位置（整数），选取单一的标量 reindex 通过标签选取行或列 get _value, set_value 通过行和列标签选取单一值","text_tokens":["versus","赋值","so","self","234","行列","10","indexers","1417","单一","'","two","强制性","唯一","数学","set","默认","即可","链接","definition","lookup","copy","行为","tuple","valid","修改","in","他们","这","对于","808","还有","reindex","tup","64","不是","row","{","对应","是","pandas","条件","range","val","某个","be","看看","方式","tools","给定","是否是","label","一组","只能","并","python","复制","gh","iat","原","3","onef","where","many","访问","等","包括","相同","来","----","is","7.2",")","。","to","anaconda3","m","的","其","因此","attributeerror","has","1416","了","ugly"," ","普通","很多","help","h","<","trying","2.0","1418","这个","6.1","单个","先","all","使用","则","或","5","int64","df","即","子集","a","而已","val1","at","很","traceback","它","value","inclusive","documentation","unique","last","docs","实际","2","}","amd64","系列","\\","810","获取","try","重复","nan","_","和","位置","._","we","中","选取","series","811","做","切片","如此","示例","显式","函数","235","和行","多列","；","总结","b","关于","stable","而","false","3.7","简单","setup","不同","乘法","数组","，","ndim","与","]","e","index","列","型","guide","print","没有","都","c","only","getitem","轴","=","caveats","相似","告诉","import","1420","视图","时候","ser","整数","lib","或列","one","给","of","pydata","the","1","实际上","全都","设置","下面","多个","有","单列","注意","包含","j","except","obj","默认值","(","http","packages","raise","不同点","s","如果","到","installed","else","时","array","类型","有些","slice","no","通过","将会","利用","msc","一些","---------------------------------------------------------------------------","ipython","call","所","末端","可以","keyerror","dtype","input","key","3.6","@","会","你","see","方法","axis","k","属性","[","相应","要","值","812","进行","view","选择","name","任何","对","标量","column","windows","反映","val2","只有","get","4",":","是否","html","loc","之间","情况","bit","f","5.0","most","indexingerror","创建","pd","1419","returning","v.1915",".","表","os","user","但是","一个","iloc","索引","\"","multi","enumerate","if","0","只是","布尔","（","地","强调","809","--","pass","dataframe","for","封闭","虽然","不能","后","core","d","根据","org","5.3","特殊","#","numpy","on","indexing","同点","）","比较","too",">","4.5","module","、","提取","/","在","36ce192f3c34","拥有","行或行","上","g","recent","但","一系","have","3.0","232","indexerror","也","i","区间","validate","便利","多行","行或列","返回","标签","行和列","运算","-","：","1.0","hack","233","836","一系列","其它","return","带有","行","settingwithcopywarning","0th","by","副本","保留","231","py","强制","数据","np","过滤","同时",",","site","从","float64","下","每","from","as","__"],"title":"7.3.索引","title_tokens":[".","7.3","索引"]},{"location":"pandas笔记/7.3.索引.html#_1","text":"# Series print ( ser . b ) print ( ser [ \"b\" ]) print ( ser . loc [ \"b\" ]) b 7.2 b 6.1 dtype: float64 b 7.2 b 6.1 dtype: float64 b 7.2 b 6.1 dtype: float64 # DataFrame df . loc [ \"a\" ] one 1.0 two 1.0 Name: a, dtype: float64","text_tokens":[".","dataframe","name","]"," ","series","print","dtype","b","6.1","two","\"",":","loc",",","7.2",")","1.0","#","[","df","float64","ser","(","a","one"],"title":"通过行标签选择行","title_tokens":["标签","选择","行","通过"]},{"location":"pandas笔记/7.3.索引.html#_2","text":"# Series ser [[ \"b\" , \"a\" ]] ser . loc [[ \"b\" , \"a\" ]] b 7.2 b 6.1 a -5.3 dtype: float64 # DataFrame df . loc [[ \"a\" , \"b\" ]] one two a 1.0 1 b 2.0 2 不能使用 () ser . loc [( \"b\" , \"a\" )] ---------------------------------------------------------------------------IndexingError Traceback (most recent call last)<ipython-input-1-36ce192f3c34> in <module> ----> 1 ser.loc[(\"b\", \"a\")] G:\\Installed\\Anaconda3\\lib\\site-packages\\pandas\\core\\indexing.py in __getitem__(self, key) 1416 except (KeyError, IndexError, AttributeError): 1417 pass -> 1418 return self._getitem_tuple(key) 1419 else: 1420 # we by definition only have the 0th axis G:\\Installed\\Anaconda3\\lib\\site-packages\\pandas\\core\\indexing.py in _getitem_tuple(self, tup) 808 809 # no multi-index, so validate all of the indexers --> 810 self._has_valid_tuple(tup) 811 812 # ugly hack for GH #836 G:\\Installed\\Anaconda3\\lib\\site-packages\\pandas\\core\\indexing.py in _has_valid_tuple(self, key) 231 for i, k in enumerate(key): 232 if i >= self.obj.ndim: --> 233 raise IndexingError(\"Too many indexers\") 234 try: 235 self._validate_key(k, i) IndexingError: Too many indexers","text_tokens":["pass","dataframe","for","traceback","so","self","234","不能","installed","else","indexers","last","1417","2","two","\\","core","5.3","810","no","#","try","definition","---------------------------------------------------------------------------","indexing","_","tuple","valid","in","ipython","808","call","tup","._","we","too",">","series","811","keyerror","dtype","input","235","module","key","b","pandas","36ce192f3c34","axis","k","[","g","recent","812","gh","have","232","indexerror","ndim","]","i","index","validate","many","only","getitem","----","=",":","-","loc","7.2",")","1.0","hack","raise","233","1420","most","indexingerror","836","anaconda3","ser","1419","return","lib","one","attributeerror","has","1416",".","0th","of","ugly"," ","by","<","the","1","2.0","1418","231","py","6.1","\"","multi","enumerate","if","all",",","使用","site","except","df","float64","obj","(","a","packages","809","__","--"],"title":"通过行标签选择多行","title_tokens":["选择","通过","多行","行","标签"]},{"location":"pandas笔记/7.3.索引.html#_3","text":"# Series ser [ 1 ] ser . iloc [ 1 ] 7.2 # DataFrame df . iloc [ 0 ] one 1.0 two 1.0 Name: a, dtype: float64","text_tokens":[".","dataframe","name","]"," ","series","dtype","1","iloc","two",":","0",",","7.2","1.0","#","[","df","float64","ser","a","one"],"title":"通过整数选择行","title_tokens":["整数","行","选择","通过"]},{"location":"pandas笔记/7.3.索引.html#_4","text":"# Series ser [[ 1 , 0 ]] ser . iloc [[ 1 , 0 ]] b 7.2 d 4.5 dtype: float64 # DataFrame df . iloc [[ 0 , 1 ]] one two a 1.0 1 b 2.0 2","text_tokens":[".","dataframe","4.5","]"," ","series","dtype","1","iloc","2.0","2","b","two",":","d","0",",","7.2","1.0","#","[","df","float64","ser","a","one"],"title":"通过整数选择多行","title_tokens":["整数","多行","选择","通过"]},{"location":"pandas笔记/7.3.索引.html#_5","text":"切片包括 整数切片 和 标签切片 。 # Series ser [ 1 : 3 ] ser . iloc [ 1 : 3 ] b 7.2 a -5.3 dtype: float64 # DataFrame print ( df [ 0 : 3 : 2 ]) print ( df [ 0 : 2 ]) one two a 1.0 1 c 3.0 3 one two a 1.0 1 b 2.0 2 切片有整数值的普通切片和标签切片。 利用标签的切片运算与普通的Python切片运算不同，其末端是包含的（inclusive），即封闭区间。 # Series print ( ser [ 0 : 2 ]) print ( ser [ \"d\" : \"a\" ]) d 4.5 b 7.2 dtype: float64 d 4.5 b 7.2 a -5.3 dtype: float64 # DataFrame print ( df [ \"a\" : \"c\" ]) print ( df . iloc [ 0 : 3 : 2 ]) one two a 1.0 1 b 2.0 2 c 3.0 3 one two a 1.0 1 c 3.0 3","text_tokens":[".","）","dataframe","封闭","4.5","与","]","区间"," ","series","普通","末端","切片","inclusive","print","dtype","标签","1","iloc","是","包括","c","2.0","运算","2","b","two","\"",":","-","d","有","0","5.3","不同","7.2","利用",")","1.0","#","包含","。","[","df","float64","即","值","ser","整数","和","a","(","的","其","python","，","（","one","3.0","3"],"title":"通过切片选择多行","title_tokens":["切片","多行","选择","通过"]},{"location":"pandas笔记/7.3.索引.html#_6","text":"与Series不同的是，DataFrame还有列选择。但是DataFrame的列选择和行选择不同。 DataFrame的行可以同时有 整数索引 和 标签索引 ，如果没有给标签赋值，则只有整数值索引。 DataFrame的列在标签赋值后，只能使用标签索引。 选取DataFrame的列，实际上是获取了一个Series，返回的Series拥有原DataFrame相同的行索引。 print ( df . one ) print ( df [ \"one\" ]) a 1.0 b 2.0 c 3.0 d NaN e 5.0 Name: one, dtype: float64 a 1.0 b 2.0 c 3.0 d NaN e 5.0 Name: one, dtype: float64","text_tokens":["了","给",".","dataframe","选择","name","赋值","与","选取","]","series","但是","列"," ","可以","如果","一个","e","print","dtype","没有","标签","返回","和行","实际上","后","是","2.0","只有","实际","相同","c","b","索引","\"","在","d",":","有","获取","同时","不同","拥有",",","则","使用","5.0",")","1.0","。","[","df","3.0","float64","值","nan","整数","和","只能","(","的","a","，","one","行","还有","原"],"title":"通过列标签选择列","title_tokens":["标签","列","选择","通过"]},{"location":"pandas笔记/7.3.索引.html#_7","text":"df [[ \"one\" , \"two\" ]] one two a 1.0 1 b 2.0 2 c 3.0 3 d NaN 4 e 5.0 5 注意： 通过索引方式返回的列只是相应数据的视图而已， 并不是副本。因此，对返回的Series所做的任何修改全都会反映到原DataFrame上。通过Series的copy方法即可显式地复制列。 df [ \"one\" ][ \"a\" ] = np . nan df . \\ setup_m . py : 1 : SettingWithCopyWarning : A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation : http : // pandas . pydata . org / pandas - docs / stable / user_guide / indexing . html #returning-a-view-versus-a-copy import os one two a NaN 1 b 2.0 2 c 3.0 3 d NaN 4 e 5.0 5","text_tokens":["versus","dataframe","到","value","documentation","docs","2","two","\\","d","set","org","slice","通过","即可","#","copy","on","nan","indexing","_","修改","in","所","不是","series","做","显式","b","会","/","pandas","stable","be","see","方法","setup","方式","[","上","相应","并","复制","，","原","3.0","3","view","]","e","任何","列","对","guide","返回","反映","c","4","=","caveats",":","-","：","html","is","5.0","1.0","import","。","to","视图","m","的","因此","one","returning","settingwithcopywarning",".","os","of","user","pydata"," ","副本","the","1","全都","trying","2.0","py","索引","\"","数据","np",",","注意","5","只是","df","http","a","而已","地","from"],"title":"通过列标签选择多列","title_tokens":["选择","通过","列","标签","多列"]},{"location":"pandas笔记/7.3.索引.html#_8","text":"df . loc [ \"c\" , \"one\" ] df . iloc [ 2 , 0 ] df . loc [ \"c\" , [ \"one\" , \"two\" ]] df . iloc [ 2 , [ 0 , 1 ]] one 3.0 two 3.0 Name: c, dtype: float64 先选择列，在选择行 df [ \"one\" ][ \"c\" ] 3.0","text_tokens":[".","选择","name","]"," ","列","dtype","1","iloc","c","2","two","先","\"",":","在","loc","0",",","[","df","float64","，","one","行","3.0"],"title":"行列同时索引","title_tokens":["同时","索引","行列"]},{"location":"pandas笔记/7.3.索引.html#_9","text":"对Series进行运算（布尔索引过滤、标量乘法、数学函数等），都会保留标签和值之间的链接。 Series的标签可以通过赋值的方式进行修改： s = pd . Series ([ 1 , 2 , 3 , 4 , 5 ], index = [ 'a' , 'b' , 'c' , 'd' , 'e' ]) s . index = [ 'f' , 'b' , 'c' , 'd' , 'e' ] s f 1 b 2 c 3 d 4 e 5 dtype: int64 虽然很多时候都强调轴标签（索引值）要唯一，但这并不是强制性的。来看看下面这个简单的带有重复索引值的Series： obj = pd . Series ( range ( 5 ), index = [ 'a' , 'a' , 'b' , 'b' , 'c' ]) obj a 0 a 1 b 2 b 3 c 4 dtype: int64 索引的is_unique属性可以告诉你它的值是否是唯一的 obj . index . is_unique False 对于带有重复值的索引，数据选取的行为将会有些不同。如果某个索引对应多个值，则返回一个Series；而对应单个值的，则返回一个标量值。对DataFrame的行进行索引时也是如此。","text_tokens":["dataframe","赋值","s","它","如果","虽然","unique","时","2","'","强制性","有些","d","唯一","数学","通过","将会","链接","重复","行为","_","和","修改","这","对于","）","不是","选取","series","可以","如此","对应","dtype","函数","是","；","、","b","会","range","而","false","某个","看看","你","简单","不同","方式","属性","乘法","[","是否是","要","值","但","并","，","3","进行","]","e","也","对","index","标量","返回","标签","都","等","c","运算","来","轴","4","=",":","是否","：","之间","is","f","告诉",")","。","时候","pd","的","带有","行","."," ","很多","一个","1","保留","这个","下面","强制","单个","索引","数据","多个","过滤","0",",","则","5","int64","obj","布尔","(","（","a","强调"],"title":"关于索引的其它","title_tokens":["索引","的","其它","关于"]},{"location":"pandas笔记/7.3.索引.html#get","text":"Series或DataFrame中的每一个都有一个 get 可以返回默认值的方法。 ser . get ( \"a\" ) -5.3 df . get ( \"onef\" , 5 ) 5","text_tokens":[".","dataframe","中","series"," ","可以","一个","返回","都","get","\"","-","方法","有","5.3","默认",",",")","或","5","。","df","默认值","ser","(","每","a","的","onef"],"title":"get方法","title_tokens":["get","方法"]},{"location":"pandas笔记/7.3.索引.html#lookup","text":"给定一系列行标签和列标签的情况下提取一组值： # 返回 ('c','one') 和 ('b','two') df . lookup ([ \"c\" , \"b\" ], [ \"one\" , \"two\" ]) array([3., 2.])","text_tokens":[".","]"," ","列","返回","标签","c","2","'","array","b","提取","系列","two","\"","：","情况",",",")","给定","#","[","lookup","df","下","一系列","值","一系","一组","(","和","的","one","行","3"],"title":"lookup方法","title_tokens":["lookup","方法"]},{"location":"pandas笔记/7.3.索引.html#_10","text":"类型 df[val] 从DataFrame选取单列或一组列； 在特殊情况下比较便利：布尔型数组（过滤行）、切片（行切片）、或布尔型DataFrame (根据条件设置值） df.loc[val] 通过标签，选取DataFrame的单个行或一组行 df.loc[:, val] 通过标签，选取单列或列子集 df.loc[val1, val2] 通过标签，同时选取行和列 df.iloc[where] 通过整数位置，从DataFrame选取单个行或行子集 df.iloc[:, where] 通过整数位置，从DataFrame选取单个列或列子集 df.iloc[where_i, where_j] 通过整数位置，同时选取行和列 df.at [label_i, label_j] 通过行和列标签，选取单一的标量 df.iat[i, j] 通过行和列的位置（整数），选取单一的标量 reindex 通过标签选取行或列 get _value, set_value 通过行和列标签选取单一值","text_tokens":["）","比较",".","dataframe","选取","]","i"," ","便利","列","型","where","切片","标量","value","行或列","标签","行和列","iloc","val2","单一","；","、","设置","get","条件","单个","类型","在","val",":","根据","set","：","情况","过滤","loc","特殊","同时",",","通过","单列","或","行或行","从","[","j","df","下","子集","label","值","一组","布尔","(","整数","（","数组","的","_","位置","，","或列","val1","行","at","iat","reindex"],"title":"索引方式总结表","title_tokens":["方式","表","索引","总结"]},{"location":"pandas笔记/7.4.索引对象.html","text":"Windows 10 Python 3.7.3 @ MSC v.1915 64 bit (AMD64) from tools import Help as H import numpy as np import pandas as pd 索引对象 pandas的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建Series或DataFrame时，所用到的任何数组或其他序列的标签都会被转换成一个Index，而 index对象是不可变的 ，也就是index对象的元素不可修改（immutable）。如果要修改index内容，只能通过重新赋值的形式。 不可修改性非常重要，因为这样才能使Index对象在多个数据结构之间安全共享。 下表列出了pandas中主要的Index对象： 类 说明 Index 最泛化的Index对象，将轴标签表示为一个由Python对象组成的NumPy 数组 Int64lndex 针对整数的特殊Index Multiindex “层次化”索引对象，表示单个轴上的多层索引。可以看做由元组组成的数组 Datetimelndex 存储纳秒级时间截（用NumPy的datetime64类型表示） Periodlndex 针对Period数据（时间间隔）的特殊Index 以下是pandas中所有Index对象： [ 'CategoricalIndex' , 'DatetimeIndex' , 'Float64Index' , 'Index' , 'Int64Index' , 'IntervalIndex' , 'MultiIndex' , 'PeriodIndex' , 'RangeIndex' , 'TimedeltaIndex' , 'UInt64Index' ] class pandas.Index(data=None, dtype=None, copy=False, name=None, fastpath=False, tupleize_cols=True) ：创建 Index 对象。 参数： data ：一个 array-like ，必须是一维的 name ：一个字符串，为 Index 的名字。 dtype ：指定数据类型。如果为 None ，则默认为 object copy ：一个布尔值。如果为 True ，则拷贝输入数据 data tupleize_cols ：一个布尔值，如果可能则尽量创建 MultiIndex 对象 每个索引都有一些方法和属性，它们可用于设置逻辑并回答有关该索引所包含的数据的常见问题。下表列出了这些函数： 说明 方法 append 连接另一个index对象.产生一个新的Index diff 计算差集，并得到一个Index intersection 计算交集 union 计算并集 isin 计算一个指示各值是否都包含在参数集合中的布尔型数组 delete 删除索引i处的元素，并得到新的Index drop 删除传入的值.并得到新的Index insert 将元素插入到索引i处，并得到新的Index is_monotonic 当各元素均大于等于前一个元素时，返回TRUE is_unique 当Index没有重复值时，返回True unique 计算Index中唯一值的数组 多级索引 MultiIndex MultiIndex 代表的是多级索引对象。它继承自 Index ，其中的多级 label 采用元组对象来表示。在 MultiIndex 内部，并不直接保存元组对象，而是使用多个 Index 对象保存索引中每级的 label 。 class pandas.MultiIndex(levels=None, labels=None, sortorder=None, names=None, copy=False, verify_integrity=True, _set_identity=True, name=None, **kwargs) 参数： levels ：一个数组的列表，给出了每一级的 level 。 labels ：一个数组的列表，给出了每一级 level 的下标。第 i 级 label 是这样产生的： 首先获取 labels[i] ，它是一个下标序列，代表第 级。 - 假设第 k 位置为整数 3，在第 级第 位的 label 就是 levels[i][3] 。- sortorder ：一个整数，给出了已经排序好了的 level 级别。 names ：一个字符串序列，给出了每个 Index 的 name 。其中每个级别对应一个 Index copy ：一个布尔值。如果为 True ，则拷贝基础数据 verify_integrity ：一个布尔值。如果为 True ，则检测各级别的 label/level 都是连续的且有效的 name ：指定了本 MultiIndex 的名字 也可以通过下面的类方法来创建 MultiIndex ： MultiIndex.from_arrays(arrays[, sortorder, ...]) ：将二维序列转换为 MultiIndex 。其中 arrays 为 array-like 的序列，每个 array-like 按顺序的给出了一列 label （一个级别） MultiIndex.from_tuples(tuples[, sortorder, ...]) ：将元组序列转换为 MultiIndex 。其中 tuples 为 tuple-like 的序列，每个 array-like 按顺序的给出了一行 label 对（不同级别的一对） MultiIndex.from_product(iterables[, ...]) ：根据多个可迭代对象生成一个 MultiIndex ，其中使用笛卡尔积的算法。其中 iterables 为可迭代对象的序列 你也可以通过传递一个元组列表给 Index() ，并且将 tupleize_cols 设置为 True 来创建 MultiIndex 从tuple创建MultiIndex import pprint arrays = [ [ 'bar' , 'bar' , 'baz' , 'baz' , 'foo' , 'foo' , 'qux' , 'qux' ], [ 'one' , 'two' , 'one' , 'two' , 'one' , 'two' , 'one' , 'two' ]] tuples = list ( zip ( * arrays )) pprint . pprint ( tuples ) print ( \"\" ) index = pd . MultiIndex . from_tuples ( tuples , names = [ 'first' , 'second' ]) pprint . pprint ( index ) [( 'bar' , 'one' ), ( 'bar' , 'two' ), ( 'baz' , 'one' ), ( 'baz' , 'two' ), ( 'foo' , 'one' ), ( 'foo' , 'two' ), ( 'qux' , 'one' ), ( 'qux' , 'two' )] MultiIndex ([( 'bar' , 'one' ), ( 'bar' , 'two' ), ( 'baz' , 'one' ), ( 'baz' , 'two' ), ( 'foo' , 'one' ), ( 'foo' , 'two' ), ( 'qux' , 'one' ), ( 'qux' , 'two' )], names = [ 'first' , 'second' ]) pd . Series ( np . random . randn ( 8 ), index = index ) first second bar one 0.546165 two 1.495862 baz one -0.786178 two 0.312848 foo one -0.473748 two 0.186548 qux one 0.836214 two -0.547680 dtype: float64 从iterables创建MultiIndex iterables = [[ 'bar' , 'baz' , 'foo' , 'qux' ], [ 'one' , 'two' ]] pprint . pprint ( iterables ) print ( \"\" ) index = pd . MultiIndex . from_product ( iterables , names = [ 'first' , 'second' ]) pprint . pprint ( index ) [['bar', 'baz', 'foo', 'qux'], ['one', 'two']] MultiIndex([('bar', 'one'), ('bar', 'two'), ('baz', 'one'), ('baz', 'two'), ('foo', 'one'), ('foo', 'two'), ('qux', 'one'), ('qux', 'two')], names = ['first', 'second']) 从DataFrame创建MultiIndex df = pd . DataFrame ([[ 'bar' , 'one' ], [ 'bar' , 'two' ], [ 'foo' , 'one' ], [ 'foo' , 'two' ]], columns = [ 'first' , 'second' ]) pprint . pprint ( df ) print ( \"\" ) index = pd . MultiIndex . from_frame ( df ) pprint . pprint ( index ) first second 0 bar one 1 bar two 2 foo one 3 foo two MultiIndex ([( 'bar' , 'one' ), ( 'bar' , 'two' ), ( 'foo' , 'one' ), ( 'foo' , 'two' )], names = [ 'first' , 'second' ]) 从list-like创建MultiIndex arrays = [ np . array ([ 'bar' , 'bar' , 'baz' , 'baz' , 'foo' , 'foo' , 'qux' , 'qux' ]), np . array ([ 'one' , 'two' , 'one' , 'two' , 'one' , 'two' , 'one' , 'two' ])] pprint . pprint ( arrays ) pd . DataFrame ( np . random . randn ( 8 , 4 ), index = arrays ) [array(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'], dtype='<U3'), array(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'], dtype='<U3')] 0 1 2 3 bar one -0.089988 1.192690 -0.938933 0.821702 two -0.112540 0.587371 0.165956 0.050362 baz one -0.288737 0.709287 -0.479770 -0.007421 two 2.653461 1.258035 -0.837434 -1.306938 foo one 0.345492 0.311450 -0.008364 0.060572 two -0.304102 0.268357 0.680016 0.445016 qux one -0.809535 1.232934 -0.550252 -2.219605 two 0.729063 -0.992456 0.094162 -0.573775 # s = pd.Series(np.random.randn(8), index=arrays) # s 选择数据 列索引是多级索引 创建示例dataframe： tuples = [( 'bar' , 'one' ), ( 'bar' , 'two' ), ( 'baz' , 'one' ), ( 'baz' , 'two' ), ( 'foo' , 'one' ), ( 'foo' , 'two' ), ( 'qux' , 'one' ), ( 'qux' , 'two' )] index = pd . MultiIndex . from_tuples ( tuples , names = [ 'first' , 'second' ]) df = pd . DataFrame ( np . random . randn ( 3 , 8 ), index = [ 'A' , 'B' , 'C' ], columns = index ) df first bar baz foo qux second one two one two one two one two A 0.137891 -0.288164 -0.236898 -1.201346 0.482293 0.197164 -0.080923 -0.190650 B 0.602663 -0.511166 -0.033371 -0.924746 -1.022346 -2.069830 2.562845 1.347849 C -0.758100 -0.662711 0.507510 0.828843 -0.514439 0.324422 -0.664171 -0.158560 dataframe的 [] 选择列： df [ \"bar\" ] second one two A 0.137891 -0.288164 B 0.602663 -0.511166 C -0.758100 -0.662711 [] 使用多级索引： # 实际上与 df[(\"bar\", \"one\")] 等价 df [ \"bar\" , \"one\" ] A 0.137891 B 0.602663 C -0.758100 Name: (bar, one), dtype: float64 [[]] 选择多列： df [[ \"bar\" , \"baz\" , \"foo\" ]] # list first bar baz foo second one two one two one two A 0.137891 -0.288164 -0.236898 -1.201346 0.482293 0.197164 B 0.602663 -0.511166 -0.033371 -0.924746 -1.022346 -2.069830 C -0.758100 -0.662711 0.507510 0.828843 -0.514439 0.324422 () 用于同一轴的多级索引： df [[( \"bar\" , \"one\" ), ( \"baz\" , \"one\" )]] # list of tuples first bar baz second one one A 0.137891 -0.236898 B 0.602663 -0.033371 C -0.758100 0.507510 # 行列索引 print ( df . loc [ \"A\" , \"bar\" ], \" \\n \" ) # () 用于同一轴的多级索引 print ( df . loc [ \"A\" , ( \"bar\" , \"one\" )], \" \\n \" ) # [] 用于增加轴 以下三行代码等价 print ( df . loc [ \"A\" , [( \"bar\" , \"one\" )]], \" \\n \" ) print ( df . loc [ \"A\" , ( \"bar\" , [ \"one\" ])], \" \\n \" ) print ( df . loc [ \"A\" , ([ \"bar\" ], \"one\" )], \" \\n \" ) # [] 用于增加轴 print ( df . loc [ \"A\" , [ \"bar\" ]], \" \\n \" ) second one 0 . 137891 two - 0 . 288164 Name : A , dtype : float64 0 . 13789062153880624 first second bar one 0 . 137891 Name : A , dtype : float64 first second bar one 0 . 137891 Name : A , dtype : float64 first second bar one 0 . 137891 Name : A , dtype : float64 first second bar one 0 . 137891 two - 0 . 288164 Name : A , dtype : float64 # tuple of lists print ( df . loc [ \"A\" , ([ \"bar\" , \"foo\" ], [ \"one\" , \"two\" ])], \" \\n \" ) # list of tuples print ( df . loc [ \"A\" , [( \"bar\" , \"one\" ), ( \"foo\" , \"two\" )]], \" \\n \" ) first second bar one 0 . 137891 two - 0 . 288164 foo one 0 . 482293 two 0 . 197164 Name : A , dtype : float64 first second bar one 0 . 137891 foo two 0 . 197164 Name : A , dtype : float64 行索引是多级索引 df = pd . DataFrame ( np . random . randn ( 8 , 4 ), index = arrays ) df 0 1 2 3 bar one -0.354819 1.546802 -0.150356 -0.801590 two 0.288168 -1.177815 0.222434 -0.717976 baz one -1.585440 0.456956 0.275572 1.242805 two 1.102600 -1.314744 -1.171307 -2.322061 foo one 0.456528 0.922200 1.599342 1.136562 two 0.524887 -0.167836 -1.314889 0.639738 qux one -0.530839 -0.562265 -0.444301 1.227126 two -0.693254 2.555574 0.341882 -0.568909 df . loc [ 'bar' , [ 0 , 1 ]] 0 1 one -0.354819 1.546802 two 0.288168 -1.177815 df . loc [([ 'bar' ], \"one\" ), [ 0 , 1 ]] # df.loc[(['bar'], \"one\"), (0, 1)] 0 1 bar one -0.354819 1.546802 选择数据进阶 创建索引 def mklbl ( prefix , n ): return [ \" %s%s \" % ( prefix , i ) for i in range ( n )] miindex = pd . MultiIndex . from_product ([ mklbl ( 'A' , 4 ), mklbl ( 'B' , 2 ), mklbl ( 'C' , 4 ), mklbl ( 'D' , 2 )]) micolumns = pd . MultiIndex . from_tuples ([( 'a' , 'foo' ), ( 'a' , 'bar' ), ( 'b' , 'foo' ), ( 'b' , 'bah' )], names = [ 'lvl0' , 'lvl1' ]) print ( miindex , \" \\n \" ) print ( micolumns , \" \\n \" ) MultiIndex ([( 'A0' , 'B0' , 'C0' , 'D0' ), ( 'A0' , 'B0' , 'C0' , 'D1' ), ( 'A0' , 'B0' , 'C1' , 'D0' ), ( 'A0' , 'B0' , 'C1' , 'D1' ), ( 'A0' , 'B0' , 'C2' , 'D0' ), ( 'A0' , 'B0' , 'C2' , 'D1' ), ( 'A0' , 'B0' , 'C3' , 'D0' ), ( 'A0' , 'B0' , 'C3' , 'D1' ), ( 'A0' , 'B1' , 'C0' , 'D0' ), ( 'A0' , 'B1' , 'C0' , 'D1' ), ( 'A0' , 'B1' , 'C1' , 'D0' ), ( 'A0' , 'B1' , 'C1' , 'D1' ), ( 'A0' , 'B1' , 'C2' , 'D0' ), ( 'A0' , 'B1' , 'C2' , 'D1' ), ( 'A0' , 'B1' , 'C3' , 'D0' ), ( 'A0' , 'B1' , 'C3' , 'D1' ), ( 'A1' , 'B0' , 'C0' , 'D0' ), ( 'A1' , 'B0' , 'C0' , 'D1' ), ( 'A1' , 'B0' , 'C1' , 'D0' ), ( 'A1' , 'B0' , 'C1' , 'D1' ), ( 'A1' , 'B0' , 'C2' , 'D0' ), ( 'A1' , 'B0' , 'C2' , 'D1' ), ( 'A1' , 'B0' , 'C3' , 'D0' ), ( 'A1' , 'B0' , 'C3' , 'D1' ), ( 'A1' , 'B1' , 'C0' , 'D0' ), ( 'A1' , 'B1' , 'C0' , 'D1' ), ( 'A1' , 'B1' , 'C1' , 'D0' ), ( 'A1' , 'B1' , 'C1' , 'D1' ), ( 'A1' , 'B1' , 'C2' , 'D0' ), ( 'A1' , 'B1' , 'C2' , 'D1' ), ( 'A1' , 'B1' , 'C3' , 'D0' ), ( 'A1' , 'B1' , 'C3' , 'D1' ), ( 'A2' , 'B0' , 'C0' , 'D0' ), ( 'A2' , 'B0' , 'C0' , 'D1' ), ( 'A2' , 'B0' , 'C1' , 'D0' ), ( 'A2' , 'B0' , 'C1' , 'D1' ), ( 'A2' , 'B0' , 'C2' , 'D0' ), ( 'A2' , 'B0' , 'C2' , 'D1' ), ( 'A2' , 'B0' , 'C3' , 'D0' ), ( 'A2' , 'B0' , 'C3' , 'D1' ), ( 'A2' , 'B1' , 'C0' , 'D0' ), ( 'A2' , 'B1' , 'C0' , 'D1' ), ( 'A2' , 'B1' , 'C1' , 'D0' ), ( 'A2' , 'B1' , 'C1' , 'D1' ), ( 'A2' , 'B1' , 'C2' , 'D0' ), ( 'A2' , 'B1' , 'C2' , 'D1' ), ( 'A2' , 'B1' , 'C3' , 'D0' ), ( 'A2' , 'B1' , 'C3' , 'D1' ), ( 'A3' , 'B0' , 'C0' , 'D0' ), ( 'A3' , 'B0' , 'C0' , 'D1' ), ( 'A3' , 'B0' , 'C1' , 'D0' ), ( 'A3' , 'B0' , 'C1' , 'D1' ), ( 'A3' , 'B0' , 'C2' , 'D0' ), ( 'A3' , 'B0' , 'C2' , 'D1' ), ( 'A3' , 'B0' , 'C3' , 'D0' ), ( 'A3' , 'B0' , 'C3' , 'D1' ), ( 'A3' , 'B1' , 'C0' , 'D0' ), ( 'A3' , 'B1' , 'C0' , 'D1' ), ( 'A3' , 'B1' , 'C1' , 'D0' ), ( 'A3' , 'B1' , 'C1' , 'D1' ), ( 'A3' , 'B1' , 'C2' , 'D0' ), ( 'A3' , 'B1' , 'C2' , 'D1' ), ( 'A3' , 'B1' , 'C3' , 'D0' ), ( 'A3' , 'B1' , 'C3' , 'D1' )], ) MultiIndex ([( 'a' , 'foo' ), ( 'a' , 'bar' ), ( 'b' , 'foo' ), ( 'b' , 'bah' )], names = [ 'lvl0' , 'lvl1' ]) 创建示例数据 dfmi = pd . DataFrame ( np . arange ( len ( miindex ) * len ( micolumns )) . reshape (( len ( miindex ), len ( micolumns ))), index = miindex , columns = micolumns ) . sort_index () . sort_index ( axis = 1 ) dfmi lvl0 a b lvl1 bar foo bah foo A0 B0 C0 D0 1 0 3 2 D1 5 4 7 6 C1 D0 9 8 11 10 D1 13 12 15 14 C2 D0 17 16 19 18 ... ... ... ... ... A3 B1 C1 D1 237 236 239 238 C2 D0 241 240 243 242 D1 245 244 247 246 C3 D0 249 248 251 250 D1 253 252 255 254 [ 64 rows x 4 columns ] 使用切片 slice dfmi . loc [( slice ( 'A1' , 'A3' ), slice ( None ), [ 'C1' , 'C3' ]), :] dfmi . loc [ 'A1' , ( slice ( None ), 'foo' )] lvl0 a b lvl1 foo foo B0 C0 D0 64 66 D1 68 70 C1 D0 72 74 D1 76 78 C2 D0 80 82 D1 84 86 C3 D0 88 90 D1 92 94 B1 C0 D0 96 98 D1 100 102 C1 D0 104 106 D1 108 110 C2 D0 112 114 D1 116 118 C3 D0 120 122 D1 124 126 IndexSlice idx = pd . IndexSlice dfmi . loc [ idx [:, :, [ 'C1' , 'C3' ]], idx [:, 'foo' ]] lvl0 a b lvl1 foo foo A0 B0 C1 D0 8 10 D1 12 14 C3 D0 24 26 D1 28 30 B1 C1 D0 40 42 D1 44 46 C3 D0 56 58 D1 60 62 A1 B0 C1 D0 72 74 D1 76 78 C3 D0 88 90 D1 92 94 B1 C1 D0 104 106 D1 108 110 C3 D0 120 122 D1 124 126 A2 B0 C1 D0 136 138 D1 140 142 C3 D0 152 154 D1 156 158 B1 C1 D0 168 170 D1 172 174 C3 D0 184 186 D1 188 190 A3 B0 C1 D0 200 202 D1 204 206 C3 D0 216 218 D1 220 222 B1 C1 D0 232 234 D1 236 238 C3 D0 248 250 D1 252 254 使用 mask 索引 mask = dfmi [( 'a' , 'foo' )] > 200 dfmi . loc [ idx [ mask , :, [ 'C1' , 'C3' ]], idx [:, 'foo' ]] lvl0 a b lvl1 foo foo A3 B0 C1 D1 204 206 C3 D0 216 218 D1 220 222 B1 C1 D0 232 234 D1 236 238 C3 D0 248 250 D1 252 254 给 loc 或 iloc 指定轴参数 loc 默认对行进行索引： dfmi . loc ( axis = 0 )[:, :, [ 'C1' , 'C3' ]] lvl0 a b lvl1 bar foo bah foo A0 B0 C1 D0 9 8 11 10 D1 13 12 15 14 C3 D0 25 24 27 26 D1 29 28 31 30 B1 C1 D0 41 40 43 42 D1 45 44 47 46 C3 D0 57 56 59 58 D1 61 60 63 62 A1 B0 C1 D0 73 72 75 74 D1 77 76 79 78 C3 D0 89 88 91 90 D1 93 92 95 94 B1 C1 D0 105 104 107 106 D1 109 108 111 110 C3 D0 121 120 123 122 D1 125 124 127 126 A2 B0 C1 D0 137 136 139 138 D1 141 140 143 142 C3 D0 153 152 155 154 D1 157 156 159 158 B1 C1 D0 169 168 171 170 D1 173 172 175 174 C3 D0 185 184 187 186 D1 189 188 191 190 A3 B0 C1 D0 201 200 203 202 D1 205 204 207 206 C3 D0 217 216 219 218 D1 221 220 223 222 B1 C1 D0 233 232 235 234 D1 237 236 239 238 C3 D0 249 248 251 250 D1 253 252 255 254 可以指定 axis 参数，指定需要索引的轴： dfmi . loc ( axis = 1 )[ \"a\" ] lvl1 bar foo A0 B0 C0 D0 1 0 D1 5 4 C1 D0 9 8 D1 13 12 C2 D0 17 16 ... ... ... A3 B1 C1 D1 237 236 C2 D0 241 240 D1 245 244 C3 D0 249 248 D1 253 252 [ 64 rows x 2 columns ] 重新赋值 df2 = dfmi . copy () df2 . loc ( axis = 0 )[:, :, [ 'C1' , 'C3' ]] = - 10 df2 df2 = dfmi . copy () df2 . loc [ idx [:, :, [ 'C1' , 'C3' ]], :] = df2 * 1000 df2 lvl0 a b lvl1 bar foo bah foo A0 B0 C0 D0 1 0 3 2 D1 5 4 7 6 C1 D0 9000 8000 11000 10000 D1 13000 12000 15000 14000 C2 D0 17 16 19 18 ... ... ... ... ... A3 B1 C1 D1 237000 236000 239000 238000 C2 D0 241 240 243 242 D1 245 244 247 246 C3 D0 249000 248000 251000 250000 D1 253000 252000 255000 254000 [ 64 rows x 4 columns ] 交叉选择 DataFrame 的 xs() 方法接受一个额外的参数，从而可以简便地在某个特定的多级索引中的某一个层级进行数据的选取。 df = pd . DataFrame ( np . random . randn ( 6 , 3 ), index = index [: 6 ]) df = df . T df first bar baz foo second one two one two one two 0 1.939044 0.588276 1.146525 -0.188147 -0.720676 1.451303 1 -0.028778 -0.897224 -0.038871 -0.485770 -0.958363 -0.963243 2 -0.911336 0.031492 0.795475 0.234746 0.361175 0.659001 .xs 方法默认 axis=0 ： df . xs ( \"bar\" , level = 'first' , axis = 1 ) df . xs ( \"one\" , level = 'second' , axis = 1 ) first bar baz foo 0 1.939044 1.146525 -0.720676 1 -0.028778 -0.038871 -0.958363 2 -0.911336 0.795475 0.361175 df . xs (( 'one' , 'bar' ), level = ( 'second' , 'first' ), axis = 1 ) first bar second one 0 1.939044 1 -0.028778 2 -0.911336 .xs 方法默认 drop_level=False ： df . xs ( 'one' , level = 'second' , axis = 1 , drop_level = False ) first bar baz foo second one one one 0 1.939044 1.146525 -0.720676 1 -0.028778 -0.038871 -0.958363 2 -0.911336 0.795475 0.361175 df . xs ( 'one' , level = 'second' , axis = 1 , drop_level = True ) first bar baz foo 0 1.939044 1.146525 -0.720676 1 -0.028778 -0.038871 -0.958363 2 -0.911336 0.795475 0.361175 Take方法 与 NumPy 的 ndarrays 相似，pandas的 Index ， Series ，和 DataFrame 也提供 take() 方法。他可以沿着某个维度，按照给定的索引取回所有的元素。这个给定的索引必须要是一个由整数组成的列表或者ndarray，用以指明在索引中的位置。 take 也可以接受负整数，作为相对于结尾的相对位置。 index = pd . Index ( np . random . randint ( 0 , 1000 , 10 )) print ( index ) positions = [ 0 , 9 , 3 ] print ( index [ positions ]) print ( index . take ( positions )) Int64Index([495, 309, 722, 91, 889, 309, 148, 970, 329, 776], dtype='int64') Int64Index([495, 776, 91], dtype='int64') Int64Index([495, 776, 91], dtype='int64') ser = pd . Series ( np . random . randn ( 10 )) print ( ser . iloc [ positions ]) print ( ser . take ( positions )) 0 0.591030 9 -0.593299 3 0.021434 dtype: float64 0 0.591030 9 -0.593299 3 0.021434 dtype: float64 对于 DataFrames 来说，这个给定的索引应当是一个一维列表或者ndarray，用于指明行或者列的位置。 frm = pd . DataFrame ( np . random . randn ( 5 , 3 )) print ( frm ) print ( frm . take ([ 1 , 4 , 3 ])) print ( frm . take ([ 0 , 2 ], axis = 1 )) 0 1 2 0 -0.019443 0.710586 0.481252 1 -0.181836 0.772916 0.783044 2 -1.793119 0.445353 1.196131 3 -1.040532 0.333872 -0.010054 4 0.351876 1.118853 0.093517 0 1 2 1 -0.181836 0.772916 0.783044 4 0.351876 1.118853 0.093517 3 -1.040532 0.333872 -0.010054 0 2 0 -0.019443 0.481252 1 -0.181836 0.783044 2 -1.793119 1.196131 3 -1.040532 -0.010054 4 0.351876 0.093517 需要注意的是， pandas对象的 take 方法并不会正常地工作在布尔索引上，并且有可能会返回一切意外的结果。 arr = np . random . randn ( 10 ) print ( arr ) print ( arr . take ([ False , False , True , True ])) print ( arr [[ 0 , 1 ]]) [-0.53649475 0.13255386 0.04098733 0.82386728 0.08692377 0.30652204 0.24007645 0.22604287 -0.53147612 2.34366636] [-0.53649475 -0.53649475 0.13255386 0.13255386] [-0.53649475 0.13255386] ser = pd . Series ( np . random . randn ( 10 )) print ( ser ) print ( ser . take ([ False , False , True , True ])) print ( ser . iloc [[ 0 , 1 ]]) 0 -0.103801 1 -1.621499 2 -0.028563 3 0.407877 4 -0.266058 5 1.390450 6 -1.002601 7 -0.335144 8 -0.461811 9 0.997019 dtype: float64 0 -0.103801 0 -0.103801 1 -1.621499 1 -1.621499 dtype: float64 0 -0.103801 1 -1.621499 dtype: float64 最后，关于性能方面的一个小建议，因为 take 方法处理的是一个范围更窄的输入，因此会比话实索引（fancy indexing）的速度快很多。 arr = np . random . randn ( 10000 , 5 ) indexer = np . arange ( 10000 ) random . shuffle ( indexer ) % timeit arr [ indexer ] % timeit arr . take ( indexer , axis = 0 ) 373 µs ± 46.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) 132 µs ± 12.3 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each) ser = pd . Series ( arr [:, 0 ]) % timeit ser . iloc [ indexer ] % timeit ser . take ( indexer ) 336 µs ± 49.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) 355 µs ± 60.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) 分类索引 CategoricalIndex 分类索引 这种索引类型非常适合有重复的索引。这是一个围绕 Categorical 而创建的容器。这可以非常高效地存储和索引的具有大量重复元素的索引。 from pandas.api.types import CategoricalDtype df = pd . DataFrame ({ 'A' : np . arange ( 6 ), 'B' : list ( 'aabbca' )}) df [ 'B' ] = df [ 'B' ] . astype ( CategoricalDtype ( list ( 'cab' ))) print ( df , \" \\n \" ) print ( df . dtypes , \" \\n \" ) print ( df . B . cat . categories , \" \\n \" ) A B 0 0 a 1 1 a 2 2 b 3 3 b 4 4 c 5 5 a A int32 B category dtype : object Index ([ 'c' , 'a' , 'b' ], dtype = 'object' ) 通过设置索引将会建立一个 CategoricalIndex 分类索引. df2 = df . set_index ( 'B' ) print ( df2 . index ) CategoricalIndex(['a', 'a', 'b', 'b', 'c', 'a'], categories=['c', 'a', 'b'], ordered=False, name='B', dtype='category') 使用 __getitem__/.iloc/.loc 进行索引，在含有重复值的 索引 上的工作原理相似。索引值 必须 在一个分类中，否者将会引发 KeyError 错误。 df2 . loc [ 'a' ] A B a 0 a 1 a 5 CategoricalIndex 在索引之后也会被 保留 : df2 . loc [ 'a' ] . index CategoricalIndex(['a', 'a', 'a'], categories=['c', 'a', 'b'], ordered=False, name='B', dtype='category') 索引排序将会按照类别清单中的顺序进行（我们已经基于 CategoricalDtype(list('cab')) 建立了一个索引，因此排序的顺序是 cab ） df2 . sort_index () A B c 4 a 0 a 1 a 5 b 2 b 3 分组操作（Groupby）也会保留索引的全部信息。 df2 . groupby ( level = 0 ) . sum () df2 . groupby ( level = 0 ) . sum () . index CategoricalIndex(['c', 'a', 'b'], categories=['c', 'a', 'b'], ordered=False, name='B', dtype='category') 重设索引的操作将会根据输入的索引值返回一个索引。传入一个列表，将会返回一个最普通的 Index ；如果使用类别对象 Categorical ，则会返回一个分类索引 CategoricalIndex ，按照其中 传入的 的类别值 Categorical dtype来进行索引。正如同你可以对 任意 pandas的索引进行重新索引一样，这将允许你随意索引任意的索引值，即便它们并 不存在 在你的类别对象中。 df2 . reindex ([ 'a' , 'e' ]) df2 . reindex ([ 'a' , 'e' ]) . index Index(['a', 'a', 'a', 'e'], dtype='object', name='B') df2 . reindex ( pd . Categorical ([ 'a' , 'e' ], categories = list ( 'abcde' ))) df2 . reindex ( pd . Categorical ([ 'a' , 'e' ], categories = list ( 'abcde' ))) . index CategoricalIndex(['a', 'a', 'a', 'e'], categories=['a', 'b', 'c', 'd', 'e'], ordered=False, name='B', dtype='category') 间隔索引 0.20.0中新加入 IntervalIndex 和它自己特有的 IntervalDtype 以及 Interval 标量类型，在pandas中，间隔数据是获得头等支持的。 IntervalIndex 间隔索引允许一些唯一的索引，并且也是 cut() 和 qcut() 的返回类型 使用 间隔索引 来进行数据索引 df = pd . DataFrame ({ 'A' : [ 1 , 2 , 3 , 4 ]}, index = pd . IntervalIndex . from_breaks ([ 0 , 1 , 2 , 3 , 4 ])) df A (0, 1] 1 (1, 2] 2 (2, 3] 3 (3, 4] 4 在间隔序列上使用基于标签的索引 .loc ，正如你所预料到的，将会选择那个特定的间隔 df . loc [ 2 ] A 2 Name: (1, 2], dtype: int64 df . loc [[ 2 , 3 ]] A (1, 2] 2 (2, 3] 3 如果你选取了一个标签，被 包含 在间隔当中，这个间隔也将会被选择 df . loc [ 2.5 ] A 3 Name: (2, 3], dtype: int64 df . loc [[ 2.5 , 3.5 ]] A (2, 3] 3 (3, 4] 4 使用 Interval 来选择，将只返回严格匹配（从pandas0.25.0开始）。 df . loc [ pd . Interval ( 1 , 2 )] A 2 Name: (1, 2], dtype: int64 试图选择一个没有被严格包含在 IntervalIndex 内的区间 Interval ，将会出发 KeyError 错误。 try : df . loc [ pd . Interval ( 0.5 , 2.5 )] except KeyError as e : print ( \"KeyError:\" , e ) KeyError : Interval ( 0.5 , 2.5 , closed = 'right' ) 可以使用 overlaps() 来创建一个布尔选择器，来选中所有与 给定区间 ( Interval )重复的所有区间。 idxr = df . index . overlaps ( pd . Interval ( 0.5 , 2.5 )) print ( idxr ) print ( df [ idxr ]) [ True True True False] A (0, 1] 1 (1, 2] 2 (2, 3] 3 使用-cut-和-qcut来为数据分块使用 cut 和 qcut 来为数据分块 cut() 和 qcut() 都将返回一个分类 Categorical 对象，并且每个分块区域都会以 分类索引 IntervalIndex 的方式被创建并保存在它的 .categories 属性中。 c = pd . cut ( range ( 4 ), bins = 2 ) print ( c ) print ( c . categories ) [(-0.003, 1.5], (-0.003, 1.5], (1.5, 3.0], (1.5, 3.0]] Categories (2, interval[float64]): [(-0.003, 1.5] < (1.5, 3.0]] IntervalIndex([(-0.003, 1.5], (1.5, 3.0]], closed = 'right', dtype='interval[float64]') cut() 也可以接受一个 IntervalIndex 作为他的 bins 参数，这样可以使用一个非常有用的pandas的写法。 首先，我们调用 cut() 在一些数据上面，并且将 bins 设置为某一个固定的数 ，从而生成bins。 随后，我们可以在其他的数据上调用 cut() ，并传入 .categories 的值，作为 bins 参数。这样新的数据就也将会被分配到同样的bins里面 pd . cut ([ 0 , 3 , 5 , 1 ], bins = c . categories ) [(-0.003, 1.5], (1.5, 3.0], NaN, (-0.003, 1.5]] Categories (2, interval[float64]): [(-0.003, 1.5] < (1.5, 3.0]] 任何落在bins之外的数据都将会被设为 NaN 生成一定区间内的间隔 如果我们需要经常地使用步进区间，我们可以使用 interval_range() 函数，结合 start , end , 和 periods 来建立一个 IntervalIndex 对于数值型的间隔，默认的 interval_range 间隔频率是1，对于datetime类型的间隔则是日历日。 pd . interval_range ( start = 0 , end = 5 ) pd . interval_range ( start = pd . Timestamp ( '2017-01-01' ), periods = 4 ) pd . interval_range ( end = pd . Timedelta ( '3 days' ), periods = 3 ) IntervalIndex ( [ (0 days 00:00:00, 1 days 00:00:00 ] , ( 1 days 00 : 00 : 00 , 2 days 00 : 00 : 00 ] , ( 2 days 00 : 00 : 00 , 3 days 00 : 00 : 00 ]] , closed = 'right' , dtype = 'interval[timedelta64[ns]]' ) freq 参数可以被用来明确非默认的频率，并且可以充分地利用各种各样的 frequency aliases datetime类型的时间间隔。 pd . interval_range ( start = 0 , periods = 5 , freq = 1.5 ) pd . interval_range ( start = pd . Timestamp ( '2017-01-01' ), periods = 4 , freq = 'W' ) pd . interval_range ( start = pd . Timedelta ( '0 days' ), periods = 3 , freq = '9H' ) IntervalIndex ( [ (0 days 00:00:00, 0 days 09:00:00 ] , ( 0 days 09 : 00 : 00 , 0 days 18 : 00 : 00 ] , ( 0 days 18 : 00 : 00 , 1 days 03 : 00 : 00 ]] , closed = 'right' , dtype = 'interval[timedelta64[ns]]' ) 此外， closed 参数可以用来声明哪个边界是包含的。默认情况下，间隔的右界是包含的。 pd . interval_range ( start = 0 , end = 4 , closed = 'both' ) pd . interval_range ( start = 0 , end = 4 , closed = 'neither' ) IntervalIndex ( [ (0, 1), (1, 2), (2, 3), (3, 4) ] , closed = 'neither' , dtype = 'interval[int64]' ) v0.23.0新加入 使用 start , end , 和 periods 可以从 start 到 end （包含）生成一个平均分配的间隔，在返回 IntervalIndex 中生成 periods 这么多的元素（译者：区间）。 pd . interval_range ( start = 0 , end = 6 , periods = 4 ) pd . interval_range ( pd . Timestamp ( '2018-01-01' ), pd . Timestamp ( '2018-02-28' ), periods = 3 ) IntervalIndex ( [ (2018-01-01, 2018-01-20 08:00:00 ] , ( 2018 - 01 - 20 08 : 00 : 00 , 2018 - 02 - 08 16 : 00 : 00 ] , ( 2018 - 02 - 08 16 : 00 : 00 , 2018 - 02 - 28 ]] , closed = 'right' , dtype = 'interval[datetime64[ns]]' )","text_tokens":["指明","赋值","sortorder","118","42","均","0.511166","多级","122","行列","234","多层","如同","10","shuffle","最","0.089988","层次","2.653461","'","df2","该","1.258035","随后","0.08692377","two","127","1.192690","唯一","241","从而","0.473748","set","173","8000","此外","不","d1","默认","140","0.680016","*","45","level","2.5","调用","含有","copy","188","191","0.158560","49.5","254","1.495862","interval","0.568909","支持","...","7","信息","tuple","0.080923","修改","存储","看做","管理","每个","insert","0.546165","in","243","153","对于","lists","意外","0.04098733","reindex","218","这","一行","fancy","64","2018","250","miindex","329","1.242805","217","转换","{","44","对应","给出","249","是","哪个","30","0.324422","不会","fastpath","当","0.137891","pandas","154","0.958363","range","以","251","某个","0.197164","categoricalindex","列出","0.190650","产生","拷贝","额外","136","tools","这样","方式","负责","184","0.028563","0.335144","给定","110","integrity","mask","61","periodindex","label","0.710586","错误","abcde","只能","100","ndarrays","并","254000","249000","python","randn","3","13","90","107","纳秒","按照","loops","结构","append","1.347849","13789062153880624","等","一级","0.573775","来","27","141","工作","集合","0.664171","进阶","223","each","lvl0","平均分","1.306938","prefix","1.002601","70","is","b1","有效","multiindex","n","187",")","同一","0.53649475","int64lndex","cols","计算","0.587371","1.136562","。","108","写法","0.167836","groupby","sort","56","c3","0.445353","indexer","的","译者","特定","139","因此","充分","得到","列表","0.275572","15000","以下","29","一列","205","0.82386728","0.922200","了","58","loop","d0"," ","普通","很多","mean","0.729063","help","h","0.938933","373","可修改性","<","157","255000","xs","62","start","12.3","字符串","1.546802","25","0.019443","0.809535","这个","处理","主要","单个","170","取回","将","93","43","换成","µ","pandas0.25","0.050362","则","使用","26","77","end","或","5","tupleize","75","0.234746","%","0.602663","匹配","int64","代表","df","建议","0.550252","2017","序列","某","构建","比如","a","frequency","层次化","平均","1.201346","被","元素","13000","0.165956","union","0.562265","这是","86","0.24007645","针对","它","114","0.444301","0.514439","而是","他","0.333872","242","对行","沿着","unique","说明","0.456956","实际","category","由","2","ns","}","假设","amd64","frame","0.924746","\\","98","大量","verify","66","分类","overlaps","0.103801","重新","获取","0.094162","原理","输入","插入","传递","like","0.481252","try","92","重复","因为","idx","nan","删除","负责管理","和","_","位置","126","提供","±","int64index","lvl1","c2","a3","0.13255386","breaks","tuples","periods","8","日历","255","中","选取","236000","必须","series","切片","共享","示例","函数","多列","235","增加","frm","；","uint64index","b","0.003","1.390450","关于","0.150356","185","而","0.288164","有关","false","0.485770","3.7","mklbl","10000","days","其中","482293","不同","0.836214","只","选择器","2.555574","micolumns","首先","970","reshape","41","0.181836","算法","0.524887","aabbca","重设","0.341882","172","freq","period","好","级别","方面","138","1.5","数组","连续","00","，","ndarray","0.093517","159","200","175","随意","0.758100","28","与","]","e","intervaldtype","index","型","列","建立","print","没有","内部","0.801590","0.288168","95","都","2.562845","b0","qux","0.112540","各值","c","251000","试图","落","indexslice","getitem","轴","顺序","=","174","106","相似","变","names","1.599342","0.445016","我们","多","import","239","int32","1.022346","日","并且","ser","结合","整数","240","1.314744","one","就","0.311450","18","数","区域","使","delete","给","0.720676","46.5","of","253000","用","sum","248000","aliases","按","1","实际上","252","分配","均分","120","01","设置","dataframes","所用","不可","none","下面","间隔","monotonic","范围","多个","0.639738","355","有","207","runs","cut","注意","包含","columns","47","except","1.227126","9000","截","安全","正如","68","(","正常","238","里面","0.407877","1.146525","124","0.507510","0.717976","1.040532","用以","名称","常见问题","109","206","用来","参数","s","len","到","如果","结尾","迭代","出发","238000","31","239000","isin","时","0.588276","级","array","0.186548","0.53147612","112","0.222434","名字","引发","生成","data","小","3.5","889","类型","252000","非常适合","datetimelndex","arr","c1","w","104","泛化","slice","132","严格","于","通过","0.693254","字符","125","交叉","msc","简便","1.939044","将会","利用","布尔值","一些","采用","1.585440","数据类型","2.069830","有用","0.007421","转换成","各","1.793119","改性","回答","60","并集","201","495","应当","所","ordered","88","前","自己","数值","步进","可以","a1","别的","keyerror","positions","0.304102","dtype","idxr","u3","快","“","加入","比话实","来说","@","会","否者","设为","kwargs","分组","二维","全部","你","0.461811","内","方法","axis","一样","k","类","rows","轴上","非常","0.033371","属性","0.828843","12000","围绕","91","0.786178","开始","右界","[","交集","0.530839","72","0.456528","t","要","值","位","197164","245","astype","为","iterables","数据结构","datetime64","预料到","11","当中","246","进行","0.361175","那个","bins","random","固定","189","选择","name","237","product","任何","168","才能","对","dtypes","分块","标量","59","windows","timestamp","222","neither","0.772916","操作","timedelta","63","137","171","0.22604287","4","常见","foo","性能","基础",":","9","是否","自","之间","loc","情况","bit","这么","arange","1000","46","本","重要","0.30652204","9h","0.010054","创建","0.354819","表列出","pd","x","各种","0.482293","接受","12","继承","v.1915","问题","94","一对",".","1.171307","220","最后","可","一定","积","73","1.118853","categoricaldtype","722","一个","0.783044","第","类别","经常","逻辑","class","2.322061","24","代码","288164","iloc","244","0.659001","其他","253","索引","\"","上面","0.591030","这些","237000","所有","0","84","79","指定","中新","11000","各种各样","def","容器","平均分配","6","0.008364","74","a0","cab","bar","任意","zip","需要","布尔","（","地","08","immutable","baz","248","156","速度","元","具有","0.288737","相对","预料","list","221","dataframe","for","0.236898","结果","允许","一维","0.992456","776","randint","下标","作为","存在","之外","first","dfmi","float64index","0.20","表列","0.268357","0.266058","drop","d","api","根据","各级","保存","bah","15","特殊","1.196131","等价","0.038871","声明","true","diff","second","143","#","numpy","它们","take","0.709287","204","indexing","频率","219","即便","头等","both","0.028778","1.314889","pprint","）","40",">","116","periodlndex","尽量","用于","arrays","1.177815","96","14000","137891","清单","明确","每级","连接","intersection","cat","121","0.312848","object","190","216","152","形式","std","正","/","在","s%","202","0.821702","60.5","更窄","categorical","types","123","料到","20","0.031492","大于","0.188147","上","元组","intervalindex","1.451303","以及","03","309","02","0.547680","表示","57","232","155","16","之后","3.0","同样","维度","158","0.911336","对象","也","i","区间","datetimeindex","a2","closed","0.5","返回","标签","排序","105","这种","获得","datetime","rangeindex","0.593299","2.34366636","另","0.963243","timedeltaindex","各样","17","卡尔","76","差集","处","且","-","203","：","89","新","0.662711","直接","labels","就是","233","148","236","特有","right","19","timedelta64","247","指示","要是","return","适合","行","1.232934","dev","传入","0.897224","78","分类索引","v0.23","0.351876","基于","0.997019","检测","82","categories","1.621499","选中","14","层级","0.837434","已经","2.219605","保留","186","111","非","per","边界","timeit","80","142","数据","09","identity","0.060572","值时","np","内容","levels","c0","336","102",",","高效","时间","三行","”","笛卡尔","从","1.102600","可能","169","或者","0.479770","下","float64","0.345492","0.795475","0.021434","一切","负","等于","每","qcut","from","as","组成","__","250000"],"title":"7.4.索引对象","title_tokens":["对象",".","7.4","索引"]},{"location":"pandas笔记/7.4.索引对象.html#_1","text":"pandas的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建Series或DataFrame时，所用到的任何数组或其他序列的标签都会被转换成一个Index，而 index对象是不可变的 ，也就是index对象的元素不可修改（immutable）。如果要修改index内容，只能通过重新赋值的形式。 不可修改性非常重要，因为这样才能使Index对象在多个数据结构之间安全共享。 下表列出了pandas中主要的Index对象： 类 说明 Index 最泛化的Index对象，将轴标签表示为一个由Python对象组成的NumPy 数组 Int64lndex 针对整数的特殊Index Multiindex “层次化”索引对象，表示单个轴上的多层索引。可以看做由元组组成的数组 Datetimelndex 存储纳秒级时间截（用NumPy的datetime64类型表示） Periodlndex 针对Period数据（时间间隔）的特殊Index 以下是pandas中所有Index对象： [ 'CategoricalIndex' , 'DatetimeIndex' , 'Float64Index' , 'Index' , 'Int64Index' , 'IntervalIndex' , 'MultiIndex' , 'PeriodIndex' , 'RangeIndex' , 'TimedeltaIndex' , 'UInt64Index' ] class pandas.Index(data=None, dtype=None, copy=False, name=None, fastpath=False, tupleize_cols=True) ：创建 Index 对象。 参数： data ：一个 array-like ，必须是一维的 name ：一个字符串，为 Index 的名字。 dtype ：指定数据类型。如果为 None ，则默认为 object copy ：一个布尔值。如果为 True ，则拷贝输入数据 data tupleize_cols ：一个布尔值，如果可能则尽量创建 MultiIndex 对象 每个索引都有一些方法和属性，它们可用于设置逻辑并回答有关该索引所包含的数据的常见问题。下表列出了这些函数： 说明 方法 append 连接另一个index对象.产生一个新的Index diff 计算差集，并得到一个Index intersection 计算交集 union 计算并集 isin 计算一个指示各值是否都包含在参数集合中的布尔型数组 delete 删除索引i处的元素，并得到新的Index drop 删除传入的值.并得到新的Index insert 将元素插入到索引i处，并得到新的Index is_monotonic 当各元素均大于等于前一个元素时，返回TRUE is_unique 当Index没有重复值时，返回True unique 计算Index中唯一值的数组","text_tokens":["名称","常见问题","dataframe","赋值","针对","参数","到","如果","均","一维","多层","unique","说明","最","被","isin","时","由","层次","级","'","array","float64index","该","名字","表列","data","类型","drop","唯一","datetimelndex","泛化","重新","特殊","不","输入","默认","通过","true","字符","diff","插入","布尔值","numpy","like","一些","它们","copy","数据类型","重复","因为","删除","负责管理","和","转换成","_","各","修改","存储","改性","管理","看做","每个","回答","并集","insert","int64index","所","）","前","中","必须","series","periodlndex","可以","转换","尽量","用于","共享","dtype","函数","连接","intersection","是","“","object","形式","fastpath","uint64index","当","会","pandas","而","有关","false","在","categoricalindex","列出","方法","产生","拷贝","类","轴上","这样","非常","负责","属性","大于","[","交集","元组","intervalindex","periodindex","要","值","period","只能","数组","为","并","python","，","数据结构","datetime64","表示","纳秒","name","对象","任何","也","]","i","index","才能","datetimeindex","型","结构","返回","标签","没有","append","都","等","各值","rangeindex","另","轴","集合","timedeltaindex","=","常见","差集","处","-","变","是否","：","之间","新","is","multiindex",")","int64lndex","就是","cols","计算","。","重要","指示","创建","整数","表列出","的","得到","以下","问题","使","了",".","delete","传入","可","用"," ","一个","可修改性","class","逻辑","字符串","设置","所用","其他","不可","主要","单个","间隔","none","索引","数据","多个","monotonic","这些","将","值时","所有","内容","有","换成","指定",",","则","时间","或","tupleize","”","包含","可能","下","序列","构建","截","比如","安全","布尔","(","等于","（","层次化","immutable","元素","元","组成","union"],"title":"索引对象","title_tokens":["对象","索引"]},{"location":"pandas笔记/7.4.索引对象.html#multiindex","text":"MultiIndex 代表的是多级索引对象。它继承自 Index ，其中的多级 label 采用元组对象来表示。在 MultiIndex 内部，并不直接保存元组对象，而是使用多个 Index 对象保存索引中每级的 label 。 class pandas.MultiIndex(levels=None, labels=None, sortorder=None, names=None, copy=False, verify_integrity=True, _set_identity=True, name=None, **kwargs) 参数： levels ：一个数组的列表，给出了每一级的 level 。 labels ：一个数组的列表，给出了每一级 level 的下标。第 i 级 label 是这样产生的： 首先获取 labels[i] ，它是一个下标序列，代表第 级。 - 假设第 k 位置为整数 3，在第 级第 位的 label 就是 levels[i][3] 。- sortorder ：一个整数，给出了已经排序好了的 level 级别。 names ：一个字符串序列，给出了每个 Index 的 name 。其中每个级别对应一个 Index copy ：一个布尔值。如果为 True ，则拷贝基础数据 verify_integrity ：一个布尔值。如果为 True ，则检测各级别的 label/level 都是连续的且有效的 name ：指定了本 MultiIndex 的名字 也可以通过下面的类方法来创建 MultiIndex ： MultiIndex.from_arrays(arrays[, sortorder, ...]) ：将二维序列转换为 MultiIndex 。其中 arrays 为 array-like 的序列，每个 array-like 按顺序的给出了一列 label （一个级别） MultiIndex.from_tuples(tuples[, sortorder, ...]) ：将元组序列转换为 MultiIndex 。其中 tuples 为 tuple-like 的序列，每个 array-like 按顺序的给出了一行 label 对（不同级别的一对） MultiIndex.from_product(iterables[, ...]) ：根据多个可迭代对象生成一个 MultiIndex ，其中使用笛卡尔积的算法。其中 iterables 为可迭代对象的序列 你也可以通过传递一个元组列表给 Index() ，并且将 tupleize_cols 设置为 True 来创建 MultiIndex","text_tokens":["sortorder","参数","它","如果","而是","多级","迭代","下标","级","array","假设","名字","生成","verify","根据","set","各级","保存","获取","不","通过","true","*","字符","level","传递","布尔值","like","采用","copy","_","...","tuple","位置","每个","tuples","一行","）","中","可以","arrays","转换","别的","对应","每级","给出","是","pandas","/","kwargs","false","在","二维","你","方法","其中","产生","拷贝","k","不同","类","这样","首先","[","算法","元组","integrity","label","位","好","级别","并","数组","为","连续","，","iterables","表示","3","name","对象","product","]","i","也","index","对","内部","排序","都","一级","来","顺序","=","卡尔","且","基础","-","自","：","names","有效","multiindex","直接",")","labels","就是","cols","本","。","并且","创建","整数","的","列表","继承","一列","一对",".","了","给","可","积"," ","一个","检测","按","第","class","字符串","已经","设置","none","下面","索引","数据","多个","identity","将","levels","指定",",","使用","则","tupleize","笛卡尔","代表","序列","布尔","(","每","（","from"],"title":"多级索引 MultiIndex","title_tokens":["multiindex","多级","索引"," "]},{"location":"pandas笔记/7.4.索引对象.html#tuplemultiindex","text":"import pprint arrays = [ [ 'bar' , 'bar' , 'baz' , 'baz' , 'foo' , 'foo' , 'qux' , 'qux' ], [ 'one' , 'two' , 'one' , 'two' , 'one' , 'two' , 'one' , 'two' ]] tuples = list ( zip ( * arrays )) pprint . pprint ( tuples ) print ( \"\" ) index = pd . MultiIndex . from_tuples ( tuples , names = [ 'first' , 'second' ]) pprint . pprint ( index ) [( 'bar' , 'one' ), ( 'bar' , 'two' ), ( 'baz' , 'one' ), ( 'baz' , 'two' ), ( 'foo' , 'one' ), ( 'foo' , 'two' ), ( 'qux' , 'one' ), ( 'qux' , 'two' )] MultiIndex ([( 'bar' , 'one' ), ( 'bar' , 'two' ), ( 'baz' , 'one' ), ( 'baz' , 'two' ), ( 'foo' , 'one' ), ( 'foo' , 'two' ), ( 'qux' , 'one' ), ( 'qux' , 'two' )], names = [ 'first' , 'second' ]) pd . Series ( np . random . randn ( 8 ), index = index ) first second bar one 0.546165 two 1.495862 baz one -0.786178 two 0.312848 foo one -0.473748 two 0.186548 qux one 0.836214 two -0.547680 dtype: float64","text_tokens":["pprint","random",".","list","8","]"," ","series","arrays","index","print","dtype","0.312848","qux","first","0.186548","'","=","two","foo","\"","-",":","0.473748","np","names",",","0.836214","multiindex","*","second",")","import","0.786178","[","float64","bar","zip","1.495862","(","_","pd","from","0.546165","one","baz","0.547680","randn","tuples"],"title":"从tuple创建MultiIndex","title_tokens":["tuple","创建","multiindex","从"]},{"location":"pandas笔记/7.4.索引对象.html#iterablesmultiindex","text":"iterables = [[ 'bar' , 'baz' , 'foo' , 'qux' ], [ 'one' , 'two' ]] pprint . pprint ( iterables ) print ( \"\" ) index = pd . MultiIndex . from_product ( iterables , names = [ 'first' , 'second' ]) pprint . pprint ( index ) [['bar', 'baz', 'foo', 'qux'], ['one', 'two']] MultiIndex([('bar', 'one'), ('bar', 'two'), ('baz', 'one'), ('baz', 'two'), ('foo', 'one'), ('foo', 'two'), ('qux', 'one'), ('qux', 'two')], names = ['first', 'second'])","text_tokens":["pprint",".","product","]"," ","index","print","qux","first","'","=","two","foo","\"","names",",","multiindex","second",")","[","bar","(","_","pd","from","iterables","one","baz"],"title":"从iterables创建MultiIndex","title_tokens":["创建","iterables","multiindex","从"]},{"location":"pandas笔记/7.4.索引对象.html#dataframemultiindex","text":"df = pd . DataFrame ([[ 'bar' , 'one' ], [ 'bar' , 'two' ], [ 'foo' , 'one' ], [ 'foo' , 'two' ]], columns = [ 'first' , 'second' ]) pprint . pprint ( df ) print ( \"\" ) index = pd . MultiIndex . from_frame ( df ) pprint . pprint ( index ) first second 0 bar one 1 bar two 2 foo one 3 foo two MultiIndex ([( 'bar' , 'one' ), ( 'bar' , 'two' ), ( 'foo' , 'one' ), ( 'foo' , 'two' )], names = [ 'first' , 'second' ])","text_tokens":["pprint",".","dataframe","]"," ","index","print","1","first","2","'","=","two","frame","foo","\"","names","0",",","multiindex","second",")","columns","[","df","bar","(","_","pd","from","one","3"],"title":"从DataFrame创建MultiIndex","title_tokens":["创建","multiindex","从","dataframe"]},{"location":"pandas笔记/7.4.索引对象.html#list-likemultiindex","text":"arrays = [ np . array ([ 'bar' , 'bar' , 'baz' , 'baz' , 'foo' , 'foo' , 'qux' , 'qux' ]), np . array ([ 'one' , 'two' , 'one' , 'two' , 'one' , 'two' , 'one' , 'two' ])] pprint . pprint ( arrays ) pd . DataFrame ( np . random . randn ( 8 , 4 ), index = arrays ) [array(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'], dtype='<U3'), array(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'], dtype='<U3')] 0 1 2 3 bar one -0.089988 1.192690 -0.938933 0.821702 two -0.112540 0.587371 0.165956 0.050362 baz one -0.288737 0.709287 -0.479770 -0.007421 two 2.653461 1.258035 -0.837434 -1.306938 foo one 0.345492 0.311450 -0.008364 0.060572 two -0.304102 0.268357 0.680016 0.445016 qux one -0.809535 1.232934 -0.550252 -2.219605 two 0.729063 -0.992456 0.094162 -0.573775 # s = pd.Series(np.random.randn(8), index=arrays) # s","text_tokens":["pprint","random",".","8","dataframe","]","s"," ","series","arrays","index","0.729063","0.938933","dtype","0.304102","<","0.992456","1","u3","qux","0.288737","0.837434","0.089988","0.112540","1.232934","2.219605","2.653461","2","array","'","0.809535","0.573775","1.258035","4","=","two","0.268357","foo","1.192690","-","0.060572","0.821702","1.306938","np","0","0.094162","0.050362","0.445016",",","0.680016",")","#","0.587371","[","0.479770","0.345492","0.008364","0.550252","bar","0.709287","0.007421","(","pd","one","baz","randn","0.311450","3","0.165956"],"title":"从list-like创建MultiIndex","title_tokens":["list","创建","multiindex","like","从","-"]},{"location":"pandas笔记/7.4.索引对象.html#_2","text":"","text_tokens":[],"title":"选择数据","title_tokens":["数据","选择"]},{"location":"pandas笔记/7.4.索引对象.html#_3","text":"创建示例dataframe： tuples = [( 'bar' , 'one' ), ( 'bar' , 'two' ), ( 'baz' , 'one' ), ( 'baz' , 'two' ), ( 'foo' , 'one' ), ( 'foo' , 'two' ), ( 'qux' , 'one' ), ( 'qux' , 'two' )] index = pd . MultiIndex . from_tuples ( tuples , names = [ 'first' , 'second' ]) df = pd . DataFrame ( np . random . randn ( 3 , 8 ), index = [ 'A' , 'B' , 'C' ], columns = index ) df first bar baz foo qux second one two one two one two one two A 0.137891 -0.288164 -0.236898 -1.201346 0.482293 0.197164 -0.080923 -0.190650 B 0.602663 -0.511166 -0.033371 -0.924746 -1.022346 -2.069830 2.562845 1.347849 C -0.758100 -0.662711 0.507510 0.828843 -0.514439 0.324422 -0.664171 -0.158560 dataframe的 [] 选择列： df [ \"bar\" ] second one two A 0.137891 -0.288164 B 0.602663 -0.511166 C -0.758100 -0.662711 [] 使用多级索引： # 实际上与 df[(\"bar\", \"one\")] 等价 df [ \"bar\" , \"one\" ] A 0.137891 B 0.602663 C -0.758100 Name: (bar, one), dtype: float64 [[]] 选择多列： df [[ \"bar\" , \"baz\" , \"foo\" ]] # list first bar baz foo second one two one two one two A 0.137891 -0.288164 -0.236898 -1.201346 0.482293 0.197164 B 0.602663 -0.511166 -0.033371 -0.924746 -1.022346 -2.069830 C -0.758100 -0.662711 0.507510 0.828843 -0.514439 0.324422 () 用于同一轴的多级索引： df [[( \"bar\" , \"one\" ), ( \"baz\" , \"one\" )]] # list of tuples first bar baz second one one A 0.137891 -0.236898 B 0.602663 -0.033371 C -0.758100 0.507510 # 行列索引 print ( df . loc [ \"A\" , \"bar\" ], \" \\n \" ) # () 用于同一轴的多级索引 print ( df . loc [ \"A\" , ( \"bar\" , \"one\" )], \" \\n \" ) # [] 用于增加轴 以下三行代码等价 print ( df . loc [ \"A\" , [( \"bar\" , \"one\" )]], \" \\n \" ) print ( df . loc [ \"A\" , ( \"bar\" , [ \"one\" ])], \" \\n \" ) print ( df . loc [ \"A\" , ([ \"bar\" ], \"one\" )], \" \\n \" ) # [] 用于增加轴 print ( df . loc [ \"A\" , [ \"bar\" ]], \" \\n \" ) second one 0 . 137891 two - 0 . 288164 Name : A , dtype : float64 0 . 13789062153880624 first second bar one 0 . 137891 Name : A , dtype : float64 first second bar one 0 . 137891 Name : A , dtype : float64 first second bar one 0 . 137891 Name : A , dtype : float64 first second bar one 0 . 137891 two - 0 . 288164 Name : A , dtype : float64 # tuple of lists print ( df . loc [ \"A\" , ([ \"bar\" , \"foo\" ], [ \"one\" , \"two\" ])], \" \\n \" ) # list of tuples print ( df . loc [ \"A\" , [( \"bar\" , \"one\" ), ( \"foo\" , \"two\" )]], \" \\n \" ) first second bar one 0 . 137891 two - 0 . 288164 foo one 0 . 482293 two 0 . 197164 Name : A , dtype : float64 first second bar one 0 . 137891 foo two 0 . 197164 Name : A , dtype : float64","text_tokens":["list","dataframe","0.236898","0.514439","0.511166","多级","行列","实际","first","'","two","0.924746","\\","等价","second","#","0.158560","2.069830","_","0.080923","tuple","lists","tuples","8","用于","137891","dtype","示例","多列","增加","0.324422","b","0.137891","0.288164","0.197164","0.190650","482293","0.033371","0.828843","[","197164","randn","3","random","选择","0.758100","name","与","]","index","列","print","2.562845","1.347849","qux","13789062153880624","c","轴","0.664171","=","foo","-",":","：","names","loc","0.662711","multiindex","n",")","同一","1.022346","创建","pd","的","0.482293","one","以下",".","of"," ","实际上","代码","288164","索引","\"","np","0",",","使用","三行","columns","0.602663","df","float64","bar","(","a","from","baz","1.201346","0.507510"],"title":"列索引是多级索引","title_tokens":["是","多级","索引","列"]},{"location":"pandas笔记/7.4.索引对象.html#_4","text":"df = pd . DataFrame ( np . random . randn ( 8 , 4 ), index = arrays ) df 0 1 2 3 bar one -0.354819 1.546802 -0.150356 -0.801590 two 0.288168 -1.177815 0.222434 -0.717976 baz one -1.585440 0.456956 0.275572 1.242805 two 1.102600 -1.314744 -1.171307 -2.322061 foo one 0.456528 0.922200 1.599342 1.136562 two 0.524887 -0.167836 -1.314889 0.639738 qux one -0.530839 -0.562265 -0.444301 1.227126 two -0.693254 2.555574 0.341882 -0.568909 df . loc [ 'bar' , [ 0 , 1 ]] 0 1 one -0.354819 1.546802 two 0.288168 -1.177815 df . loc [([ 'bar' ], \"one\" ), [ 0 , 1 ]] # df.loc[(['bar'], \"one\"), (0, 1)] 0 1 bar one -0.354819 1.546802","text_tokens":["random",".","8","1.171307","dataframe","0.922200","0.562265","]"," ","1.242805","index","arrays","1.177815","0.444301","0.801590","0.288168","1","2.322061","qux","0.456956","1.546802","2","'","0.222434","4","=","0.150356","two","foo","\"","-","0.639738","0.717976","np","loc","0","1.599342",",","0.693254","2.555574",")","#","1.136562","1.102600","1.585440","[","1.227126","df","0.524887","0.530839","0.167836","0.341882","bar","0.456528","0.568909","(","0.354819","pd","1.314744","one","baz","0.275572","randn","3","1.314889"],"title":"行索引是多级索引","title_tokens":["是","多级","索引","行"]},{"location":"pandas笔记/7.4.索引对象.html#_5","text":"","text_tokens":[],"title":"选择数据进阶","title_tokens":["进阶","数据","选择"]},{"location":"pandas笔记/7.4.索引对象.html#_6","text":"def mklbl ( prefix , n ): return [ \" %s%s \" % ( prefix , i ) for i in range ( n )] miindex = pd . MultiIndex . from_product ([ mklbl ( 'A' , 4 ), mklbl ( 'B' , 2 ), mklbl ( 'C' , 4 ), mklbl ( 'D' , 2 )]) micolumns = pd . MultiIndex . from_tuples ([( 'a' , 'foo' ), ( 'a' , 'bar' ), ( 'b' , 'foo' ), ( 'b' , 'bah' )], names = [ 'lvl0' , 'lvl1' ]) print ( miindex , \" \\n \" ) print ( micolumns , \" \\n \" ) MultiIndex ([( 'A0' , 'B0' , 'C0' , 'D0' ), ( 'A0' , 'B0' , 'C0' , 'D1' ), ( 'A0' , 'B0' , 'C1' , 'D0' ), ( 'A0' , 'B0' , 'C1' , 'D1' ), ( 'A0' , 'B0' , 'C2' , 'D0' ), ( 'A0' , 'B0' , 'C2' , 'D1' ), ( 'A0' , 'B0' , 'C3' , 'D0' ), ( 'A0' , 'B0' , 'C3' , 'D1' ), ( 'A0' , 'B1' , 'C0' , 'D0' ), ( 'A0' , 'B1' , 'C0' , 'D1' ), ( 'A0' , 'B1' , 'C1' , 'D0' ), ( 'A0' , 'B1' , 'C1' , 'D1' ), ( 'A0' , 'B1' , 'C2' , 'D0' ), ( 'A0' , 'B1' , 'C2' , 'D1' ), ( 'A0' , 'B1' , 'C3' , 'D0' ), ( 'A0' , 'B1' , 'C3' , 'D1' ), ( 'A1' , 'B0' , 'C0' , 'D0' ), ( 'A1' , 'B0' , 'C0' , 'D1' ), ( 'A1' , 'B0' , 'C1' , 'D0' ), ( 'A1' , 'B0' , 'C1' , 'D1' ), ( 'A1' , 'B0' , 'C2' , 'D0' ), ( 'A1' , 'B0' , 'C2' , 'D1' ), ( 'A1' , 'B0' , 'C3' , 'D0' ), ( 'A1' , 'B0' , 'C3' , 'D1' ), ( 'A1' , 'B1' , 'C0' , 'D0' ), ( 'A1' , 'B1' , 'C0' , 'D1' ), ( 'A1' , 'B1' , 'C1' , 'D0' ), ( 'A1' , 'B1' , 'C1' , 'D1' ), ( 'A1' , 'B1' , 'C2' , 'D0' ), ( 'A1' , 'B1' , 'C2' , 'D1' ), ( 'A1' , 'B1' , 'C3' , 'D0' ), ( 'A1' , 'B1' , 'C3' , 'D1' ), ( 'A2' , 'B0' , 'C0' , 'D0' ), ( 'A2' , 'B0' , 'C0' , 'D1' ), ( 'A2' , 'B0' , 'C1' , 'D0' ), ( 'A2' , 'B0' , 'C1' , 'D1' ), ( 'A2' , 'B0' , 'C2' , 'D0' ), ( 'A2' , 'B0' , 'C2' , 'D1' ), ( 'A2' , 'B0' , 'C3' , 'D0' ), ( 'A2' , 'B0' , 'C3' , 'D1' ), ( 'A2' , 'B1' , 'C0' , 'D0' ), ( 'A2' , 'B1' , 'C0' , 'D1' ), ( 'A2' , 'B1' , 'C1' , 'D0' ), ( 'A2' , 'B1' , 'C1' , 'D1' ), ( 'A2' , 'B1' , 'C2' , 'D0' ), ( 'A2' , 'B1' , 'C2' , 'D1' ), ( 'A2' , 'B1' , 'C3' , 'D0' ), ( 'A2' , 'B1' , 'C3' , 'D1' ), ( 'A3' , 'B0' , 'C0' , 'D0' ), ( 'A3' , 'B0' , 'C0' , 'D1' ), ( 'A3' , 'B0' , 'C1' , 'D0' ), ( 'A3' , 'B0' , 'C1' , 'D1' ), ( 'A3' , 'B0' , 'C2' , 'D0' ), ( 'A3' , 'B0' , 'C2' , 'D1' ), ( 'A3' , 'B0' , 'C3' , 'D0' ), ( 'A3' , 'B0' , 'C3' , 'D1' ), ( 'A3' , 'B1' , 'C0' , 'D0' ), ( 'A3' , 'B1' , 'C0' , 'D1' ), ( 'A3' , 'B1' , 'C1' , 'D0' ), ( 'A3' , 'B1' , 'C1' , 'D1' ), ( 'A3' , 'B1' , 'C2' , 'D0' ), ( 'A3' , 'B1' , 'C2' , 'D1' ), ( 'A3' , 'B1' , 'C3' , 'D0' ), ( 'A3' , 'B1' , 'C3' , 'D1' )], ) MultiIndex ([( 'a' , 'foo' ), ( 'a' , 'bar' ), ( 'b' , 'foo' ), ( 'b' , 'bah' )], names = [ 'lvl0' , 'lvl1' ])","text_tokens":[".","for","d0","product","s","i"," ","]","miindex","a1","a2","print","b0","c","2","'","b","4","=","range","\\","\"","foo","s%",":","d","mklbl","prefix","lvl0","c1","bah","names","c0","d1",",","b1","multiindex","n",")","micolumns","def","%","[","a0","bar","(","_","pd","a","return","c3","in","from","lvl1","c2","a3","tuples"],"title":"创建索引","title_tokens":["创建","索引"]},{"location":"pandas笔记/7.4.索引对象.html#_7","text":"dfmi = pd . DataFrame ( np . arange ( len ( miindex ) * len ( micolumns )) . reshape (( len ( miindex ), len ( micolumns ))), index = miindex , columns = micolumns ) . sort_index () . sort_index ( axis = 1 ) dfmi lvl0 a b lvl1 bar foo bah foo A0 B0 C0 D0 1 0 3 2 D1 5 4 7 6 C1 D0 9 8 11 10 D1 13 12 15 14 C2 D0 17 16 19 18 ... ... ... ... ... A3 B1 C1 D1 237 236 239 238 C2 D0 241 240 243 242 D1 245 244 247 246 C3 D0 249 248 251 250 D1 253 252 255 254 [ 64 rows x 4 columns ]","text_tokens":["dataframe","len","242","10","dfmi","2","241","c1","bah","15","d1","*","254","_","7","...","243","lvl1","c2","a3","64","8","255","250","miindex","249","b","251","axis","rows","micolumns","reshape","[","245","11","13","246","3","16","237","]","index","b0","4","=","17","foo","lvl0","9","b1","arange",")","239","236","19","247","sort","c3","pd","x","240","12","18",".","d0"," ","1","14","252","244","253","np","c0","0",",","5","columns","6","a0","bar","(","a","238","248"],"title":"创建示例数据","title_tokens":["创建","数据","示例"]},{"location":"pandas笔记/7.4.索引对象.html#_8","text":"","text_tokens":[],"title":"使用切片","title_tokens":["切片","使用"]},{"location":"pandas笔记/7.4.索引对象.html#slice","text":"dfmi . loc [( slice ( 'A1' , 'A3' ), slice ( None ), [ 'C1' , 'C3' ]), :] dfmi . loc [ 'A1' , ( slice ( None ), 'foo' )] lvl0 a b lvl1 foo foo B0 C0 D0 64 66 D1 68 70 C1 D0 72 74 D1 76 78 C2 D0 80 82 D1 84 86 C3 D0 88 90 D1 92 94 B1 C0 D0 96 98 D1 100 102 C1 D0 104 106 D1 108 110 C2 D0 112 114 D1 116 118 C3 D0 120 122 D1 124 126","text_tokens":["94","64",".","88","78","86","d0","118","]","114"," ","116","a1","82","122","96","b0","120","dfmi","'","b","112","none","80","76","124","foo","98","lvl0",":","66","106","c1","loc","c0","70","slice","84","102","d1",",","b1","104",")","108","[","92","74","110","72","68","(","c3","a","100","126","lvl1","c2","a3","90"],"title":"slice","title_tokens":["slice"]},{"location":"pandas笔记/7.4.索引对象.html#indexslice","text":"idx = pd . IndexSlice dfmi . loc [ idx [:, :, [ 'C1' , 'C3' ]], idx [:, 'foo' ]] lvl0 a b lvl1 foo foo A0 B0 C1 D0 8 10 D1 12 14 C3 D0 24 26 D1 28 30 B1 C1 D0 40 42 D1 44 46 C3 D0 56 58 D1 60 62 A1 B0 C1 D0 72 74 D1 76 78 C3 D0 88 90 D1 92 94 B1 C1 D0 104 106 D1 108 110 C3 D0 120 122 D1 124 126 A2 B0 C1 D0 136 138 D1 140 142 C3 D0 152 154 D1 156 158 B1 C1 D0 168 170 D1 172 174 C3 D0 184 186 D1 188 190 A3 B0 C1 D0 200 202 D1 204 206 C3 D0 216 218 D1 220 222 B1 C1 D0 232 234 D1 236 238 C3 D0 248 250 D1 252 254","text_tokens":["206","42","122","234","10","dfmi","'","c1","104","d1","140","92","188","idx","204","254","126","60","lvl1","a3","218","8","40","88","250","a1","44","190","30","216","152","b","154","202","136","184","[","110","72","172","138","200","90","232","158","28","]","168","a2","222","b0","indexslice","=","76","174","foo","106","lvl0",":","loc","b1","46","108","236","56","c3","pd","12","94",".","78","58","220","d0"," ","14","24","62","252","120","186","170","142",",","26","74","a0","a","238","248","156","124"],"title":"IndexSlice","title_tokens":["indexslice"]},{"location":"pandas笔记/7.4.索引对象.html#mask","text":"mask = dfmi [( 'a' , 'foo' )] > 200 dfmi . loc [ idx [ mask , :, [ 'C1' , 'C3' ]], idx [:, 'foo' ]] lvl0 a b lvl1 foo foo A3 B0 C1 D1 204 206 C3 D0 216 218 D1 220 222 B1 C1 D0 232 234 D1 236 238 C3 D0 248 250 D1 252 254","text_tokens":["a3",".","220","206",">","d0","250","]"," ","234","222","b0","252","232","216","dfmi","'","b","=","foo",":","lvl0","c1","loc","d1",",","b1",")","[","236","mask","idx","204","254","(","c3","a","238","248","lvl1","200","218"],"title":"使用 mask 索引","title_tokens":["索引"," ","mask","使用"]},{"location":"pandas笔记/7.4.索引对象.html#lociloc","text":"loc 默认对行进行索引： dfmi . loc ( axis = 0 )[:, :, [ 'C1' , 'C3' ]] lvl0 a b lvl1 bar foo bah foo A0 B0 C1 D0 9 8 11 10 D1 13 12 15 14 C3 D0 25 24 27 26 D1 29 28 31 30 B1 C1 D0 41 40 43 42 D1 45 44 47 46 C3 D0 57 56 59 58 D1 61 60 63 62 A1 B0 C1 D0 73 72 75 74 D1 77 76 79 78 C3 D0 89 88 91 90 D1 93 92 95 94 B1 C1 D0 105 104 107 106 D1 109 108 111 110 C3 D0 121 120 123 122 D1 125 124 127 126 A2 B0 C1 D0 137 136 139 138 D1 141 140 143 142 C3 D0 153 152 155 154 D1 157 156 159 158 B1 C1 D0 169 168 171 170 D1 173 172 175 174 C3 D0 185 184 187 186 D1 189 188 191 190 A3 B0 C1 D0 201 200 203 202 D1 205 204 207 206 C3 D0 217 216 219 218 D1 221 220 223 222 B1 C1 D0 233 232 235 234 D1 237 236 239 238 C3 D0 249 248 251 250 D1 253 252 255 254 可以指定 axis 参数，指定需要索引的轴： dfmi . loc ( axis = 1 )[ \"a\" ] lvl1 bar foo A0 B0 C0 D0 1 0 D1 5 4 C1 D0 9 8 D1 13 12 C2 D0 17 16 ... ... ... A3 B1 C1 D1 237 236 C2 D0 241 240 D1 245 244 C3 D0 249 248 D1 253 252 [ 64 rows x 2 columns ]","text_tokens":["221","109","206","参数","42","122","234","10","31","对行","dfmi","'","2","127","241","c1","173","bah","15","104","d1","默认","45","140","125","143","191","92","188","204","254","...","219","126","60","153","201","lvl1","c2","a3","218","64","8","40","88","255","250","217","a1","可以","44","235","121","249","190","30","216","152","b","154","185","251","202","axis","rows","123","136","184","41","91","[","110","61","72","172","245","138","，","11","159","57","13","进行","90","155","200","232","16","175","107","158","189","28","237","]","168","a2","59","95","222","b0","105","63","137","27","171","141","轴","223","=","76","174","foo","4","106",":","lvl0","9","203","：","loc","89","b1","187",")","46","239","233","108","236","56","c3","的","x","139","240","12","205","29","94",".","78","58","220","d0","73"," ","157","1","14","24","62","252","244","120","111","25","186","253","170","索引","142","\"","93","43","c0","0","207","79","指定",",","77","26","5","75","169","47","columns","74","a0","bar","需要","(","a","238","17","248","156","124"],"title":"给 loc或iloc 指定轴参数","title_tokens":["给","指定","参数","或"," ","轴","iloc","loc"]},{"location":"pandas笔记/7.4.索引对象.html#_9","text":"df2 = dfmi . copy () df2 . loc ( axis = 0 )[:, :, [ 'C1' , 'C3' ]] = - 10 df2 df2 = dfmi . copy () df2 . loc [ idx [:, :, [ 'C1' , 'C3' ]], :] = df2 * 1000 df2 lvl0 a b lvl1 bar foo bah foo A0 B0 C0 D0 1 0 3 2 D1 5 4 7 6 C1 D0 9000 8000 11000 10000 D1 13000 12000 15000 14000 C2 D0 17 16 19 18 ... ... ... ... ... A3 B1 C1 D1 237000 236000 239000 238000 C2 D0 241 240 243 242 D1 245 244 247 246 C3 D0 249000 248000 251000 250000 D1 253000 252000 255000 254000 [ 64 rows x 4 columns ]","text_tokens":["242","238000","10","239000","dfmi","'","2","df2","252000","241","c1","8000","bah","d1","*","copy","idx","...","7","243","lvl1","c2","a3","64","236000","14000","b","10000","axis","rows","12000","[","245","254000","249000","3","246","16","]","b0","251000","4","=","17","foo","-",":","lvl0","loc","b1",")","1000","19","247","c3","x","240","15000","18",".","d0","253000"," ","248000","1","255000","244","237000","c0","0",",","5","11000","columns","9000","6","a0","bar","(","a","13000","250000"],"title":"重新赋值","title_tokens":["重新","赋值"]},{"location":"pandas笔记/7.4.索引对象.html#_10","text":"DataFrame 的 xs() 方法接受一个额外的参数，从而可以简便地在某个特定的多级索引中的某一个层级进行数据的选取。 df = pd . DataFrame ( np . random . randn ( 6 , 3 ), index = index [: 6 ]) df = df . T df first bar baz foo second one two one two one two 0 1.939044 0.588276 1.146525 -0.188147 -0.720676 1.451303 1 -0.028778 -0.897224 -0.038871 -0.485770 -0.958363 -0.963243 2 -0.911336 0.031492 0.795475 0.234746 0.361175 0.659001 .xs 方法默认 axis=0 ： df . xs ( \"bar\" , level = 'first' , axis = 1 ) df . xs ( \"one\" , level = 'second' , axis = 1 ) first bar baz foo 0 1.939044 1.146525 -0.720676 1 -0.028778 -0.038871 -0.958363 2 -0.911336 0.795475 0.361175 df . xs (( 'one' , 'bar' ), level = ( 'second' , 'first' ), axis = 1 ) first bar second one 0 1.939044 1 -0.028778 2 -0.911336 .xs 方法默认 drop_level=False ： df . xs ( 'one' , level = 'second' , axis = 1 , drop_level = False ) first bar baz foo second one one one 0 1.939044 1.146525 -0.720676 1 -0.028778 -0.038871 -0.958363 2 -0.911336 0.795475 0.361175 df . xs ( 'one' , level = 'second' , axis = 1 , drop_level = True ) first bar baz foo 0 1.939044 1.146525 -0.720676 1 -0.028778 -0.038871 -0.958363 2 -0.911336 0.795475 0.361175","text_tokens":["dataframe","参数","多级","first","0.588276","2","'","two","从而","drop","0.038871","默认","true","second","简便","1.939044","level","_","0.028778","中","选取","可以","0.958363","0.485770","false","在","某个","方法","axis","额外","0.031492","0.188147","[","1.451303","t","，","randn","3","0.361175","进行","random","0.911336","]","index","0.963243","=","foo",":","-","：",")","。","pd","的","特定","接受","one",".","0.720676","0.897224"," ","一个","xs","1","层级","0.659001","索引","数据","\"","np","0",",","0.234746","df","0.795475","6","某","bar","(","地","baz","1.146525"],"title":"交叉选择","title_tokens":["交叉","选择"]},{"location":"pandas笔记/7.4.索引对象.html#take","text":"与 NumPy 的 ndarrays 相似，pandas的 Index ， Series ，和 DataFrame 也提供 take() 方法。他可以沿着某个维度，按照给定的索引取回所有的元素。这个给定的索引必须要是一个由整数组成的列表或者ndarray，用以指明在索引中的位置。 take 也可以接受负整数，作为相对于结尾的相对位置。 index = pd . Index ( np . random . randint ( 0 , 1000 , 10 )) print ( index ) positions = [ 0 , 9 , 3 ] print ( index [ positions ]) print ( index . take ( positions )) Int64Index([495, 309, 722, 91, 889, 309, 148, 970, 329, 776], dtype='int64') Int64Index([495, 776, 91], dtype='int64') Int64Index([495, 776, 91], dtype='int64') ser = pd . Series ( np . random . randn ( 10 )) print ( ser . iloc [ positions ]) print ( ser . take ( positions )) 0 0.591030 9 -0.593299 3 0.021434 dtype: float64 0 0.591030 9 -0.593299 3 0.021434 dtype: float64 对于 DataFrames 来说，这个给定的索引应当是一个一维列表或者ndarray，用于指明行或者列的位置。 frm = pd . DataFrame ( np . random . randn ( 5 , 3 )) print ( frm ) print ( frm . take ([ 1 , 4 , 3 ])) print ( frm . take ([ 0 , 2 ], axis = 1 )) 0 1 2 0 -0.019443 0.710586 0.481252 1 -0.181836 0.772916 0.783044 2 -1.793119 0.445353 1.196131 3 -1.040532 0.333872 -0.010054 4 0.351876 1.118853 0.093517 0 1 2 1 -0.181836 0.772916 0.783044 4 0.351876 1.118853 0.093517 3 -1.040532 0.333872 -0.010054 0 2 0 -0.019443 0.481252 1 -0.181836 0.783044 2 -1.793119 1.196131 3 -1.040532 -0.010054 4 0.351876 0.093517 需要注意的是， pandas对象的 take 方法并不会正常地工作在布尔索引上，并且有可能会返回一切意外的结果。 arr = np . random . randn ( 10 ) print ( arr ) print ( arr . take ([ False , False , True , True ])) print ( arr [[ 0 , 1 ]]) [-0.53649475 0.13255386 0.04098733 0.82386728 0.08692377 0.30652204 0.24007645 0.22604287 -0.53147612 2.34366636] [-0.53649475 -0.53649475 0.13255386 0.13255386] [-0.53649475 0.13255386] ser = pd . Series ( np . random . randn ( 10 )) print ( ser ) print ( ser . take ([ False , False , True , True ])) print ( ser . iloc [[ 0 , 1 ]]) 0 -0.103801 1 -1.621499 2 -0.028563 3 0.407877 4 -0.266058 5 1.390450 6 -1.002601 7 -0.335144 8 -0.461811 9 0.997019 dtype: float64 0 -0.103801 0 -0.103801 1 -1.621499 1 -1.621499 dtype: float64 0 -0.103801 1 -1.621499 dtype: float64 最后，关于性能方面的一个小建议，因为 take 方法处理的是一个范围更窄的输入，因此会比话实索引（fancy indexing）的速度快很多。 arr = np . random . randn ( 10000 , 5 ) indexer = np . arange ( 10000 ) random . shuffle ( indexer ) % timeit arr [ indexer ] % timeit arr . take ( indexer , axis = 0 ) 373 µs ± 46.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) 132 µs ± 12.3 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each) ser = pd . Series ( arr [:, 0 ]) % timeit ser . iloc [ indexer ] % timeit ser . take ( indexer ) 336 µs ± 49.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) 355 µs ± 60.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)","text_tokens":["dataframe","指明","0.24007645","s","结尾","结果","他","一维","0.333872","776","10","沿着","randint","shuffle","由","2","'","0.53147612","0.08692377","小","889","0.266058","arr","0.103801","1.196131","132","输入","于","true","numpy","0.481252","take","49.5","因为","indexing","和","7","1.793119","位置","意外","对于","提供","±","int64index","495","应当","0.04098733","0.13255386","fancy","）","8","中","必须","series","329","可以","用于","positions","dtype","快","是","frm","比话实","不会","std","来说","会","pandas","1.390450","关于","false","在","某个","0.461811","10000","60.5","方法","axis","更窄","0.028563","970","给定","0.335144","91","0.181836","[","上","0.710586","方面","ndarrays","并","309","，","ndarray","1.040532","0.093517","randn","3","random","维度","按照","对象","与","]","也","index","列","loops","print","返回","0.772916","工作","0.593299","2.34366636","0.22604287","4","=","性能","each","-","相似","9",":","1.002601","arange",")","1000","0.53649475","。","148","0.30652204","ser","0.010054","并且","整数","0.445353","要是","pd","的","indexer","因此","接受","列表","行","0.82386728","最后",".","46.5","dev","loop","0.351876","of","1.118853"," ","722","0.997019","一个","很多","mean","0.783044","1.621499","373","1","iloc","12.3","dataframes","处理","0.019443","这个","per","timeit","范围","索引","取回","0.591030","所有","np","有","0","µ","355","336","runs",",","注意","5","0.021434","作为","负","%","或者","可能","int64","float64","6","一切","建议","需要","布尔","(","正常","地","（","0.407877","元素","速度","组成","相对","用以"],"title":"Take方法","title_tokens":["take","方法"]},{"location":"pandas笔记/7.4.索引对象.html#_11","text":"CategoricalIndex 分类索引 这种索引类型非常适合有重复的索引。这是一个围绕 Categorical 而创建的容器。这可以非常高效地存储和索引的具有大量重复元素的索引。 from pandas.api.types import CategoricalDtype df = pd . DataFrame ({ 'A' : np . arange ( 6 ), 'B' : list ( 'aabbca' )}) df [ 'B' ] = df [ 'B' ] . astype ( CategoricalDtype ( list ( 'cab' ))) print ( df , \" \\n \" ) print ( df . dtypes , \" \\n \" ) print ( df . B . cat . categories , \" \\n \" ) A B 0 0 a 1 1 a 2 2 b 3 3 b 4 4 c 5 5 a A int32 B category dtype : object Index ([ 'c' , 'a' , 'b' ], dtype = 'object' ) 通过设置索引将会建立一个 CategoricalIndex 分类索引. df2 = df . set_index ( 'B' ) print ( df2 . index ) CategoricalIndex(['a', 'a', 'b', 'b', 'c', 'a'], categories=['c', 'a', 'b'], ordered=False, name='B', dtype='category') 使用 __getitem__/.iloc/.loc 进行索引，在含有重复值的 索引 上的工作原理相似。索引值 必须 在一个分类中，否者将会引发 KeyError 错误。 df2 . loc [ 'a' ] A B a 0 a 1 a 5 CategoricalIndex 在索引之后也会被 保留 : df2 . loc [ 'a' ] . index CategoricalIndex(['a', 'a', 'a'], categories=['c', 'a', 'b'], ordered=False, name='B', dtype='category') 索引排序将会按照类别清单中的顺序进行（我们已经基于 CategoricalDtype(list('cab')) 建立了一个索引，因此排序的顺序是 cab ） df2 . sort_index () A B c 4 a 0 a 1 a 5 b 2 b 3 分组操作（Groupby）也会保留索引的全部信息。 df2 . groupby ( level = 0 ) . sum () df2 . groupby ( level = 0 ) . sum () . index CategoricalIndex(['c', 'a', 'b'], categories=['c', 'a', 'b'], ordered=False, name='B', dtype='category') 重设索引的操作将会根据输入的索引值返回一个索引。传入一个列表，将会返回一个最普通的 Index ；如果使用类别对象 Categorical ，则会返回一个分类索引 CategoricalIndex ，按照其中 传入的 的类别值 Categorical dtype来进行索引。正如同你可以对 任意 pandas的索引进行重新索引一样，这将允许你随意索引任意的索引值，即便它们并 不存在 在你的类别对象中。 df2 . reindex ([ 'a' , 'e' ]) df2 . reindex ([ 'a' , 'e' ]) . index Index(['a', 'a', 'a', 'e'], dtype='object', name='B') df2 . reindex ( pd . Categorical ([ 'a' , 'e' ], categories = list ( 'abcde' ))) df2 . reindex ( pd . Categorical ([ 'a' , 'e' ], categories = list ( 'abcde' ))) . index CategoricalIndex(['a', 'a', 'a', 'e'], categories=['a', 'b', 'c', 'd', 'e'], ordered=False, name='B', dtype='category')","text_tokens":["list","这是","dataframe","如果","允许","如同","最","被","category","存在","引发","2","'","}","df2","\\","类型","非常适合","大量","分类","api","根据","set","d","重新","原理","不","输入","通过","将会","level","它们","含有","重复","_","和","信息","存储","即便","这","reindex","ordered","）","中","必须","可以","{","keyerror","清单","dtype","cat","object","是","；","正","b","否者","会","pandas","/","而","分组","false","在","全部","你","categoricalindex","其中","一样","categorical","types","非常","围绕","[","上","aabbca","重设","值","错误","astype","abcde","并","，","之后","3","进行","按照","随意","name","对象","]","也","e","index","dtypes","建立","对","print","返回","排序","操作","这种","c","来","工作","getitem","顺序","4","=",":","相似","loc","我们","n","arange",")","import","。","int32","groupby","sort","创建","pd","适合","的","因此","列表","分类索引",".","了","传入","基于","sum","categoricaldtype"," ","普通","一个","categories","类别","1","iloc","保留","已经","设置","索引","\"","将","np","有","0",",","使用","则","高效","5","容器","df","6","cab","任意","(","地","a","（","from","元素","具有","__"],"title":"分类索引","title_tokens":["分类","分类索引","索引"]},{"location":"pandas笔记/7.4.索引对象.html#_12","text":"0.20.0中新加入 IntervalIndex 和它自己特有的 IntervalDtype 以及 Interval 标量类型，在pandas中，间隔数据是获得头等支持的。 IntervalIndex 间隔索引允许一些唯一的索引，并且也是 cut() 和 qcut() 的返回类型","text_tokens":[".","中","自己","它"," ","intervaldtype","也","允许","标量","返回","是","获得","加入","0.20","pandas","间隔","索引","数据","类型","在","唯一","0","中新","cut",")","一些","。","特有","intervalindex","interval","并且","支持","以及","(","和","qcut","的","，","头等"],"title":"间隔索引","title_tokens":["间隔","索引"]},{"location":"pandas笔记/7.4.索引对象.html#_13","text":"df = pd . DataFrame ({ 'A' : [ 1 , 2 , 3 , 4 ]}, index = pd . IntervalIndex . from_breaks ([ 0 , 1 , 2 , 3 , 4 ])) df A (0, 1] 1 (1, 2] 2 (2, 3] 3 (3, 4] 4 在间隔序列上使用基于标签的索引 .loc ，正如你所预料到的，将会选择那个特定的间隔 df . loc [ 2 ] A 2 Name: (1, 2], dtype: int64 df . loc [[ 2 , 3 ]] A (1, 2] 2 (2, 3] 3 如果你选取了一个标签，被 包含 在间隔当中，这个间隔也将会被选择 df . loc [ 2.5 ] A 3 Name: (2, 3], dtype: int64 df . loc [[ 2.5 , 3.5 ]] A (2, 3] 3 (3, 4] 4 使用 Interval 来选择，将只返回严格匹配（从pandas0.25.0开始）。 df . loc [ pd . Interval ( 1 , 2 )] A 2 Name: (1, 2], dtype: int64 试图选择一个没有被严格包含在 IntervalIndex 内的区间 Interval ，将会出发 KeyError 错误。 try : df . loc [ pd . Interval ( 0.5 , 2.5 )] except KeyError as e : print ( \"KeyError:\" , e ) KeyError : Interval ( 0.5 , 2.5 , closed = 'right' ) 可以使用 overlaps() 来创建一个布尔选择器，来选中所有与 给定区间 ( Interval )重复的所有区间。 idxr = df . index . overlaps ( pd . Interval ( 0.5 , 2.5 )) print ( idxr ) print ( df [ idxr ]) [ True True True False] A (0, 1] 1 (1, 2] 2 (2, 3] 3","text_tokens":["dataframe","如果","出发","2","'","}","3.5","overlaps","严格","将会","true","2.5","try","重复","interval","_","所","breaks","）","选取","可以","{","keyerror","idxr","dtype","会","false","在","你","内","只","选择器","料到","给定","开始","[","上","intervalindex","错误","，","预料到","当中","3","那个","选择","name","与","]","也","区间","e","index","closed","print","0.5","返回","标签","没有","来","试图","4","=",":","loc",")","。","right","创建","pd","的","特定",".","了","基于"," ","一个","选中","1","这个","间隔","索引","\"","将","所有","0","pandas0.25",",","使用","包含","从","匹配","int64","df","except","序列","正如","布尔","(","a","（","from","as","被","预料"],"title":"使用 间隔索引 来进行数据索引","title_tokens":["来","使用"," ","间隔","索引","数据","进行"]},{"location":"pandas笔记/7.4.索引对象.html#-cut-qcut-cut-qcut","text":"cut() 和 qcut() 都将返回一个分类 Categorical 对象，并且每个分块区域都会以 分类索引 IntervalIndex 的方式被创建并保存在它的 .categories 属性中。 c = pd . cut ( range ( 4 ), bins = 2 ) print ( c ) print ( c . categories ) [(-0.003, 1.5], (-0.003, 1.5], (1.5, 3.0], (1.5, 3.0]] Categories (2, interval[float64]): [(-0.003, 1.5] < (1.5, 3.0]] IntervalIndex([(-0.003, 1.5], (1.5, 3.0]], closed = 'right', dtype='interval[float64]') cut() 也可以接受一个 IntervalIndex 作为他的 bins 参数，这样可以使用一个非常有用的pandas的写法。 首先，我们调用 cut() 在一些数据上面，并且将 bins 设置为某一个固定的数 ，从而生成bins。 随后，我们可以在其他的数据上调用 cut() ，并传入 .categories 的值，作为 bins 参数。这样新的数据就也将会被分配到同样的bins里面 pd . cut ([ 0 , 3 , 5 , 1 ], bins = c . categories ) [(-0.003, 1.5], (1.5, 3.0], NaN, (-0.003, 1.5]] Categories (2, interval[float64]): [(-0.003, 1.5] < (1.5, 3.0]] 任何落在bins之外的数据都将会被设为 NaN","text_tokens":["参数","它","到","他","之外","2","'","生成","从而","分类","保存","调用","一些","有用","interval","nan","和","随后","每个","中","可以","dtype","0.003","会","pandas","设为","range","在","categorical","方式","这样","非常","属性","首先","[","上","intervalindex","值","1.5","并","为","，","3.0","3","同样","bins","固定","对象","]","也","closed","任何","分块","print","返回","都","c","落","4","=","-",":","新","我们",")","。","写法","right","并且","创建","pd","的","接受","就","数","区域","分类索引",".","传入"," ","一个","categories","<","1","分配","设置","其他","索引","数据","上面","将","0",",","使用","cut","5","作为","以","float64","某","(","qcut","里面","被"],"title":"使用-cut-和-qcut来为数据分块使用 cut 和 qcut来为数据分块","title_tokens":["来","使用","cut","和","qcut","为"," ","分块","数据","-"]},{"location":"pandas笔记/7.4.索引对象.html#_14","text":"如果我们需要经常地使用步进区间，我们可以使用 interval_range() 函数，结合 start , end , 和 periods 来建立一个 IntervalIndex 对于数值型的间隔，默认的 interval_range 间隔频率是1，对于datetime类型的间隔则是日历日。 pd . interval_range ( start = 0 , end = 5 ) pd . interval_range ( start = pd . Timestamp ( '2017-01-01' ), periods = 4 ) pd . interval_range ( end = pd . Timedelta ( '3 days' ), periods = 3 ) IntervalIndex ( [ (0 days 00:00:00, 1 days 00:00:00 ] , ( 1 days 00 : 00 : 00 , 2 days 00 : 00 : 00 ] , ( 2 days 00 : 00 : 00 , 3 days 00 : 00 : 00 ]] , closed = 'right' , dtype = 'interval[timedelta64[ns]]' ) freq 参数可以被用来明确非默认的频率，并且可以充分地利用各种各样的 frequency aliases datetime类型的时间间隔。 pd . interval_range ( start = 0 , periods = 5 , freq = 1.5 ) pd . interval_range ( start = pd . Timestamp ( '2017-01-01' ), periods = 4 , freq = 'W' ) pd . interval_range ( start = pd . Timedelta ( '0 days' ), periods = 3 , freq = '9H' ) IntervalIndex ( [ (0 days 00:00:00, 0 days 09:00:00 ] , ( 0 days 09 : 00 : 00 , 0 days 18 : 00 : 00 ] , ( 0 days 18 : 00 : 00 , 1 days 03 : 00 : 00 ]] , closed = 'right' , dtype = 'interval[timedelta64[ns]]' ) 此外， closed 参数可以用来声明哪个边界是包含的。默认情况下，间隔的右界是包含的。 pd . interval_range ( start = 0 , end = 4 , closed = 'both' ) pd . interval_range ( start = 0 , end = 4 , closed = 'neither' ) IntervalIndex ( [ (0, 1), (1, 2), (2, 3), (3, 4) ] , closed = 'neither' , dtype = 'interval[int64]' ) v0.23.0新加入 使用 start , end , 和 periods 可以从 start 到 end （包含）生成一个平均分配的间隔，在返回 IntervalIndex 中生成 periods 这么多的元素（译者：区间）。 pd . interval_range ( start = 0 , end = 6 , periods = 4 ) pd . interval_range ( pd . Timestamp ( '2018-01-01' ), pd . Timestamp ( '2018-02-28' ), periods = 3 ) IntervalIndex ( [ (2018-01-01, 2018-01-20 08:00:00 ] , ( 2018 - 01 - 20 08 : 00 : 00 , 2018 - 02 - 08 16 : 00 : 00 ] , ( 2018 - 02 - 08 16 : 00 : 00 , 2018 - 02 - 28 ]] , closed = 'right' , dtype = 'interval[datetime64[ns]]' )","text_tokens":["用来","参数","如果","到","2","'","ns","生成","类型","w","此外","默认","声明","利用","interval","频率","_","和","平均分","对于","both","均分","2018","periods","）","日历","中","数值","步进","可以","dtype","明确","函数","是","哪个","加入","range","在","days","20","右界","[","intervalindex","freq","1.5","03","00","，","02","datetime64","3","16","28","]","区间","closed","型","建立","返回","timestamp","neither","timedelta","datetime","元素","来","各样","4","=","-",":","：","情况","新","这么","我们",")","多","。","right","timedelta64","日","9h","并且","结合","pd","的","各种","译者","充分","18",".","v0.23"," ","一个","aliases","经常","1","分配","start","01","非","边界","间隔","09","0",",","使用","则","时间","end","5","各种各样","包含","从","平均分配","int64","下","6","2017","需要","(","地","frequency","（","08","平均","被"],"title":"生成一定区间内的间隔","title_tokens":["一定","区间","的","生成","间隔","内"]},{"location":"pandas笔记/7.5.索引的基本操作.html","text":"Windows 10 Python 3.7.3 @ MSC v.1915 64 bit (AMD64) from tools import Help as H import pandas as pd from pandas import DataFrame , Series import numpy as np h = H ( pd ) d = h . dicts module 索引对象的方法 tuples = [( 'bar' , 'one' ), ( 'bar' , 'two' ), ( 'baz' , 'one' ), ( 'baz' , 'two' ), ( 'foo' , 'one' ), ( 'foo' , 'two' ), ( 'qux' , 'one' ), ( 'qux' , 'two' )] index = pd . MultiIndex . from_tuples ( tuples , names = [ 'first' , 'second' ]) index MultiIndex([('bar', 'one'), ('bar', 'two'), ('baz', 'one'), ('baz', 'two'), ('foo', 'one'), ('foo', 'two'), ('qux', 'one'), ('qux', 'two')], names=['first', 'second']) .levels 为 property 属性，它返回一个 FrozenList （不可变列表），列表中存储每一级的 label （也就是创建 MultiIndex 时传入的 levels 参数）。 index . levels FrozenList([['bar', 'baz', 'foo', 'qux'], ['one', 'two']]) .get_level_values(level) ：返回指定 level 的 Index ，用于 MultiIndex 。 print ( index . get_level_values ( 0 ), \" \\n \" ) print ( index . get_level_values ( 1 ), \" \\n \" ) print ( index . get_level_values ( 'second' )) Index ([ 'bar' , 'bar' , 'baz' , 'baz' , 'foo' , 'foo' , 'qux' , 'qux' ], dtype = 'object' , name = 'first' ) Index ([ 'one' , 'two' , 'one' , 'two' , 'one' , 'two' , 'one' , 'two' ], dtype = 'object' , name = 'second' ) Index ([ 'one' , 'two' , 'one' , 'two' , 'one' , 'two' , 'one' , 'two' ], dtype = 'object' , name = 'second' ) df = pd . DataFrame ( np . random . randn ( 6 , 6 ), index = index [: 6 ], columns = index [: 6 ]) df . columns . levels # original MultiIndex df [[ 'foo' , 'qux' ]] . columns . levels # sliced df [[ 'foo' , 'qux' ]] . columns . to_numpy () # for a specific level df [[ 'foo' , 'qux' ]] . columns . get_level_values ( 0 ) Index(['foo', 'foo'], dtype='object', name='first') new_mi = df [[ 'foo' , 'qux' ]] . columns . remove_unused_levels () new_mi . levels FrozenList([['foo'], ['one', 'two']]) 索引重赋值、索引对齐 level 参数已经被加入到pandas对象中的 reindex() 和 align() 方法中。这将有助于沿着一个层级来广播值（broadcast values）。例如： 创建示例 df ： midx = pd . MultiIndex ( levels = [[ 'zero' , 'one' ], [ 'x' , 'y' ]], codes = [[ 1 , 1 , 0 , 0 ], [ 1 , 0 , 1 , 0 ]]) df = pd . DataFrame ( np . random . randn ( 4 , 2 ), index = midx ) df 0 1 one y 1.821732 0.913649 x 0.346144 0.378045 zero y 1.329143 -0.694748 x -1.393348 0.618127 创建示例 df2 ： df2 = df . mean ( level = 0 ) df2 0 1 one 1.083938 0.645847 zero -0.032103 -0.038310 df2 . reindex ( df . index , level = 0 ) 0 1 one y 1.083938 0.645847 x 1.083938 0.645847 zero y -0.032103 -0.038310 x -0.032103 -0.038310 # aligning df_aligned , df2_aligned = df . align ( df2 , level = 0 ) print ( df_aligned , \" \\n \" ) print ( df2_aligned ) 0 1 one y 1 . 821732 0 . 913649 x 0 . 346144 0 . 378045 zero y 1 . 329143 - 0 . 694748 x - 1 . 393348 0 . 618127 0 1 one y 1 . 083938 0 . 645847 x 1 . 083938 0 . 645847 zero y - 0 . 032103 - 0 . 038310 x - 0 . 032103 - 0 . 038310 reindex 方法参数 重新索引： Series/DataFrame.reindex(index=None, **kwargs) ： index ：一个 array-like 对象，给出了新的 index 的 label columns ：一个 array-like 对象，给出了新的 columns 的 label method ：当新的 label 的值缺失时，如何处理。参数值可以为： None ：不做任何处理，缺失地方填充 NaN - 'backfill'/'bfill' ：用下一个可用的值填充该空缺（后向填充） - 'pad'/'ffill' ：用上一个可用的值填充该空缺（前向填充） - 'nearest' ：用最近的可用值填充该空缺- copy ：一个布尔值，如果为 True ，则返回一个新的 Series 对象（即使传入的 index 与原来的 index 相同） level ：一个整数或者 name ，在 MultiIndex 的指定级别上匹配简单索引 fill_value ：一个标量。指定缺失值的填充数据，默认为 NaN （如果该参数与 method 同时出现，则以 method 为主） limit ：一个整数，指定前向/后向填充时：如果有连续的 k 个 NaN ，则只填充其中 limit 个。它与 method 配合 tolerance ：一个整数，用于给出在不匹配时，连续采用前向/后向/最近邻匹配的跨度的最大值。它与 method 配合 交换索引层级： swaplevel 方法 swaplevel() 函数可以用来交换两个层级 print ( df , \" \\n \" ) print ( df . swaplevel ( 0 , 1 , axis = 0 )) 0 1 one y 1 . 821732 0 . 913649 x 0 . 346144 0 . 378045 zero y 1 . 329143 - 0 . 694748 x - 1 . 393348 0 . 618127 0 1 y one 1 . 821732 0 . 913649 x one 0 . 346144 0 . 378045 y zero 1 . 329143 - 0 . 694748 x zero - 1 . 393348 0 . 618127 交换索引层级： reorder_levels 方法 reorder_levels() 是一个更一般化的 swaplevel 方法，允许您用简单的一步来重排列索引的层级： print ( df , \" \\n \" ) print ( df . reorder_levels ([ 1 , 0 ], axis = 0 )) 0 1 one y 1 . 821732 0 . 913649 x 0 . 346144 0 . 378045 zero y 1 . 329143 - 0 . 694748 x - 1 . 393348 0 . 618127 0 1 y one 1 . 821732 0 . 913649 x one 0 . 346144 0 . 378045 y zero 1 . 329143 - 0 . 694748 x zero - 1 . 393348 0 . 618127 重命名索引 - `` File \"<ipython-input-1-2af17b23912b>\", line 1 - `` ^ SyntaxError: invalid syntax rename() 方法可以用来重命名多层索引，也可以用来重命名列。 renames 的 columns 参数可以接受一个字典，从而仅仅重命名你希望更改名字的列： df . rename ( columns = { 0 : \"col0\" , 1 : \"col1\" }) col0 col1 one y 1.821732 0.913649 x 0.346144 0.378045 zero y 1.329143 -0.694748 x -1.393348 0.618127 用于重命名索引： df . rename ( index = { \"one\" : \"two\" , \"y\" : \"z\" }) 0 1 two z 1.821732 0.913649 x 0.346144 0.378045 zero z 1.329143 -0.694748 x -1.393348 0.618127 rename_axis() 方法可以用于对 Index 或者 MultiIndex 进行重命名。尤其的，你可以明确 MultiIndex 中的不同层级的名称，这可以被用于在之后使用 reset_index() ，把多层级索引的值转换为一个列 df . rename_axis ( index = [ 'abc' , 'def' ]) 0 1 abc def one y 1.821732 0.913649 x 0.346144 0.378045 zero y 1.329143 -0.694748 x -1.393348 0.618127 注意， DataFrame 的列也是一个索引，因此在 rename_axis 中使用 columns 参数，将会改变那个索引的名称 df . rename_axis ( columns = \"Cols\" ) . columns RangeIndex(start=0, stop=2, step=1, name='Cols') rename 和 rename_axis 都支持一个明确的字典， Series 或者一个映射函数，将标签，名称映射为新的值。 df . rename_axis ( index = [ 'abc' , 'def' ], inplace = True ) print ( df ) 0 1 abc def one y 1.821732 0.913649 x 0.346144 0.378045 zero y 1.329143 -0.694748 x -1.393348 0.618127 对 多索引 进行排序 对于拥有多层级索引的对象来说，使用 sort_index 方法来排序。 创建示例 s ： import random tuples = [( 'bar' , 'one' ), ( 'bar' , 'two' ), ( 'baz' , 'one' ), ( 'baz' , 'two' ), ( 'foo' , 'one' ), ( 'foo' , 'two' ), ( 'qux' , 'one' ), ( 'qux' , 'two' )] random . shuffle ( tuples ) s = pd . Series ( np . random . randn ( 8 ), index = pd . MultiIndex . from_tuples ( tuples )) s qux two -0.805656 one 0.404373 baz one 0.597193 bar two -0.280613 one -0.581470 baz two 1.072317 foo one 0.244656 two -0.071497 dtype: float64 # 两者等价 s . sort_index () s . sort_index ( level = 0 ) bar one -0.581470 two -0.280613 baz one 0.597193 two 1.072317 foo one 0.244656 two -0.071497 qux one 0.404373 two -0.805656 dtype: float64 s . sort_index ( level = 1 ) bar one -0.581470 baz one 0.597193 foo one 0.244656 qux one 0.404373 bar two -0.280613 baz two 1.072317 foo two -0.071497 qux two -0.805656 dtype: float64 如果“多层级索引”都被命名了的话，你也可以向 sort_index 传入一个层级名称。 s . index . set_names ([ 'L1' , 'L2' ], inplace = True ) print ( s . sort_index ( level = 'L1' ), \" \\n \" ) print ( s . sort_index ( level = 'L2' )) L1 L2 bar one - 0 . 581470 two - 0 . 280613 baz one 0 . 597193 two 1 . 072317 foo one 0 . 244656 two - 0 . 071497 qux one 0 . 404373 two - 0 . 805656 dtype : float64 L1 L2 bar one - 0 . 581470 baz one 0 . 597193 foo one 0 . 244656 qux one 0 . 404373 bar two - 0 . 280613 baz two 1 . 072317 foo two - 0 . 071497 qux two - 0 . 805656 dtype : float64 对于多维度的对象来说，你也可以对任意的的维度来进行索引，只要他们是具有 多层级索引 的： df . T . sort_index ( level = 1 , axis = 1 ) abc one zero one zero def x x y y 0 0.346144 -1.393348 1.821732 1.329143 1 0.378045 0.618127 0.913649 -0.694748 即便数据没有排序，你仍然可以对他们进行索引，但是索引的效率会极大降低，并且也会抛出 PerformanceWarning 警告。而且，这将返回一个数据的副本而非一个数据的视图： dfm = pd . DataFrame ({ 'jim' : [ 0 , 0 , 1 , 1 ], 'joe' : [ 'x' , 'x' , 'z' , 'y' ], 'jolie' : np . random . rand ( 4 )}) dfm = dfm . set_index ([ 'jim' , 'joe' ]) dfm dfm . loc [( 1 , 'z' )] .\\setup_m.py:9: PerformanceWarning: indexing past lexsort depth may impact performance. jolie jim joe 1 z 0.646365 另外，如果你试图索引一个没有完全lexsorted的对象，你将会碰到如下的错误： try : dfm . loc [( 0 , 'y' ):( 1 , 'z' )] except Exception as e : print ( f \"UnsortedIndexError: {e} \" ) UnsortedIndexError: 'Key length (2) was greater than MultiIndex lexsort depth (1)' 排序之后则不会报错 dfm . sort_index () . loc [( 0 , 'y' ):( 1 , 'z' )] jolie jim joe 1 y 0.041386 z 0.646365 在 MultiIndex 上使用 is_lexsorted() 方法，你可以查看这个索引是否已经被排序。而使用 lexsort_depth 属性则可以返回排序的深度 dfm . index . is_lexsorted () False dfm . index . lexsort_depth 1 dfm = dfm . sort_index () dfm jolie jim joe 0 x 0.785068 x 0.473428 1 y 0.041386 z 0.646365 dfm . index . is_lexsorted () True dfm . index . lexsort_depth 2 现在，你的选择就可以正常工作了。 dfm . loc [( 0 , 'y' ):( 1 , 'z' )] jolie jim joe 1 y 0.041386 z 0.646365 将列转换为索引 将列数据变成行索引（只对 DataFrame 有效，因为 Series 没有列索引），其中： col label 变成 index name ，列数据变成行 label ： DataFrame . set_index ( keys , drop = True , append = False , inplace = False , verify_integrity = False ) keys ： 指定了一个或者一列的 column label 。这些列将会转换为行 index drop ：一个布尔值。如果为 True ，则 keys 对应的列会被删除；否则这些列仍然被保留 append ：一个布尔值。如果为 True ，则原有的行索引将保留（此时一定是个多级索引）；否则抛弃原来的行索引。 inplace ：一个布尔值。如果为 True ，则原地修改并且返回 None verify_integrity ：一个布尔值。如果为 True ，则检查新的 index 是否有重复值。否则会推迟到检测过程到必须检测的时候。 df = DataFrame ( np . random . randint ( low = 0 , high = 10 , size = ( 4 , 3 ))) df [ \"key\" ] = [ \"A\" , \"B\" , \"C\" , \"D\" ] print ( df ) df . set_index ( keys = \"key\" , append = True ) 0 1 2 key 0 6 9 6 A 1 9 8 1 B 2 5 6 8 C 3 8 4 0 D 0 1 2 key 0 A 6 9 6 1 B 9 8 1 2 C 5 6 8 3 D 8 4 0 将索引转换为列： reset_index reset_index 会将层次化的行 index 转移到列中，成为新的一列。同时 index 变成一个整数型的，从0开始编号： DataFrame . reset_index ( level = None , drop = False , inplace = False , col_level = 0 , col_fill = '' ) Series . reset_index ( level = None , drop = False , name = None , inplace = False ) level ：一个整数、 str 、元组或者列表。它指定了将从层次化的 index 中移除的 level 。如果为 None ，则移除所有的 level 。 drop ： drop=True ，丢弃指定level，不加入列中。 drop=False ，则将指定的level转换为列。 inplace ：一个布尔值。如果为 True ，则原地修改并且返回 None 。 col_level ：索引转换为列后，指定该列的列标签位于列索引的哪个level。 col_fill ：指定除 col_level 之外的列level的名字。默认为空字符串。当存在多级列索引时生效。 对于 Series ， name 就是插入后，对应的列 label columns = [[ \"a\" , \"a\" , \"b\" ],[ \"1\" , \"2\" , \"3\" ]] df = DataFrame ( np . random . randint ( low = 0 , high = 10 , size = ( 4 , 3 )), columns = columns ) print ( df ) df . reset_index ( drop = False , col_level = 0 ) a b 1 2 3 0 6 9 9 1 1 1 4 2 4 8 3 3 2 8 6 index a b 1 2 3 0 0 6 9 9 1 1 1 1 4 2 2 4 8 3 3 3 2 8 6 按label删除行、列 丢弃某条轴上的一个或者多个 label ： Series/DataFrame.drop(labels[, axis, level, inplace, errors]) : labels ：单个 label 或者一个 label 序列，代表要被丢弃的 label axis ：一个整数，或者轴的名字。默认为 0 轴 level ：一个整数或者 level 名字，用于 MultiIndex 。因为可能在多个 level 上都有同名的 label 。 inplace ：一个布尔值。如果为 True ，则原地修改并且返回 None errors ：可以为 'ignore'/'raise' a = df . reset_index ( drop = False , col_level = 0 ) a . drop ( labels = \"a\" , axis = 1 ) a idx = a . index def fun ( x ): return x + 10 idx . map ( fun ) import gensim from gensim.models import Word2Vec Word2Vec . wv File \"<ipython-input-1-5cbf7b740fd7>\", line 19 Word2Vec.wv ^ IndentationError: unexpected indent","text_tokens":["821732","赋值","地方","多级","0.805656","dfm","多层","效率","10","618127","shuffle","层次","'","original","df2","该","0.071497","two","碰到","从而","set","多维度","0.785068","不","默认","*","level","copy","字典","sliced","支持","存储","即便","修改","这","对于","他们","393348","reindex","64","method","new","models","否则","转换","{","对应","给出","是","哪个","不会","当","成为","pandas","reset","对齐","limit","tools","integrity","align","label","0.032103","错误","查看","python","specific","071497","randn","3","尤其","ignore","如何","fill","将列","abc","append","交换","tolerance","一级","来","相同","工作","0.280613","is","更改","有效","multiindex","n",")","原有","cols","。","to","0.597193","l2","除","sort","m","的","因此","列表","一列","了","line","编号"," ","mean","help","h","<","+","start","仅仅","映射","字符串","than","处理","这个","单个","将","0.581470","exception","则","使用","为行","5","pad","重","匹配","df","代表","序列","midx","a","层次化","被","该列","它","bfill","value","转移","沿着","2","}","amd64","\\","邻","jolie","verify","重新","nearest","244656","原来","插入","reorder","like","缺失","try","greater","col","改变","重复","广播","重命名","nan","因为","警告","unsortedindexerror","删除","_","和","列中","idx","l1","列会","最大值","indentationerror","tuples","8","中","必须","series","做","用下","示例","最大","函数","0.913649","；","remove","b","而","597193","出现","false","str","3.7","简单","其中","setup","来重","不同","只","z","填充","位于","级别","jim","同名","连续","，","performance","可用","errors","与","]","一般化","e","index","列","print","没有","都","qux","c","试图","轴","=","变","即使","names","keys","而且","038310","多","import","希望","视图","时候","有助","并且","您","645847","整数","aligned","rename","one","就","renames","1.083938","用","按","1","1.072317","的话","不可","none","多个","1.393348","有","backfill","注意","columns","except","0.038310","两个","(","正常","raise","broadcast","2af17b23912b","083938","346144","0.618127","名称","一步","用来","参数","s","到","1.329143","如果","1.821732","5cbf7b740fd7","high","时","array","名字","将会","另外","抛弃","字符","msc","布尔值","syntax","采用","stop","col0","329143","280613","多维","只要","unexpected","ipython","may","参数值","两者","0.404373","数值","可以","dtype","input","“","key","加入","来说","@","会","kwargs","你","word2vec","方法","axis","k","step","更","属性","开始","[","某条","unused","t","要","值","0.694748","为","例如","一般","进行","那个","random","选择","name","任何","大值","跨度","对","标量","column","空缺","windows","^","命名","前向","get","mi","4","foo",":","9","是否","loc","values","bit","f","indent","length","depth","zero","0.646365","创建","丢弃","pd","x","过程","接受","v.1915","为主",".","frozenlist","一定","swaplevel","但是","一个","列后","rand","0.645847","past","lexsort","索引","\"","这些","所有","0","指定","def","现在","6","助于","配合","size","任意","bar","变成","布尔","0.244656","（","baz","805656","具有","dataframe","for","降低","允许","404373","完全","randint","报错","后","694748","col1","581470","极大","之外","impact","first","存在","个","d","drop","invalid","等价","true","second","dicts","#","numpy","当新","was","把","indexing","移除","深度","）","032103",">","performancewarning","用于","明确","072317","module","object","joe","、","gensim","排列","/","inplace","在","列将会","拥有","有助于","0.378045","上","此时","元组","推迟","378045","之后","lexsorted","维度","对象","也","整数型","返回","property","标签","排序","为列","y","rangeindex","-","low","：","新","检查","labels","就是","生效","19","最近","return","aligning","行","fun","原地","传入","如下","为空","syntaxerror","检测","副本","0.346144","层级","`","已经","保留","wv","非","py","map","向","ffill","映射函数","数据","np","levels","同时",",","file","仍然","codes","”","从","913649","或者","以","抛出","可能","float64","每","from","0.473428","as","0.041386"],"title":"7.5.索引的基本操作","title_tokens":["基本",".","基本操作","7.5","的","索引","操作"]},{"location":"pandas笔记/7.5.索引的基本操作.html#_1","text":"tuples = [( 'bar' , 'one' ), ( 'bar' , 'two' ), ( 'baz' , 'one' ), ( 'baz' , 'two' ), ( 'foo' , 'one' ), ( 'foo' , 'two' ), ( 'qux' , 'one' ), ( 'qux' , 'two' )] index = pd . MultiIndex . from_tuples ( tuples , names = [ 'first' , 'second' ]) index MultiIndex([('bar', 'one'), ('bar', 'two'), ('baz', 'one'), ('baz', 'two'), ('foo', 'one'), ('foo', 'two'), ('qux', 'one'), ('qux', 'two')], names=['first', 'second']) .levels 为 property 属性，它返回一个 FrozenList （不可变列表），列表中存储每一级的 label （也就是创建 MultiIndex 时传入的 levels 参数）。 index . levels FrozenList([['bar', 'baz', 'foo', 'qux'], ['one', 'two']]) .get_level_values(level) ：返回指定 level 的 Index ，用于 MultiIndex 。 print ( index . get_level_values ( 0 ), \" \\n \" ) print ( index . get_level_values ( 1 ), \" \\n \" ) print ( index . get_level_values ( 'second' )) Index ([ 'bar' , 'bar' , 'baz' , 'baz' , 'foo' , 'foo' , 'qux' , 'qux' ], dtype = 'object' , name = 'first' ) Index ([ 'one' , 'two' , 'one' , 'two' , 'one' , 'two' , 'one' , 'two' ], dtype = 'object' , name = 'second' ) Index ([ 'one' , 'two' , 'one' , 'two' , 'one' , 'two' , 'one' , 'two' ], dtype = 'object' , name = 'second' ) df = pd . DataFrame ( np . random . randn ( 6 , 6 ), index = index [: 6 ], columns = index [: 6 ]) df . columns . levels # original MultiIndex df [[ 'foo' , 'qux' ]] . columns . levels # sliced df [[ 'foo' , 'qux' ]] . columns . to_numpy () # for a specific level df [[ 'foo' , 'qux' ]] . columns . get_level_values ( 0 ) Index(['foo', 'foo'], dtype='object', name='first') new_mi = df [[ 'foo' , 'qux' ]] . columns . remove_unused_levels () new_mi . levels FrozenList([['foo'], ['one', 'two']])","text_tokens":["dataframe","for","参数","它","时","first","'","original","two","\\","second","level","#","numpy","sliced","_","存储","tuples","）","中","new","用于","dtype","object","remove","属性","[","unused","label","为","，","specific","randn","random","name","]","也","index","print","返回","property","qux","一级","get","mi","=","foo",":","变","：","names","values","multiindex","n",")","就是","。","to","创建","pd","的","one","列表",".","传入","frozenlist"," ","一个","1","不可","\"","np","levels","0","指定",",","columns","df","6","bar","(","（","每","a","from","baz"],"title":"索引对象的方法","title_tokens":["对象","索引","的","方法"]},{"location":"pandas笔记/7.5.索引的基本操作.html#_2","text":"level 参数已经被加入到pandas对象中的 reindex() 和 align() 方法中。这将有助于沿着一个层级来广播值（broadcast values）。例如： 创建示例 df ： midx = pd . MultiIndex ( levels = [[ 'zero' , 'one' ], [ 'x' , 'y' ]], codes = [[ 1 , 1 , 0 , 0 ], [ 1 , 0 , 1 , 0 ]]) df = pd . DataFrame ( np . random . randn ( 4 , 2 ), index = midx ) df 0 1 one y 1.821732 0.913649 x 0.346144 0.378045 zero y 1.329143 -0.694748 x -1.393348 0.618127 创建示例 df2 ： df2 = df . mean ( level = 0 ) df2 0 1 one 1.083938 0.645847 zero -0.032103 -0.038310 df2 . reindex ( df . index , level = 0 ) 0 1 one y 1.083938 0.645847 x 1.083938 0.645847 zero y -0.032103 -0.038310 x -0.032103 -0.038310 # aligning df_aligned , df2_aligned = df . align ( df2 , level = 0 ) print ( df_aligned , \" \\n \" ) print ( df2_aligned ) 0 1 one y 1 . 821732 0 . 913649 x 0 . 346144 0 . 378045 zero y 1 . 329143 - 0 . 694748 x - 1 . 393348 0 . 618127 0 1 one y 1 . 083938 0 . 645847 x 1 . 083938 0 . 645847 zero y - 0 . 032103 - 0 . 038310 x - 0 . 032103 - 0 . 038310","text_tokens":["821732","083938","346144","dataframe","0.618127","参数","到","1.329143","1.821732","沿着","618127","694748","2","'","df2","\\","level","#","329143","广播","_","和","这","393348","reindex","）","中","032103","示例","0.913649","加入","pandas","方法","有助于","0.378045","[","align","值","0.032103","0.694748","randn","378045","例如","random","对象","]","index","print","y","来","4","=","-","：","values","multiindex","n","038310",")","zero","。","有助","创建","645847","pd","的","x","aligned","aligning","one",".","1.083938"," ","mean","一个","0.346144","1","层级","0.645847","已经","\"","将","1.393348","np","levels","0",",","codes","913649","df","助于","0.038310","(","midx","（","被","broadcast"],"title":"索引重赋值、索引对齐","title_tokens":["对齐","、","赋值","索引","重"]},{"location":"pandas笔记/7.5.索引的基本操作.html#reindex","text":"重新索引： Series/DataFrame.reindex(index=None, **kwargs) ： index ：一个 array-like 对象，给出了新的 index 的 label columns ：一个 array-like 对象，给出了新的 columns 的 label method ：当新的 label 的值缺失时，如何处理。参数值可以为： None ：不做任何处理，缺失地方填充 NaN - 'backfill'/'bfill' ：用下一个可用的值填充该空缺（后向填充） - 'pad'/'ffill' ：用上一个可用的值填充该空缺（前向填充） - 'nearest' ：用最近的可用值填充该空缺- copy ：一个布尔值，如果为 True ，则返回一个新的 Series 对象（即使传入的 index 与原来的 index 相同） level ：一个整数或者 name ，在 MultiIndex 的指定级别上匹配简单索引 fill_value ：一个标量。指定缺失值的填充数据，默认为 NaN （如果该参数与 method 同时出现，则以 method 为主） limit ：一个整数，指定前向/后向填充时：如果有连续的 k 个 NaN ，则只填充其中 limit 个。它与 method 配合 tolerance ：一个整数，用于给出在不匹配时，连续采用前向/后向/最近邻匹配的跨度的最大值。它与 method 配合","text_tokens":["dataframe","参数","它","地方","bfill","如果","value","后","时","array","'","该","个","邻","重新","nearest","不","默认","原来","true","*","level","当新","like","布尔值","采用","缺失","copy","nan","_","最大值","reindex","参数值","method","）","数值","series","可以","做","用下","用于","最大","给出","/","kwargs","出现","在","简单","其中","limit","k","只","填充","上","label","值","级别","为","连续","，","可用","name","对象","如何","与","任何","大值","跨度","index","fill","标量","空缺","返回","tolerance","相同","前向","=","-","即使","：","新","multiindex",")","。","最近","整数","的","为主",".","了","传入","用"," ","一个","处理","none","向","ffill","索引","数据","有","同时","指定",",","则","backfill","pad","columns","或者","匹配","以","配合","布尔","(","（"],"title":"reindex方法参数","title_tokens":["参数","reindex","方法"]},{"location":"pandas笔记/7.5.索引的基本操作.html#swaplevel","text":"swaplevel() 函数可以用来交换两个层级 print ( df , \" \\n \" ) print ( df . swaplevel ( 0 , 1 , axis = 0 )) 0 1 one y 1 . 821732 0 . 913649 x 0 . 346144 0 . 378045 zero y 1 . 329143 - 0 . 694748 x - 1 . 393348 0 . 618127 0 1 y one 1 . 821732 0 . 913649 x one 0 . 346144 0 . 378045 y zero 1 . 329143 - 0 . 694748 x zero - 1 . 393348 0 . 618127","text_tokens":["821732",".","346144","用来","swaplevel"," ","可以","print","函数","1","618127","交换","层级","694748","y","=","\\","\"","-","axis","0",",","n",")","zero","913649","329143","df","两个","(","x","one","393348","378045"],"title":"交换索引层级：swaplevel方法","title_tokens":["swaplevel","索引","方法","：","交换","层级"]},{"location":"pandas笔记/7.5.索引的基本操作.html#reorder_levels","text":"reorder_levels() 是一个更一般化的 swaplevel 方法，允许您用简单的一步来重排列索引的层级： print ( df , \" \\n \" ) print ( df . reorder_levels ([ 1 , 0 ], axis = 0 )) 0 1 one y 1 . 821732 0 . 913649 x 0 . 346144 0 . 378045 zero y 1 . 329143 - 0 . 694748 x - 1 . 393348 0 . 618127 0 1 y one 1 . 821732 0 . 913649 x one 0 . 346144 0 . 378045 y zero 1 . 329143 - 0 . 694748 x zero - 1 . 393348 0 . 618127","text_tokens":["821732",".","346144","一步","swaplevel","一般化","用"," ","]","一个","允许","print","1","618127","层级","是","694748","y","排列","=","索引","\"","\\","-","简单","方法","：","levels","0","axis","来重",",","n",")","reorder","更","zero","913649","[","329143","df","您","_","(","的","x","，","one","393348","378045","一般"],"title":"交换索引层级：reorder_levels方法","title_tokens":["levels","_","reorder","索引","方法","：","交换","层级"]},{"location":"pandas笔记/7.5.索引的基本操作.html#_3","text":"- `` File \"<ipython-input-1-2af17b23912b>\", line 1 - `` ^ SyntaxError: invalid syntax rename() 方法可以用来重命名多层索引，也可以用来重命名列。 renames 的 columns 参数可以接受一个字典，从而仅仅重命名你希望更改名字的列： df . rename ( columns = { 0 : \"col0\" , 1 : \"col1\" }) col0 col1 one y 1.821732 0.913649 x 0.346144 0.378045 zero y 1.329143 -0.694748 x -1.393348 0.618127 用于重命名索引： df . rename ( index = { \"one\" : \"two\" , \"y\" : \"z\" }) 0 1 two z 1.821732 0.913649 x 0.346144 0.378045 zero z 1.329143 -0.694748 x -1.393348 0.618127 rename_axis() 方法可以用于对 Index 或者 MultiIndex 进行重命名。尤其的，你可以明确 MultiIndex 中的不同层级的名称，这可以被用于在之后使用 reset_index() ，把多层级索引的值转换为一个列 df . rename_axis ( index = [ 'abc' , 'def' ]) 0 1 abc def one y 1.821732 0.913649 x 0.346144 0.378045 zero y 1.329143 -0.694748 x -1.393348 0.618127 注意， DataFrame 的列也是一个索引，因此在 rename_axis 中使用 columns 参数，将会改变那个索引的名称 df . rename_axis ( columns = \"Cols\" ) . columns RangeIndex(start=0, stop=2, step=1, name='Cols') rename 和 rename_axis 都支持一个明确的字典， Series 或者一个映射函数，将标签，名称映射为新的值。 df . rename_axis ( index = [ 'abc' , 'def' ], inplace = True ) print ( df ) 0 1 abc def one y 1.821732 0.913649 x 0.346144 0.378045 zero y 1.329143 -0.694748 x -1.393348 0.618127","text_tokens":["2af17b23912b","名称","0.618127","dataframe","用来","参数","1.329143","多层","1.821732","col1","2","'","}","名字","two","从而","invalid","将会","true","syntax","stop","col0","字典","改变","把","重命名","支持","_","和","这","ipython","中",">","series","可以","用于","{","转换","明确","input","函数","0.913649","是","inplace","在","你","方法","axis","reset","不同","step","z","0.378045","[","值","0.694748","为","，","之后","进行","那个","尤其","name","]","也","列","index","对","print","标签","abc","都","^","命名","y","rangeindex","=",":","-","：","新","更改","multiindex",")","zero","多","希望","cols","。","的","x","因此","rename","接受","one","renames",".","line"," ","syntaxerror","一个","<","0.346144","1","层级","仅仅","start","映射","`","映射函数","索引","\"","1.393348","将","0","file",",","使用","注意","def","columns","或者","df","(","被"],"title":"重命名索引","title_tokens":["命名","重命名","索引"]},{"location":"pandas笔记/7.5.索引的基本操作.html#_4","text":"对于拥有多层级索引的对象来说，使用 sort_index 方法来排序。 创建示例 s ： import random tuples = [( 'bar' , 'one' ), ( 'bar' , 'two' ), ( 'baz' , 'one' ), ( 'baz' , 'two' ), ( 'foo' , 'one' ), ( 'foo' , 'two' ), ( 'qux' , 'one' ), ( 'qux' , 'two' )] random . shuffle ( tuples ) s = pd . Series ( np . random . randn ( 8 ), index = pd . MultiIndex . from_tuples ( tuples )) s qux two -0.805656 one 0.404373 baz one 0.597193 bar two -0.280613 one -0.581470 baz two 1.072317 foo one 0.244656 two -0.071497 dtype: float64 # 两者等价 s . sort_index () s . sort_index ( level = 0 ) bar one -0.581470 two -0.280613 baz one 0.597193 two 1.072317 foo one 0.244656 two -0.071497 qux one 0.404373 two -0.805656 dtype: float64 s . sort_index ( level = 1 ) bar one -0.581470 baz one 0.597193 foo one 0.244656 qux one 0.404373 bar two -0.280613 baz two 1.072317 foo two -0.071497 qux two -0.805656 dtype: float64 如果“多层级索引”都被命名了的话，你也可以向 sort_index 传入一个层级名称。 s . index . set_names ([ 'L1' , 'L2' ], inplace = True ) print ( s . sort_index ( level = 'L1' ), \" \\n \" ) print ( s . sort_index ( level = 'L2' )) L1 L2 bar one - 0 . 581470 two - 0 . 280613 baz one 0 . 597193 two 1 . 072317 foo one 0 . 244656 two - 0 . 071497 qux one 0 . 404373 two - 0 . 805656 dtype : float64 L1 L2 bar one - 0 . 581470 baz one 0 . 597193 foo one 0 . 244656 qux one 0 . 404373 bar two - 0 . 280613 baz two 1 . 072317 foo two - 0 . 071497 qux two - 0 . 805656 dtype : float64 对于多维度的对象来说，你也可以对任意的的维度来进行索引，只要他们是具有 多层级索引 的： df . T . sort_index ( level = 1 , axis = 1 ) abc one zero one zero def x x y y 0 0.346144 -1.393348 1.821732 1.329143 1 0.378045 0.618127 0.913649 -0.694748 即便数据没有排序，你仍然可以对他们进行索引，但是索引的效率会极大降低，并且也会抛出 PerformanceWarning 警告。而且，这将返回一个数据的副本而非一个数据的视图： dfm = pd . DataFrame ({ 'jim' : [ 0 , 0 , 1 , 1 ], 'joe' : [ 'x' , 'x' , 'z' , 'y' ], 'jolie' : np . random . rand ( 4 )}) dfm = dfm . set_index ([ 'jim' , 'joe' ]) dfm dfm . loc [( 1 , 'z' )] .\\setup_m.py:9: PerformanceWarning: indexing past lexsort depth may impact performance. jolie jim joe 1 z 0.646365 另外，如果你试图索引一个没有完全lexsorted的对象，你将会碰到如下的错误： try : dfm . loc [( 0 , 'y' ):( 1 , 'z' )] except Exception as e : print ( f \"UnsortedIndexError: {e} \" ) UnsortedIndexError: 'Key length (2) was greater than MultiIndex lexsort depth (1)' 排序之后则不会报错 dfm . sort_index () . loc [( 0 , 'y' ):( 1 , 'z' )] jolie jim joe 1 y 0.041386 z 0.646365 在 MultiIndex 上使用 is_lexsorted() 方法，你可以查看这个索引是否已经被排序。而使用 lexsort_depth 属性则可以返回排序的深度 dfm . index . is_lexsorted () False dfm . index . lexsort_depth 1 dfm = dfm . sort_index () dfm jolie jim joe 0 x 0.785068 x 0.473428 1 y 0.041386 z 0.646365 dfm . index . is_lexsorted () True dfm . index . lexsort_depth 2 现在，你的选择就可以正常工作了。 dfm . loc [( 0 , 'y' ):( 1 , 'z' )] jolie jim joe 1 y 0.041386 z 0.646365","text_tokens":["名称","0.618127","dataframe","s","如果","1.329143","降低","0.805656","dfm","1.821732","效率","404373","完全","报错","shuffle","581470","极大","impact","2","'","0.071497","}","two","\\","碰到","jolie","set","多维度","0.785068","244656","等价","true","另外","level","#","280613","try","greater","多维","was","只要","警告","indexing","unsortedindexerror","_","即便","l1","对于","他们","这","may","深度","tuples","8","805656","两者","0.404373","performancewarning","series","可以","{","dtype","示例","072317","0.913649","是","“","key","joe","不会","来说","会","inplace","而","597193","false","在","你","方法","axis","setup","拥有","z","0.378045","属性","[","上","t","jim","错误","0.694748","查看","，","performance","071497","randn","lexsorted","之后","进行","random","维度","选择","对象","]","也","e","index","对","print","没有","返回","排序","abc","都","qux","命名","y","来","试图","工作","0.280613","4","=","foo","-",":","9","是否","：","names","loc","is","f","而且","multiindex","n","length",")","depth","zero","多","import","。","l2","0.597193","0.646365","视图","并且","sort","创建","m","pd","的","x","one","就",".","了","传入","如下"," ","但是","一个","副本","0.346144","1","层级","rand","1.072317","than","已经","非","py","这个","的话","向","past","lexsort","索引","\"","数据","1.393348","将","np","0","0.581470","exception",",","使用","则","仍然","def","”","抛出","except","现在","df","float64","任意","bar","(","0.244656","正常","from","0.473428","baz","as","被","0.041386","具有"],"title":"对多索引进行排序","title_tokens":["多","对","索引","排序","进行"]},{"location":"pandas笔记/7.5.索引的基本操作.html#_5","text":"将列数据变成行索引（只对 DataFrame 有效，因为 Series 没有列索引），其中： col label 变成 index name ，列数据变成行 label ： DataFrame . set_index ( keys , drop = True , append = False , inplace = False , verify_integrity = False ) keys ： 指定了一个或者一列的 column label 。这些列将会转换为行 index drop ：一个布尔值。如果为 True ，则 keys 对应的列会被删除；否则这些列仍然被保留 append ：一个布尔值。如果为 True ，则原有的行索引将保留（此时一定是个多级索引）；否则抛弃原来的行索引。 inplace ：一个布尔值。如果为 True ，则原地修改并且返回 None verify_integrity ：一个布尔值。如果为 True ，则检查新的 index 是否有重复值。否则会推迟到检测过程到必须检测的时候。 df = DataFrame ( np . random . randint ( low = 0 , high = 10 , size = ( 4 , 3 ))) df [ \"key\" ] = [ \"A\" , \"B\" , \"C\" , \"D\" ] print ( df ) df . set_index ( keys = \"key\" , append = True ) 0 1 2 key 0 6 9 6 A 1 9 8 1 B 2 5 6 8 C 3 8 4 0 D 0 1 2 key 0 A 6 9 6 1 B 9 8 1 2 C 5 6 8 3 D 8 4 0","text_tokens":["dataframe","如果","到","多级","10","randint","high","2","个","drop","verify","d","set","原来","true","抛弃","布尔值","col","重复","因为","删除","_","修改","列会","）","8","必须","series","否则","转换","对应","是","；","key","b","会","inplace","false","列将会","其中","只","[","此时","integrity","推迟","label","值","为","，","3","random","name","]","对","列","index","将列","column","print","没有","返回","append","c","4","=","low","9","是否","：","新","keys","有效","检查",")","原有","。","时候","并且","的","过程","行","原地","一列",".","了","一定"," ","一个","检测","1","保留","none","索引","数据","\"","这些","将","np","有","0","指定",",","则","为行","仍然","5","或者","df","6","size","变成","布尔","(","（","a","被"],"title":"将列转换为索引","title_tokens":["转换","将列","为","索引"]},{"location":"pandas笔记/7.5.索引的基本操作.html#reset_index","text":"reset_index 会将层次化的行 index 转移到列中，成为新的一列。同时 index 变成一个整数型的，从0开始编号： DataFrame . reset_index ( level = None , drop = False , inplace = False , col_level = 0 , col_fill = '' ) Series . reset_index ( level = None , drop = False , name = None , inplace = False ) level ：一个整数、 str 、元组或者列表。它指定了将从层次化的 index 中移除的 level 。如果为 None ，则移除所有的 level 。 drop ： drop=True ，丢弃指定level，不加入列中。 drop=False ，则将指定的level转换为列。 inplace ：一个布尔值。如果为 True ，则原地修改并且返回 None 。 col_level ：索引转换为列后，指定该列的列标签位于列索引的哪个level。 col_fill ：指定除 col_level 之外的列level的名字。默认为空字符串。当存在多级列索引时生效。 对于 Series ， name 就是插入后，对应的列 label columns = [[ \"a\" , \"a\" , \"b\" ],[ \"1\" , \"2\" , \"3\" ]] df = DataFrame ( np . random . randint ( low = 0 , high = 10 , size = ( 4 , 3 )), columns = columns ) print ( df ) df . reset_index ( drop = False , col_level = 0 ) a b 1 2 3 0 6 9 9 1 1 1 4 2 4 8 3 3 2 8 6 index a b 1 2 3 0 0 6 9 9 1 1 1 1 4 2 2 4 8 3 3 3 2 8 6","text_tokens":["dataframe","它","到","如果","多级","转移","10","randint","后","之外","存在","层次","时","2","'","high","名字","drop","不","默认","true","字符","插入","level","布尔值","col","列中","_","修改","对于","移除","8","中","series","转换","对应","哪个","加入","、","当","b","成为","会","inplace","false","str","reset","开始","[","元组","位于","label","为","，","3","random","name","]","index","列","fill","整数型","print","返回","标签","为列","4","=","low","9","：","新",")","就是","生效","。","除","并且","整数","丢弃","的","列表","行","原地","一列",".","了","编号","为空"," ","一个","列后","1","字符串","none","索引","\"","将","所有","np","0","同时","指定",",","则","从","columns","或者","df","6","size","变成","布尔","(","a","层次化","该列"],"title":"将索引转换为列：reset_index","title_tokens":["为列","_","index","转换","索引","将","：","reset"]},{"location":"pandas笔记/7.5.索引的基本操作.html#label","text":"丢弃某条轴上的一个或者多个 label ： Series/DataFrame.drop(labels[, axis, level, inplace, errors]) : labels ：单个 label 或者一个 label 序列，代表要被丢弃的 label axis ：一个整数，或者轴的名字。默认为 0 轴 level ：一个整数或者 level 名字，用于 MultiIndex 。因为可能在多个 level 上都有同名的 label 。 inplace ：一个布尔值。如果为 True ，则原地修改并且返回 None errors ：可以为 'ignore'/'raise' a = df . reset_index ( drop = False , col_level = 0 ) a . drop ( labels = \"a\" , axis = 1 ) a idx = a . index def fun ( x ): return x + 10 idx . map ( fun ) import gensim from gensim.models import Word2Vec Word2Vec . wv File \"<ipython-input-1-5cbf7b740fd7>\", line 19 Word2Vec.wv ^ IndentationError: unexpected indent","text_tokens":["dataframe","如果","10","5cbf7b740fd7","'","名字","drop","默认","true","level","布尔值","col","因为","idx","_","修改","unexpected","ipython","indentationerror",">","series","models","可以","用于","input","gensim","/","inplace","false","在","word2vec","axis","reset","某条","[","上","label","要","同名","为","，","errors","ignore","]","index","返回","都","^","轴","=",":","-","：","indent","multiindex",")","labels","import","。","19","并且","丢弃","整数","的","x","return","fun","原地",".","line"," ","一个","<","+","1","wv","map","none","单个","\"","多个","有","0",",","则","file","def","或者","可能","代表","df","序列","布尔","(","a","from","被","raise"],"title":"按label删除行、列","title_tokens":["label","、","删除","列","按","行"]},{"location":"pandas笔记/7.6.拼接.html","text":"Windows 10 Python 3.7.3 @ MSC v.1915 64 bit (AMD64) from tools import Help as H import numpy as np import pandas as pd concat 函数 在深入研究 concat 函数的细节及其作用之前，这里有一个简单的示例： df1 = pd . DataFrame ({ 'A' : [ 'A0' , 'A1' , 'A2' , 'A3' ], 'B' : [ 'B0' , 'B1' , 'B2' , 'B3' ], 'C' : [ 'C0' , 'C1' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D1' , 'D2' , 'D3' ]}, index = [ 0 , 1 , 2 , 3 ]) df2 = pd . DataFrame ({ 'A' : [ 'A4' , 'A5' , 'A6' , 'A7' ], 'B' : [ 'B4' , 'B5' , 'B6' , 'B7' ], 'C' : [ 'C4' , 'C5' , 'C6' , 'C7' ], 'D' : [ 'D4' , 'D5' , 'D6' , 'D7' ]}, index = [ 4 , 5 , 6 , 7 ]) df3 = pd . DataFrame ({ 'A' : [ 'A8' , 'A9' , 'A10' , 'A11' ], 'B' : [ 'B8' , 'B9' , 'B10' , 'B11' ], 'C' : [ 'C8' , 'C9' , 'C10' , 'C11' ], 'D' : [ 'D8' , 'D9' , 'D10' , 'D11' ]}, index = [ 8 , 9 , 10 , 11 ]) frames = [ df1 , df2 , df3 ] result = pd . concat ( frames ) 与其在ndarrays上的同级函数一样 numpy.concatenate ，， pandas.concat 获取同类类型对象的列表或字典，并将它们与“对其他轴的操作”的一些可配置处理进行连接： pd . concat ( objs , axis = 0 , join = 'outer' , ignore_index = False , keys = None , levels = None , names = None , verify_integrity = False , copy = True ) objs ：Series或DataFrame对象的序列或映射。如果传递了dict ，则除非传递了排序的键，否则将使用排序后的键作为keys参数，在这种情况下，将选择值（请参见下文）。除非它们都为None，否则所有None对象都将被静默删除，在这种情况下将引发ValueError。 axis ：{0，1，…}，默认值为0。沿着该轴进行拼接。 join ：{'inner'，'outer'}，默认为 'outer' 。如何处理其他轴上的索引。 'outer' 为并集， 'inner' 为交集。 ignore_index ：布尔值，默认为False。如果为True，则用0, …, n-1代替串联轴的原索引。注意，拼接时仍会考虑其他轴上的索引值。 keys ：序列，默认为无。使用传递的键作为最外层级别来构造层次结构索引。如果通过了多个级别，则应包含元组。 levels ：序列列表，默认为无。用于构造MultiIndex的特定级别（唯一值）。否则，将从按键推断出它们。 names ：列表，默认为None。生成层次结构索引中的级别的名称。 verify_integrity ：布尔值，默认为False。检查新的串联轴是否包含重复项。相对于实际数据串联而言，这可能非常昂贵。 copy ：布尔值，默认为True。如果为False，在非必要的情况下不会复制数据。 没有一点上下文，这些论点中的许多就没有多大意义。让我们回顾一下上面的例子。假设我们想将特定的键与切碎的DataFrame的每个片段相关联。我们可以使用 keys 参数来做到这一点 ： result = pd . concat ( frames , keys = [ 'x' , 'y' , 'z' ]) 如您所见（如果您已经阅读了文档的其余部分），结果对象的索引具有 层次结构索引 。这意味着我们现在可以通过键选择每个块： result . loc [ 'y' ] A B C D 4 A4 B4 C4 D4 5 A5 B5 C5 D5 6 A6 B6 C6 D6 7 A7 B7 C7 D7 看到这如何非常有用并不是一件容易的事。有关此功能的详细信息，请参见下文。 注意 值得注意的是 concat() （并因此 append() ）制作了数据的完整副本，并且不断重复使用此功能可能会严重影响性能。如果需要对多个数据集使用该操作，请使用列表推导。 frames = [ process_your_file ( f ) for f in files ] result = pd . concat ( frames ) ---------------------------------------------------------------------------NameError Traceback (most recent call last)<ipython-input-1-442ff6d9e7b9> in <module> ----> 1 frames = [ process_your_file(f) for f in files ] 2 result = pd.concat(frames) NameError: name 'files' is not defined 处理其他轴的逻辑：join参数 将多个DataFrame粘合在一起时，可以选择如何处理其他轴（而不是串联的轴）。这可以通过以下两种方式完成： 把它们全部结合起来 join='outer' 。这是默认选项，这不会丢失信息。 只保留交集 join='inner' 。 默认 join='outer' ： df4 = pd . DataFrame ({ 'B' : [ 'B2' , 'B3' , 'B6' , 'B7' ], 'D' : [ 'D2' , 'D3' , 'D6' , 'D7' ], 'F' : [ 'F2' , 'F3' , 'F6' , 'F7' ]}, index = [ 2 , 3 , 7 , 6 ]) result = pd . concat ([ df1 , df4 ], axis = 1 , sort = True , join = \"outer\" ) 只保留交集 join='inner' ： result = pd . concat ([ df1 , df4 ], axis = 1 , join = 'inner' ) 如果只想用其中一个DataFrame的索引： result = pd . concat ([ df1 , df4 ], axis = 1 ) . reindex ( df1 . index ) 也可以在连接之前建立索引： pd . concat ([ df1 , df4 . reindex ( df1 . index )], axis = 1 ) A B C D B D F 0 A0 B0 C0 D0 NaN NaN NaN 1 A1 B1 C1 D1 NaN NaN NaN 2 A2 B2 C2 D2 B2 D2 F2 3 A3 B3 C3 D3 B3 D3 F3 使用 append 拼接 concat() 的一个快捷方式是 append() ，这是Series和DataFrame的 append() 实例方法 。这些方法实际上早于 concat 。 append() 方法让Series和DataFrame沿着行（ axis=0 ）拼接在一起： append ( self , other , ignore_index = False , verify_integrity = False , sort = None ) 实际上，不要求两个DataFrame的行索引交集为空，列索引也是这样： result = df1 . append ( df4 , sort = False , ignore_index = True ) append 可以拼接多个对象： result = df1 . append ([ df2 , df3 ]) 与list对象的 append() 方法不同，DataFrame对象的 append() 方法会返回副本， 不会修改 df1 。 忽略串联轴上的索引：ignore_index 如果 DataFrame 的索引没有意义，可以使用 ignore_index 参数： result = pd . concat ([ df1 , df4 ], ignore_index = True , sort = False ) DataFrame.append() 方法也有这个参数： result = df1 . append ( df4 , ignore_index = True , sort = False ) 混合串联 Series 和 DataFrame 可以拼接 Series 和 DataFrame 。该 Series 会转化为 DataFrame 的一列，列名是 Series 的 name 。 s1 = pd . Series ([ 'X0' , 'X1' , 'X2' , 'X3' ], name = 'X' ) result = pd . concat ([ df1 , s1 ], axis = 1 ) 如果 Series 未命名，则将连续编号。 s2 = pd . Series ([ '_0' , '_1' , '_2' , '_3' ]) result = pd . concat ([ df1 , s2 , s2 , s2 ], axis = 1 ) 通过 ignore_index=True 删除原有索引标签。 result = pd . concat ([ df1 , s1 ], axis = 1 , ignore_index = True ) key 参数 keys 参数的一个相当普遍的用法是重新指定原DataFrame或Series的名字，可以作为拼接后的DataFrame的列索引： s3 = pd . Series ([ 0 , 1 , 2 , 3 ], name = 'foo' ) s4 = pd . Series ([ 0 , 1 , 2 , 3 ]) s5 = pd . Series ([ 0 , 1 , 4 , 5 ]) pd . concat ([ s3 , s4 , s5 ], axis = 1 ) foo 0 1 0 0 0 0 1 1 1 1 2 2 2 4 3 3 3 5 通过 keys 参数，可以覆盖现有的列名。 pd . concat ([ s3 , s4 , s5 ], axis = 1 , keys = [ 'red' , 'blue' , 'yellow' ]) red blue yellow 0 0 0 0 1 1 1 1 2 2 2 4 3 3 3 5 让我们考虑第一个示例的变体： result = pd . concat ( frames , keys = [ 'x' , 'y' , 'z' ]) 还可以将需要拼接的DataFrame以dict形式传递给 concat 函数，在这种情况下，dict键将用作 keys 参数（除非指定了其他键）： pieces = { 'x' : df1 , 'y' : df2 , 'z' : df3 } result = pd . concat ( pieces ) result = pd . concat ( pieces , keys = [ 'z' , 'y' ]) 创建的MultiIndex具有根据传递的键和 DataFrame 片段索引构造的级别： result . index . levels FrozenList([['z', 'y'], [4, 5, 6, 7, 8, 9, 10, 11]]) 如果想指定其他级别（偶尔会这样），则可以使用以下 levels 参数： result = pd . concat ( pieces , keys = [ 'x' , 'y' , 'z' ], levels = [[ 'z' , 'y' , 'x' , 'w' ]], names = [ 'group_key' ]) result . index . levels FrozenList([['z', 'y', 'x', 'w'], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]]) 行追加到 DataFrame 尽管效率不是很高（因为必须创建一个新的对象），但是可以向 append 传递一个 Series 或dict来将一行附加到 DataFrame ： s2 = pd . Series ([ 'X0' , 'X1' , 'X2' , 'X3' ], index = [ 'A' , 'B' , 'C' , 'D' ]) result = df1 . append ( s2 , ignore_index = True ) 还可以传递字典或系列的列表： dicts = [{ 'A' : 1 , 'B' : 2 , 'C' : 3 , 'X' : 4 }, { 'A' : 5 , 'B' : 6 , 'C' : 7 , 'Y' : 8 }] result = df1 . append ( dicts , ignore_index = True , sort = False ) 数据库形式的拼接 pandas具有全功能、高性能的内存连接操作，与SQL等关系数据库非常相似。这些方法的性能比其他开源实现（如R中的base：：merge.data.frame）要好得多（在某些情况下甚至超过一个数量级）。原因是仔细的算法设计和DataFrame的数据的内部布局。 pandas提供函数 merge() ，作为DataFrame或Series对象之间所有标准数据库拼接操作的入口点： pd . merge ( left , right , how = 'inner' , on = None , left_on = None , right_on = None , left_index = False , right_index = False , sort = True , suffixes = ( '_x' , '_y' ), copy = True , indicator = False , validate = None ) left ：一个DataFrame或Series的对象。 right ：另一个DataFrame或Series的对象。 on ：一个 label 或者 label list 。它指定用作连接键的列的 label 。并且必须在两个 DataFrame 中这些 label 都存在。如果它为 None ，则默认使用两个 DataFrame 的列 label 的交集。你可以通过 left_on/right_on 分别指定两侧 DataFrame 对齐的连接键。 left_on ：一个 label 或者 label list 。指定左边 DataFrame 用作连接键的列，参考 on 。 right_on ：一个 label 或者 label list 。指定右边 DataFrame 用作连接键的列，参考 on 。 left_index ：一个布尔值。如果为 True ，则使用左边的 DataFrame 的行的 index value 来作为连接键来合并。 right_index ：一个布尔值。如果为 True ，则使用右边的 DataFrame 的行的 index value 来作为连接键来合并。 how ：其一 'left' ， 'right' ， 'outer' ， 'inner' 。默认为 inner 。有关每种方法的详细说明，请参见下文。 sort ：一个布尔值。如果为 True ，则在结果中，对合并采用的连接键进行排序。 suffixes ：一个二元序列。对于结果中同名的列，它会添加前缀来指示它们来自哪个 DataFrame 。 copy ：一个布尔值。如果为 True ，则拷贝基础数据。否则不拷贝数据。 indicator ：一个字符串或者布尔值。 如果为 True ，则结果中多了一列称作 _merge ，该列给出了每一行来自于那个 DataFrame 。 如果为字符串，则结果中多了一列（该列名字由 indicator 字符串给出），该列给出了每一行来自于那个 DataFrame 。 validate ：字符串，默认为无。如果指定，则检查合并是否为指定的类型。 'one_to_one'或'1:1'：检查合并键在左右数据集中是否唯一。 'one_to_many'或'1:m'：检查合并键在左数据集中是否唯一。 'many_to_one'或'm:1'：检查合并键在正确的数据集中是否唯一。 'many_to_many'或'm:m'：允许，但不进行检查。 新功能： 0.23.0版本中添加了指定索引级别的 on 、 left_on 、 right_on 参数的支持。在0.24.0版中添加了合并命名的Series的支持。 merge 是pandas命名空间中的一个函数，它也可以作为DataFrame实例方法 merge() 使用，调用 DataFrame.merge 时， DataFrame 被视为拼接中的左侧对象。 相关 join() 方法在 merge 内部用于索引索引连接（默认情况下）和索引列连接。如果仅加入索引，则可能希望使用 DataFrame.join 来节省一些输入。 合并方法简介（关系代数） 有经验的关系数据库（如SQL）用户将熟悉用于描述两个SQL类表结构（DataFrame对象）之间的连接操作的术语。有几个案例需要考虑，这些案例非常重要： one-to-one 联接：两个DataFrame对象的组合键都是唯一值。 many-to-one 联接：其中一个DataFrame对象的组合键是唯一值，另一个有重复值。 many-to-many 联接：两个DataFrame对象的组合键都有重复值。 注意 在列上连接列时（可能是多对多连接），传递的 DataFrame 对象上的所有索引 都将被丢弃 。 值得花些时间了解多对多连接案例的结果。 在SQL/标准关系代数中，如果键组合在两个表中出现不止一次，则生成的表将具有关联数据的笛卡尔积。 下面是一个非常基本的例子，使用一个组合键，并且组合键的值都是唯一的： left = pd . DataFrame ({ 'key' : [ 'K0' , 'K1' , 'K2' , 'K3' ], 'A' : [ 'A0' , 'A1' , 'A2' , 'A3' ], 'B' : [ 'B0' , 'B1' , 'B2' , 'B3' ]}) right = pd . DataFrame ({ 'key' : [ 'K0' , 'K1' , 'K2' , 'K3' ], 'C' : [ 'C0' , 'C1' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D1' , 'D2' , 'D3' ]}) result = pd . merge ( left , right , on = 'key' ) 多个组合键的示例（默认 how='inner' ）： left = pd . DataFrame ({ 'key1' : [ 'K0' , 'K0' , 'K1' , 'K2' ], 'key2' : [ 'K0' , 'K1' , 'K0' , 'K1' ], 'A' : [ 'A0' , 'A1' , 'A2' , 'A3' ], 'B' : [ 'B0' , 'B1' , 'B2' , 'B3' ]}) right = pd . DataFrame ({ 'key1' : [ 'K0' , 'K1' , 'K1' , 'K2' ], 'key2' : [ 'K0' , 'K0' , 'K0' , 'K0' ], 'C' : [ 'C0' , 'C1' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D1' , 'D2' , 'D3' ]}) result = pd . merge ( left , right , on = [ 'key1' , 'key2' ]) 当左右两边的组合键不一致时，处理行为由 how 参数指定。以下是 how 选项及其SQL等效名称的摘要： 合并方式 SQL连接名称 描述 left LEFT OUTER JOIN 仅保留left出现的组合键 right RIGHT OUTER JOIN 仅保留right出现的组合键 outer FULL OUTER JOIN 保留left和right组合键的并集 inner INNER JOIN 保留left和right组合键的交集 result = pd . merge ( left , right , how = 'left' , on = [ 'key1' , 'key2' ]) result = pd . merge ( left , right , how = 'right' , on = [ 'key1' , 'key2' ]) result = pd . merge ( left , right , how = 'outer' , on = [ 'key1' , 'key2' ]) result = pd . merge ( left , right , how = 'inner' , on = [ 'key1' , 'key2' ]) 这是组合键具有重复值的示例： left = pd . DataFrame ({ 'A' : [ 1 , 2 ], 'B' : [ 2 , 2 ]}) right = pd . DataFrame ({ 'A' : [ 4 , 5 , 6 ], 'B' : [ 2 , 2 , 2 ]}) result = pd . merge ( left , right , on = 'B' , how = 'outer' ) 警告 在重复键上进行拼接，会导致返回的DataFrame的函数是原来两个DataFrame行数的乘积，这可能导致内存溢出。如果DataFrame很大，应该对重复键进行管理。 检查重复键：validate 0.21.0版中的新功能。 可以使用 validate 参数自动检查组合键中是否有意外的重复项。在合并操作之前检查键的唯一性，可以防止内存溢出。检查组合键的唯一性也是确保数据结构符合预期的一种好方法。 在以下示例中，right中的 B 存在重复的值。由于这不是 validate 参数中指定的一对一合并，因此将引发异常。 left = pd . DataFrame ({ 'A' : [ 1 , 2 ], 'B' : [ 1 , 2 ]}) right = pd . DataFrame ({ 'A' : [ 4 , 5 , 6 ], 'B' : [ 2 , 2 , 2 ]}) try : result = pd . merge ( left , right , on = 'B' , how = 'outer' , validate = \"one_to_one\" ) except Exception as e : print ( \"MergeError:\" , e ) MergeError : Merge keys are not unique in right dataset ; not a one - to - one merge 如果用户知道右边的重复项， DataFrame 但要确保左边的DataFrame中没有重复项，则可以改用该 validate='one_to_many' 参数，这不会引发异常。 pd . merge ( left , right , on = 'B' , how = 'outer' , validate = \"one_to_many\" ) A_x B A_y 0 1 1 NaN 1 2 2 4.0 2 2 2 5.0 3 2 2 6.0 指示符：indicator merge() 接受指示符参数 indicator 。如果 indicator=True ，则将一个名为 _merge ，dtype为Categorical的列添加到输出DataFrame的末尾： indicator _merge 值 仅出现在 'left' 组合键 left_only 仅出现在 'right' 组合键 right_only 同时出现在 'left' 和 'right' 组合键 both df1 = pd . DataFrame ({ 'col1' : [ 0 , 1 ], 'col_left' : [ 'a' , 'b' ]}) df2 = pd . DataFrame ({ 'col1' : [ 1 , 2 , 2 ], 'col_right' : [ 2 , 2 , 2 ]}) pd . merge ( df1 , df2 , on = 'col1' , how = 'outer' , indicator = True ) col1 col_left col_right _merge 0 0 a NaN left_only 1 1 b 2.0 both 2 2 NaN 2.0 right_only 3 2 NaN 2.0 right_only indicator 参数还可以接受字符串参数，在这种情况下，指标函数将使用传递的字符串的值作为 指标列 的名称。 pd . merge ( df1 , df2 , on = 'col1' , how = 'outer' , indicator = 'indicator_column' ) col1 col_left col_right indicator_column 0 0 a NaN left_only 1 1 b 2.0 both 2 2 NaN 2.0 right_only 3 2 NaN 2.0 right_only 合并时数据类型的转换 合并将保留组合键的数据类型 left = pd . DataFrame ({ 'key' : [ 1 ], 'v1' : [ 10 ]}) print ( left , \" \\n \" ) right = pd . DataFrame ({ 'key' : [ 1 , 2 ], 'v1' : [ 20 , 30 ]}) print ( right ) key v1 0 1 10 key v1 0 1 20 1 2 30 我们可以保留组合键： print ( pd . merge ( left , right , how = 'outer' ), \" \\n \" ) print ( pd . merge ( left , right , how = 'outer' ) . dtypes ) key v1 0 1 10 1 1 20 2 2 30 key int64 v1 int64 dtype : object 如果缺少引入的值，则生成的dtype将被转换： print ( pd . merge ( left , right , how = 'outer' , on = 'key' ), \" \\n \" ) print ( pd . merge ( left , right , how = 'outer' , on = 'key' ) . dtypes ) key v1_x v1_y 0 1 10 . 0 20 1 2 NaN 30 key int64 v1_x float64 v1_y int64 dtype : object 合并将保留mergands的category类型。另请参阅关于 categoricals 的部分。 left： from pandas.api.types import CategoricalDtype X = pd . Series ( np . random . choice ([ 'foo' , 'bar' ], size = ( 10 ,))) X = X . astype ( CategoricalDtype ( categories = [ 'foo' , 'bar' ])) left = pd . DataFrame ({ 'X' : X , 'Y' : np . random . choice ([ 'one' , 'two' , 'three' ], size = ( 10 ,))}) print ( left , \" \\n \" ) print ( left . dtypes ) X Y 0 foo three 1 foo two 2 bar three 3 bar three 4 bar two 5 foo two 6 bar two 7 bar one 8 bar two 9 bar two X category Y object dtype : object right： right = pd . DataFrame ({ 'X' : pd . Series ([ 'foo' , 'bar' ], dtype = CategoricalDtype ([ 'foo' , 'bar' ])), 'Z' : [ 1 , 2 ]}) print ( right , \" \\n \" ) print ( right . dtypes ) X Z 0 foo 1 1 bar 2 X category Z int64 dtype : object 合并结果： result = pd . merge ( left , right , how = 'outer' ) print ( result , \" \\n \" ) print ( result . dtypes ) X Y Z 0 foo three 1 1 foo two 1 2 foo two 1 3 bar three 2 4 bar three 2 5 bar two 2 6 bar two 2 7 bar one 2 8 bar two 2 9 bar two 2 X category Y object Z int64 dtype : object 注意 category 类型必须 完全相同 ，这意味着category对象有相同的类别和有序属性。否则，category类型将被转换成object类型。 注意 与object数据类型合并相比，在相同的category数据类型上进行合并可以获得更好的性能。 DataFrame.join() 这是一个非常基本的示例： left = pd . DataFrame ({ 'A' : [ 'A0' , 'A1' , 'A2' ], 'B' : [ 'B0' , 'B1' , 'B2' ]}, index = [ 'K0' , 'K1' , 'K2' ]) right = pd . DataFrame ({ 'C' : [ 'C0' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D2' , 'D3' ]}, index = [ 'K0' , 'K2' , 'K3' ]) result = left . join ( right ) result = left . join ( right , how = 'outer' ) 与上述相同，但带有 how='inner' ： result = left . join ( right , how = 'inner' ) 此处的数据对齐在索引（行标签）上。使用 merge 指示其使用索引的附加参数可以实现相同的行为： result = pd . merge ( left , right , left_index = True , right_index = True , how = 'outer' ) result = pd . merge ( left , right , left_index = True , right_index = True , how = 'inner' ) 按 组合键列 和 索引 拼接：join join() 接受一个可选的 on 参数，该参数可以是一个列或多个列名，它指定传递的DataFrame将在原DataFrame中的该列上对齐。即这两个函数调用完全等价： left . join ( right , on = key_or_keys ) pd . merge ( left , right , left_on = key_or_keys , right_index = True , how = 'left' , sort = False ) 显然，您可以选择任何一种更方便的形式。对于many-to-one拼接（其中一个DataFrame的索引是组合键），使用 join 可能会更方便。这是一个简单的示例： left = pd . DataFrame ({ 'A' : [ 'A0' , 'A1' , 'A2' , 'A3' ], 'B' : [ 'B0' , 'B1' , 'B2' , 'B3' ], 'key' : [ 'K0' , 'K1' , 'K0' , 'K1' ]}) right = pd . DataFrame ({ 'C' : [ 'C0' , 'C1' ], 'D' : [ 'D0' , 'D1' ]}, index = [ 'K0' , 'K1' ]) result = left . join ( right , on = 'key' ) result = pd . merge ( left , right , left_on = 'key' , right_index = True , how = 'left' , sort = False ); 如果组合键有多个，传递的DataFrame必须具有 MultiIndex ： left = pd . DataFrame ({ 'A' : [ 'A0' , 'A1' , 'A2' , 'A3' ], 'B' : [ 'B0' , 'B1' , 'B2' , 'B3' ], 'key1' : [ 'K0' , 'K0' , 'K1' , 'K2' ], 'key2' : [ 'K0' , 'K1' , 'K0' , 'K1' ]}) index = pd . MultiIndex . from_tuples ([( 'K0' , 'K0' ), ( 'K1' , 'K0' ), ( 'K2' , 'K0' ), ( 'K2' , 'K1' )]) right = pd . DataFrame ({ 'C' : [ 'C0' , 'C1' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D1' , 'D2' , 'D3' ]}, index = index ) 现在，可以通过传递两个组合键来进行拼接： result = left . join ( right , on = [ 'key1' , 'key2' ]) 默认的 DataFrame.join 是执行左联接（对于Excel用户，本质上是“ VLOOKUP”操作），该联接仅使用在调用DataFrame中找到的键。其他联接类型（例如内部联接）也可以轻松执行： result = left . join ( right , on = [ 'key1' , 'key2' ], how = 'inner' ) 如您所见，这将删除所有不匹配的行。 按 单层索引 和 多层索引 拼接：join 可以将单层索引DataFrame与多层索引DataFrame的 一个级别 连接起来。该级别将与单索引DataFrame的索引名称和多索引DataFrame的级别名称相匹配 left = pd . DataFrame ({ 'A' : [ 'A0' , 'A1' , 'A2' ], 'B' : [ 'B0' , 'B1' , 'B2' ]}, index = pd . Index ([ 'K0' , 'K1' , 'K2' ], name = 'key' )) index = pd . MultiIndex . from_tuples ([( 'K0' , 'Y0' ), ( 'K1' , 'Y1' ), ( 'K2' , 'Y2' ), ( 'K2' , 'Y3' )], names = [ 'key' , 'Y' ]) right = pd . DataFrame ({ 'C' : [ 'C0' , 'C1' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D1' , 'D2' , 'D3' ]}, index = index ) result = left . join ( right , how = 'inner' ) 下面的函数和上面的方法是等效的，但 pd.merge 的信息更详细，存储效率更高/更快。 result = pd . merge ( left . reset_index (), right . reset_index (), on = [ 'key' ], how = 'inner' ) . set_index ([ 'key' , 'Y' ]) 按MultiIndexes拼接：join 只要在连接中完全使用了右参数的索引，并且该参数是左参数中索引的子集，就可以用有限的方式来支持它，如下例所示： leftindex = pd . MultiIndex . from_product ([ list ( 'abc' ), list ( 'xy' ), [ 1 , 2 ]], names = [ 'abc' , 'xy' , 'num' ]) left = pd . DataFrame ({ 'v1' : range ( 12 )}, index = leftindex ) print ( left , \" \\n \" ) rightindex = pd . MultiIndex . from_product ([ list ( 'abc' ), list ( 'xy' )], names = [ 'abc' , 'xy' ]) right = pd . DataFrame ({ 'v2' : [ 100 * i for i in range ( 1 , 7 )]}, index = rightindex ) print ( right , \" \\n \" ) left . join ( right , on = [ 'abc' , 'xy' ], how = 'inner' ) v1 abc xy num a x 1 0 2 1 y 1 2 2 3 b x 1 4 2 5 y 1 6 2 7 c x 1 8 2 9 y 1 10 2 11 v2 abc xy a x 100 y 200 b x 300 y 400 c x 500 y 600 v1 v2 abc xy num a x 1 0 100 2 1 100 y 1 2 200 2 3 200 b x 1 4 300 2 5 300 y 1 6 400 2 7 400 c x 1 8 500 2 9 500 y 1 10 600 2 11 600 如果不满足该条件，则可以使用以下代码完成具有两个多索引的联接。 leftindex = pd . MultiIndex . from_tuples ([( 'K0' , 'X0' ), ( 'K0' , 'X1' ), ( 'K1' , 'X2' )], names = [ 'key' , 'X' ]) left = pd . DataFrame ({ 'A' : [ 'A0' , 'A1' , 'A2' ], 'B' : [ 'B0' , 'B1' , 'B2' ]}, index = leftindex ) rightindex = pd . MultiIndex . from_tuples ([( 'K0' , 'Y0' ), ( 'K1' , 'Y1' ), ( 'K2' , 'Y2' ), ( 'K2' , 'Y3' )], names = [ 'key' , 'Y' ]) right = pd . DataFrame ({ 'C' : [ 'C0' , 'C1' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D1' , 'D2' , 'D3' ]}, index = rightindex ) result = pd . merge ( left . reset_index (), right . reset_index (), on = [ 'key' ], how = 'inner' ) . set_index ([ 'key' , 'X' , 'Y' ]) 按照列和索引合并 0.23版中的新功能。 on 、 left_on 和 right_on 参数可以引用列名或索引级名称。这允许在索引和列的组合上合并DataFrame实例，而不必重置索引： left_index = pd . Index ([ 'K0' , 'K0' , 'K1' , 'K2' ], name = 'key1' ) left = pd . DataFrame ({ 'A' : [ 'A0' , 'A1' , 'A2' , 'A3' ], 'B' : [ 'B0' , 'B1' , 'B2' , 'B3' ], 'key2' : [ 'K0' , 'K1' , 'K0' , 'K1' ]}, index = left_index ) right_index = pd . Index ([ 'K0' , 'K1' , 'K2' , 'K2' ], name = 'key1' ) right = pd . DataFrame ({ 'C' : [ 'C0' , 'C1' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D1' , 'D2' , 'D3' ], 'key2' : [ 'K0' , 'K0' , 'K0' , 'K1' ]}, index = right_index ) result = left . merge ( right , on = [ 'key1' , 'key2' ]) 值列重叠 merge 函数的 suffixes 参数接受字符串列表的元组，以附加到输入DataFrame中重叠的列名以消除结果列的歧义： left = pd . DataFrame ({ 'k' : [ 'K0' , 'K1' , 'K2' ], 'v' : [ 1 , 2 , 3 ]}) right = pd . DataFrame ({ 'k' : [ 'K0' , 'K0' , 'K3' ], 'v' : [ 4 , 5 , 6 ]}) result = pd . merge ( left , right , on = 'k' ) result = pd . merge ( left , right , on = 'k' , suffixes = [ '_l' , '_r' ]) DataFrame.join() 具有 lsuffix 和 rsuffix 行为类似的参数。 left = left . set_index ( 'k' ) right = right . set_index ( 'k' ) result = left . join ( right , lsuffix = '_l' , rsuffix = '_r' ) 拼接多个DataFrames DataFrames 也可以传递的列表或元组以 join() 将它们连接到它们的索引上。 right2 = pd . DataFrame ({ 'v' : [ 7 , 8 , 9 ]}, index = [ 'K1' , 'K1' , 'K2' ]) result = left . join ([ right , right2 ]) 按索引填补缺失值 另一个相当常见的情况是有两个索引存在交集的对象，其中一个存在缺失值，想通过另一个对象填补缺失值。这是一个例子： df1 = pd . DataFrame ([[ np . nan , 3. , 5. ], [ - 4.6 , np . nan , np . nan ], [ np . nan , 7. , np . nan ]]) df2 = pd . DataFrame ([[ - 42.6 , np . nan , - 8.2 ], [ - 5. , 1.6 , 4 ]], index = [ 1 , 2 ]) combine_first() 方法可以达到这个效果： result = df1 . combine_first ( df2 ) 请注意， combine_first 返回副本，而 update() 则会修改原对象： df1 . update ( df2 ) 合并时间序列 合并有序数据 merge_ordered() 函数允许组合时间序列和其他有序数据。 merge_ordered ( left , right , on = None , left_on = None , right_on = None , left_by = None , right_by = None , fill_method = None , suffixes = ( \"_x\" , \"_y\" ), how = \"outer\" , ) left_by : Group left DataFrame by group columns and merge piece by piece with right DataFrame left = pd . DataFrame ({ 'k' : [ 'K0' , 'K1' , 'K1' , 'K2' ], 'lv' : [ 1 , 2 , 3 , 4 ], 's' : [ 'a' , 'b' , 'c' , 'd' ]}) right = pd . DataFrame ({ 'k' : [ 'K1' , 'K2' , 'K4' ], 'rv' : [ 1 , 2 , 3 ]}) print ( left , \" \\n \" ) print ( right ) pd . merge_ordered ( left , right , fill_method = None , left_by = 's' ) k lv s 0 K0 1 a 1 K1 2 b 2 K1 3 c 3 K2 4 d k rv 0 K1 1 1 K2 2 2 K4 3 k lv s rv 0 K0 1.0 a NaN 1 K1 NaN a 1.0 2 K2 NaN a 2.0 3 K4 NaN a 3.0 4 K1 2.0 b 1.0 5 K2 NaN b 2.0 6 K4 NaN b 3.0 7 K1 3.0 c 1.0 8 K2 NaN c 2.0 9 K4 NaN c 3.0 10 K1 NaN d 1.0 11 K2 4.0 d 2.0 12 K4 NaN d 3.0 它具有一个可选 fill_method 关键字来填充丢失的数据： # 前向填充：后面的缺失值用前面的数字填充 pd . merge_ordered ( left , right , fill_method = \"ffill\" , left_by = 's' ) k lv s rv 0 K0 1.0 a NaN 1 K1 1.0 a 1.0 2 K2 1.0 a 2.0 3 K4 1.0 a 3.0 4 K1 2.0 b 1.0 5 K2 2.0 b 2.0 6 K4 2.0 b 3.0 7 K1 3.0 c 1.0 8 K2 3.0 c 2.0 9 K4 3.0 c 3.0 10 K1 NaN d 1.0 11 K2 4.0 d 2.0 12 K4 4.0 d 3.0 合并ASOF merge_asof() 类似于有序左联接，只是我们匹配最近的键而不是相等的键。对于左数据框中的每一行，我们选择右数据框中的最后一行，该行的on键小于lefs键。两个数据帧都必须按键排序。 可选地，asof合并可以执行逐组合并。除了on键上最接近的匹配之外，它与by键的匹配相同 merge_asof ( left , right , on = None , left_on = None , right_on = None , left_index = False , right_index = False , by = None , left_by = None , right_by = None , suffixes = ( \"_x\" , \"_y\" ), tolerance = None , allow_exact_matches = True , direction = \"backward\" , ) 例如，我们可能有 trades 和 quotes ，我们想合并它们 trades = pd . DataFrame ({ 'time' : pd . to_datetime ([ '20160525 13:30:00.023' , '20160525 13:30:00.038' , '20160525 13:30:00.048' , '20160525 13:30:00.048' , '20160525 13:30:00.048' ]), 'ticker' : [ 'MSFT' , 'MSFT' , 'GOOG' , 'GOOG' , 'AAPL' ], 'price' : [ 51.95 , 51.95 , 720.77 , 720.92 , 98.00 ], 'quantity' : [ 75 , 155 , 100 , 100 , 100 ]}, columns = [ 'time' , 'ticker' , 'price' , 'quantity' ]) quotes = pd . DataFrame ({ 'time' : pd . to_datetime ([ '20160525 13:30:00.023' , '20160525 13:30:00.023' , '20160525 13:30:00.030' , '20160525 13:30:00.041' , '20160525 13:30:00.048' , '20160525 13:30:00.049' , '20160525 13:30:00.072' , '20160525 13:30:00.075' ]), 'ticker' : [ 'GOOG' , 'MSFT' , 'MSFT' , 'MSFT' , 'GOOG' , 'AAPL' , 'GOOG' , 'MSFT' ], 'bid' : [ 720.50 , 51.95 , 51.97 , 51.99 , 720.50 , 97.99 , 720.50 , 52.01 ], 'ask' : [ 720.93 , 51.96 , 51.98 , 52.00 , 720.93 , 98.01 , 720.88 , 52.03 ]}, columns = [ 'time' , 'ticker' , 'bid' , 'ask' ]) print ( trades , \" \\n \" ) print ( quotes ) time ticker price quantity 0 2016 - 05 - 25 13 : 30 : 00 . 023 MSFT 51 . 95 75 1 2016 - 05 - 25 13 : 30 : 00 . 038 MSFT 51 . 95 155 2 2016 - 05 - 25 13 : 30 : 00 . 048 GOOG 720 . 77 100 3 2016 - 05 - 25 13 : 30 : 00 . 048 GOOG 720 . 92 100 4 2016 - 05 - 25 13 : 30 : 00 . 048 AAPL 98 . 00 100 time ticker bid ask 0 2016 - 05 - 25 13 : 30 : 00 . 023 GOOG 720 . 50 720 . 93 1 2016 - 05 - 25 13 : 30 : 00 . 023 MSFT 51 . 95 51 . 96 2 2016 - 05 - 25 13 : 30 : 00 . 030 MSFT 51 . 97 51 . 98 3 2016 - 05 - 25 13 : 30 : 00 . 041 MSFT 51 . 99 52 . 00 4 2016 - 05 - 25 13 : 30 : 00 . 048 GOOG 720 . 50 720 . 93 5 2016 - 05 - 25 13 : 30 : 00 . 049 AAPL 97 . 99 98 . 01 6 2016 - 05 - 25 13 : 30 : 00 . 072 GOOG 720 . 50 720 . 88 7 2016 - 05 - 25 13 : 30 : 00 . 075 MSFT 52 . 01 52 . 03 默认情况下，我们采用的是quotes。 pd . merge_asof ( trades , quotes , on = 'time' , by = 'ticker' ) time ticker price quantity bid ask 0 2016-05-25 13:30:00.023 MSFT 51.95 75 51.95 51.96 1 2016-05-25 13:30:00.038 MSFT 51.95 155 51.97 51.98 2 2016-05-25 13:30:00.048 GOOG 720.77 100 720.50 720.93 3 2016-05-25 13:30:00.048 GOOG 720.92 100 720.50 720.93 4 2016-05-25 13:30:00.048 AAPL 98.00 100 NaN NaN 我们只在quote 时间和trade 时间之间的2毫秒内合并： pd . merge_asof ( trades , quotes , on = 'time' , by = 'ticker' , tolerance = pd . Timedelta ( '2ms' )) time ticker price quantity bid ask 0 2016-05-25 13:30:00.023 MSFT 51.95 75 51.95 51.96 1 2016-05-25 13:30:00.038 MSFT 51.95 155 NaN NaN 2 2016-05-25 13:30:00.048 GOOG 720.77 100 720.50 720.93 3 2016-05-25 13:30:00.048 GOOG 720.92 100 720.50 720.93 4 2016-05-25 13:30:00.048 AAPL 98.00 100 NaN NaN 我们只在quote 时间和trade 时间之间的10毫秒内合并，并且不包括精确匹配。注意，尽管我们排除了（quotes的）完全匹配项，但以前的quotes确实会传播到那个时间点。 pd . merge_asof ( trades , quotes , on = 'time' , by = 'ticker' , tolerance = pd . Timedelta ( '10ms' ), allow_exact_matches = False ) time ticker price quantity bid ask 0 2016-05-25 13:30:00.023 MSFT 51.95 75 NaN NaN 1 2016-05-25 13:30:00.038 MSFT 51.95 155 51.97 51.98 2 2016-05-25 13:30:00.048 GOOG 720.77 100 NaN NaN 3 2016-05-25 13:30:00.048 GOOG 720.92 100 NaN NaN 4 2016-05-25 13:30:00.048 AAPL 98.00 100 NaN NaN","text_tokens":["51","frames","inner","self","99","20160525","00.030","效率","多层","10","concatenate","最","matches","f2","层次","'","df2","该","代替","two","指标","dict","唯一","仅","y0","set","不","d1","默认","*","three","98.01","必要","调用","数量级","字典","copy","请","系数","categoricals","符","支持","行为","7","信息","版中","所示","修改","in","每个","442ff6d9e7b9","这","附加","其余部分","对于","管理","意外","f7","reindex","一行","64","与其","参见","重复使用","method","串联","不是","否则","转换","{","正确","未命名","部分","给出","第一","回顾","是","键来","哪个","30","2016","不会","花些","当","本质","pandas","条件","range","行数","0.21","改用","做到",";","reset","not","对齐","拷贝","方式","tools","这样","defined","类似","ticker","右边","integrity","label","列上","update","快捷方式","ndarrays","100","并","python","复制","实现","唯一性","原","3","13","粘合","exact","相当","ignore","两种","indicator","左侧","如何","按照","many","相关联","fill","甚至","结构","merge","请参阅","append","abc","d9","and","nameerror","s3","等","tolerance","来","相同","现有","072","包括","objs","防止","c7","pieces","能比","----","数字","左边","is","b1","multiindex","n",")","相等","列时","原有","块","。","看到","一件","to","300","v1","基本","k1","sort","m","c3","的","其","特定","因此","关系数据库","推断出","a11","列表","不断","0.23","以下","一列","b9","版本","了","编号","d0"," ","52.03","help","h","切碎","这里","<","s5","映射","组合键","2.0","字符串","处理","c9","d10","这个","group","25","一起","排除","实例","将","丢失","b7","backward","51.98","93","换成","exception","考虑","则","使用","片段","二元","77","或","5","75","重置","分别","combine","毫秒","k0","匹配","int64","要求","类表","即","多大","子集","序列","time","d6","由于","a","s2","表中","被","该列","很","这是","经验","除了","traceback","它","追加","value","b11","沿着","unique","last","说明","实际","层次结构","category","由","2","显然","}","假设","1.6","amd64","系列","开源","还","frame","高性能","\\","98","verify","符合","重新","获取","51.97","输入","…","早","原来","传递","添加","连接起来","try","缺失","d3","col","92","join","重复","因为","nan","警告","删除","a5","_","和","许多","参阅","提供","c2","a3","术语","tuples","8","leftindex","中","不止","必须","series","示例","函数","excel","配置","x2","一种","b","v","关于","而","有关","false","出现","3.7","其一","简单","其中","不同","上述","只","值得","z","某些","填充","算法","推导","rsuffix","x0","阅读","级别","好","同名","其余","量级","key2","连续","00","，","075","200","与","]","e","index","列","建立","a9","print","精确","没有","内部","s1","95","b0","都","bid","c","only","关键字","50","集","值用","轴","=","功能","左","相似","更好","048","or","00.041","普遍","names","keys","df3","allow","我们","97.99","转化","多","500","import","希望","末尾","key1","之前","4.6","并且","如","您","结合","性能比","b8","达到","one","就","上下文","而言","高","给","第一个","b2","用","详细信息","a7","asof","按","quotes","仔细","choice","c6","2ms","1","实际上","只想用","00.048","前缀","01","dataframes","none","下面","可选地","suffixes","多个","小于","lefs","720.77","几个","有","00.049","51.95","选","注意","关联","包含","columns","except","一下","默认值","前面","自动","两侧","720.93","multiindexes","两个","(","v2","b6","51.99","及其","52.00","轻松","例子","名称","a8","参数","忽略","如果","到","4.0","s","原因","布局","时","引发","级","名字","生成","data","df4","类型","超过","c1","w","038","很大","8.2","d5","通过","于","字符","c4","msc","深入研究","布尔值","一些","d7","d11","采用","描述","51.96","yellow","数据库","c11","中多","有用","尽管","---------------------------------------------------------------------------","数据类型","只要","quantity","aapl","转换成","影响","此","细节","集中","设计","right2","ipython","call","据库","ordered","88","other","a1","可以","dtype","input","用法","快","“","key","加入","推断","存储","数量","ask","@","会","your","a4","全部","d2","你","内","方法","axis","一样","值列","k","轴上","混合","非常","更","属性","049","[","交集","相比","接近","要","值","astype","事","files","为","数据结构","11","dataset","例如","进行","容易","那个","random","选择","name","are","任何","product","对","dtypes","concat","column","windows","昂贵","操作","timedelta","乘积","下文","一点","命名","此处","前向","outer","4","x3","常见","foo","性能","基础",":","b4","9","是否","b10","情况","loc","想用","之间","bit","f","c8","trades","trade","5.0","600","用作","c5","了解","覆盖","most","一个二元","重要","mergeerror","帧","00.038","97","制作","后面","创建","丢弃","全功能","pd","base","x","点","720.88","来自","不止一次","接受","12","视为","y3","v.1915","完成","代数",".","一对","frozenlist","size","可","42.6","积","最后","该行","categoricaldtype","但是","一个","简介","类别","意味着","逻辑","项","称作","代码","720","逐","上下","每种","其他","确保","索引","\"","上面","y1","这些","所有","文档","0","无","指定","找到","空间","更高","好得多","相匹配","只是","现在","接起","6","想","s4","a0","应","red","一致","内存","bar","需要","df1","布尔","填补","x1","quote","（","10ms","goog","可选","知道","所见","外层","num","具有","lv","相对","process","作用","0.24","list","dataframe","for","left","应该","传播","构造","结果","允许","l","完全","不必","720.50","k4","后","full","关系","col1","存在","函数调用","标准","first","之外","a6","值得注意","d8","d","api","vlookup","根据","歧义","等价","c10","true","合并","偶尔","030","dicts","快捷","#","numpy","blue","它们","how","表将","k2","引入","熟悉","on","把","一对一","右","完全相同","有限","lsuffix","k3","98.00","选项","result","两边","both","确实","）",">","导致","研究","00.075","关键","用于","96","连接","sql","用户","r","module","object","起来","、","rv","形式","让","/","d4","在","52","piece","categorical","types","列名","引用","20","联接","等效","f6","上","元组","意味","组合","recent","但","with","03","00.072","3.0","满足","155","023","完整","对象","也","节省","i","validate","a2","rightindex","除非","返回","标签","排序","6.0","05","变体","这种","参考","消除","获得","datetime","框中","y","论点","另","按键","b3","同级","卡尔","-","00.023","：","效果","仍会","新","溢出","检查","price","预期","1.0","方便","400","入口","a10","right","案例","最近","指示","mergands","严重","详细","单层","带有","拼接","行","720.92","msft","相关","异常","如下","为空","有序","by","categories","xy","副本","键上","缺少","输出","余部","单","已经","保留","一次","重叠","以前","52.01","向","深入","ffill","数据","f3","左右","direction","np","c0","levels","y2","同类","同时",",","file","b5","时间","摘要","执行","”","作为","从","笛卡尔","可能","以","高性","或者","下","float64","041","静默","valueerror","每","意义","名为","from","它会","例","as","非必要","键"],"title":"7.6.拼接","title_tokens":["7.6",".","拼接"]},{"location":"pandas笔记/7.6.拼接.html#concat","text":"在深入研究 concat 函数的细节及其作用之前，这里有一个简单的示例： df1 = pd . DataFrame ({ 'A' : [ 'A0' , 'A1' , 'A2' , 'A3' ], 'B' : [ 'B0' , 'B1' , 'B2' , 'B3' ], 'C' : [ 'C0' , 'C1' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D1' , 'D2' , 'D3' ]}, index = [ 0 , 1 , 2 , 3 ]) df2 = pd . DataFrame ({ 'A' : [ 'A4' , 'A5' , 'A6' , 'A7' ], 'B' : [ 'B4' , 'B5' , 'B6' , 'B7' ], 'C' : [ 'C4' , 'C5' , 'C6' , 'C7' ], 'D' : [ 'D4' , 'D5' , 'D6' , 'D7' ]}, index = [ 4 , 5 , 6 , 7 ]) df3 = pd . DataFrame ({ 'A' : [ 'A8' , 'A9' , 'A10' , 'A11' ], 'B' : [ 'B8' , 'B9' , 'B10' , 'B11' ], 'C' : [ 'C8' , 'C9' , 'C10' , 'C11' ], 'D' : [ 'D8' , 'D9' , 'D10' , 'D11' ]}, index = [ 8 , 9 , 10 , 11 ]) frames = [ df1 , df2 , df3 ] result = pd . concat ( frames ) 与其在ndarrays上的同级函数一样 numpy.concatenate ，， pandas.concat 获取同类类型对象的列表或字典，并将它们与“对其他轴的操作”的一些可配置处理进行连接： pd . concat ( objs , axis = 0 , join = 'outer' , ignore_index = False , keys = None , levels = None , names = None , verify_integrity = False , copy = True ) objs ：Series或DataFrame对象的序列或映射。如果传递了dict ，则除非传递了排序的键，否则将使用排序后的键作为keys参数，在这种情况下，将选择值（请参见下文）。除非它们都为None，否则所有None对象都将被静默删除，在这种情况下将引发ValueError。 axis ：{0，1，…}，默认值为0。沿着该轴进行拼接。 join ：{'inner'，'outer'}，默认为 'outer' 。如何处理其他轴上的索引。 'outer' 为并集， 'inner' 为交集。 ignore_index ：布尔值，默认为False。如果为True，则用0, …, n-1代替串联轴的原索引。注意，拼接时仍会考虑其他轴上的索引值。 keys ：序列，默认为无。使用传递的键作为最外层级别来构造层次结构索引。如果通过了多个级别，则应包含元组。 levels ：序列列表，默认为无。用于构造MultiIndex的特定级别（唯一值）。否则，将从按键推断出它们。 names ：列表，默认为None。生成层次结构索引中的级别的名称。 verify_integrity ：布尔值，默认为False。检查新的串联轴是否包含重复项。相对于实际数据串联而言，这可能非常昂贵。 copy ：布尔值，默认为True。如果为False，在非必要的情况下不会复制数据。 没有一点上下文，这些论点中的许多就没有多大意义。让我们回顾一下上面的例子。假设我们想将特定的键与切碎的DataFrame的每个片段相关联。我们可以使用 keys 参数来做到这一点 ： result = pd . concat ( frames , keys = [ 'x' , 'y' , 'z' ]) 如您所见（如果您已经阅读了文档的其余部分），结果对象的索引具有 层次结构索引 。这意味着我们现在可以通过键选择每个块： result . loc [ 'y' ] A B C D 4 A4 B4 C4 D4 5 A5 B5 C5 D5 6 A6 B6 C6 D6 7 A7 B7 C7 D7 看到这如何非常有用并不是一件容易的事。有关此功能的详细信息，请参见下文。 注意 值得注意的是 concat() （并因此 append() ）制作了数据的完整副本，并且不断重复使用此功能可能会严重影响性能。如果需要对多个数据集使用该操作，请使用列表推导。 frames = [ process_your_file ( f ) for f in files ] result = pd . concat ( frames ) ---------------------------------------------------------------------------NameError Traceback (most recent call last)<ipython-input-1-442ff6d9e7b9> in <module> ----> 1 frames = [ process_your_file(f) for f in files ] 2 result = pd.concat(frames) NameError: name 'files' is not defined","text_tokens":["frames","inner","10","concatenate","最","层次","'","df2","该","代替","dict","唯一","d1","默认","必要","字典","copy","请","7","信息","in","每个","442ff6d9e7b9","这","其余部分","与其","重复使用","参见","串联","不是","否则","{","部分","回顾","是","不会","pandas","做到","not","defined","integrity","ndarrays","并","复制","原","3","ignore","如何","相关联","结构","append","d9","nameerror","来","objs","c7","----","is","b1","multiindex","n",")","块","。","看到","一件","c3","的","特定","因此","推断出","a11","列表","不断","b9","了","d0"," ","切碎","这里","<","映射","处理","c9","d10","将","b7","考虑","则","使用","片段","或","5","多大","序列","d6","a","被","traceback","b11","沿着","last","实际","层次结构","2","}","假设","verify","获取","…","传递","d3","join","重复","删除","a5","_","许多","c2","a3","8","中","series","示例","函数","配置","b","有关","false","简单","值得","z","推导","阅读","级别","其余","，","与","]","index","a9","没有","b0","都","c","集","轴","=","功能","names","keys","df3","我们","之前","并且","如","您","b8","就","上下文","而言","b2","用","详细信息","a7","c6","1","none","多个","有","注意","关联","包含","一下","默认值","(","b6","及其","例子","名称","a8","参数","如果","时","引发","生成","类型","c1","d5","通过","于","c4","深入研究","布尔值","一些","d7","d11","c11","有用","---------------------------------------------------------------------------","影响","此","细节","ipython","call","a1","可以","input","“","推断","会","your","a4","d2","axis","一样","轴上","非常","[","交集","值","事","files","为","11","进行","容易","选择","name","对","concat","昂贵","操作","下文","一点","outer","4","性能",":","b4","9","是否","loc","b10","情况","f","c8","c5","most","制作","pd","x",".","可","一个","意味着","项","上下","其他","索引","上面","这些","所有","文档","0","无","现在","6","想","a0","应","需要","df1","布尔","（","所见","外层","具有","相对","process","作用","dataframe","for","构造","结果","后","a6","值得注意","d8","d","c10","true","numpy","它们","result","）",">","研究","用于","连接","module","让","d4","在","上","元组","意味","recent","完整","对象","a2","除非","排序","这种","y","论点","按键","b3","同级","-","：","仍会","新","检查","a10","严重","详细","拼接","相关","副本","余部","已经","深入","数据","c0","levels","同类",",","file","b5","”","作为","从","可能","下","静默","valueerror","意义","非必要","键"],"title":"concat函数","title_tokens":["函数","concat"]},{"location":"pandas笔记/7.6.拼接.html#join","text":"将多个DataFrame粘合在一起时，可以选择如何处理其他轴（而不是串联的轴）。这可以通过以下两种方式完成： 把它们全部结合起来 join='outer' 。这是默认选项，这不会丢失信息。 只保留交集 join='inner' 。 默认 join='outer' ： df4 = pd . DataFrame ({ 'B' : [ 'B2' , 'B3' , 'B6' , 'B7' ], 'D' : [ 'D2' , 'D3' , 'D6' , 'D7' ], 'F' : [ 'F2' , 'F3' , 'F6' , 'F7' ]}, index = [ 2 , 3 , 7 , 6 ]) result = pd . concat ([ df1 , df4 ], axis = 1 , sort = True , join = \"outer\" ) 只保留交集 join='inner' ： result = pd . concat ([ df1 , df4 ], axis = 1 , join = 'inner' ) 如果只想用其中一个DataFrame的索引： result = pd . concat ([ df1 , df4 ], axis = 1 ) . reindex ( df1 . index ) 也可以在连接之前建立索引： pd . concat ([ df1 , df4 . reindex ( df1 . index )], axis = 1 ) A B C D B D F 0 A0 B0 C0 D0 NaN NaN NaN 1 A1 B1 C1 D1 NaN NaN NaN 2 A2 B2 C2 D2 B2 D2 F2 3 A3 B3 C3 D3 B3 D3 F3","text_tokens":["dataframe","这是","inner","如果","f2","时","2","'","}","df4","d","c1","d1","默认","通过","true","d7","它们","d3","join","把","nan","信息","7","选项","result","这","c2","f7","reindex","a3","）","不是","串联","可以","a1","{","连接","起来","不会","b","而","在","全部","d2","axis","其中","只","方式","[","交集","f6","，","3","粘合","两种","选择","如何","]","也","index","a2","建立","concat","b0","c","outer","轴","b3","=",":","：","想用","f","b1",")","。","之前","结合","sort","c3","pd","的","以下","完成",".","d0","b2"," ","一个","1","只想用","保留","处理","其他","一起","索引","\"","多个","f3","将","丢失","b7","c0","0",",","6","a0","df1","(","d6","（","a","b6"],"title":"处理其他轴的逻辑：join参数","title_tokens":["处理","参数","轴","其他","的","逻辑","：","join"]},{"location":"pandas笔记/7.6.拼接.html#append","text":"concat() 的一个快捷方式是 append() ，这是Series和DataFrame的 append() 实例方法 。这些方法实际上早于 concat 。 append() 方法让Series和DataFrame沿着行（ axis=0 ）拼接在一起： append ( self , other , ignore_index = False , verify_integrity = False , sort = None ) 实际上，不要求两个DataFrame的行索引交集为空，列索引也是这样： result = df1 . append ( df4 , sort = False , ignore_index = True ) append 可以拼接多个对象： result = df1 . append ([ df2 , df3 ]) 与list对象的 append() 方法不同，DataFrame对象的 append() 方法会返回副本， 不会修改 df1 。","text_tokens":["）",".","list","这是","dataframe","ignore","对象","与","]","为空"," ","series","other","一个","index","self","列","concat","也","可以","返回","副本","append","实际上","沿着","是","实际","不会","让","df2","none","会","一起","=","df4","索引","实例","false","在","这些","verify","多个","：","方法","axis","0","不","不同","df3","于","早","方式",",","true",")","这样","快捷","。","交集","[","要求","integrity","快捷方式","df1","sort","两个","(","和","（","_","的","result","修改","，","拼接","行"],"title":"使用append拼接","title_tokens":["append","拼接","使用"]},{"location":"pandas笔记/7.6.拼接.html#ignore_index","text":"如果 DataFrame 的索引没有意义，可以使用 ignore_index 参数： result = pd . concat ([ df1 , df4 ], ignore_index = True , sort = False ) DataFrame.append() 方法也有这个参数： result = df1 . append ( df4 , ignore_index = True , sort = False )","text_tokens":[".","dataframe","ignore","参数","]","也","如果"," ","可以","index","concat","没有","append","这个","=","df4","索引","false","：","方法","有",",","使用","true",")","[","df1","sort","_","(","pd","的","意义","result","，"],"title":"忽略串联轴上的索引：ignore_index","title_tokens":["ignore","串联","轴上","忽略","_","的","index","索引","："]},{"location":"pandas笔记/7.6.拼接.html#seriesdataframe","text":"可以拼接 Series 和 DataFrame 。该 Series 会转化为 DataFrame 的一列，列名是 Series 的 name 。 s1 = pd . Series ([ 'X0' , 'X1' , 'X2' , 'X3' ], name = 'X' ) result = pd . concat ([ df1 , s1 ], axis = 1 ) 如果 Series 未命名，则将连续编号。 s2 = pd . Series ([ '_0' , '_1' , '_2' , '_3' ]) result = pd . concat ([ df1 , s2 , s2 , s2 ], axis = 1 ) 通过 ignore_index=True 删除原有索引标签。 result = pd . concat ([ df1 , s1 ], axis = 1 , ignore_index = True )","text_tokens":[".","dataframe","ignore","name","编号","]","series"," ","可以","如果","index","concat","未命名","标签","s1","1","x2","是","命名","_","2","'","该","会","=","x3","索引","将","axis","0",",","则","列名","通过","true",")","转化","原有","。","[","x0","df1","删除","(","和","pd","为","的","x1","x","，","result","连续","s2","拼接","3","一列"],"title":"混合串联Series和DataFrame","title_tokens":["dataframe","串联","和","混合","series"]},{"location":"pandas笔记/7.6.拼接.html#key","text":"keys 参数的一个相当普遍的用法是重新指定原DataFrame或Series的名字，可以作为拼接后的DataFrame的列索引： s3 = pd . Series ([ 0 , 1 , 2 , 3 ], name = 'foo' ) s4 = pd . Series ([ 0 , 1 , 2 , 3 ]) s5 = pd . Series ([ 0 , 1 , 4 , 5 ]) pd . concat ([ s3 , s4 , s5 ], axis = 1 ) foo 0 1 0 0 0 0 1 1 1 1 2 2 2 4 3 3 3 5 通过 keys 参数，可以覆盖现有的列名。 pd . concat ([ s3 , s4 , s5 ], axis = 1 , keys = [ 'red' , 'blue' , 'yellow' ]) red blue yellow 0 0 0 0 1 1 1 1 2 2 2 4 3 3 3 5 让我们考虑第一个示例的变体： result = pd . concat ( frames , keys = [ 'x' , 'y' , 'z' ]) 还可以将需要拼接的DataFrame以dict形式传递给 concat 函数，在这种情况下，dict键将用作 keys 参数（除非指定了其他键）： pieces = { 'x' : df1 , 'y' : df2 , 'z' : df3 } result = pd . concat ( pieces ) result = pd . concat ( pieces , keys = [ 'z' , 'y' ]) 创建的MultiIndex具有根据传递的键和 DataFrame 片段索引构造的级别： result . index . levels FrozenList([['z', 'y'], [4, 5, 6, 7, 8, 9, 10, 11]]) 如果想指定其他级别（偶尔会这样），则可以使用以下 levels 参数： result = pd . concat ( pieces , keys = [ 'x' , 'y' , 'z' ], levels = [[ 'z' , 'y' , 'x' , 'w' ]], names = [ 'group_key' ]) result . index . levels FrozenList([['z', 'y', 'x', 'w'], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]])","text_tokens":["frames","dataframe","参数","如果","构造","10","后","2","'","}","df2","名字","还","dict","根据","w","重新","通过","传递","偶尔","blue","yellow","_","和","7","result","）","8","series","可以","{","示例","函数","第一","用法","是","key","形式","让","会","在","axis","列名","z","这样","[","级别","，","11","原","3","相当","name","]","列","index","concat","除非","变体","这种","s3","y","现有","pieces","4","=","foo",":","9","：","普遍","情况","names","keys","df3","我们","multiindex",")","用作","覆盖","。","创建","pd","的","x","拼接","以下",".","给","第一个","了","frozenlist"," ","一个","1","s5","group","其他","索引","将","0","levels","考虑","指定",",","片段","则","使用","或","5","作为","以","下","6","想","s4","red","需要","df1","(","（","具有","键"],"title":"key参数","title_tokens":["参数","key"]},{"location":"pandas笔记/7.6.拼接.html#dataframe","text":"尽管效率不是很高（因为必须创建一个新的对象），但是可以向 append 传递一个 Series 或dict来将一行附加到 DataFrame ： s2 = pd . Series ([ 'X0' , 'X1' , 'X2' , 'X3' ], index = [ 'A' , 'B' , 'C' , 'D' ]) result = df1 . append ( s2 , ignore_index = True ) 还可以传递字典或系列的列表： dicts = [{ 'A' : 1 , 'B' : 2 , 'C' : 3 , 'X' : 4 }, { 'A' : 5 , 'B' : 6 , 'C' : 7 , 'Y' : 8 }] result = df1 . append ( dicts , ignore_index = True , sort = False )","text_tokens":["高","）","很",".","dataframe","ignore","不是","对象","8","]","必须"," ","但是","可以","一个","series","到","index","{","7","效率","append","1","x2","y","来","c","2","'","}","b","向","系列","4","=","x3","还","dict","d",":","将","false","：","新",",","true",")","传递","或","5","dicts","[","字典","6","x0","尽管","因为","df1","sort","创建","(","x1","（","pd","的","附加","a","，","result","_","x","s2","列表","3","一行"],"title":"行追加到 DataFrame","title_tokens":["dataframe"," ","到","追加","行"]},{"location":"pandas笔记/7.6.拼接.html#_1","text":"pandas具有全功能、高性能的内存连接操作，与SQL等关系数据库非常相似。这些方法的性能比其他开源实现（如R中的base：：merge.data.frame）要好得多（在某些情况下甚至超过一个数量级）。原因是仔细的算法设计和DataFrame的数据的内部布局。 pandas提供函数 merge() ，作为DataFrame或Series对象之间所有标准数据库拼接操作的入口点： pd . merge ( left , right , how = 'inner' , on = None , left_on = None , right_on = None , left_index = False , right_index = False , sort = True , suffixes = ( '_x' , '_y' ), copy = True , indicator = False , validate = None ) left ：一个DataFrame或Series的对象。 right ：另一个DataFrame或Series的对象。 on ：一个 label 或者 label list 。它指定用作连接键的列的 label 。并且必须在两个 DataFrame 中这些 label 都存在。如果它为 None ，则默认使用两个 DataFrame 的列 label 的交集。你可以通过 left_on/right_on 分别指定两侧 DataFrame 对齐的连接键。 left_on ：一个 label 或者 label list 。指定左边 DataFrame 用作连接键的列，参考 on 。 right_on ：一个 label 或者 label list 。指定右边 DataFrame 用作连接键的列，参考 on 。 left_index ：一个布尔值。如果为 True ，则使用左边的 DataFrame 的行的 index value 来作为连接键来合并。 right_index ：一个布尔值。如果为 True ，则使用右边的 DataFrame 的行的 index value 来作为连接键来合并。 how ：其一 'left' ， 'right' ， 'outer' ， 'inner' 。默认为 inner 。有关每种方法的详细说明，请参见下文。 sort ：一个布尔值。如果为 True ，则在结果中，对合并采用的连接键进行排序。 suffixes ：一个二元序列。对于结果中同名的列，它会添加前缀来指示它们来自哪个 DataFrame 。 copy ：一个布尔值。如果为 True ，则拷贝基础数据。否则不拷贝数据。 indicator ：一个字符串或者布尔值。 如果为 True ，则结果中多了一列称作 _merge ，该列给出了每一行来自于那个 DataFrame 。 如果为字符串，则结果中多了一列（该列名字由 indicator 字符串给出），该列给出了每一行来自于那个 DataFrame 。 validate ：字符串，默认为无。如果指定，则检查合并是否为指定的类型。 'one_to_one'或'1:1'：检查合并键在左右数据集中是否唯一。 'one_to_many'或'1:m'：检查合并键在左数据集中是否唯一。 'many_to_one'或'm:1'：检查合并键在正确的数据集中是否唯一。 'many_to_many'或'm:m'：允许，但不进行检查。 新功能： 0.23.0版本中添加了指定索引级别的 on 、 left_on 、 right_on 参数的支持。在0.24.0版中添加了合并命名的Series的支持。 merge 是pandas命名空间中的一个函数，它也可以作为DataFrame实例方法 merge() 使用，调用 DataFrame.merge 时， DataFrame 被视为拼接中的左侧对象。 相关 join() 方法在 merge 内部用于索引索引连接（默认情况下）和索引列连接。如果仅加入索引，则可能希望使用 DataFrame.join 来节省一些输入。","text_tokens":["0.24","list","dataframe","left","参数","inner","它","如果","结果","原因","value","允许","说明","关系","布局","存在","标准","由","时","'","开源","名字","data","frame","高性能","类型","超过","唯一","仅","不","输入","默认","通过","true","字符","于","合并","添加","布尔值","调用","数量级","采用","一些","how","它们","copy","系数","请","数据库","中多","on","join","支持","_","和","版中","对于","提供","设计","集中","据库","一行","）","参见","中","必须","series","可以","否则","用于","正确","函数","m","连接","给出","sql","r","是","哪个","键来","加入","、","数量","pandas","/","有关","false","在","你","其一","方法","对齐","拷贝","非常","某些","交集","算法","右边","label","要","级别","但","同名","量级","为","，","实现","进行","那个","indicator","左侧","对象","与","也","节省","index","validate","列","对","many","甚至","merge","内部","排序","操作","都","参考","下文","等","命名","y","来","outer","另","能比","功能","=","性能","基础",":","相似","左","左边","：","是否","情况","之间","新","检查",")","用作","希望","。","一个二元","入口","right","to","并且","如","sort","指示","性能比","全功能","base","点","的","pd","x","详细","关系数据库","来自","one","拼接","行","0.23","视为","一列","版本",".","了","相关"," ","一个","仔细","1","称作","前缀","字符串","每种","其他","none","suffixes","数据","索引","实例","这些","左右","所有","0","指定",",","则","使用","二元","无","空间","或","分别","好得多","作为","或者","可能","高性","下","序列","内存","两侧","布尔","两个","(","（","每","它会","被","具有","键","该列"],"title":"数据库形式的拼接","title_tokens":["形式","的","数据","拼接","据库","数据库"]},{"location":"pandas笔记/7.6.拼接.html#_2","text":"有经验的关系数据库（如SQL）用户将熟悉用于描述两个SQL类表结构（DataFrame对象）之间的连接操作的术语。有几个案例需要考虑，这些案例非常重要： one-to-one 联接：两个DataFrame对象的组合键都是唯一值。 many-to-one 联接：其中一个DataFrame对象的组合键是唯一值，另一个有重复值。 many-to-many 联接：两个DataFrame对象的组合键都有重复值。 注意 在列上连接列时（可能是多对多连接），传递的 DataFrame 对象上的所有索引 都将被丢弃 。 值得花些时间了解多对多连接案例的结果。 在SQL/标准关系代数中，如果键组合在两个表中出现不止一次，则生成的表将具有关联数据的笛卡尔积。 下面是一个非常基本的例子，使用一个组合键，并且组合键的值都是唯一的： left = pd . DataFrame ({ 'key' : [ 'K0' , 'K1' , 'K2' , 'K3' ], 'A' : [ 'A0' , 'A1' , 'A2' , 'A3' ], 'B' : [ 'B0' , 'B1' , 'B2' , 'B3' ]}) right = pd . DataFrame ({ 'key' : [ 'K0' , 'K1' , 'K2' , 'K3' ], 'C' : [ 'C0' , 'C1' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D1' , 'D2' , 'D3' ]}) result = pd . merge ( left , right , on = 'key' ) 多个组合键的示例（默认 how='inner' ）： left = pd . DataFrame ({ 'key1' : [ 'K0' , 'K0' , 'K1' , 'K2' ], 'key2' : [ 'K0' , 'K1' , 'K0' , 'K1' ], 'A' : [ 'A0' , 'A1' , 'A2' , 'A3' ], 'B' : [ 'B0' , 'B1' , 'B2' , 'B3' ]}) right = pd . DataFrame ({ 'key1' : [ 'K0' , 'K1' , 'K1' , 'K2' ], 'key2' : [ 'K0' , 'K0' , 'K0' , 'K0' ], 'C' : [ 'C0' , 'C1' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D1' , 'D2' , 'D3' ]}) result = pd . merge ( left , right , on = [ 'key1' , 'key2' ]) 当左右两边的组合键不一致时，处理行为由 how 参数指定。以下是 how 选项及其SQL等效名称的摘要： 合并方式 SQL连接名称 描述 left LEFT OUTER JOIN 仅保留left出现的组合键 right RIGHT OUTER JOIN 仅保留right出现的组合键 outer FULL OUTER JOIN 保留left和right组合键的并集 inner INNER JOIN 保留left和right组合键的交集 result = pd . merge ( left , right , how = 'left' , on = [ 'key1' , 'key2' ]) result = pd . merge ( left , right , how = 'right' , on = [ 'key1' , 'key2' ]) result = pd . merge ( left , right , how = 'outer' , on = [ 'key1' , 'key2' ]) result = pd . merge ( left , right , how = 'inner' , on = [ 'key1' , 'key2' ]) 这是组合键具有重复值的示例： left = pd . DataFrame ({ 'A' : [ 1 , 2 ], 'B' : [ 2 , 2 ]}) right = pd . DataFrame ({ 'A' : [ 4 , 5 , 6 ], 'B' : [ 2 , 2 , 2 ]}) result = pd . merge ( left , right , on = 'B' , how = 'outer' ) 警告 在重复键上进行拼接，会导致返回的DataFrame的函数是原来两个DataFrame行数的乘积，这可能导致内存溢出。如果DataFrame很大，应该对重复键进行管理。","text_tokens":["例子","名称","dataframe","这是","经验","left","应该","参数","inner","如果","结果","full","关系","标准","时","由","'","}","2","生成","仅","唯一","d","c1","很大","不","d1","默认","原来","合并","传递","描述","表将","k2","d3","how","系数","熟悉","数据库","重复","on","join","警告","行为","k3","和","选项","result","管理","这","两边","c2","a3","据库","术语","）","中","不止","导致","a1","用于","{","示例","函数","连接","sql","用户","是","key","花些","当","b","会","/","行数","出现","在","d2","其中","值得","方式","非常","联接","等效","[","交集","上","组合","列上","值","并","key2","，","进行","对象","]","many","对","a2","结构","merge","返回","操作","都","b0","乘积","c","集","outer","另","b3","4","=","卡尔","-",":","：","之间","溢出","b1",")","列时","多","了解","。","to","重要","right","案例","基本","key1","k1","并且","如","丢弃","c3","pd","的","关系数据库","不止一次","one","拼接","以下","代数",".","积","d0","b2"," ","一个","1","键上","组合键","一次","保留","处理","下面","索引","数据","多个","这些","将","几个","左右","所有","有","c0","考虑","指定",",","则","使用","时间","注意","摘要","5","关联","笛卡尔","k0","可能","类表","一致","6","a0","内存","需要","两个","(","（","a","表中","被","及其","具有","键"],"title":"合并方法简介（关系代数）","title_tokens":["代数","）","关系","合并","（","简介","方法"]},{"location":"pandas笔记/7.6.拼接.html#validate","text":"0.21.0版中的新功能。 可以使用 validate 参数自动检查组合键中是否有意外的重复项。在合并操作之前检查键的唯一性，可以防止内存溢出。检查组合键的唯一性也是确保数据结构符合预期的一种好方法。 在以下示例中，right中的 B 存在重复的值。由于这不是 validate 参数中指定的一对一合并，因此将引发异常。 left = pd . DataFrame ({ 'A' : [ 1 , 2 ], 'B' : [ 1 , 2 ]}) right = pd . DataFrame ({ 'A' : [ 4 , 5 , 6 ], 'B' : [ 2 , 2 , 2 ]}) try : result = pd . merge ( left , right , on = 'B' , how = 'outer' , validate = \"one_to_one\" ) except Exception as e : print ( \"MergeError:\" , e ) MergeError : Merge keys are not unique in right dataset ; not a one - to - one merge 如果用户知道右边的重复项， DataFrame 但要确保左边的DataFrame中没有重复项，则可以改用该 validate='one_to_many' 参数，这不会引发异常。 pd . merge ( left , right , on = 'B' , how = 'outer' , validate = \"one_to_many\" ) A_x B A_y 0 1 1 NaN 1 2 2 4.0 2 2 2 5.0 3 2 2 6.0","text_tokens":["dataframe","left","参数","4.0","如果","unique","存在","引发","2","'","}","该","唯一","符合","合并","try","how","重复","一对一","on","nan","_","版中","result","in","意外","这","中","不是","可以","{","示例","用户","是","一种","不会","b","0.21","在","改用",";","方法","not","[","右边","组合","要","值","好","但","，","数据结构","唯一性","dataset","3","are","]","也","e","validate","many","结构","merge","print","没有","6.0","操作","y","outer","防止","4","功能","=",":","-","是否","左边","新","溢出","keys","检查","5.0","预期",")","。","right","to","mergeerror","之前","pd","的","x","因此","one","以下","一对",".","异常"," ","项","1","组合键","确保","数据","\"","将","有","0","exception","指定",",","使用","则","5","except","6","自动","内存","由于","(","a","知道","as","键"],"title":"检查重复键：validate","title_tokens":["重复","检查","validate","键","："]},{"location":"pandas笔记/7.6.拼接.html#indicator","text":"merge() 接受指示符参数 indicator 。如果 indicator=True ，则将一个名为 _merge ，dtype为Categorical的列添加到输出DataFrame的末尾： indicator _merge 值 仅出现在 'left' 组合键 left_only 仅出现在 'right' 组合键 right_only 同时出现在 'left' 和 'right' 组合键 both df1 = pd . DataFrame ({ 'col1' : [ 0 , 1 ], 'col_left' : [ 'a' , 'b' ]}) df2 = pd . DataFrame ({ 'col1' : [ 1 , 2 , 2 ], 'col_right' : [ 2 , 2 , 2 ]}) pd . merge ( df1 , df2 , on = 'col1' , how = 'outer' , indicator = True ) col1 col_left col_right _merge 0 0 a NaN left_only 1 1 b 2.0 both 2 2 NaN 2.0 right_only 3 2 NaN 2.0 right_only indicator 参数还可以接受字符串参数，在这种情况下，指标函数将使用传递的字符串的值作为 指标列 的名称。 pd . merge ( df1 , df2 , on = 'col1' , how = 'outer' , indicator = 'indicator_column' ) col1 col_left col_right indicator_column 0 0 a NaN left_only 1 1 b 2.0 both 2 2 NaN 2.0 right_only 3 2 NaN 2.0 right_only","text_tokens":["名称","dataframe","left","参数","如果","到","col1","2","'","}","df2","还","指标","仅","true","字符","传递","添加","how","col","on","nan","符","_","和","both","可以","{","dtype","函数","b","出现","在","categorical","[","组合","值","为","，","3","indicator","]","列","column","merge","这种","only","outer","=",":","：","情况",")","。","right","末尾","指示","pd","的","接受","."," ","一个","1","输出","组合键","2.0","字符串","将","0","同时",",","则","使用","作为","下","df1","(","a","名为"],"title":"指示符：indicator","title_tokens":["：","指示","符","indicator"]},{"location":"pandas笔记/7.6.拼接.html#_3","text":"合并将保留组合键的数据类型 left = pd . DataFrame ({ 'key' : [ 1 ], 'v1' : [ 10 ]}) print ( left , \" \\n \" ) right = pd . DataFrame ({ 'key' : [ 1 , 2 ], 'v1' : [ 20 , 30 ]}) print ( right ) key v1 0 1 10 key v1 0 1 20 1 2 30 我们可以保留组合键： print ( pd . merge ( left , right , how = 'outer' ), \" \\n \" ) print ( pd . merge ( left , right , how = 'outer' ) . dtypes ) key v1 0 1 10 1 1 20 2 2 30 key int64 v1 int64 dtype : object 如果缺少引入的值，则生成的dtype将被转换： print ( pd . merge ( left , right , how = 'outer' , on = 'key' ), \" \\n \" ) print ( pd . merge ( left , right , how = 'outer' , on = 'key' ) . dtypes ) key v1_x v1_y 0 1 10 . 0 20 1 2 NaN 30 key int64 v1_x float64 v1_y int64 dtype : object 合并将保留mergands的category类型。另请参阅关于 categoricals 的部分。 left： from pandas.api.types import CategoricalDtype X = pd . Series ( np . random . choice ([ 'foo' , 'bar' ], size = ( 10 ,))) X = X . astype ( CategoricalDtype ( categories = [ 'foo' , 'bar' ])) left = pd . DataFrame ({ 'X' : X , 'Y' : np . random . choice ([ 'one' , 'two' , 'three' ], size = ( 10 ,))}) print ( left , \" \\n \" ) print ( left . dtypes ) X Y 0 foo three 1 foo two 2 bar three 3 bar three 4 bar two 5 foo two 6 bar two 7 bar one 8 bar two 9 bar two X category Y object dtype : object right： right = pd . DataFrame ({ 'X' : pd . Series ([ 'foo' , 'bar' ], dtype = CategoricalDtype ([ 'foo' , 'bar' ])), 'Z' : [ 1 , 2 ]}) print ( right , \" \\n \" ) print ( right . dtypes ) X Z 0 foo 1 1 bar 2 X category Z int64 dtype : object 合并结果： result = pd . merge ( left , right , how = 'outer' ) print ( result , \" \\n \" ) print ( result . dtypes ) X Y Z 0 foo three 1 1 foo two 1 2 foo two 1 3 bar three 2 4 bar three 2 5 bar two 2 6 bar two 2 7 bar one 2 8 bar two 2 9 bar two 2 X category Y object Z int64 dtype : object 注意 category 类型必须 完全相同 ，这意味着category对象有相同的类别和有序属性。否则，category类型将被转换成object类型。 注意 与object数据类型合并相比，在相同的category数据类型上进行合并可以获得更好的性能。","text_tokens":["dataframe","left","如果","结果","10","完全","category","2","'","}","生成","two","\\","类型","api","合并","three","how","引入","数据类型","on","categoricals","nan","完全相同","_","7","和","转换成","result","参阅","这","8","必须","series","可以","转换","{","否则","dtype","部分","object","key","30","关于","pandas","在","types","z","20","属性","[","上","相比","意味","组合","值","astype","，","3","进行","random","对象","与","]","dtypes","请参阅","print","merge","获得","y","相同","outer","另","4","=","foo","性能",":","9","更好","：","我们","n",")","import","。","right","v1","mergands","pd","的","x","one",".","categoricaldtype"," ","有序","categories","类别","choice","意味着","1","缺少","组合键","保留","数据","\"","将","np","有","0","换成",",","则","注意","5","int64","float64","6","size","bar","(","from","被"],"title":"合并时数据类型的转换","title_tokens":["时","合并","的","转换","数据","类型","数据类型"]},{"location":"pandas笔记/7.6.拼接.html#dataframejoin","text":"这是一个非常基本的示例： left = pd . DataFrame ({ 'A' : [ 'A0' , 'A1' , 'A2' ], 'B' : [ 'B0' , 'B1' , 'B2' ]}, index = [ 'K0' , 'K1' , 'K2' ]) right = pd . DataFrame ({ 'C' : [ 'C0' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D2' , 'D3' ]}, index = [ 'K0' , 'K2' , 'K3' ]) result = left . join ( right ) result = left . join ( right , how = 'outer' ) 与上述相同，但带有 how='inner' ： result = left . join ( right , how = 'inner' ) 此处的数据对齐在索引（行标签）上。使用 merge 指示其使用索引的附加参数可以实现相同的行为： result = pd . merge ( left , right , left_index = True , right_index = True , how = 'outer' ) result = pd . merge ( left , right , left_index = True , right_index = True , how = 'inner' )","text_tokens":["这是","dataframe","left","参数","inner","'","}","d","true","k2","how","d3","join","行为","_","k3","result","附加","c2","）","a1","可以","{","示例","b","在","d2","对齐","上述","非常","[","上","但","，","实现","与","]","index","a2","merge","标签","b0","此处","c","相同","outer","=",":","：","b1",")","。","right","基本","k1","指示","c3","pd","的","其","带有","行",".","d0","b2"," ","一个","索引","数据","c0",",","使用","k0","a0","(","a","（"],"title":"DataFrame.join()","title_tokens":[".","dataframe","(",")","join"]},{"location":"pandas笔记/7.6.拼接.html#join_1","text":"join() 接受一个可选的 on 参数，该参数可以是一个列或多个列名，它指定传递的DataFrame将在原DataFrame中的该列上对齐。即这两个函数调用完全等价： left . join ( right , on = key_or_keys ) pd . merge ( left , right , left_on = key_or_keys , right_index = True , how = 'left' , sort = False ) 显然，您可以选择任何一种更方便的形式。对于many-to-one拼接（其中一个DataFrame的索引是组合键），使用 join 可能会更方便。这是一个简单的示例： left = pd . DataFrame ({ 'A' : [ 'A0' , 'A1' , 'A2' , 'A3' ], 'B' : [ 'B0' , 'B1' , 'B2' , 'B3' ], 'key' : [ 'K0' , 'K1' , 'K0' , 'K1' ]}) right = pd . DataFrame ({ 'C' : [ 'C0' , 'C1' ], 'D' : [ 'D0' , 'D1' ]}, index = [ 'K0' , 'K1' ]) result = left . join ( right , on = 'key' ) result = pd . merge ( left , right , left_on = 'key' , right_index = True , how = 'left' , sort = False ); 如果组合键有多个，传递的DataFrame必须具有 MultiIndex ： left = pd . DataFrame ({ 'A' : [ 'A0' , 'A1' , 'A2' , 'A3' ], 'B' : [ 'B0' , 'B1' , 'B2' , 'B3' ], 'key1' : [ 'K0' , 'K0' , 'K1' , 'K2' ], 'key2' : [ 'K0' , 'K1' , 'K0' , 'K1' ]}) index = pd . MultiIndex . from_tuples ([( 'K0' , 'K0' ), ( 'K1' , 'K0' ), ( 'K2' , 'K0' ), ( 'K2' , 'K1' )]) right = pd . DataFrame ({ 'C' : [ 'C0' , 'C1' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D1' , 'D2' , 'D3' ]}, index = index ) 现在，可以通过传递两个组合键来进行拼接： result = left . join ( right , on = [ 'key1' , 'key2' ]) 默认的 DataFrame.join 是执行左联接（对于Excel用户，本质上是“ VLOOKUP”操作），该联接仅使用在调用DataFrame中找到的键。其他联接类型（例如内部联接）也可以轻松执行： result = left . join ( right , on = [ 'key1' , 'key2' ], how = 'inner' ) 如您所见，这将删除所有不匹配的行。","text_tokens":["dataframe","这是","left","参数","inner","它","如果","完全","函数调用","显然","'","}","该","类型","vlookup","d","仅","c1","不","等价","d1","通过","true","默认","传递","轻松","调用","how","k2","d3","join","on","删除","_","result","这","对于","c2","a3","tuples","）","中","必须","可以","a1","{","示例","函数","excel","用户","是","“","key","一种","形式","b","本质","会","false","在","d2","简单",";","其中","对齐","列名","更","联接","[","上","列上","组合","key2","，","原","例如","进行","选择","任何","]","也","列","index","many","a2","merge","内部","b0","操作","c","来","b3","=","左","-",":","or","：","keys","b1","multiindex",")","方便","。","right","to","key1","k1","如","sort","您","c3","pd","的","接受","one","拼接","行",".","d0","b2"," ","一个","组合键","其他","索引","多个","将","所有","c0","有","指定",",","使用","找到","或","执行","”","k0","可能","现在","匹配","即","a0","两个","(","（","a","from","可选","所见","具有","键"],"title":"按组合键列和索引拼接：join","title_tokens":["组合","和","join","列","按","索引","拼接","：","组合键"]},{"location":"pandas笔记/7.6.拼接.html#join_2","text":"可以将单层索引DataFrame与多层索引DataFrame的 一个级别 连接起来。该级别将与单索引DataFrame的索引名称和多索引DataFrame的级别名称相匹配 left = pd . DataFrame ({ 'A' : [ 'A0' , 'A1' , 'A2' ], 'B' : [ 'B0' , 'B1' , 'B2' ]}, index = pd . Index ([ 'K0' , 'K1' , 'K2' ], name = 'key' )) index = pd . MultiIndex . from_tuples ([( 'K0' , 'Y0' ), ( 'K1' , 'Y1' ), ( 'K2' , 'Y2' ), ( 'K2' , 'Y3' )], names = [ 'key' , 'Y' ]) right = pd . DataFrame ({ 'C' : [ 'C0' , 'C1' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D1' , 'D2' , 'D3' ]}, index = index ) result = left . join ( right , how = 'inner' ) 下面的函数和上面的方法是等效的，但 pd.merge 的信息更详细，存储效率更高/更快。 result = pd . merge ( left . reset_index (), right . reset_index (), on = [ 'key' ], how = 'inner' ) . set_index ([ 'key' , 'Y' ])","text_tokens":["名称","dataframe","left","inner","多层","效率","'","}","该","d","y0","c1","set","d1","连接起来","k2","how","d3","join","on","_","和","信息","result","存储","c2","tuples","可以","a1","{","函数","连接","快","是","起来","key","b","/","d2","方法","reset","更","等效","[","级别","但","，","name","与","]","index","a2","merge","b0","y","c","=",":","names","b1","multiindex",")","多","。","right","k1","c3","pd","详细","单层","的","y3",".","d0","b2"," ","一个","单","下面","索引","y1","上面","将","c0","y2",",","更高","k0","相匹配","匹配","接起","a0","(","a","from"],"title":"按单层索引和多层索引拼接：join","title_tokens":["和","单层","按","索引","拼接","多层","：","join"]},{"location":"pandas笔记/7.6.拼接.html#multiindexesjoin","text":"只要在连接中完全使用了右参数的索引，并且该参数是左参数中索引的子集，就可以用有限的方式来支持它，如下例所示： leftindex = pd . MultiIndex . from_product ([ list ( 'abc' ), list ( 'xy' ), [ 1 , 2 ]], names = [ 'abc' , 'xy' , 'num' ]) left = pd . DataFrame ({ 'v1' : range ( 12 )}, index = leftindex ) print ( left , \" \\n \" ) rightindex = pd . MultiIndex . from_product ([ list ( 'abc' ), list ( 'xy' )], names = [ 'abc' , 'xy' ]) right = pd . DataFrame ({ 'v2' : [ 100 * i for i in range ( 1 , 7 )]}, index = rightindex ) print ( right , \" \\n \" ) left . join ( right , on = [ 'abc' , 'xy' ], how = 'inner' ) v1 abc xy num a x 1 0 2 1 y 1 2 2 3 b x 1 4 2 5 y 1 6 2 7 c x 1 8 2 9 y 1 10 2 11 v2 abc xy a x 100 y 200 b x 300 y 400 c x 500 y 600 v1 v2 abc xy num a x 1 0 100 2 1 100 y 1 2 200 2 3 200 b x 1 4 300 2 5 300 y 1 6 400 2 7 400 c x 1 8 500 2 9 500 y 1 10 600 2 11 600 如果不满足该条件，则可以使用以下代码完成具有两个多索引的联接。 leftindex = pd . MultiIndex . from_tuples ([( 'K0' , 'X0' ), ( 'K0' , 'X1' ), ( 'K1' , 'X2' )], names = [ 'key' , 'X' ]) left = pd . DataFrame ({ 'A' : [ 'A0' , 'A1' , 'A2' ], 'B' : [ 'B0' , 'B1' , 'B2' ]}, index = leftindex ) rightindex = pd . MultiIndex . from_tuples ([( 'K0' , 'Y0' ), ( 'K1' , 'Y1' ), ( 'K2' , 'Y2' ), ( 'K2' , 'Y3' )], names = [ 'key' , 'Y' ]) right = pd . DataFrame ({ 'C' : [ 'C0' , 'C1' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D1' , 'D2' , 'D3' ]}, index = rightindex ) result = pd . merge ( left . reset_index (), right . reset_index (), on = [ 'key' ], how = 'inner' ) . set_index ([ 'key' , 'X' , 'Y' ])","text_tokens":["list","dataframe","for","left","参数","inner","它","如果","10","完全","2","'","}","该","\\","d","y0","c1","set","不","d1","*","how","k2","d3","join","on","只要","右","有限","支持","_","7","所示","result","in","c2","tuples","8","leftindex","中","可以","a1","{","连接","x2","是","key","b","条件","range","在","d2","reset","方式","联接","[","x0","100","，","11","3","200","满足","product","]","i","index","rightindex","a2","print","merge","abc","b0","y","来","c","4","=","左",":","9","：","names","b1","multiindex","n",")","600","多","500","。","400","right","300","v1","k1","并且","c3","pd","的","x","12","就","y3","以下","完成","了",".","如下","d0","用","b2"," ","xy","1","代码","索引","\"","y1","c0","0","y2",",","使用","则","5","k0","6","子集","a0","两个","(","x1","a","v2","from","例","num","具有"],"title":"按MultiIndexes拼接：join","title_tokens":["multiindexes","按","拼接","：","join"]},{"location":"pandas笔记/7.6.拼接.html#_4","text":"0.23版中的新功能。 on 、 left_on 和 right_on 参数可以引用列名或索引级名称。这允许在索引和列的组合上合并DataFrame实例，而不必重置索引： left_index = pd . Index ([ 'K0' , 'K0' , 'K1' , 'K2' ], name = 'key1' ) left = pd . DataFrame ({ 'A' : [ 'A0' , 'A1' , 'A2' , 'A3' ], 'B' : [ 'B0' , 'B1' , 'B2' , 'B3' ], 'key2' : [ 'K0' , 'K1' , 'K0' , 'K1' ]}, index = left_index ) right_index = pd . Index ([ 'K0' , 'K1' , 'K2' , 'K2' ], name = 'key1' ) right = pd . DataFrame ({ 'C' : [ 'C0' , 'C1' , 'C2' , 'C3' ], 'D' : [ 'D0' , 'D1' , 'D2' , 'D3' ], 'key2' : [ 'K0' , 'K0' , 'K0' , 'K1' ]}, index = right_index ) result = left . merge ( right , on = [ 'key1' , 'key2' ])","text_tokens":[".","名称","dataframe","left","name","d0","参数","]","b2"," ","可以","列","允许","index","{","a1","a2","merge","不必","b0","、","c","级","'","}","b","b3","功能","=","索引","而","实例","在",":","d","d2","c1","：","c0","新","d1",",","b1","引用","列名","合并","或",")","重置","k0","。","[","上","k2","right","d3","a0","on","组合","key1","k1","_","和","版中","pd","的","(","a","，","key2","这","c3","result","0.23","c2","a3"],"title":"按照列和索引合并","title_tokens":["按照","和","合并","列","索引"]},{"location":"pandas笔记/7.6.拼接.html#_5","text":"merge 函数的 suffixes 参数接受字符串列表的元组，以附加到输入DataFrame中重叠的列名以消除结果列的歧义： left = pd . DataFrame ({ 'k' : [ 'K0' , 'K1' , 'K2' ], 'v' : [ 1 , 2 , 3 ]}) right = pd . DataFrame ({ 'k' : [ 'K0' , 'K0' , 'K3' ], 'v' : [ 4 , 5 , 6 ]}) result = pd . merge ( left , right , on = 'k' ) result = pd . merge ( left , right , on = 'k' , suffixes = [ '_l' , '_r' ]) DataFrame.join() 具有 lsuffix 和 rsuffix 行为类似的参数。 left = left . set_index ( 'k' ) right = right . set_index ( 'k' ) result = left . join ( right , lsuffix = '_l' , rsuffix = '_r' )","text_tokens":[".","dataframe","中","left","参数","]"," ","到","结果","列","{","l","index","merge","函数","1","消除","r","字符串","重叠","'","2","}","v","4","=","suffixes",":","歧义","set","：","k","输入",",","列名","字符",")","5","类似","k0","以","[","k2","。","元组","right","6","join","rsuffix","on","k1","lsuffix","行为","(","k3","pd","_","的","附加","result","，","和","接受","列表","3","具有"],"title":"值列重叠","title_tokens":["值列","重叠"]},{"location":"pandas笔记/7.6.拼接.html#dataframes","text":"DataFrames 也可以传递的列表或元组以 join() 将它们连接到它们的索引上。 right2 = pd . DataFrame ({ 'v' : [ 7 , 8 , 9 ]}, index = [ 'K1' , 'K1' , 'K2' ]) result = left . join ([ right , right2 ])","text_tokens":[".","8","dataframe","left","]","也"," ","到","可以","index","{","连接","dataframes","'","}","v","=","索引",":","将","9",",",")","传递","或","它们","以","上","。","元组","[","k2","right","join","k1","(","7","pd","的","result","right2","列表"],"title":"拼接多个DataFrames","title_tokens":["dataframes","拼接","多个"]},{"location":"pandas笔记/7.6.拼接.html#_6","text":"另一个相当常见的情况是有两个索引存在交集的对象，其中一个存在缺失值，想通过另一个对象填补缺失值。这是一个例子： df1 = pd . DataFrame ([[ np . nan , 3. , 5. ], [ - 4.6 , np . nan , np . nan ], [ np . nan , 7. , np . nan ]]) df2 = pd . DataFrame ([[ - 42.6 , np . nan , - 8.2 ], [ - 5. , 1.6 , 4 ]], index = [ 1 , 2 ]) combine_first() 方法可以达到这个效果： result = df1 . combine_first ( df2 ) 请注意， combine_first 返回副本，而 update() 则会修改原对象： df1 . update ( df2 )","text_tokens":["例子",".","相当","这是","dataframe","42.6","对象","]"," ","index","一个","可以","返回","副本","1","是","存在","1.6","2","first","另","df2","这个","会","4","=","常见","索引","而","-","update","：","np","有","其中","情况","方法","效果","8.2",",","通过","则",")","注意","5","combine","缺失","交集","。","[","想","请","值","nan","df1","两个","填补","(","4.6","pd","7","的","_","result","，","修改","达到","原","3"],"title":"按索引填补缺失值","title_tokens":["值","填补","按","索引","缺失"]},{"location":"pandas笔记/7.6.拼接.html#_7","text":"","text_tokens":[],"title":"合并时间序列","title_tokens":["序列","时间","合并"]},{"location":"pandas笔记/7.6.拼接.html#_8","text":"merge_ordered() 函数允许组合时间序列和其他有序数据。 merge_ordered ( left , right , on = None , left_on = None , right_on = None , left_by = None , right_by = None , fill_method = None , suffixes = ( \"_x\" , \"_y\" ), how = \"outer\" , ) left_by : Group left DataFrame by group columns and merge piece by piece with right DataFrame left = pd . DataFrame ({ 'k' : [ 'K0' , 'K1' , 'K1' , 'K2' ], 'lv' : [ 1 , 2 , 3 , 4 ], 's' : [ 'a' , 'b' , 'c' , 'd' ]}) right = pd . DataFrame ({ 'k' : [ 'K1' , 'K2' , 'K4' ], 'rv' : [ 1 , 2 , 3 ]}) print ( left , \" \\n \" ) print ( right ) pd . merge_ordered ( left , right , fill_method = None , left_by = 's' ) k lv s 0 K0 1 a 1 K1 2 b 2 K1 3 c 3 K2 4 d k rv 0 K1 1 1 K2 2 2 K4 3 k lv s rv 0 K0 1.0 a NaN 1 K1 NaN a 1.0 2 K2 NaN a 2.0 3 K4 NaN a 3.0 4 K1 2.0 b 1.0 5 K2 NaN b 2.0 6 K4 NaN b 3.0 7 K1 3.0 c 1.0 8 K2 NaN c 2.0 9 K4 NaN c 3.0 10 K1 NaN d 1.0 11 K2 4.0 d 2.0 12 K4 NaN d 3.0 它具有一个可选 fill_method 关键字来填充丢失的数据： # 前向填充：后面的缺失值用前面的数字填充 pd . merge_ordered ( left , right , fill_method = \"ffill\" , left_by = 's' ) k lv s rv 0 K0 1.0 a NaN 1 K1 1.0 a 1.0 2 K2 1.0 a 2.0 3 K4 1.0 a 3.0 4 K1 2.0 b 1.0 5 K2 2.0 b 2.0 6 K4 2.0 b 3.0 7 K1 3.0 c 1.0 8 K2 3.0 c 2.0 9 K4 3.0 c 3.0 10 K1 NaN d 1.0 11 K2 4.0 d 2.0 12 K4 4.0 d 3.0","text_tokens":["dataframe","left","s","4.0","它","允许","10","k4","2","'","}","\\","d","#","how","k2","缺失","on","nan","_","和","7","ordered","method","8","关键","{","函数","rv","b","piece","k","填充","[","组合","with","11","3.0","3","]","fill","print","merge","and","y","c","关键字","来","前向","值用","outer","4","=","数字",":","9","：","n",")","1.0","。","right","k1","后面","pd","x","的","12",".","可"," ","有序","by","一个","1","具有","2.0","group","其他","none","ffill","suffixes","数据","\"","丢失","0","选",",","时间","5","columns","k0","6","序列","前面","(","a","lv"],"title":"合并有序数据","title_tokens":["合并","有序","数据"]},{"location":"pandas笔记/7.6.拼接.html#asof","text":"merge_asof() 类似于有序左联接，只是我们匹配最近的键而不是相等的键。对于左数据框中的每一行，我们选择右数据框中的最后一行，该行的on键小于lefs键。两个数据帧都必须按键排序。 可选地，asof合并可以执行逐组合并。除了on键上最接近的匹配之外，它与by键的匹配相同 merge_asof ( left , right , on = None , left_on = None , right_on = None , left_index = False , right_index = False , by = None , left_by = None , right_by = None , suffixes = ( \"_x\" , \"_y\" ), tolerance = None , allow_exact_matches = True , direction = \"backward\" , ) 例如，我们可能有 trades 和 quotes ，我们想合并它们 trades = pd . DataFrame ({ 'time' : pd . to_datetime ([ '20160525 13:30:00.023' , '20160525 13:30:00.038' , '20160525 13:30:00.048' , '20160525 13:30:00.048' , '20160525 13:30:00.048' ]), 'ticker' : [ 'MSFT' , 'MSFT' , 'GOOG' , 'GOOG' , 'AAPL' ], 'price' : [ 51.95 , 51.95 , 720.77 , 720.92 , 98.00 ], 'quantity' : [ 75 , 155 , 100 , 100 , 100 ]}, columns = [ 'time' , 'ticker' , 'price' , 'quantity' ]) quotes = pd . DataFrame ({ 'time' : pd . to_datetime ([ '20160525 13:30:00.023' , '20160525 13:30:00.023' , '20160525 13:30:00.030' , '20160525 13:30:00.041' , '20160525 13:30:00.048' , '20160525 13:30:00.049' , '20160525 13:30:00.072' , '20160525 13:30:00.075' ]), 'ticker' : [ 'GOOG' , 'MSFT' , 'MSFT' , 'MSFT' , 'GOOG' , 'AAPL' , 'GOOG' , 'MSFT' ], 'bid' : [ 720.50 , 51.95 , 51.97 , 51.99 , 720.50 , 97.99 , 720.50 , 52.01 ], 'ask' : [ 720.93 , 51.96 , 51.98 , 52.00 , 720.93 , 98.01 , 720.88 , 52.03 ]}, columns = [ 'time' , 'ticker' , 'bid' , 'ask' ]) print ( trades , \" \\n \" ) print ( quotes ) time ticker price quantity 0 2016 - 05 - 25 13 : 30 : 00 . 023 MSFT 51 . 95 75 1 2016 - 05 - 25 13 : 30 : 00 . 038 MSFT 51 . 95 155 2 2016 - 05 - 25 13 : 30 : 00 . 048 GOOG 720 . 77 100 3 2016 - 05 - 25 13 : 30 : 00 . 048 GOOG 720 . 92 100 4 2016 - 05 - 25 13 : 30 : 00 . 048 AAPL 98 . 00 100 time ticker bid ask 0 2016 - 05 - 25 13 : 30 : 00 . 023 GOOG 720 . 50 720 . 93 1 2016 - 05 - 25 13 : 30 : 00 . 023 MSFT 51 . 95 51 . 96 2 2016 - 05 - 25 13 : 30 : 00 . 030 MSFT 51 . 97 51 . 98 3 2016 - 05 - 25 13 : 30 : 00 . 041 MSFT 51 . 99 52 . 00 4 2016 - 05 - 25 13 : 30 : 00 . 048 GOOG 720 . 50 720 . 93 5 2016 - 05 - 25 13 : 30 : 00 . 049 AAPL 97 . 99 98 . 01 6 2016 - 05 - 25 13 : 30 : 00 . 072 GOOG 720 . 50 720 . 88 7 2016 - 05 - 25 13 : 30 : 00 . 075 MSFT 52 . 01 52 . 03 默认情况下，我们采用的是quotes。 pd . merge_asof ( trades , quotes , on = 'time' , by = 'ticker' ) time ticker price quantity bid ask 0 2016-05-25 13:30:00.023 MSFT 51.95 75 51.95 51.96 1 2016-05-25 13:30:00.038 MSFT 51.95 155 51.97 51.98 2 2016-05-25 13:30:00.048 GOOG 720.77 100 720.50 720.93 3 2016-05-25 13:30:00.048 GOOG 720.92 100 720.50 720.93 4 2016-05-25 13:30:00.048 AAPL 98.00 100 NaN NaN 我们只在quote 时间和trade 时间之间的2毫秒内合并： pd . merge_asof ( trades , quotes , on = 'time' , by = 'ticker' , tolerance = pd . Timedelta ( '2ms' )) time ticker price quantity bid ask 0 2016-05-25 13:30:00.023 MSFT 51.95 75 51.95 51.96 1 2016-05-25 13:30:00.038 MSFT 51.95 155 NaN NaN 2 2016-05-25 13:30:00.048 GOOG 720.77 100 720.50 720.93 3 2016-05-25 13:30:00.048 GOOG 720.92 100 720.50 720.93 4 2016-05-25 13:30:00.048 AAPL 98.00 100 NaN NaN 我们只在quote 时间和trade 时间之间的10毫秒内合并，并且不包括精确匹配。注意，尽管我们排除了（quotes的）完全匹配项，但以前的quotes确实会传播到那个时间点。 pd . merge_asof ( trades , quotes , on = 'time' , by = 'ticker' , tolerance = pd . Timedelta ( '10ms' ), allow_exact_matches = False ) time ticker price quantity bid ask 0 2016-05-25 13:30:00.023 MSFT 51.95 75 NaN NaN 1 2016-05-25 13:30:00.038 MSFT 51.95 155 51.97 51.98 2 2016-05-25 13:30:00.048 GOOG 720.77 100 NaN NaN 3 2016-05-25 13:30:00.048 GOOG 720.92 100 NaN NaN 4 2016-05-25 13:30:00.048 AAPL 98.00 100 NaN NaN","text_tokens":["dataframe","left","传播","它","到","99","20160525","00.030","10","完全","720.50","最","matches","除了","之外","2","'","}","\\","98","038","不","51.97","于","默认","true","合并","030","98.01","采用","它们","51.96","92","on","尽管","nan","右","quantity","aapl","_","和","98.00","7","对于","确实","一行","）","88","不是","必须","00.075","可以","{","96","是","30","2016","ask","会","而","false","在","内","52","只","联接","类似","049","ticker","[","上","接近","组合","但","100","并","03","00","，","00.072","例如","13","155","3","075","那个","023","exact","选择","与","]","index","print","merge","精确","排序","05","51","都","95","timedelta","tolerance","datetime","框中","y","相同","bid","50","072","包括","按键","4","=","左",":","00.023","-","048","00.041","：","情况","之间","allow","trades","我们","price","n",")","相等","97.99","trade","。","right","to","帧","00.038","97","最近","并且","720.88","pd","点","的","x","720.92","最后","msft",".","了","该行"," ","有序","by","52.03","asof","quotes","项","2ms","1","00.048","720","01","逐","25","以前","52.01","none","可选地","排除","suffixes","数据","\"","小于","lefs","720.77","backward","93","51.98","direction","有","0","00.049","51.95",",","77","时间","注意","5","75","执行","毫秒","columns","只是","匹配","可能","下","6","想","041","quote","720.93","time","两个","(","每","（","10ms","goog","可选","51.99","52.00","键"],"title":"合并ASOF","title_tokens":["asof","合并"]},{"location":"pandas笔记/7.7.变换索引.html","text":"Windows 10 Python 3.7.3 @ MSC v.1915 64 bit (AMD64) from tools import Help as H import numpy as np import pandas as pd 重塑和数据透视表 pivot DataFrame.pivot() 方法重排数据。它是一个快捷方式，它使用 set_index 将列数据变成行索引，然后使用 unstack 将行索引转为列索引。 DataFrame . pivot ( index = None , columns = None , values = None ) index ：一个字符串。指定了一个 column name ，用该列数据来 set_index （将该列数据变成行索引，删除了原来的旧的行索引）。如果为 None ，则不执行 set_index columns ：一个字符串，指定了哪个列数据作为结果的 columns labels 。 实际上对 index,clumns 指定的列数据均 set_index，然后仅对 columns 对应的列数据 unstack values ：一个字符串，指定了哪个列数据作为结果的数据。如果未提供，则剩余的所有列都将作为结果的数据。 创建示例DataFrame： import pandas.util.testing as tm tm . N = 3 def unpivot ( frame ): N , K = frame . shape data = { 'value' : frame . to_numpy () . ravel ( 'F' ), 'variable' : np . asarray ( frame . columns ) . repeat ( N ), 'date' : np . tile ( np . asarray ( frame . index ), K )} return pd . DataFrame ( data , columns = [ 'date' , 'variable' , 'value' ]) df = unpivot ( tm . makeTimeDataFrame ()) df date variable value 0 2000-01-03 A -0.794700 1 2000-01-04 A 0.080430 2 2000-01-05 A -0.573297 3 2000-01-03 B 0.739518 4 2000-01-04 B 0.967577 5 2000-01-05 B 1.744425 6 2000-01-03 C 0.656323 7 2000-01-04 C 0.691297 8 2000-01-05 C 0.377455 9 2000-01-03 D 0.488279 10 2000-01-04 D 0.016629 11 2000-01-05 D 0.516103 要选择所有 variable=A 的值，可以这样做： df [ df [ 'variable' ] == 'A' ] date variable value 0 2000-01-03 A -0.794700 1 2000-01-04 A 0.080430 2 2000-01-05 A -0.573297 但是假设我们希望对变量进行时间序列运算，更好的表示方法是列是唯一的变量，行索引作为日期。为了将数据重塑为这种形式，我们使用 DataFrame.pivot() 方法（也实现为顶级函数 pivot() ）： df . pivot ( index = 'date' , columns = 'variable' , values = 'value' ) variable A B C D date 2000-01-03 -0.794700 0.739518 0.656323 0.488279 2000-01-04 0.080430 0.967577 0.691297 0.016629 2000-01-05 -0.573297 1.744425 0.377455 0.516103 如果省略 values 参数，并且输入 DataFrame 具有多于一列的值，则结果DataFrame将具有多层次列索引： df [ 'value2' ] = df [ 'value' ] * 2 print ( df ) pivoted = df . pivot ( index = 'date' , columns = 'variable' ) pivoted date variable value value2 0 2000-01-03 A -0.794700 -1.589400 1 2000-01-04 A 0.080430 0.160860 2 2000-01-05 A -0.573297 -1.146593 3 2000-01-03 B 0.739518 1.479037 4 2000-01-04 B 0.967577 1.935153 5 2000-01-05 B 1.744425 3.488850 6 2000-01-03 C 0.656323 1.312645 7 2000-01-04 C 0.691297 1.382595 8 2000-01-05 C 0.377455 0.754910 9 2000-01-03 D 0.488279 0.976557 10 2000-01-04 D 0.016629 0.033257 11 2000-01-05 D 0.516103 1.032207 value value2 variable A B C D A B C D date 2000-01-03 -0.794700 0.739518 0.656323 0.488279 -1.589400 1.479037 1.312645 0.976557 2000-01-04 0.080430 0.967577 0.691297 0.016629 0.160860 1.935153 1.382595 0.033257 2000-01-05 -0.573297 1.744425 0.377455 0.516103 -1.146593 3.488850 0.754910 1.032207 注意 如果索引包含重复项， pivot() 将出错，无法重塑。在这种情况下，请考虑使用 pivot_table() ，它是pivot的泛化，可以处理一个索引/列对的重复值。 stack DataFrame.stack() 方法将数据的列索引旋转为行索引。 注意：它跟转置不同，转置会同时旋转数据。 DataFrame.stack(level=-1, dropna=True) level ：一个整数、字符串或者整数字符串的列表。如果列索引为多级索引，它指定了将哪个级别的索引旋转为行索引 dropna ：一个布尔值。如果为 True ，则如果结果中某行全为 NaN ，则抛弃该行 旋转时，列索引旋转为行索引，新的行索引是多级索引，最内层的行索引就是原来的列索引。 最清晰的解释方式是通过示例。先创建一个示例数据： tuples = list ( zip ( * [[ 'bar' , 'bar' , 'baz' , 'baz' , 'foo' , 'foo' , 'qux' , 'qux' ], [ 'one' , 'two' , 'one' , 'two' , 'one' , 'two' , 'one' , 'two' ]])) index = pd . MultiIndex . from_tuples ( tuples , names = [ 'first' , 'second' ]) df = pd . DataFrame ( np . random . randn ( 8 , 2 ), index = index , columns = [ 'A' , 'B' ]) df2 = df [: 4 ] df2 A B first second bar one -0.057986 0.355058 two 0.575360 1.254999 baz one 0.105935 -0.669381 two -0.273632 2.168700 stacked = df2 . stack () stacked first second bar one A -0.057986 B 0.355058 two A 0.575360 B 1.254999 baz one A 0.105935 B -0.669381 two A -0.273632 B 2.168700 dtype: float64 unstack 与 DataFrame.stack() 对应的就是 DataFrame.unstack() 方法。 它将数据的行索引转换为列索引。 注意：它跟转置不同，转置会同时旋转数据。 DataFrame.unstack(level=-1, fill_value=None) level ：一个整数、字符串或者整数字符串的列表。如果行索引为多级索引，它指定了将哪个级别的索引旋转为列索引 fill_value ：一个标量。如果结果中有 NaN ，则使用 fill_value 替换。 unstack 默认情况下将最后一级行索引转换成列索引： print ( stacked ) first second bar one A -0.057986 B 0.355058 two A 0.575360 B 1.254999 baz one A 0.105935 B -0.669381 two A -0.273632 B 2.168700 dtype: float64 stacked . unstack () A B first second bar one -0.057986 0.355058 two 0.575360 1.254999 baz one 0.105935 -0.669381 two -0.273632 2.168700 stacked . unstack ( 1 ) second one two first bar A -0.057986 0.575360 B 0.355058 1.254999 baz A 0.105935 -0.273632 B -0.669381 2.168700 stacked . unstack ( 0 ) first bar baz second one A -0.057986 0.105935 B 0.355058 -0.669381 two A 0.575360 -0.273632 B 1.254999 2.168700 如果索引具有名称，则可以使用级别名称而不是指定级别编号： stacked . unstack ( 'second' ) second one two first bar A -0.057986 0.575360 B 0.355058 1.254999 baz A 0.105935 -0.273632 B -0.669381 2.168700 注意， stack 和 unstack 方法会隐式地对索引进行排序： index = pd . MultiIndex . from_product ([[ 2 , 1 ], [ 'a' , 'b' ]]) df = pd . DataFrame ( np . random . randn ( 4 ), index = index , columns = [ 'A' ]) print ( df , \" \\n \" ) print ( df . unstack () . stack ()) all ( df . unstack () . stack () == df . sort_index ()) A 2 a - 0 . 775482 b - 0 . 358023 1 a 0 . 150078 b - 1 . 990797 A 1 a 0 . 150078 b - 1 . 990797 2 a - 0 . 775482 b - 0 . 358023 True 多级别索引 还可以通过传递一个索引名字列表来一次堆栈或取消堆栈多个级别的索引，在这种情况下，最终结果就好像列表中的每个级别的索引都是单独处理的： columns = pd . MultiIndex . from_tuples ([ ( 'A' , 'cat' , 'long' ), ( 'B' , 'cat' , 'long' ), ( 'A' , 'dog' , 'short' ), ( 'B' , 'dog' , 'short' )], names = [ 'exp' , 'animal' , 'hair_length' ]) df = pd . DataFrame ( np . random . randn ( 4 , 4 ), columns = columns ) print ( df ) df . stack ( level = [ 'animal' , 'hair_length' ]) exp A B A B animal cat cat dog dog hair_length long long short short 0 -0.590259 0.643611 -0.253519 -0.723468 1 0.316200 1.340781 1.300858 0.531254 2 -0.666685 1.021562 0.119488 1.266647 3 0.161535 -1.919107 -1.652191 -0.134814 exp A B animal hair_length 0 cat long -0.590259 0.643611 dog short -0.253519 -0.723468 1 cat long 0.316200 1.340781 dog short 1.300858 0.531254 2 cat long -0.666685 1.021562 dog short 0.119488 1.266647 3 cat long 0.161535 -1.919107 dog short -1.652191 -0.134814 索引列表可以包含索引名称或索引级别的编号（但不能同时包含两者）： # df.stack(level=['animal', 'hair_length']) # from above is equivalent to: df . stack ( level = [ 1 , 2 ]) exp A B animal hair_length 0 cat long -0.590259 0.643611 dog short -0.253519 -0.723468 1 cat long 0.316200 1.340781 dog short 1.300858 0.531254 2 cat long -0.666685 1.021562 dog short 0.119488 1.266647 3 cat long 0.161535 -1.919107 dog short -1.652191 -0.134814 缺失数据 这些函数对于处理丢失的数据非常智能，并且不希望层次索引中的每个子组都具有相同的标签集。它们还可以处理未排序的索引（当然，您可以通过调用sort_index对其进行排序）。下面是一个更复杂的例子： columns = pd . MultiIndex . from_tuples ([( 'A' , 'cat' ), ( 'B' , 'dog' ), ( 'B' , 'cat' ), ( 'A' , 'dog' )], names = [ 'exp' , 'animal' ]) index = pd . MultiIndex . from_product ([( 'bar' , 'baz' , 'foo' , 'qux' ), ( 'one' , 'two' )], names = [ 'first' , 'second' ]) df = pd . DataFrame ( np . random . randn ( 8 , 4 ), index = index , columns = columns ) df2 = df . iloc [[ 0 , 1 , 2 , 4 , 5 , 7 ]] print ( df2 ) exp A B A animal cat dog cat dog first second bar one -0.170026 -0.849601 -0.731394 0.221731 two 1.343975 2.249542 0.092470 0.565612 baz one -0.783770 0.689877 0.406778 -1.099836 foo one 1.291947 -1.701371 0.101385 0.200045 two 3.026423 -0.763562 -0.189664 0.091951 qux two -0.621108 -1.022019 -1.033913 0.404069 如上所述， stack 可以使用 level 参数来调用以选择要堆叠的列中的级别： df2 . stack ( 'exp' ) animal cat dog first second exp bar one A -0.170026 0.221731 B -0.731394 -0.849601 two A 1.343975 0.565612 B 0.092470 2.249542 baz one A -0.783770 -1.099836 B 0.406778 0.689877 foo one A 1.291947 0.200045 B 0.101385 -1.701371 two A 3.026423 0.091951 B -0.189664 -0.763562 qux two A -0.621108 0.404069 B -1.033913 -1.022019 df2 . stack ( 'animal' ) exp A B first second animal bar one cat -0.170026 -0.731394 dog 0.221731 -0.849601 two cat 1.343975 0.092470 dog 0.565612 2.249542 baz one cat -0.783770 0.406778 dog -1.099836 0.689877 foo one cat 1.291947 0.101385 dog 0.200045 -1.701371 two cat 3.026423 -0.189664 dog 0.091951 -0.763562 qux two cat -0.621108 -1.033913 dog 0.404069 -1.022019 如果子组没有相同的标签集，则取消堆叠可能会导致缺少值。默认情况下，缺少的值将替换为该数据类型的默认填充值，NaN表示浮点，NaT表示datetimelike，等等。对于整数类型，默认情况下，数据将转换为浮点，缺少的值将设置为NaN： df3 = df . iloc [[ 0 , 1 , 4 , 7 ], [ 1 , 2 ]] print ( df3 ) df3 . unstack () exp B animal dog cat first second bar one -0.849601 -0.731394 two 2.249542 0.092470 foo one -1.701371 0.101385 qux two -1.022019 -1.033913 exp B animal dog cat second one two one two first bar -0.849601 2.249542 -0.731394 0.092470 foo -1.701371 NaN 0.101385 NaN qux NaN -1.022019 NaN -1.033913 或者设置 fill_value 参数，用于指定缺失数据的值。 df3 . unstack ( fill_value =- 1e9 ) exp B animal dog cat second one two one two first bar -8.496012e-01 2.249542e+00 -7.313939e-01 9.246967e-02 foo -1.701371e+00 -1.000000e+09 1.013849e-01 -1.000000e+09 qux -1.000000e+09 -1.022019e+00 -1.000000e+09 -1.033913e+00 多级索引 当列是多索引时，取消堆栈也会小心地执行正确的操作： df [: 3 ] . unstack ( 0 ) exp A B A animal cat dog cat dog first bar baz bar baz bar baz bar baz second one -0.170026 -0.78377 -0.849601 0.689877 -0.731394 0.406778 0.221731 -1.099836 two 1.343975 NaN 2.249542 NaN 0.092470 NaN 0.565612 NaN df2 . unstack ( 1 ) exp A B A animal cat dog cat dog second one two one two one two one two first bar -0.170026 1.343975 -0.849601 2.249542 -0.731394 0.092470 0.221731 0.565612 baz -0.783770 NaN 0.689877 NaN 0.406778 NaN -1.099836 NaN foo 1.291947 3.026423 -1.701371 -0.763562 0.101385 -0.189664 0.200045 0.091951 qux NaN -0.621108 NaN -1.022019 NaN -1.033913 NaN 0.404069 通过Melt重塑 阿斯蒂芬 cheese = pd . DataFrame ({ 'first' : [ 'John' , 'Mary' ], 'last' : [ 'Doe' , 'Bo' ], 'height' : [ 5.5 , 6.0 ], 'weight' : [ 130 , 150 ]}) print ( cheese ) first last height weight 0 John Doe 5.5 130 1 Mary Bo 6.0 150 cheese . melt ( id_vars = [ 'first' , 'last' ]) first last variable value 0 John Doe height 5.5 1 Mary Bo height 6.0 2 John Doe weight 130.0 3 Mary Bo weight 150.0 cheese . melt ( id_vars = [ 'first' , 'last' ], var_name = 'quantity' ) first last quantity value 0 John Doe height 5.5 1 Mary Bo height 6.0 2 John Doe weight 130.0 3 Mary Bo weight 150.0 另一种转换方法是使用 wide_to_long() 面板数据便利功能。它不如灵活 melt() ，但更易于使用。 dft = pd . DataFrame ({ \"A1970\" : { 0 : \"a\" , 1 : \"b\" , 2 : \"c\" }, \"A1980\" : { 0 : \"d\" , 1 : \"e\" , 2 : \"f\" }, \"B1970\" : { 0 : 2.5 , 1 : 1.2 , 2 : . 7 }, \"B1980\" : { 0 : 3.2 , 1 : 1.3 , 2 : . 1 }, \"X\" : dict ( zip ( range ( 3 ), np . random . randn ( 3 )))}) dft [ \"id\" ] = dft . index print ( dft ) pd . wide_to_long ( dft , [ \"A\" , \"B\" ], i = \"id\" , j = \"year\" ) A1970 A1980 B1970 B1980 X id 0 a d 2.5 3.2 -0.468296 0 1 b e 1.2 1.3 0.739891 1 2 c f 0.7 0.1 0.146285 2 X A B id year 0 1970 -0.468296 a 2.5 1 1970 0.739891 b 1.2 2 1970 0.146285 c 0.7 0 1980 -0.468296 d 3.2 1 1980 0.739891 e 1.3 2 1980 0.146285 f 0.1","text_tokens":["浮点","不如","cheese","均","多级","多层","10","0.057986","1.3","最","130","层次","'","df2","该","two","仅","唯一","dict","set","0.731394","不","默认","1.032207","*","level","2.5","a1980","调用","智能","请","重塑","7","每个","对于","64","不是","当列","转换","{","对应","正确","是","哪个","0.134814","unstack","多层次","pandas","range","0.967577","pivoted","方式","tools","这样","灵活","快捷方式","python","实现","randn","3","清晰","替换","将列","fill","8.496012","中有","一级","来","相同","1.340781","clumns","is","multiindex","n",")","above","。","to","当然","1980","0.092470","sort","0.590259","a1970","的","animal","其","2.249542","列表","一列","了","编号"," ","如上所述","help","h","+","0.643611","weight","字符串","处理","列对","先","150.0","将","丢失","面板","dropna","换成","maketimedataframe","all","考虑","旋转","使用","则","为行","跟","height","或","5","df","序列","0.091951","a","150078","bo","该列","它","value","0.976557","last","实际","2","}","0.377455","假设","amd64","用该","还","frame","\\","输入","原来","传递","0.739518","缺失","未","重复","等等","列中","nan","删除","b1980","_","和","提供","单独","tuples","util","8","3.026423","中","0.488279","做","0.406778","0.101385","示例","函数","datetimelike","一种","小心","b","ravel","而","3.7","tile","year","b1970","table","不同","775482","0.316200","填充","358023","unpivot","0.221731","级别","00","，","斯蒂芬","asarray","0.565612","0.355058","与","]","e","index","列","0.189664","堆叠","print","没有","1.935153","都","9.246967","qux","透视","c","melt","=","功能","0.849601","更好","names","df3","我们","内层","多","import","希望","990797","并且","您","整数","1.479037","one","就","实际上","1","01","设置","none","下面","vars","多个","注意","exp","如上","0.78377","包含","columns","dog","nat","j","0.1","(","0.516103","0.404069","shape","例子","名称","0.723468","参数","如果","时","0.794700","名字","0.763562","data","类型","0.160860","2000","泛化","1.382595","通过","字符","抛弃","msc","布尔值","7.313939","数据类型","quantity","1.266647","转换成","variable","testing","value2","两者","多于","2.168700","1e9","1970","变量","可以","1.146593","3.2","dtype","1.589400","0.575360","5.5","0.170026","@","会","john","stacked","将行","日期","方法","k","doe","转置","顶级","非常","更","然后","[","旧","要","值","1.300858","0.621108","为","1.013849","11","tm","进行","random","选择","name","3.488850","0.666685","product","0.783770","对","转换方法","标量","column","windows","操作","4","foo",":","9","情况","0.146285","values","bit","f","为了","1.254999","length","0.253519","创建","0.119488","pd","150","1.919107","x","v.1915","最后",".","表","该行","但是","一个","标签集","1.022019","0.691297","项","0.739891","iloc","索引","\"","所述","这些","所有","0","0.656323","阿","指定","0.080430","易于","某行","def","0.468296","堆栈","6","bar","zip","变成","布尔","（","地","取消","好像","出错","wide","baz","具有","0.531254","list","dataframe","隐式","结果","不能","04","long","first","d","子组","0.200045","1.312645","true","second","1.701371","快捷","#","numpy","dft","它们","stack","pivot","0.273632","省略","mary","id","解释","）","导致","无法","用于","cat","、","形式","全为","/","130.0","1.099836","在","repeat","但","03","short","02","0.669381","1.033913","1.291947","1.652191","表示","equivalent","也","便利","i","标签","6.0","05","排序","这种","为列","1.2","转为","运算","另","1.021562","-","复杂","：","新","1.744425","1.343975","labels","就是","重排","0.573297","hair","return","行","0.161535","剩余","0.689877","date","0.016629","缺少","一次","0.105935","1.000000","0.033257","数据","09","0.7","最终","np","同时",",","时间","执行","作为","或者","以","可能","下","float64","0.754910","from","as","var"],"title":"7.7.变换索引","title_tokens":["变换","7.7","索引","."]},{"location":"pandas笔记/7.7.变换索引.html#_1","text":"","text_tokens":[],"title":"重塑和数据透视表","title_tokens":["重塑","透视","表","和","数据"]},{"location":"pandas笔记/7.7.变换索引.html#pivot","text":"DataFrame.pivot() 方法重排数据。它是一个快捷方式，它使用 set_index 将列数据变成行索引，然后使用 unstack 将行索引转为列索引。 DataFrame . pivot ( index = None , columns = None , values = None ) index ：一个字符串。指定了一个 column name ，用该列数据来 set_index （将该列数据变成行索引，删除了原来的旧的行索引）。如果为 None ，则不执行 set_index columns ：一个字符串，指定了哪个列数据作为结果的 columns labels 。 实际上对 index,clumns 指定的列数据均 set_index，然后仅对 columns 对应的列数据 unstack values ：一个字符串，指定了哪个列数据作为结果的数据。如果未提供，则剩余的所有列都将作为结果的数据。 创建示例DataFrame： import pandas.util.testing as tm tm . N = 3 def unpivot ( frame ): N , K = frame . shape data = { 'value' : frame . to_numpy () . ravel ( 'F' ), 'variable' : np . asarray ( frame . columns ) . repeat ( N ), 'date' : np . tile ( np . asarray ( frame . index ), K )} return pd . DataFrame ( data , columns = [ 'date' , 'variable' , 'value' ]) df = unpivot ( tm . makeTimeDataFrame ()) df date variable value 0 2000-01-03 A -0.794700 1 2000-01-04 A 0.080430 2 2000-01-05 A -0.573297 3 2000-01-03 B 0.739518 4 2000-01-04 B 0.967577 5 2000-01-05 B 1.744425 6 2000-01-03 C 0.656323 7 2000-01-04 C 0.691297 8 2000-01-05 C 0.377455 9 2000-01-03 D 0.488279 10 2000-01-04 D 0.016629 11 2000-01-05 D 0.516103 要选择所有 variable=A 的值，可以这样做： df [ df [ 'variable' ] == 'A' ] date variable value 0 2000-01-03 A -0.794700 1 2000-01-04 A 0.080430 2 2000-01-05 A -0.573297 但是假设我们希望对变量进行时间序列运算，更好的表示方法是列是唯一的变量，行索引作为日期。为了将数据重塑为这种形式，我们使用 DataFrame.pivot() 方法（也实现为顶级函数 pivot() ）： df . pivot ( index = 'date' , columns = 'variable' , values = 'value' ) variable A B C D date 2000-01-03 -0.794700 0.739518 0.656323 0.488279 2000-01-04 0.080430 0.967577 0.691297 0.016629 2000-01-05 -0.573297 1.744425 0.377455 0.516103 如果省略 values 参数，并且输入 DataFrame 具有多于一列的值，则结果DataFrame将具有多层次列索引： df [ 'value2' ] = df [ 'value' ] * 2 print ( df ) pivoted = df . pivot ( index = 'date' , columns = 'variable' ) pivoted date variable value value2 0 2000-01-03 A -0.794700 -1.589400 1 2000-01-04 A 0.080430 0.160860 2 2000-01-05 A -0.573297 -1.146593 3 2000-01-03 B 0.739518 1.479037 4 2000-01-04 B 0.967577 1.935153 5 2000-01-05 B 1.744425 3.488850 6 2000-01-03 C 0.656323 1.312645 7 2000-01-04 C 0.691297 1.382595 8 2000-01-05 C 0.377455 0.754910 9 2000-01-03 D 0.488279 0.976557 10 2000-01-04 D 0.016629 0.033257 11 2000-01-05 D 0.516103 1.032207 value value2 variable A B C D A B C D date 2000-01-03 -0.794700 0.739518 0.656323 0.488279 -1.589400 1.479037 1.312645 0.976557 2000-01-04 0.080430 0.967577 0.691297 0.016629 0.160860 1.935153 1.382595 0.033257 2000-01-05 -0.573297 1.744425 0.377455 0.516103 -1.146593 3.488850 0.754910 1.032207 注意 如果索引包含重复项， pivot() 将出错，无法重塑。在这种情况下，请考虑使用 pivot_table() ，它是pivot的泛化，可以处理一个索引/列对的重复值。","text_tokens":["dataframe","参数","它","如果","结果","均","value","0.976557","多层","04","10","实际","层次","0.794700","'","}","2","0.377455","假设","用该","data","frame","仅","d","唯一","0.160860","set","2000","泛化","不","1.382595","输入","原来","1.312645","字符","*","1.032207","快捷","numpy","0.739518","未","请","重复","重塑","删除","pivot","_","7","省略","variable","testing","提供","value2","）","util","8","多于","0.488279","变量","可以","做","{","1.146593","无法","对应","示例","函数","是","哪个","形式","1.589400","unstack","b","多层次","pandas","ravel","/","将行","在","日期","方法","tile","repeat","0.967577","k","table","pivoted","方式","这样","顶级","然后","[","unpivot","旧","要","值","快捷方式","为","03","，","实现","11","表示","3","tm","进行","asarray","选择","name","3.488850","]","也","index","列","对","将列","column","print","05","1.935153","都","这种","来","转为","c","运算","4","=",":","-","9","更好","：","情况","clumns","values","f","1.744425","为了","我们","n",")","labels","import","希望","。","重排","0.573297","to","并且","创建","pd","的","return","1.479037","行","剩余","一列",".","了","date"," ","但是","一个","0.691297","0.016629","项","实际上","1","具有","字符串","01","处理","0.033257","列对","none","索引","数据","将","所有","np","0","0.656323","maketimedataframe","考虑","指定",",","使用","则","时间","0.080430","5","注意","执行","def","包含","columns","作为","df","下","6","序列","变成","(","0.754910","（","a","0.516103","出错","as","shape","该列"],"title":"pivot","title_tokens":["pivot"]},{"location":"pandas笔记/7.7.变换索引.html#stack","text":"DataFrame.stack() 方法将数据的列索引旋转为行索引。 注意：它跟转置不同，转置会同时旋转数据。 DataFrame.stack(level=-1, dropna=True) level ：一个整数、字符串或者整数字符串的列表。如果列索引为多级索引，它指定了将哪个级别的索引旋转为行索引 dropna ：一个布尔值。如果为 True ，则如果结果中某行全为 NaN ，则抛弃该行 旋转时，列索引旋转为行索引，新的行索引是多级索引，最内层的行索引就是原来的列索引。 最清晰的解释方式是通过示例。先创建一个示例数据： tuples = list ( zip ( * [[ 'bar' , 'bar' , 'baz' , 'baz' , 'foo' , 'foo' , 'qux' , 'qux' ], [ 'one' , 'two' , 'one' , 'two' , 'one' , 'two' , 'one' , 'two' ]])) index = pd . MultiIndex . from_tuples ( tuples , names = [ 'first' , 'second' ]) df = pd . DataFrame ( np . random . randn ( 8 , 2 ), index = index , columns = [ 'A' , 'B' ]) df2 = df [: 4 ] df2 A B first second bar one -0.057986 0.355058 two 0.575360 1.254999 baz one 0.105935 -0.669381 two -0.273632 2.168700 stacked = df2 . stack () stacked first second bar one A -0.057986 B 0.355058 two A 0.575360 B 1.254999 baz one A 0.105935 B -0.669381 two A -0.273632 B 2.168700 dtype: float64","text_tokens":["list","dataframe","它","如果","结果","多级","0.057986","最","时","first","2","'","df2","two","通过","true","*","字符","抛弃","level","原来","second","布尔值","nan","stack","_","0.273632","解释","tuples","8","中","2.168700","dtype","示例","哪个","是","、","0.575360","全为","b","会","stacked","方法","不同","方式","转置","[","级别","为","，","0.669381","randn","清晰","random","0.355058","]","列","index","qux","4","=","foo","-",":","：","names","新","multiindex","1.254999",")","内层","就是","。","创建","整数","pd","的","one","列表","行",".","了","该行"," ","一个","1","字符串","0.105935","先","索引","数据","将","dropna","np","同时","指定","旋转",",","则","为行","跟","注意","某行","columns","或者","df","float64","bar","zip","布尔","(","a","from","baz"],"title":"stack","title_tokens":["stack"]},{"location":"pandas笔记/7.7.变换索引.html#unstack","text":"与 DataFrame.stack() 对应的就是 DataFrame.unstack() 方法。 它将数据的行索引转换为列索引。 注意：它跟转置不同，转置会同时旋转数据。 DataFrame.unstack(level=-1, fill_value=None) level ：一个整数、字符串或者整数字符串的列表。如果行索引为多级索引，它指定了将哪个级别的索引旋转为列索引 fill_value ：一个标量。如果结果中有 NaN ，则使用 fill_value 替换。 unstack 默认情况下将最后一级行索引转换成列索引： print ( stacked ) first second bar one A -0.057986 B 0.355058 two A 0.575360 B 1.254999 baz one A 0.105935 B -0.669381 two A -0.273632 B 2.168700 dtype: float64 stacked . unstack () A B first second bar one -0.057986 0.355058 two 0.575360 1.254999 baz one 0.105935 -0.669381 two -0.273632 2.168700 stacked . unstack ( 1 ) second one two first bar A -0.057986 0.575360 B 0.355058 1.254999 baz A 0.105935 -0.273632 B -0.669381 2.168700 stacked . unstack ( 0 ) first bar baz second one A -0.057986 0.105935 B 0.355058 -0.669381 two A 0.575360 -0.273632 B 1.254999 2.168700 如果索引具有名称，则可以使用级别名称而不是指定级别编号： stacked . unstack ( 'second' ) second one two first bar A -0.057986 0.575360 B 0.355058 1.254999 baz A 0.105935 -0.273632 B -0.669381 2.168700 注意， stack 和 unstack 方法会隐式地对索引进行排序： index = pd . MultiIndex . from_product ([[ 2 , 1 ], [ 'a' , 'b' ]]) df = pd . DataFrame ( np . random . randn ( 4 ), index = index , columns = [ 'A' ]) print ( df , \" \\n \" ) print ( df . unstack () . stack ()) all ( df . unstack () . stack () == df . sort_index ()) A 2 a - 0 . 775482 b - 0 . 358023 1 a 0 . 150078 b - 1 . 990797 A 1 a 0 . 150078 b - 1 . 990797 2 a - 0 . 775482 b - 0 . 358023 True","text_tokens":["名称","dataframe","它","如果","隐式","结果","value","多级","0.057986","first","2","'","two","\\","默认","true","字符","second","level","nan","stack","_","转换成","0.273632","和","不是","2.168700","可以","转换","对应","dtype","哪个","、","0.575360","unstack","b","会","stacked","而","方法","不同","转置","775482","[","358023","级别","为","，","0.669381","randn","进行","random","0.355058","与","product","]","列","替换","对","fill","标量","index","print","排序","中有","为列","一级","4","=","-",":","：","情况","1.254999","multiindex","n",")","就是","。","990797","sort","整数","pd","的","one","列表","行","最后",".","了","编号"," ","一个","1","字符串","0.105935","none","索引","数据","\"","将","np","0","换成","all","同时","指定","旋转",",","则","跟","使用","注意","columns","或者","df","下","float64","bar","(","a","地","150078","from","baz","具有"],"title":"unstack","title_tokens":["unstack"]},{"location":"pandas笔记/7.7.变换索引.html#_2","text":"还可以通过传递一个索引名字列表来一次堆栈或取消堆栈多个级别的索引，在这种情况下，最终结果就好像列表中的每个级别的索引都是单独处理的： columns = pd . MultiIndex . from_tuples ([ ( 'A' , 'cat' , 'long' ), ( 'B' , 'cat' , 'long' ), ( 'A' , 'dog' , 'short' ), ( 'B' , 'dog' , 'short' )], names = [ 'exp' , 'animal' , 'hair_length' ]) df = pd . DataFrame ( np . random . randn ( 4 , 4 ), columns = columns ) print ( df ) df . stack ( level = [ 'animal' , 'hair_length' ]) exp A B A B animal cat cat dog dog hair_length long long short short 0 -0.590259 0.643611 -0.253519 -0.723468 1 0.316200 1.340781 1.300858 0.531254 2 -0.666685 1.021562 0.119488 1.266647 3 0.161535 -1.919107 -1.652191 -0.134814 exp A B animal hair_length 0 cat long -0.590259 0.643611 dog short -0.253519 -0.723468 1 cat long 0.316200 1.340781 dog short 1.300858 0.531254 2 cat long -0.666685 1.021562 dog short 0.119488 1.266647 3 cat long 0.161535 -1.919107 dog short -1.652191 -0.134814 索引列表可以包含索引名称或索引级别的编号（但不能同时包含两者）： # df.stack(level=['animal', 'hair_length']) # from above is equivalent to: df . stack ( level = [ 1 , 2 ]) exp A B animal hair_length 0 cat long -0.590259 0.643611 dog short -0.253519 -0.723468 1 cat long 0.316200 1.340781 dog short 1.300858 0.531254 2 cat long -0.666685 1.021562 dog short 0.119488 1.266647 3 cat long 0.161535 -1.919107 dog short -1.652191 -0.134814","text_tokens":["0.531254","名称","dataframe","0.723468","结果","不能","long","2","'","名字","还","通过","传递","level","#","stack","1.266647","_","每个","单独","tuples","）","两者","中","可以","cat","是","0.134814","b","在","0.316200","[","1.300858","级别","但","short","，","randn","1.652191","3","equivalent","random","0.666685","]","print","都","这种","来","4","=","1.021562","1.340781","-",":","：","情况","names","is","multiindex","length",")","0.253519","above","to","hair","0.590259","0.119488","pd","的","animal","1.919107","列表","就","0.161535",".","编号"," ","一个","0.643611","1","一次","处理","索引","多个","最终","np","0","同时",",","或","exp","包含","columns","dog","df","堆栈","下","(","a","取消","（","from","好像"],"title":"多级别索引","title_tokens":["索引","级别","多"]},{"location":"pandas笔记/7.7.变换索引.html#_3","text":"这些函数对于处理丢失的数据非常智能，并且不希望层次索引中的每个子组都具有相同的标签集。它们还可以处理未排序的索引（当然，您可以通过调用sort_index对其进行排序）。下面是一个更复杂的例子： columns = pd . MultiIndex . from_tuples ([( 'A' , 'cat' ), ( 'B' , 'dog' ), ( 'B' , 'cat' ), ( 'A' , 'dog' )], names = [ 'exp' , 'animal' ]) index = pd . MultiIndex . from_product ([( 'bar' , 'baz' , 'foo' , 'qux' ), ( 'one' , 'two' )], names = [ 'first' , 'second' ]) df = pd . DataFrame ( np . random . randn ( 8 , 4 ), index = index , columns = columns ) df2 = df . iloc [[ 0 , 1 , 2 , 4 , 5 , 7 ]] print ( df2 ) exp A B A animal cat dog cat dog first second bar one -0.170026 -0.849601 -0.731394 0.221731 two 1.343975 2.249542 0.092470 0.565612 baz one -0.783770 0.689877 0.406778 -1.099836 foo one 1.291947 -1.701371 0.101385 0.200045 two 3.026423 -0.763562 -0.189664 0.091951 qux two -0.621108 -1.022019 -1.033913 0.404069 如上所述， stack 可以使用 level 参数来调用以选择要堆叠的列中的级别： df2 . stack ( 'exp' ) animal cat dog first second exp bar one A -0.170026 0.221731 B -0.731394 -0.849601 two A 1.343975 0.565612 B 0.092470 2.249542 baz one A -0.783770 -1.099836 B 0.406778 0.689877 foo one A 1.291947 0.200045 B 0.101385 -1.701371 two A 3.026423 0.091951 B -0.189664 -0.763562 qux two A -0.621108 0.404069 B -1.033913 -1.022019 df2 . stack ( 'animal' ) exp A B first second animal bar one cat -0.170026 -0.731394 dog 0.221731 -0.849601 two cat 1.343975 0.092470 dog 0.565612 2.249542 baz one cat -0.783770 0.406778 dog -1.099836 0.689877 foo one cat 1.291947 0.101385 dog 0.200045 -1.701371 two cat 3.026423 -0.189664 dog 0.091951 -0.763562 qux two cat -0.621108 -1.033913 dog 0.404069 -1.022019 如果子组没有相同的标签集，则取消堆叠可能会导致缺少值。默认情况下，缺少的值将替换为该数据类型的默认填充值，NaN表示浮点，NaT表示datetimelike，等等。对于整数类型，默认情况下，数据将转换为浮点，缺少的值将设置为NaN： df3 = df . iloc [[ 0 , 1 , 4 , 7 ], [ 1 , 2 ]] print ( df3 ) df3 . unstack () exp B animal dog cat first second bar one -0.849601 -0.731394 two 2.249542 0.092470 foo one -1.701371 0.101385 qux two -1.022019 -1.033913 exp B animal dog cat second one two one two first bar -0.849601 2.249542 -0.731394 0.092470 foo -1.701371 NaN 0.101385 NaN qux NaN -1.022019 NaN -1.033913 或者设置 fill_value 参数，用于指定缺失数据的值。 df3 . unstack ( fill_value =- 1e9 ) exp B animal dog cat second one two one two first bar -8.496012e-01 2.249542e+00 -7.313939e-01 9.246967e-02 foo -1.701371e+00 -1.000000e+09 1.013849e-01 -1.000000e+09 qux -1.000000e+09 -1.022019e+00 -1.000000e+09 -1.033913e+00","text_tokens":["例子","dataframe","浮点","参数","如果","value","层次","first","2","'","df2","该","0.763562","还","two","类型","子组","0.731394","不","默认","通过","0.200045","1.701371","second","level","调用","它们","缺失","未","7.313939","智能","数据类型","等等","列中","nan","stack","_","7","每个","对于","tuples","）","8","3.026423","中","1e9","导致","可以","0.406778","0.101385","转换","用于","函数","cat","是","datetimelike","unstack","b","0.170026","会","1.099836","非常","更","填充","[","0.221731","要","级别","值","0.621108","为","1.013849","00","，","02","1.033913","1.291947","randn","表示","进行","0.565612","random","0.783770","选择","product","]","e","index","对","替换","0.189664","堆叠","fill","print","没有","标签","排序","都","8.496012","9.246967","qux","相同","来","4","=","foo","0.849601","-","复杂","：","names","情况","df3","multiindex",")","1.343975","希望","。","当然","0.092470","并且","您","sort","整数","pd","的","其","animal","2.249542","one","0.689877","."," ","标签集","一个","1.022019","如上所述","+","1","iloc","缺少","01","设置","1.000000","处理","下面","索引","数据","所述","09","这些","将","丢失","np","0","指定",",","使用","则","5","exp","如上","columns","dog","nat","以","可能","或者","df","下","bar","0.091951","(","（","a","取消","from","0.404069","baz","具有"],"title":"缺失数据","title_tokens":["数据","缺失"]},{"location":"pandas笔记/7.7.变换索引.html#_4","text":"当列是多索引时，取消堆栈也会小心地执行正确的操作： df [: 3 ] . unstack ( 0 ) exp A B A animal cat dog cat dog first bar baz bar baz bar baz bar baz second one -0.170026 -0.78377 -0.849601 0.689877 -0.731394 0.406778 0.221731 -1.099836 two 1.343975 NaN 2.249542 NaN 0.092470 NaN 0.565612 NaN df2 . unstack ( 1 ) exp A B A animal cat dog cat dog second one two one two one two one two first bar -0.170026 1.343975 -0.849601 2.249542 -0.731394 0.092470 0.221731 0.565612 baz -0.783770 NaN 0.689877 NaN 0.406778 NaN -1.099836 NaN foo 1.291947 3.026423 -1.701371 -0.763562 0.101385 -0.189664 0.200045 0.091951 qux NaN -0.621108 NaN -1.022019 NaN -1.033913 NaN 0.404069","text_tokens":[".","3.026423","0.783770","当列","也"," ","]","0.406778","0.101385","0.189664","1.022019","正确","cat","操作","1","是","qux","0.689877","时","小心","first","unstack","b","0.170026","df2","会","0.763562","1.099836","two","索引","foo","0.849601",":","-","：","0.731394","0","0.200045","1.701371","second",")","1.343975","多","exp","执行","0.78377","dog","[","df","堆栈","bar","0.221731","nan","0.092470","0.091951","(","0.621108","地","取消","的","a","animal","，","2.249542","0.404069","one","baz","1.033913","1.291947","3","0.565612"],"title":"多级索引","title_tokens":["多级","索引"]},{"location":"pandas笔记/7.7.变换索引.html#melt","text":"阿斯蒂芬 cheese = pd . DataFrame ({ 'first' : [ 'John' , 'Mary' ], 'last' : [ 'Doe' , 'Bo' ], 'height' : [ 5.5 , 6.0 ], 'weight' : [ 130 , 150 ]}) print ( cheese ) first last height weight 0 John Doe 5.5 130 1 Mary Bo 6.0 150 cheese . melt ( id_vars = [ 'first' , 'last' ]) first last variable value 0 John Doe height 5.5 1 Mary Bo height 6.0 2 John Doe weight 130.0 3 Mary Bo weight 150.0 cheese . melt ( id_vars = [ 'first' , 'last' ], var_name = 'quantity' ) first last quantity value 0 John Doe height 5.5 1 Mary Bo height 6.0 2 John Doe weight 130.0 3 Mary Bo weight 150.0 另一种转换方法是使用 wide_to_long() 面板数据便利功能。它不如灵活 melt() ，但更易于使用。 dft = pd . DataFrame ({ \"A1970\" : { 0 : \"a\" , 1 : \"b\" , 2 : \"c\" }, \"A1980\" : { 0 : \"d\" , 1 : \"e\" , 2 : \"f\" }, \"B1970\" : { 0 : 2.5 , 1 : 1.2 , 2 : . 7 }, \"B1980\" : { 0 : 3.2 , 1 : 1.3 , 2 : . 1 }, \"X\" : dict ( zip ( range ( 3 ), np . random . randn ( 3 )))}) dft [ \"id\" ] = dft . index print ( dft ) pd . wide_to_long ( dft , [ \"A\" , \"B\" ], i = \"id\" , j = \"year\" ) A1970 A1980 B1970 B1980 X id 0 a d 2.5 3.2 -0.468296 0 1 b e 1.2 1.3 0.739891 1 2 c f 0.7 0.1 0.146285 2 X A B id year 0 1970 -0.468296 a 2.5 1 1970 0.739891 b 1.2 2 1970 0.146285 c 0.7 0 1980 -0.468296 d 3.2 1 1980 0.739891 e 1.3 2 1980 0.146285 f 0.1","text_tokens":["dataframe","不如","cheese","它","value","long","last","1.3","130","first","2","'","}","dict","d","2.5","a1980","dft","quantity","b1980","_","7","mary","variable","id","1970","转换","{","3.2","是","一种","5.5","b","john","130.0","range","方法","year","b1970","doe","更","灵活","[","但","，","斯蒂芬","randn","3","random","name","]","e","便利","i","转换方法","index","print","6.0","1.2","c","另","melt","=","功能",":","-","0.146285","f",")","。","to","1980","a1970","pd","150","x","."," ","0.739891","1","weight","vars","数据","\"","150.0","0.7","面板","np","0","阿",",","使用","height","易于","0.468296","j","zip","0.1","(","a","wide","var","bo"],"title":"通过Melt重塑","title_tokens":["重塑","melt","通过"]},{"location":"开发环境管理/5.1.conda笔记.html","text":"conda usage : conda - script . py [ - h ] [ - V ] command ... conda is a tool for managing and deploying applications , environments and packages . Options : positional arguments : command clean 删除未使用的包和缓存 。 config 修改 . condarc中的配置值 。 create Create a new conda environment from a list of specified packages . help Displays a list of available conda commands and their help strings . info 显示有关当前安装的conda的信息 。 init Initialize conda for shell interaction . [ Experimental ] install 把一个列表中包含的包安装到指定的conda环境 。 list 列出链接到某个conda环境的所有包名 。 remove 从指定的conda环境移除列表中包含的包 。 uninstall conda remove的别名 。 run 在 conda 环境中运行可执行文件 。 [ 实验 ] search Search for packages and display associated information . The input is a MatchSpec , a query language for conda packages . See examples below . update 将 conda 包更新为最新的兼容版本 。 upgrade conda update的别名 optional arguments : - h , -- help Show this help message and exit . - V , -- version Show the conda version number and exit . conda命令 conda info 该命令可以查看当前安装的 conda 的详细信息，包括 conda 版本、python 版本、软件包仓库地址、新建环境的存放路径等。 usage: conda-script.py info [ -h ] [ --json ] [ -v ] [ -q ] [ -a ] [ --base ] [ -e ] [ -s ] [ --unsafe-channels ] Display information about current conda install. Options: optional arguments: -h, --help Show this help message and exit. -a, --all 显示所有信息。 --base 基本显示 base 环境路径。 -e, --envs 列出所有已知的Conda环境。 -s, --system 列出环境变量。 --unsafe-channels Display list of channels with tokens exposed. Output, Prompt, and Flow Control Options: --json Report all output as json. Suitable for using conda programmatically. -v, --verbose Use once for info, twice for debug, three times for trace. -q, --quiet Do not display progress bar. conda create usage: conda-script.py create [ -h ] [ --clone ENV ] [ -n ENVIRONMENT | -p PATH ] [ -c CHANNEL ] [ --use-local ] [ --override-channels ] [ --repodata-fn REPODATA_FNS ] [ --strict-channel-priority ] [ --no-channel-priority ] [ --no-deps | --only-deps ] [ --no-pin ] [ --copy ] [ --no-shortcuts ] [ -C ] [ -k ] [ --offline ] [ -d ] [ --json ] [ -q ] [ -v ] [ -y ] [ --download-only ] [ --show-channel-urls ] [ --file FILE ] [ --no-default-packages ] [ --dev ] [ package_spec [ package_spec ... ]] Create a new conda environment from a list of specified packages. To use the created environment, use 'source activate envname' look in that directory first. This command requires either the -n NAME or -p PREFIX option. Options: positional arguments: package_spec Packages to install or update in the conda environment. optional arguments: -h, --help Show this help message and exit. --clone ENV 通过克隆其他环境来创建一个新环境， 'ENV' 可以是现有本地环境的路径（或名 称）。 --file FILE 从文件创建环境 ( 从给定的文件读入指定版本的包 ) 。可以传递重复的文件规范（例 如--file = file1 --file = file2）。 --dev Use ` sys.executable -m conda ` in wrapper scripts instead of CONDA_EXE This is mainly for use during tests where we test new conda source against old Python versions. Target Environment Specification: -n ENVIRONMENT, --name ENVIRONMENT Name of environment. -p PATH, --prefix PATH Full path to environment location ( i.e. prefix ) . Channel Customization: -c CHANNEL, --channel CHANNEL 用于搜索包的其他通道。这些 URL 按给定顺序搜索 ( 包括本地目录file:// ) 。然 后,搜索 .condarc 中的默认值或通道 ( 除非提供 --override-channels ) 。 您可以使用 \"defaults\" 获取 conda 的默认包。您还可以使用任何名称, .condarc的channel_alias值将预置。默认的channel_alias是 http://conda.anaconda.org/。 --use-local 使用本地构建的包。等同于 \"-c local\" 。 --override-channels 不在 default 或者 .condarc channels 中搜索. Requires --channel. --repodata-fn REPODATA_FNS Specify name of repodata on remote server. Conda will try whatever you specify, but will ultimately fall back to repodata.json if your specs are not satisfiable with what you specify here. This is used to employ repodata that is reduced in time scope. You may pass this flagmore than once. Leftmost entries are tried first, and the fallback torepodata.json is added for you automatically. Solver Mode Modifiers: --strict-channel-priority Packages in lower priority channels are not considered if a package with the same name appears in a higher priority channel. --no-channel-priority Package version takes precedence over channel priority. Overrides the value given by ` conda config --show channel_priority ` . --no-deps Do not install, update, remove, or change dependencies. This WILL lead to broken environments and inconsistent behavior. Use at your own risk. --only-deps Only install dependencies. --no-pin Ignore pinned file. --no-default-packages Ignore create_default_packages in the .condarc file. Package Linking and Install-time Options: --copy Install all packages using copies instead of hard- or soft-linking. --no-shortcuts Don 't install start menu shortcuts Networking Options: -C, --use-index-cache Use cache of channel index files, even if it has expired. -k, --insecure Allow conda to perform \"insecure\" SSL connections and transfers. Equivalent to setting ' ssl_verify ' to ' false '. --offline Offline mode. Don' t connect to the Internet. Output, Prompt, and Flow Control Options: -d, --dry-run Only display what would have been done . --json Report all output as json. Suitable for using conda programmatically. -q, --quiet Do not display progress bar. -v, --verbose Can be used multiple times. Once for INFO, twice for DEBUG, three times for TRACE. -y, --yes Do not ask for confirmation. --download-only Solve an environment and ensure package caches are populated, but exit prior to unlinking and linking packages into the prefix. --show-channel-urls Show channel urls. Overrides the value given by ` conda config --show show_channel_urls ` . conda常用命令 查看信息 # 查看conda的信息 ## 该命令可以查看当前安装的 conda 的详细信息，包括 conda 版本、python 版本、软件包仓库地址、新建环境的存放路径等。 conda info # 查看conda版本信息 conda -V conda --version 环境管理 # 查看环境信息 ## 查看系统中安装的所有环境： ### 这两个命令都可以查看当前 conda 中已经创建的环境列表，处于激活状态的环境旁边会有一个*的字样。 conda env list conda info –-envs conda info -e ## 查看 Conda 环境系统信息： conda info –-system conda info –s ## 查看环境系统更加详细的信息： conda info –-all conda info –a # 进入指定环境 conda activate <env> # 推出环境 conda deactivate # 导出环境 ## 导出环境之前首先要进入该环境 conda list -e > package-list.txt conda list -e > package-list.yml ## 或者这样 ### 这会将当前环境中由 conda 管理的包和由 pip 安装的包同时导出到文件中，所以当根据文件创建环境时，无需重新安装 pip 的包。 conda env export –-name base –-file base_bunnies.yml # 创建环境 ## 新建一个名为 newenv 的环境，并指定新环境中的 python 版本为 3.6 创建出来的环境中只带有最基本的包 conda create --name newenv python = 3 .6 ## 也可以在创建环境时候，包含某些程序或者包 conda create --name newenv python = 3 .6 biopython ipython ## 通过克隆创建一个新环境 conda create –-name newenv –clone base ## 从文件创建环境 ### 如果是用 conda env export --name 导出的文件，则可用下列命令创建： conda env create -f package-list.yml ### 如果是用 conda list -e 导出的文件，则用如下方式创建： conda create –-name <env> –-file <deps file> # 更新环境 conda env update –-name <env> –file = <deps file> # 删除环境 ## 删除环境中指定的包： conda remove –-name <env> ipython biopython ## 彻底删除环境： conda env remove –name <env> 从指定路径安装环境 conda 创建出来的环境默认放在 /User/<yourname>/anaconda/env 目录下，你可以将其中的某个环境文件夹整体拷贝走，复制到另一台机器上，然后基于此文件夹创建环境。 包管理 conda list # 查看已经安装的包 conda update conda # 升级conda自身 conda search requests # 查询某个包 conda install requests # 安装新包 conda install -n base requests # 将包安装到指定环境 conda update --all # 更新所有包 conda update requests # 升级包 conda remove requests # 移除包 conda remove -n base requests # 从指定环境中移除包 conda 不提供检查可更新的包的命令，update 所有包时会有提示，列出所有可更新的包，并让用户确认是否全部更新。 为 anaconda 指定国内镜像源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes 使用 conda config --show channels 命令可以查看当前的源仓库地址。","text_tokens":["prompt","control","最","别名","'","该","displays","target","set","不","默认","search","*","链接","three","change","copy","旁边","...","信息","url","修改","environment","in","管理","这","下列","copies","upgrade","new","directory","package","against","同于","是","当","offline","某个","be","列出","not","拷贝","程序","方式","defaults","这样","给定","language","读入","update","并","一台","查看","applications","python","复制","查询","3","规范","remote","ignore","where","hard","and","等","包括","来","现有","appears","conda","走","prefix","about","show","is","you","satisfiable","n",")","克隆","整体","。","txt","twice","edu","to","pkgs","tried","基本","tuna","进入","m","的","列表","has","版本","件夹","script"," ","help","h","<","start","升级包","specs","than","导出","command","perform","specification","progress","strict","将","all","file1","broken","源","would","使用","则","或","but","path","confirmation","构建","test","time","a","时会","yes","环境变","国内","yourname","at","requires","exe","inconsistent","alias","tsinghua","value","options","缓存","versions","由","current","还","exposed","verify","重新","获取","menu","传递","location","try","另一台","未","config","已知","目录","重复","tests","删除","_","和","推出","包名","condarc","shortcuts","提供","系统","we","状态","override","中","tokens","report","repodata","配置","当前","fn","remove","suitable","modifiers","v","overrides","init","有关","false","an","lead","其中","只","可执行文件","channel","deps","某些","首先","arguments","don","机器","reduced","##","###","，","what","activate","可用","字样","实验","更加","]","e","文件创建","index","lower","pinned","yml","local","connect","环境变量","都","c","only","顺序","=","or","文件夹","allow","debug","priority","时候","dependencies","之前","如","您","cn","预置","复制到","dry","solver","anaconda","of","linking","详细信息","用","按","the","quiet","that","运行","solve","deploying","有","times","clean","ensure","usage","newenv","包含","unsafe","mirrors","常用","默认值","transfers","两个","(","http","default","仓库","packages","associated","output","名称","s","到","如果","mode","instead","risk","positional","flow","等同","时","verbose","常用命令","tool","json","兼容","cache","软件包","no","scope","通过","flagmore","use","等同于","environments","安装","路径","channels","unlinking","这会","然","此","scripts","ipython","may","地址","examples","软件","变量","可以","information","input","server","create","搜索","exit","ask","3.6","during","会","run","your","can","their","soft","你","see","全部","k","back","either","然后","added","[","info","本地","|","t","要","值","命令","version","files","为","提示","存放","populated","message","strings","name","are","任何","here","it","own","multiple","given","trace",":","torepodata","是否","无需","mainly","connections","f","env","matchspec","pip","激活状态","entries","main","higher","显示","创建","base","been","称","system","expired",".","新包","commands","可","user","一个","激活","experimental","envname","fns","其他","放在","自身","\"","这些","if","所有","指定","even","彻底","insecure","6","p","bar","文件","（","顺序搜索","--","pass","list","for","option","环境","install","executable","number","clone","或名","后","full","first","export","处于","once","deactivate","d","query","根据","same","org","ssl","considered","–","networking","#","bunnies","below","sys","on","把","升级","移除","新建","used","prior","pin","）","shell",">","employ","用于","用户","、","行文","让","managing","/","add","在","caches","available","over","download","file2","programmatically","确认","上","with","have","urls","equivalent","interaction","source","free","spec","i","也","display","initialize","除非","behavior","更新","y","setting","biopython","-","automatically","precedence","：","新","检查","uninstall","do","will","所以","takes","using","requests","old","customization","详细","created","wrapper","版本信息","带有","q","dev","whatever","如下","基于","出来","by","环境中运行","specified","通道","重新安装","`","已经","into","py","done","optional","ultimately","specify","envs","新安","同时",",","file","fallback","镜像","https","执行","leftmost","从","look","或者","下","包","this","internet","fall","名为","最新","from","例","as"],"title":"5.1.conda笔记","title_tokens":["5.1",".","笔记","conda"]},{"location":"开发环境管理/5.1.conda笔记.html#conda","text":"usage : conda - script . py [ - h ] [ - V ] command ... conda is a tool for managing and deploying applications , environments and packages . Options : positional arguments : command clean 删除未使用的包和缓存 。 config 修改 . condarc中的配置值 。 create Create a new conda environment from a list of specified packages . help Displays a list of available conda commands and their help strings . info 显示有关当前安装的conda的信息 。 init Initialize conda for shell interaction . [ Experimental ] install 把一个列表中包含的包安装到指定的conda环境 。 list 列出链接到某个conda环境的所有包名 。 remove 从指定的conda环境移除列表中包含的包 。 uninstall conda remove的别名 。 run 在 conda 环境中运行可执行文件 。 [ 实验 ] search Search for packages and display associated information . The input is a MatchSpec , a query language for conda packages . See examples below . update 将 conda 包更新为最新的兼容版本 。 upgrade conda update的别名 optional arguments : - h , -- help Show this help message and exit . - V , -- version Show the conda version number and exit .","text_tokens":["list","for","环境","到","install","number","options","positional","别名","缓存","tool","displays","兼容","query","search","链接","未","config","environments","安装","below","把","删除","...","和","信息","修改","environment","包名","condarc","移除","upgrade","examples","中","shell","new","information","input","配置","当前","create","remove","行文","exit","v","managing","init","run","有关","their","某个","在","see","列出","available","可执行文件","arguments","[","info","language","值","update","version","为","applications","interaction","message","strings","实验","]","display","initialize","更新","and","conda","-",":","show","is","uninstall","matchspec","。","显示","的","列表","版本",".","commands","script","of"," ","一个","help","h","环境中运行","specified","the","experimental","py","command","optional","运行","deploying","将","所有","指定",",","clean","使用","usage","执行","包含","从","包","this","a","文件","最新","from","packages","associated","--"],"title":"conda","title_tokens":["conda"]},{"location":"开发环境管理/5.1.conda笔记.html#conda_1","text":"","text_tokens":[],"title":"conda命令","title_tokens":["命令","conda"]},{"location":"开发环境管理/5.1.conda笔记.html#conda-info","text":"该命令可以查看当前安装的 conda 的详细信息，包括 conda 版本、python 版本、软件包仓库地址、新建环境的存放路径等。 usage: conda-script.py info [ -h ] [ --json ] [ -v ] [ -q ] [ -a ] [ --base ] [ -e ] [ -s ] [ --unsafe-channels ] Display information about current conda install. Options: optional arguments: -h, --help Show this help message and exit. -a, --all 显示所有信息。 --base 基本显示 base 环境路径。 -e, --envs 列出所有已知的Conda环境。 -s, --system 列出环境变量。 --unsafe-channels Display list of channels with tokens exposed. Output, Prompt, and Flow Control Options: --json Report all output as json. Suitable for using conda programmatically. -v, --verbose Use once for info, twice for debug, three times for trace. -q, --quiet Do not display progress bar.","text_tokens":["output","list","for","s","环境","install","prompt","options","control","flow","该","once","current","verbose","json","exposed","软件包","three","use","已知","安装","路径","channels","信息","新建","地址","软件","tokens","变量","可以","information","report","当前","、","suitable","exit","v","列出","not","programmatically","arguments","info","[","with","命令","查看","python","，","存放","message","]","e","display","环境变量","and","等","包括","trace","conda",":","-","about","show","debug","do","。","twice","using","基本","显示","base","详细","的","system","版本","q",".","script","of","详细信息"," ","help","h","quiet","py","optional","progress","envs","所有","all","times",",","usage","unsafe","this","bar","a","仓库","环境变","as","--"],"title":"conda info","title_tokens":[" ","conda","info"]},{"location":"开发环境管理/5.1.conda笔记.html#conda-create","text":"usage: conda-script.py create [ -h ] [ --clone ENV ] [ -n ENVIRONMENT | -p PATH ] [ -c CHANNEL ] [ --use-local ] [ --override-channels ] [ --repodata-fn REPODATA_FNS ] [ --strict-channel-priority ] [ --no-channel-priority ] [ --no-deps | --only-deps ] [ --no-pin ] [ --copy ] [ --no-shortcuts ] [ -C ] [ -k ] [ --offline ] [ -d ] [ --json ] [ -q ] [ -v ] [ -y ] [ --download-only ] [ --show-channel-urls ] [ --file FILE ] [ --no-default-packages ] [ --dev ] [ package_spec [ package_spec ... ]] Create a new conda environment from a list of specified packages. To use the created environment, use 'source activate envname' look in that directory first. This command requires either the -n NAME or -p PREFIX option. Options: positional arguments: package_spec Packages to install or update in the conda environment. optional arguments: -h, --help Show this help message and exit. --clone ENV 通过克隆其他环境来创建一个新环境， 'ENV' 可以是现有本地环境的路径（或名 称）。 --file FILE 从文件创建环境 ( 从给定的文件读入指定版本的包 ) 。可以传递重复的文件规范（例 如--file = file1 --file = file2）。 --dev Use ` sys.executable -m conda ` in wrapper scripts instead of CONDA_EXE This is mainly for use during tests where we test new conda source against old Python versions. Target Environment Specification: -n ENVIRONMENT, --name ENVIRONMENT Name of environment. -p PATH, --prefix PATH Full path to environment location ( i.e. prefix ) . Channel Customization: -c CHANNEL, --channel CHANNEL 用于搜索包的其他通道。这些 URL 按给定顺序搜索 ( 包括本地目录file:// ) 。然 后,搜索 .condarc 中的默认值或通道 ( 除非提供 --override-channels ) 。 您可以使用 \"defaults\" 获取 conda 的默认包。您还可以使用任何名称, .condarc的channel_alias值将预置。默认的channel_alias是 http://conda.anaconda.org/。 --use-local 使用本地构建的包。等同于 \"-c local\" 。 --override-channels 不在 default 或者 .condarc channels 中搜索. Requires --channel. --repodata-fn REPODATA_FNS Specify name of repodata on remote server. Conda will try whatever you specify, but will ultimately fall back to repodata.json if your specs are not satisfiable with what you specify here. This is used to employ repodata that is reduced in time scope. You may pass this flagmore than once. Leftmost entries are tried first, and the fallback torepodata.json is added for you automatically. Solver Mode Modifiers: --strict-channel-priority Packages in lower priority channels are not considered if a package with the same name appears in a higher priority channel. --no-channel-priority Package version takes precedence over channel priority. Overrides the value given by ` conda config --show channel_priority ` . --no-deps Do not install, update, remove, or change dependencies. This WILL lead to broken environments and inconsistent behavior. Use at your own risk. --only-deps Only install dependencies. --no-pin Ignore pinned file. --no-default-packages Ignore create_default_packages in the .condarc file. Package Linking and Install-time Options: --copy Install all packages using copies instead of hard- or soft-linking. --no-shortcuts Don 't install start menu shortcuts Networking Options: -C, --use-index-cache Use cache of channel index files, even if it has expired. -k, --insecure Allow conda to perform \"insecure\" SSL connections and transfers. Equivalent to setting ' ssl_verify ' to ' false '. --offline Offline mode. Don' t connect to the Internet. Output, Prompt, and Flow Control Options: -d, --dry-run Only display what would have been done . --json Report all output as json. Suitable for using conda programmatically. -q, --quiet Do not display progress bar. -v, --verbose Can be used multiple times. Once for INFO, twice for DEBUG, three times for TRACE. -y, --yes Do not ask for confirmation. --download-only Solve an environment and ensure package caches are populated, but exit prior to unlinking and linking packages into the prefix. --show-channel-urls Show channel urls. Overrides the value given by ` conda config --show show_channel_urls ` .","text_tokens":["prompt","control","'","target","不","默认","three","change","copy","...","url","environment","in","copies","new","directory","package","against","同于","是","offline","be","not","defaults","给定","读入","update","python","规范","remote","ignore","where","hard","and","包括","来","现有","appears","conda","prefix","show","is","you","satisfiable","n",")","克隆","。","twice","to","tried","m","的","has","版本","script"," ","help","h","start","specs","than","command","perform","specification","progress","strict","将","all","file1","broken","would","使用","或","but","path","confirmation","构建","test","time","a","yes","at","requires","exe","inconsistent","alias","value","options","versions","还","verify","获取","menu","传递","location","try","config","目录","重复","tests","_","shortcuts","condarc","提供","we","override","中","repodata","report","fn","remove","suitable","modifiers","v","overrides","false","an","lead","channel","deps","arguments","don","reduced","，","what","activate","]","e","文件创建","index","lower","pinned","local","connect","c","only","顺序","=","or","allow","debug","priority","dependencies","如","您","预置","dry","solver","anaconda","of","linking","按","the","quiet","that","solve","times","ensure","usage","默认值","transfers","(","http","default","packages","output","名称","mode","instead","risk","positional","flow","等同","verbose","json","cache","no","scope","通过","flagmore","use","等同于","environments","路径","channels","unlinking","然","scripts","may","可以","server","create","搜索","exit","ask","during","your","run","can","soft","k","back","either","added","[","info","本地","|","t","值","version","files","populated","message","name","are","任何","here","it","own","multiple","given","trace",":","torepodata","mainly","connections","env","entries","higher","创建","been","称","expired",".","一个","envname","fns","其他","\"","这些","if","指定","even","insecure","p","bar","（","文件","顺序搜索","--","pass","list","for","option","环境","install","executable","clone","或名","后","full","first","once","d","same","org","ssl","considered","networking","sys","on","used","prior","pin","）","employ","用于","/","在","caches","over","download","file2","programmatically","with","have","urls","equivalent","source","spec","i","display","除非","behavior","y","setting","-","automatically","precedence","新","will","do","takes","using","old","customization","created","wrapper","q","dev","whatever","by","specified","通道","`","into","py","done","optional","ultimately","specify","file",",","fallback","leftmost","从","look","或者","包","this","internet","fall","from","例","as"],"title":"conda create","title_tokens":["create"," ","conda"]},{"location":"开发环境管理/5.1.conda笔记.html#conda_2","text":"","text_tokens":[],"title":"conda常用命令","title_tokens":["命令","常用命令","常用","conda"]},{"location":"开发环境管理/5.1.conda笔记.html#_1","text":"# 查看conda的信息 ## 该命令可以查看当前安装的 conda 的详细信息，包括 conda 版本、python 版本、软件包仓库地址、新建环境的存放路径等。 conda info # 查看conda版本信息 conda -V conda --version","text_tokens":["详细信息","环境"," ","可以","当前","等","包括","、","该","v","conda","-","软件包","#","。","info","安装","路径","##","命令","信息","--","详细","的","查看","python","，","仓库","版本信息","存放","新建","version","地址","软件","版本"],"title":"查看信息","title_tokens":["信息","查看"]},{"location":"开发环境管理/5.1.conda笔记.html#_2","text":"# 查看环境信息 ## 查看系统中安装的所有环境： ### 这两个命令都可以查看当前 conda 中已经创建的环境列表，处于激活状态的环境旁边会有一个*的字样。 conda env list conda info –-envs conda info -e ## 查看 Conda 环境系统信息： conda info –-system conda info –s ## 查看环境系统更加详细的信息： conda info –-all conda info –a # 进入指定环境 conda activate <env> # 推出环境 conda deactivate # 导出环境 ## 导出环境之前首先要进入该环境 conda list -e > package-list.txt conda list -e > package-list.yml ## 或者这样 ### 这会将当前环境中由 conda 管理的包和由 pip 安装的包同时导出到文件中，所以当根据文件创建环境时，无需重新安装 pip 的包。 conda env export –-name base –-file base_bunnies.yml # 创建环境 ## 新建一个名为 newenv 的环境，并指定新环境中的 python 版本为 3.6 创建出来的环境中只带有最基本的包 conda create --name newenv python = 3 .6 ## 也可以在创建环境时候，包含某些程序或者包 conda create --name newenv python = 3 .6 biopython ipython ## 通过克隆创建一个新环境 conda create –-name newenv –clone base ## 从文件创建环境 ### 如果是用 conda env export --name 导出的文件，则可用下列命令创建： conda env create -f package-list.yml ### 如果是用 conda list -e 导出的文件，则用如下方式创建： conda create –-name <env> –-file <deps file> # 更新环境 conda env update –-name <env> –file = <deps file> # 删除环境 ## 删除环境中指定的包： conda remove –-name <env> ipython biopython ## 彻底删除环境： conda env remove –name <env>","text_tokens":["list","s","环境","到","如果","clone","最","时","由","export","该","处于","deactivate","根据","重新","–","通过","*","#","bunnies","安装","旁边","删除","这会","_","和","信息","推出","管理","这","下列","ipython","新建","系统","状态","中",">","可以","package","当前","create","是","remove","当","3.6","会","在","只","程序","方式","deps","这样","某些","首先","info","要","update","##","###","命令","并","为","查看","python","，","activate","可用","3","字样","name","更加","e","也","文件创建","yml","更新","都","biopython","=","conda","-","：","无需","新","f","env","所以","pip","克隆","激活状态","。","txt","基本","时候","之前","进入","创建","base","详细","的","system","带有","列表","版本",".","如下","出来","用"," ","一个","<","激活","重新安装","已经","导出","envs","将","新安","所有","有","all","同时","指定","file","则","newenv","包含","从","彻底","或者","6","包","两个","文件","a","名为","--"],"title":"环境管理","title_tokens":["管理","环境"]},{"location":"开发环境管理/5.1.conda笔记.html#_3","text":"conda 创建出来的环境默认放在 /User/<yourname>/anaconda/env 目录下，你可以将其中的某个环境文件夹整体拷贝走，复制到另一台机器上，然后基于此文件夹创建环境。","text_tokens":["件夹",">","user","anaconda","出来","环境"," ","基于","可以","<","放在","/","conda","某个","你","将","走","文件夹","其中","拷贝","默认","env","然后","机器","整体","。","另一台","上","下","目录","创建","文件","一台","的","复制","，","此","yourname","复制到"],"title":"从指定路径安装环境","title_tokens":["路径","指定","环境","从","安装"]},{"location":"开发环境管理/5.1.conda笔记.html#_4","text":"conda list # 查看已经安装的包 conda update conda # 升级conda自身 conda search requests # 查询某个包 conda install requests # 安装新包 conda install -n base requests # 将包安装到指定环境 conda update --all # 更新所有包 conda update requests # 升级包 conda remove requests # 移除包 conda remove -n base requests # 从指定环境中移除包 conda 不提供检查可更新的包的命令，update 所有包时会有提示，列出所有可更新的包，并让用户确认是否全部更新。","text_tokens":["新包","list","可","中","环境"," ","到","install","更新","用户","升级包","已经","remove","让","自身","conda","-","某个","将","全部","是否","所有","列出","有","all","不","指定","检查","search","n","#","从","确认","。","安装","requests","包","update","命令","base","提示","的","查看","时会","，","并","升级","提供","移除","查询","--"],"title":"包管理","title_tokens":["管理","包"]},{"location":"开发环境管理/5.1.conda笔记.html#anaconda","text":"conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes 使用 conda config --show channels 命令可以查看当前的源仓库地址。","text_tokens":[".","free","anaconda"," ","tsinghua","可以","地址","当前","/","add","conda",":","set","show","源","使用","channel","https","edu","pkgs","config","。","mirrors","main","channels","tuna","_","命令","cn","的","查看","yes","仓库","urls","--"],"title":"为 anaconda 指定国内镜像源","title_tokens":["指定","源","anaconda","镜像","为"," ","国内"]},{"location":"开发环境管理/5.3.pip对比conda.html","text":"了解conda and pip的异同 本文翻译自 Understanding Conda and Pip ( Jonathan Helmus )。 Conda和pip这两个工具有一些重叠的功能，因此它们常常被认为是没什么区别的，但实际上它们被设计用于不同的目的。 pip 是Python Packaging Authority 推荐的从 Python Package Index (PyPI)安装包的工具。 pip可以安装打包为wheels格式的包，或者直接从源代码编译安装。从源代码文件安装可能需要系统安装兼容的编译器和相应的库 1 。 Conda 是跨平台的包和环境管理器，可以安装和管理来自 Anaconda repository 和 Anaconda Cloud 的conda包。Conda包是二进制文件，不需要使用编译器来安装。另外，conda包不限于Python包，还可以包含C或C++ 库、R包或任何其他软件。 这是conda和pip的关键区别。pip只能安装Python包，而conda安装的包可以是用任何语言编写的。例如，在使用pip之前，必须通过”系统程序管理器“或”下载并运行安装程序“来安装Python解释器，而Conda可以直接安装Python包和Python解释器。 这两个工具的另一个显著区别是conda可以为不同版本的python或package创建隔离的环境。这在使用数据科学工具时非常有用，因为不同的工具可能包含冲突的依赖，这可能会导致它们不适合安装到相同的环境中。pip没有内置的环境管理功能，而是依赖于 virtualenv 或 venv 等其他工具来创建隔离环境。 pipenv、poetry、hatch wrap pip、virtualenv等工具提供了统一的方法来创建单独的环境。 pip和conda在如何实现环境中的依赖关系方面也有所不同。安装包时，pip会在递归的串行循环中安装依赖项，没有努力确保同时满足所有包的依赖性。如果较早安装的包与稍后安装的包具有不兼容的依赖，环境就会被破坏。相反的，conda使用一个satisfiability (SAT)的处理程序去检查环境中的所有包的依赖是否都得到满足。此检查可能需要额外的时间，但可以防止创建一个被破坏的环境。只要包含依赖关系的package metadata是正确的，conda就可以创建有效的环境。 考虑到conda和pip之间的相似性，有些人试图将这些工具结合起来创建数据科学环境也就不足为奇了。将pip与conda结合的主要原因是有些包只能通过pip安装。在Anaconda repository中有1500多个包可用，其中涵盖了最流行的数据科学、机器学习和AI框架。另外，在conda-forge和bioconda的channel还有数以千计的包可以使用conda安装。尽管Anaconda cloud有大量的包，但与PyPI上可提供的150,000多个包相比，数量仍然很少。有时候需要的包没有相应的conda包，但在PyPI上有安装文件，则可以用pip安装。 补充 conda 安装包路径是 \\Anaconda3\\pkgs pip 安装包路径在虚拟环境下是 \\Anaconda3\\envs\\Lib\\site-packages pip可能会生成存在冲突的环境，而conda不会 pip与conda不会重复安装已经安装的依赖 pip安装的包不会显示在anaconda navigation的环境中 conda 为多个环境安装包时，对于同一个包只安装一次，由conda集中管理 pip 为多个环境安装包时，因为每个环境安装包使用的pip在不同的路径下，因此会重复安装 关于Python包管理工具的发展历史可以参考 Python's New Package Landscape (andrew)，其中文翻译版本 在这 。插图来自https://www.xkcd.com/1987/。 编译器和库用于编译源代码。 ↩","text_tokens":["1987","这是","s","环境","到","如果","而是","认为","管理器","限于","原因","虚拟","最","关系","实际","hatch","时","metadata","存在","较","由","'","virtualenv","相反","下载","生成","还","没什么","\\","目的","兼容","有些","大量","有时候","插图","包是","不","通过","另外","早","poetry","不足","科学","一些","集中管理","xkcd","它们","冲突","安装","andrew","很少","重复","有用","因为","尽管","只要","去","路径","和","此","管理","这","提供","设计","推荐","解释","单独","还有","数以千计","对于","系统","集中","软件","pipenv","理工","有所","串行","中","必须","导致","new","可以","用于","关键","相似性","有所不同","正确","常常","package","r","是","“","释器","起来","、","涵盖","不会","understanding","框架","异同","数量","有时","会","关于","/","jonathan","而","格式","在","跨平台","方法","其中","不同","解释器","程序","额外","channel","努力","非常","补充","sat","机器","000","上","相比","com","相应","但","landscape","方面","只能","为","并","python","，","实现","可用","工具","依赖","例如","满足","cloud","翻译","处理程序","如何","与","任何","其他软件","也","破坏","index","语言","没有","发展","依赖于","都","内置","and","中有","等","参考","来","c","相同","试图","另","防止","编写","递归","学习","ai","功能","隔离","历史","conda","-","相似",":","自","是否","venv","之间","1500","平台","安装文件","库","helmus","安装程序","检查","直接","有效",")","赖于","稍后","pip","同一","了解","不足为奇","。","安装包","理器","pkgs","统一","时候","之前","anaconda3","结合","创建","显示","150","的","适合","lib","其","因此","来自","中文翻译","得到","就","虚拟环境","版本","打包","什么","了","流行",".","可","进制","anaconda","用"," ","循环","包只","一个","管理工具","编译器","项","bioconda","实际上","1","代码","packaging","同一个","已经","一次","重叠","处理","www","其他","wheels","运行","主要","确保","显著","数据","多个","satisfiability","将","这些","envs","所有","依赖性","有","↩","同时","wrap","考虑","人","repository","使用",",","时间","则","或","仍然","https","区别","site","forge","包含","从","”","或者","可能","中文","下","pypi","包","c++","编译","authority","navigation","需要","包不","两个","(","二进制","文件","本文","packages","每个","被","源代码","具有"],"title":"5.3.pip对比conda","title_tokens":["5.3",".","对比","pip","conda"]},{"location":"开发环境管理/5.3.pip对比conda.html#conda-and-pip","text":"本文翻译自 Understanding Conda and Pip ( Jonathan Helmus )。 Conda和pip这两个工具有一些重叠的功能，因此它们常常被认为是没什么区别的，但实际上它们被设计用于不同的目的。 pip 是Python Packaging Authority 推荐的从 Python Package Index (PyPI)安装包的工具。 pip可以安装打包为wheels格式的包，或者直接从源代码编译安装。从源代码文件安装可能需要系统安装兼容的编译器和相应的库 1 。 Conda 是跨平台的包和环境管理器，可以安装和管理来自 Anaconda repository 和 Anaconda Cloud 的conda包。Conda包是二进制文件，不需要使用编译器来安装。另外，conda包不限于Python包，还可以包含C或C++ 库、R包或任何其他软件。 这是conda和pip的关键区别。pip只能安装Python包，而conda安装的包可以是用任何语言编写的。例如，在使用pip之前，必须通过”系统程序管理器“或”下载并运行安装程序“来安装Python解释器，而Conda可以直接安装Python包和Python解释器。 这两个工具的另一个显著区别是conda可以为不同版本的python或package创建隔离的环境。这在使用数据科学工具时非常有用，因为不同的工具可能包含冲突的依赖，这可能会导致它们不适合安装到相同的环境中。pip没有内置的环境管理功能，而是依赖于 virtualenv 或 venv 等其他工具来创建隔离环境。 pipenv、poetry、hatch wrap pip、virtualenv等工具提供了统一的方法来创建单独的环境。 pip和conda在如何实现环境中的依赖关系方面也有所不同。安装包时，pip会在递归的串行循环中安装依赖项，没有努力确保同时满足所有包的依赖性。如果较早安装的包与稍后安装的包具有不兼容的依赖，环境就会被破坏。相反的，conda使用一个satisfiability (SAT)的处理程序去检查环境中的所有包的依赖是否都得到满足。此检查可能需要额外的时间，但可以防止创建一个被破坏的环境。只要包含依赖关系的package metadata是正确的，conda就可以创建有效的环境。 考虑到conda和pip之间的相似性，有些人试图将这些工具结合起来创建数据科学环境也就不足为奇了。将pip与conda结合的主要原因是有些包只能通过pip安装。在Anaconda repository中有1500多个包可用，其中涵盖了最流行的数据科学、机器学习和AI框架。另外，在conda-forge和bioconda的channel还有数以千计的包可以使用conda安装。尽管Anaconda cloud有大量的包，但与PyPI上可提供的150,000多个包相比，数量仍然很少。有时候需要的包没有相应的conda包，但在PyPI上有安装文件，则可以用pip安装。","text_tokens":["这是","环境","到","如果","而是","认为","管理器","限于","原因","最","关系","实际","hatch","时","metadata","较","virtualenv","相反","下载","还","没什么","目的","兼容","有些","大量","有时候","包是","不","通过","另外","早","poetry","不足","科学","一些","它们","冲突","安装","很少","有用","因为","尽管","只要","去","和","此","管理","这","提供","设计","推荐","解释","单独","还有","数以千计","系统","软件","pipenv","有所","串行","中","必须","导致","可以","用于","关键","相似性","有所不同","正确","常常","package","r","是","“","释器","起来","、","涵盖","understanding","框架","数量","有时","会","jonathan","而","格式","在","跨平台","方法","其中","不同","解释器","程序","额外","channel","努力","非常","sat","机器","000","上","相比","相应","但","方面","只能","为","并","python","，","实现","可用","工具","依赖","例如","满足","cloud","翻译","处理程序","如何","与","任何","其他软件","也","破坏","index","语言","没有","依赖于","都","内置","and","中有","等","来","c","相同","试图","另","防止","编写","递归","学习","ai","功能","隔离","conda","-","相似","自","是否","venv","之间","1500","平台","安装文件","库","helmus","安装程序","检查","直接","有效",")","赖于","稍后","pip","不足为奇","。","安装包","理器","统一","时候","之前","结合","创建","150","的","适合","因此","来自","得到","就","版本","打包","什么","了","流行","可","进制","anaconda","用"," ","循环","一个","编译器","项","bioconda","实际上","1","代码","packaging","重叠","处理","其他","wheels","运行","主要","确保","显著","数据","多个","satisfiability","将","这些","所有","依赖性","有","同时","wrap","考虑","人","repository","使用",",","时间","则","或","仍然","区别","forge","包含","从","”","或者","可能","pypi","包","c++","编译","authority","需要","包不","两个","(","二进制","文件","本文","被","源代码","具有"],"title":"了解conda and pip的异同","title_tokens":["and","异同"," ","pip","的","了解","conda"]},{"location":"开发环境管理/5.3.pip对比conda.html#_1","text":"conda 安装包路径是 \\Anaconda3\\pkgs pip 安装包路径在虚拟环境下是 \\Anaconda3\\envs\\Lib\\site-packages pip可能会生成存在冲突的环境，而conda不会 pip与conda不会重复安装已经安装的依赖 pip安装的包不会显示在anaconda navigation的环境中 conda 为多个环境安装包时，对于同一个包只安装一次，由conda集中管理 pip 为多个环境安装包时，因为每个环境安装包使用的pip在不同的路径下，因此会重复安装 关于Python包管理工具的发展历史可以参考 Python's New Package Landscape (andrew)，其中文翻译版本 在这 。插图来自https://www.xkcd.com/1987/。 编译器和库用于编译源代码。 ↩","text_tokens":["1987","s","环境","虚拟","存在","时","由","'","生成","\\","插图","集中管理","xkcd","冲突","安装","andrew","重复","路径","因为","和","每个","管理","对于","集中","这","理工","中","new","可以","用于","package","是","不会","会","关于","/","而","在","不同","com","landscape","为","python","，","工具","依赖","翻译","与","发展","参考","conda","-",":","历史","库",")","同一","pip","。","pkgs","安装包","anaconda3","显示","其","的","lib","中文翻译","因此","来自","虚拟环境","版本",".","anaconda"," ","包只","一个","管理工具","编译器","代码","同一个","已经","一次","www","多个","envs","↩","使用","https","site","可能","中文","下","包","navigation","编译","(","packages","源代码"],"title":"补充","title_tokens":["补充"]},{"location":"开发环境管理/5.4.anaconda.html","text":"Anaconda下各个文件夹作用 anacoda3/conda-meta/history ：记录用户使用conda命令安装、卸载、升级包的操作 anaconda3/pkgs/urls.txt ：记录用户使用conda命令下载包的地址，直接复制地址到浏览器中也可以下载 anaconda3/conda-meta/ ：文件夹里保存着与各个包同名的.json文件（有些包会有多个.json文件），这些json文件会记录对应的包的版本、存放位置、md5值等信息 anaconda3/pkgs/ ：这个文件夹里存放了每个包刚下载来的文件，格式是.tar.gz2，另外也会自动解压到这个文件夹里。比如你下载了six这个包，anaconda3/pkgs/这个文件夹里会多出如下2个文件。另外，当你卸载包的时候，这里的2个文件是不会被删除的 anaconda3/lib/python3.6/site-packages/ ：包的存放目录 anaconda3/bin ：安装一些包的时候会往里添加一些可执行文件 anaconda3/lib ：安装一些包的时候会往里添加一些.so文件 anaconda3/include ：安装一些包的时候会往里添加了一些文件 anaconda3/man ：安装一些包的时候会往里里添加了一些文件 anaconda3/share ：安装一些包的时候会往里里添加了一些文件","text_tokens":["作用","多出","到","so","包会","浏览","里","2","下载","个","json","有些","python3.6","保存","各个","另外","卸载","添加","anacoda3","bin","一些","安装","目录","删除","信息","位置","每个","升级","地址","）","中","可以","include","对应","用户","meta","是","、","行文","不会","当","会","/","格式","你","gz2","可执行文件","tar","值","同名","命令","share","复制","，","存放","man","urls","与","也","操作","等","来","记录","history","conda","-","：","文件夹","浏览器","直接","。","pkgs","txt","解压","时候","anaconda3","的","lib","版本","件夹",".","了","md5","anaconda","如下"," ","这里","升级包","six","这个","多个","里会","包刚","这些","有","使用","site","执行","会往","下","包","自动","比如","文件","（","packages","着","被"],"title":"5.4.anaconda","title_tokens":["anaconda",".","5.4"]},{"location":"开发环境管理/5.4.anaconda.html#anaconda","text":"anacoda3/conda-meta/history ：记录用户使用conda命令安装、卸载、升级包的操作 anaconda3/pkgs/urls.txt ：记录用户使用conda命令下载包的地址，直接复制地址到浏览器中也可以下载 anaconda3/conda-meta/ ：文件夹里保存着与各个包同名的.json文件（有些包会有多个.json文件），这些json文件会记录对应的包的版本、存放位置、md5值等信息 anaconda3/pkgs/ ：这个文件夹里存放了每个包刚下载来的文件，格式是.tar.gz2，另外也会自动解压到这个文件夹里。比如你下载了six这个包，anaconda3/pkgs/这个文件夹里会多出如下2个文件。另外，当你卸载包的时候，这里的2个文件是不会被删除的 anaconda3/lib/python3.6/site-packages/ ：包的存放目录 anaconda3/bin ：安装一些包的时候会往里添加一些可执行文件 anaconda3/lib ：安装一些包的时候会往里添加一些.so文件 anaconda3/include ：安装一些包的时候会往里添加了一些文件 anaconda3/man ：安装一些包的时候会往里里添加了一些文件 anaconda3/share ：安装一些包的时候会往里里添加了一些文件","text_tokens":["多出","到","so","包会","浏览","里","2","下载","个","json","有些","python3.6","保存","各个","另外","卸载","添加","anacoda3","bin","一些","安装","目录","删除","信息","位置","每个","升级","地址","）","中","可以","include","对应","用户","meta","是","、","行文","不会","当","会","/","格式","你","gz2","可执行文件","tar","值","同名","命令","share","复制","，","存放","man","urls","与","也","操作","等","来","记录","history","conda","-","：","文件夹","浏览器","直接","。","pkgs","txt","解压","时候","anaconda3","的","lib","版本",".","件夹","了","md5","如下"," ","这里","升级包","six","这个","多个","里会","包刚","这些","有","使用","site","执行","会往","包","自动","比如","文件","（","packages","着","被"],"title":"Anaconda下各个文件夹作用","title_tokens":["作用","件夹","各个","anaconda","文件","下","文件夹"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html","text":"让代码窗口输出全部结果 将此代码放置在jupyter单元中： from IPython.core.interactiveshell import InteractiveShell InteractiveShell . ast_node_interactivity = \"all\" 修改全局设置 在Windows中，以下步骤会使更改永久生效。应该适用于其他操作系统。您可能必须更改路径。 C:\\Users\\your_profile\\\\.ipython\\profile_default 做一个ipython_config.py文件与下面的代码profile_defaults： c = get_config () c . InteractiveShell . ast_node_interactivity = \"all\" 使用 print 函数 快捷键使用指南 Jupyter Notebook 有两种键盘输入模式。即命令模式和编辑模式，这与 Vim 有些类似。在编辑模式下，可以往cell中键入代码或文本，此时命令模式下的快捷键不生效。在命令模式下，可以用快捷键命令运行单元格，移动单元格，切换单元格编辑状态等等，此时编辑模式下的快捷键不生效。 从命令模式进入编辑模式需按 Enter 键，从编辑模式切换到命令模式需按 Esc 键。 以下两表分别是对命令和编辑两种模式下快捷键的简单说明： 命令模式快捷键（按 Esc 键开启）: 快捷键 作用 说明 Enter 转入编辑模式 Shift-Enter 运行本单元，选中下个单元 新单元默认为命令模式 Ctrl-Enter 运行本单元 Alt-Enter 运行本单元，在其下插入新单元 新单元默认为编辑模式 Y 单元转入代码状态 M 单元转入 markdown 状态 R 单元转入 raw 状态 1 设定 1 级标题 仅在 markdown 状态下时建议使用标题相关快捷键，如果单元处于其他状态，则会强制切换到 markdown 状态 2 设定 2 级标题 3 设定 3 级标题 4 设定 4 级标题 5 设定 5 级标题 6 设定 6 级标题 Up 选中上方单元 K 选中上方单元 Down 选中下方单元 J 选中下方单元 Shift-K 连续选择上方单元 Shift-J 连续选择下方单元 A 在上方插入新单元 B 在下方插入新单元 X 剪切选中的单元 C 复制选中的单元 Shift-V 粘贴到上方单元 V 粘贴到下方单元 Z 恢复删除的最后一个单元 D,D 删除选中的单元 连续按两个 D 键 Shift-M 合并选中的单元 Ctrl-S 保存当前 NoteBook S 保存当前 NoteBook L 开关行号 编辑框的行号是可以开启和关闭的 O 转换输出 Shift-O 转换输出滚动 Esc 关闭页面 Q 关闭页面 H 显示快捷键帮助 I,I 中断 NoteBook 内核 0,0 重启 NoteBook 内核 Shift 忽略 Shift-Space 向上滚动 Space 向下滚动 编辑模式快捷键（ 按 Enter 键启动）: 快捷键 作用 说明 Tab 代码补全或缩进 Shift-Tab 提示 输出帮助信息，部分函数、类、方法等会显示其定义原型，如果在其后加 ? 再运行会显示更加详细的帮助 Ctrl-] 缩进 向右缩进 Ctrl-[ 解除缩进 向左缩进 Ctrl-A 全选 Ctrl-Z 撤销 Ctrl-Shift-Z 重做 Ctrl-Y 重做 Ctrl-Home 跳到单元开头 Ctrl-Up 跳到单元开头 Ctrl-End 跳到单元末尾 Ctrl-Down 跳到单元末尾 Ctrl-Left 跳到左边一个字首 Ctrl-Right 跳到右边一个字首 Ctrl-Backspace 删除前面一个字 Ctrl-Delete 删除后面一个字 Esc 切换到命令模式 Ctrl-M 切换到命令模式 Shift-Enter 运行本单元，选中下一单元 新单元默认为命令模式 Ctrl-Enter 运行本单元 Alt-Enter 运行本单元，在下面插入一单元 新单元默认为编辑模式 Ctrl-Shift-- 分割单元 按光标所在行进行分割 Ctrl-Shift-Subtract 分割单元 Ctrl-S 保存当前 NoteBook Shift 忽略 Up 光标上移或转入上一单元 Down 光标下移或转入下一单元 Ctrl-/ 注释整行/撤销注释 仅代码状态有效 注： 如果快捷键被系统中的其它应用占用，则可能会失效 在任意目录下打开notebook 在该目录下：shift + 右键 👉 打开powershell，输入jupter notebook 自定义主题 通过 pip 安装 jupyterthemes package： # 安装 pip install jupyterthemes # 更新jupyterthemes pip install --upgrade jupyterthemes 安装好 jupyterthemes package之后，就可以在命令行输入 jupyterthemes 的命令： # 列出所有安装好的主题 jt -l # 使用帮助 jt -h 具体使用方法参见： jupyterthemes官方说明 安装扩展 安装 jupyter_contrib_nbextensions 包。该插件并不是jupyter notebook官方的插件。具体参考 Unofficial Jupyter Notebook Extensions 和 为Jupyter Notebook安装扩展并启用Configurator 。 # 安装 pip install jupyter_contrib_nbextensions # 或者通过conda安装 conda install -c conda-forge jupyter_contrib_nbextensions # 激活 jupyter contrib nbextension install --user # 启用 jupyter nbextensions_configurator enable --user 输出带有中文的pdf jupyter notebook本身不能输出pdf，输出pdf依赖于$\\LaTeX$引擎。目前，带有中文的ipynb文件输出为pdf会报错，主要原因是jupyter的$\\LaTeX$模板设置了$\\text{pdf}\\LaTeX$引擎，但是Pdf$\\LaTeX$不可以直接编译中文文档的。因此，需要把jupyter的$\\LaTeX$引擎改为$\\text{Xe}\\LaTeX$引擎。 修改模板，模板位置为：...\\site-packages\\nbconvert\\templates\\latex\\article.tplx，将latex模板类由article改为ctexart。 原来的代码： ((* block docclass *)) \\documentclass [11pt] { article } ((* endblock docclass *)) 修改后的代码： ((* block docclass *)) \\documentclass [13pt] { ctexart } ((* endblock docclass *)) 或者，依然使用PdfLatex引擎，但引入xeCJK宏包： \\documentclass [11pt] { article } \\usepackage { xeCJK } % 如果设置mainfont，必须设置为已安装的中文字体，例如微软雅黑。 %\\setCJKmainfont{SourceHanSansCN-Light} 想要修改输出pdf的排版，则需要修改其预定义的latex排版模板，即base.tplx文件。例如可以在base.tplx加入如下代码控制输出的pdf的页边距。 \\geometry { a4paper,left=2cm,right=2cm,top=1cm,bottom=1cm } 但是，可能改了jupyter的latex模板，jupyter notebook输出pdf依然报错。例如下面的报错信息： nbconvert failed: PDF creating failed, captured latex output: This is XeTeX, Version 3.14159265-2.6-0.99999 (TeX Live 2018/W32TeX) (preloaded format=xelatex) restricted \\write18 enabled. entering extended mode ! Undefined control sequence. <*> .\\notebook .tex ? ! Emergency stop. <*> .\\notebook .tex No pages of output. Transcript written on ?. 这是jupyter中控制调用latex引擎的脚本pdf.py有bug，位于66行。 原来的代码： writer = Instance ( \"nbconvert.writers.FilesWriter\" , args = (), kw = { 'build_directory' : '.' }) 正确的代码： writer = Instance ( \"nbconvert.writers.FilesWriter\" , args = (), kw = { 'build_directory' : '' }) 原来的代码给xelatex引擎发送了错误的文件路径： 错误的路径： xelatex .\\notebook.tex 正确的路径： xelatex notebook.tex 详细内容参考这里 Problem in Converting Jupyter notebook to pdf #144 。 版本控制 Save and CheckPoint 和 Revert to CheckPoint。","text_tokens":["tab","字","writers","control","'","该","cell","仅","nbconvert","backspace","不","默认","*","帮助","调用","jupter","transcript","...","信息","上移","修改","13pt","in","这","ipynb","upgrade","2018","shift","参见","标题","不是","转换","{","directory","正确","package","部分","failed","是","启动","列出","defaults","单元","类似","文本","右边","top","错误","bottom","docclass","并","复制","sequence","文字","依赖","3","关闭","两种","entering","latex","再","and","重做","等","下时","0.99999","alt","conda","移动","左边","is","更改","有效","预定",")","赖于","适用","usepackage","notebook","。","to","2.6","进入","m","的","其","因此","放置","以下","打开","版本","了","页","build"," ","h","<","这里","+","emergency","缩进","改为","主要","全局","将","all","使用","则","end","或","5","!","分别","%","即","建议","解除","unofficial","node","a","其后","xe","被","这是","interactiveshell","键入","开关","使用指南","注释","pages","说明","nbextension","由","2","w32tex","}","preloaded","\\","依然","66","输入","written","原来","插入","发送","义","其下","config","目录","revert","单元格","等等","markdown","删除","_","和","subtract","位置","captured","enabled","系统","profile","状态","中","必须","space","xetex","做","函数","当前","b","v","checkpoint","页面","插件","简单","向上","z","xelatex","位于","好","启用","连续","，","o","版本控制","更加","与","]","jupyter","print","编辑","下个","c","下移","=","左","ctexart","enable","指南","滚动","import","扩展","内核","中断","末尾","format","您","undefined","up","就","powershell","使","delete","给","of","用","按","11pt","1","整行","restricted","设置","jt","下面","运行","有","problem","j","前面","编辑框","两个","(","default","应用","vim","packages","output","users","忽略","s","到","如果","微软","原因","右键","mode","级","2cm","需","有些","geometry","开启","no","于","通过","恢复","失效","stop","3.14159265","安装","路径","上方","此","控制","边","ipython","原型","字体","中文字体","键盘","可以","加入","$","距","会","your","全部","documentclass","xecjk","方法","configurator","k","contrib","类","writer","向下","开头","args","[","命令","雅黑","提示","为","version","144","自定","例如","补全","进行","选择","对","windows","👉","依赖于","操作","get","write18","4","粘贴",":","down","pip","本","本身","save","显示","后面","base","x","text","fileswriter","排版","最后",".","占用","1cm","user","但是","一个","激活","代码","其他","转入","article","creating","\"","想要","所有","文档","0","切换","引擎","forge","分割","中文","6","pdf","任意","编译","需要","文件","（","键盘输入","已","--","作用","left","应该","结果","l","install","light","不能","剪切","操作系统","报错","后","mainfont","处于","raw","core","d","两表","保存","步骤","注","主题","合并","快捷","#","引入","改了","on","把","所在","右","extended","窗口","templates","）","设定",">","r","、","让","ast","block","/","在","instance","脚本","?","nbextensions","快捷键","此时","上","pdflatex","重启","但","之后","加","i","永久","更新","jupyterthemes","参考","y","interactivity","live","endblock","-","具体","：","新","直接","目前","生效","right","其它","esc","详细","字首","带有","sourcehansanscn","行","tplx","命令行","setcjkmainfont","enter","q","相关","ctrl","行号","如下","tex","选中","输出","官方","py","converting","向","强制","定义","a4paper","光标","一","内容","撤销","自定义",",","跳","模板","宏包","下方","site","bug","从","全选","可能","或者","下","包","this","往","kw","extensions","from","home","模式","键"],"title":"5.5.jupyter使用笔记","title_tokens":[".","笔记","使用","5.5","jupyter"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_1","text":"将此代码放置在jupyter单元中： from IPython.core.interactiveshell import InteractiveShell InteractiveShell . ast_node_interactivity = \"all\" 修改全局设置 在Windows中，以下步骤会使更改永久生效。应该适用于其他操作系统。您可能必须更改路径。 C:\\Users\\your_profile\\\\.ipython\\profile_default 做一个ipython_config.py文件与下面的代码profile_defaults： c = get_config () c . InteractiveShell . ast_node_interactivity = \"all\" 使用 print 函数","text_tokens":["使",".","users","中","应该","与","必须"," ","interactiveshell","做","一个","永久","jupyter","print","windows","函数","操作","操作系统","代码","interactivity","c","设置","py","get","ast","其他","会","下面","=","your","全局","\"","\\","core","在",":","将","：","步骤","all","更改","于","使用","defaults",")","单元","import","适用","生效","。","可能","config","路径","您","_","(","node","文件","default","修改","from","此","，","的","ipython","放置","以下","系统","profile"],"title":"让代码窗口输出全部结果","title_tokens":["让","结果","窗口","全部","输出","代码"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_2","text":"Jupyter Notebook 有两种键盘输入模式。即命令模式和编辑模式，这与 Vim 有些类似。在编辑模式下，可以往cell中键入代码或文本，此时命令模式下的快捷键不生效。在命令模式下，可以用快捷键命令运行单元格，移动单元格，切换单元格编辑状态等等，此时编辑模式下的快捷键不生效。 从命令模式进入编辑模式需按 Enter 键，从编辑模式切换到命令模式需按 Esc 键。 以下两表分别是对命令和编辑两种模式下快捷键的简单说明：","text_tokens":["enter","状态","两种","中","与","用"," ","到","键盘","可以","对","键入","按","jupyter","编辑","代码","说明","是","运行","需","有些","在","cell","移动","两表","简单","：","有","不","输入","切换","或","单元","快捷","分别","类似","生效","notebook","文本","。","快捷键","此时","从","即","下","单元格","等等","往","进入","命令","和","esc","的","，","这","键盘输入","vim","以下","模式","键"],"title":"快捷键使用指南","title_tokens":["使用","指南","快捷","使用指南","快捷键"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#esc","text":"快捷键 作用 说明 Enter 转入编辑模式 Shift-Enter 运行本单元，选中下个单元 新单元默认为命令模式 Ctrl-Enter 运行本单元 Alt-Enter 运行本单元，在其下插入新单元 新单元默认为编辑模式 Y 单元转入代码状态 M 单元转入 markdown 状态 R 单元转入 raw 状态 1 设定 1 级标题 仅在 markdown 状态下时建议使用标题相关快捷键，如果单元处于其他状态，则会强制切换到 markdown 状态 2 设定 2 级标题 3 设定 3 级标题 4 设定 4 级标题 5 设定 5 级标题 6 设定 6 级标题 Up 选中上方单元 K 选中上方单元 Down 选中下方单元 J 选中下方单元 Shift-K 连续选择上方单元 Shift-J 连续选择下方单元 A 在上方插入新单元 B 在下方插入新单元 X 剪切选中的单元 C 复制选中的单元 Shift-V 粘贴到上方单元 V 粘贴到下方单元 Z 恢复删除的最后一个单元 D,D 删除选中的单元 连续按两个 D 键 Shift-M 合并选中的单元 Ctrl-S 保存当前 NoteBook S 保存当前 NoteBook L 开关行号 编辑框的行号是可以开启和关闭的 O 转换输出 Shift-O 转换输出滚动 Esc 关闭页面 Q 关闭页面 H 显示快捷键帮助 I,I 中断 NoteBook 内核 0,0 重启 NoteBook 内核 Shift 忽略 Shift-Space 向上滚动 Space 向下滚动","text_tokens":["作用","忽略","s","如果","到","l","开关","剪切","说明","级","2","处于","raw","仅","d","保存","开启","默认","插入","合并","帮助","恢复","快捷","其下","markdown","删除","和","上方","shift","设定","状态","标题","space","可以","转换","当前","r","是","b","v","会","在","页面","k","向上","z","向下","单元","快捷键","重启","命令","为","连续","复制","，","o","3","关闭","选择","i","编辑","下个","y","c","下时","4","alt","粘贴","-","新","down","滚动","内核","本","notebook","中断","显示","m","esc","x","的","up","enter","最后","q","相关","ctrl","行号"," ","一个","按","h","选中","1","输出","代码","其他","转入","运行","强制","0",",","使用","则","切换","5","下方","j","6","建议","编辑框","两个","a","模式","键"],"title":"命令模式快捷键（按 Esc 键开启）:","title_tokens":["开启","）","命令","（","esc"," ","快捷","按","快捷键",":","模式","键"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#enter","text":"快捷键 作用 说明 Tab 代码补全或缩进 Shift-Tab 提示 输出帮助信息，部分函数、类、方法等会显示其定义原型，如果在其后加 ? 再运行会显示更加详细的帮助 Ctrl-] 缩进 向右缩进 Ctrl-[ 解除缩进 向左缩进 Ctrl-A 全选 Ctrl-Z 撤销 Ctrl-Shift-Z 重做 Ctrl-Y 重做 Ctrl-Home 跳到单元开头 Ctrl-Up 跳到单元开头 Ctrl-End 跳到单元末尾 Ctrl-Down 跳到单元末尾 Ctrl-Left 跳到左边一个字首 Ctrl-Right 跳到右边一个字首 Ctrl-Backspace 删除前面一个字 Ctrl-Delete 删除后面一个字 Esc 切换到命令模式 Ctrl-M 切换到命令模式 Shift-Enter 运行本单元，选中下一单元 新单元默认为命令模式 Ctrl-Enter 运行本单元 Alt-Enter 运行本单元，在下面插入一单元 新单元默认为编辑模式 Ctrl-Shift-- 分割单元 按光标所在行进行分割 Ctrl-Shift-Subtract 分割单元 Ctrl-S 保存当前 NoteBook Shift 忽略 Up 光标上移或转入上一单元 Down 光标下移或转入下一单元 Ctrl-/ 注释整行/撤销注释 仅代码状态有效 注： 如果快捷键被系统中的其它应用占用，则可能会失效","text_tokens":["作用","left","tab","忽略","s","字","如果","到","注释","说明","仅","保存","backspace","注","默认","插入","帮助","快捷","失效","所在","右","删除","信息","上移","subtract","原型","系统","shift","状态","中","函数","部分","当前","、","会","/","在","方法","类","?","z","开头","单元","快捷键","[","上","右边","命令","提示","为","，","补全","进行","加","更加","]","编辑","再","重做","等","y","下移","alt","左","-","左边","：","新","有效","down","本","notebook","right","末尾","其它","显示","后面","m","详细","其","的","esc","字首","up","行","enter","delete","占用","ctrl"," ","一个","按","选中","输出","缩进","代码","整行","转入","运行","向","下面","定义","光标","一","撤销","则","跳","end","或","切换","全选","分割","可能","下","前面","解除","a","应用","其后","home","被","模式","--"],"title":"编辑模式快捷键（ 按 Enter 键启动）:","title_tokens":["enter","）","（","启动"," ","快捷","按","快捷键","编辑",":","模式","键"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#notebook","text":"在该目录下：shift + 右键 👉 打开powershell，输入jupter notebook","text_tokens":["shift","输入","：","👉","该"," ","打开","，","右键","notebook","在","+","下","jupter","目录","powershell"],"title":"在任意目录下打开notebook","title_tokens":["任意","notebook","在","打开","下","目录"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_3","text":"通过 pip 安装 jupyterthemes package： # 安装 pip install jupyterthemes # 更新jupyterthemes pip install --upgrade jupyterthemes 安装好 jupyterthemes package之后，就可以在命令行输入 jupyterthemes 的命令： # 列出所有安装好的主题 jt -l # 使用帮助 jt -h 具体使用方法参见： jupyterthemes官方说明","text_tokens":["参见"," ","可以","install","l","h","package","更新","jupyterthemes","说明","jt","官方","在","-","具体","：","列出","所有","方法","主题","输入","通过","使用","帮助","pip","#","安装","好","命令","的","，","就","之后","upgrade","命令行","--"],"title":"自定义主题","title_tokens":["定义","主题","自定义","自定"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_4","text":"安装 jupyter_contrib_nbextensions 包。该插件并不是jupyter notebook官方的插件。具体参考 Unofficial Jupyter Notebook Extensions 和 为Jupyter Notebook安装扩展并启用Configurator 。 # 安装 pip install jupyter_contrib_nbextensions # 或者通过conda安装 conda install -c conda-forge jupyter_contrib_nbextensions # 激活 jupyter contrib nbextension install --user # 启用 jupyter nbextensions_configurator enable --user","text_tokens":["不是","user"," ","install","jupyter","激活","参考","nbextension","c","官方","该","conda","插件","具体","-","configurator","enable","contrib","通过","pip","nbextensions","扩展","#","forge","notebook","。","或者","安装","包","unofficial","_","和","启用","并","的","extensions","为","--"],"title":"安装扩展","title_tokens":["扩展","安装"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#pdf","text":"jupyter notebook本身不能输出pdf，输出pdf依赖于$\\LaTeX$引擎。目前，带有中文的ipynb文件输出为pdf会报错，主要原因是jupyter的$\\LaTeX$模板设置了$\\text{pdf}\\LaTeX$引擎，但是Pdf$\\LaTeX$不可以直接编译中文文档的。因此，需要把jupyter的$\\LaTeX$引擎改为$\\text{Xe}\\LaTeX$引擎。 修改模板，模板位置为：...\\site-packages\\nbconvert\\templates\\latex\\article.tplx，将latex模板类由article改为ctexart。 原来的代码： ((* block docclass *)) \\documentclass [11pt] { article } ((* endblock docclass *)) 修改后的代码： ((* block docclass *)) \\documentclass [13pt] { ctexart } ((* endblock docclass *)) 或者，依然使用PdfLatex引擎，但引入xeCJK宏包： \\documentclass [11pt] { article } \\usepackage { xeCJK } % 如果设置mainfont，必须设置为已安装的中文字体，例如微软雅黑。 %\\setCJKmainfont{SourceHanSansCN-Light} 想要修改输出pdf的排版，则需要修改其预定义的latex排版模板，即base.tplx文件。例如可以在base.tplx加入如下代码控制输出的pdf的页边距。 \\geometry { a4paper,left=2cm,right=2cm,top=1cm,bottom=1cm } 但是，可能改了jupyter的latex模板，jupyter notebook输出pdf依然报错。例如下面的报错信息： nbconvert failed: PDF creating failed, captured latex output: This is XeTeX, Version 3.14159265-2.6-0.99999 (TeX Live 2018/W32TeX) (preloaded format=xelatex) restricted \\write18 enabled. entering extended mode ! Undefined control sequence. <*> .\\notebook .tex ? ! Emergency stop. <*> .\\notebook .tex No pages of output. Transcript written on ?. 这是jupyter中控制调用latex引擎的脚本pdf.py有bug，位于66行。 原来的代码： writer = Instance ( \"nbconvert.writers.FilesWriter\" , args = (), kw = { 'build_directory' : '.' }) 正确的代码： writer = Instance ( \"nbconvert.writers.FilesWriter\" , args = (), kw = { 'build_directory' : '' }) 原来的代码给xelatex引擎发送了错误的文件路径： 错误的路径： xelatex .\\notebook.tex 正确的路径： xelatex notebook.tex 详细内容参考这里 Problem in Converting Jupyter notebook to pdf #144 。","text_tokens":["output","这是","left","如果","微软","原因","light","不能","pages","mode","control","writers","报错","后","由","2cm","w32tex","}","preloaded","'","mainfont","\\","依然","66","nbconvert","geometry","不","no","written","原来","*","发送","义","#","调用","stop","3.14159265","引入","安装","transcript","改了","on","把","路径","extended","...","信息","_","修改","位置","13pt","in","captured","控制","边","enabled","ipynb","字体","2018","templates","中文字体","中",">","必须","xetex","可以","{","directory","正确","failed","是","加入","$","距","block","会","/","documentclass","在","xecjk","instance","脚本","类","?","writer","args","xelatex","[","pdflatex","top","位于","但","错误","bottom","docclass","雅黑","version","为","144","，","sequence","文字","依赖","例如","entering","]","latex","jupyter","依赖于","参考","live","endblock","0.99999","write18","=","-",":","ctexart","：","is","直接","目前",")","赖于","预定","usepackage","notebook","本身","。","right","to","format","2.6","base","详细","的","其","因此","带有","sourcehansanscn","undefined","行","text","fileswriter","tplx","setcjkmainfont","排版","了",".","给","页","1cm","build","如下","of"," ","但是","tex","<","这里","11pt","emergency","输出","代码","restricted","设置","改为","py","converting","article","主要","下面","a4paper","creating","\"","想要","将","文档","有","内容",",","使用","则","模板","!","宏包","引擎","site","bug","%","problem","或者","可能","中文","即","pdf","this","编译","需要","(","文件","kw","xe","packages","已"],"title":"输出带有中文的pdf","title_tokens":["的","带有","中文","pdf","输出"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_5","text":"Save and CheckPoint 和 Revert to CheckPoint。","text_tokens":["and","和"," ","checkpoint","save","to","revert","。"],"title":"版本控制","title_tokens":["版本控制","控制","版本"]},{"location":"标准库/8.1.string.html","text":"Windows 10 Python 3.7.3 @ MSC v.1915 64 bit (AMD64) Template 在 string.Template 中，通过前置 $ 来识别变量（例如， $var ）。另外， 如果有需要，可以通过大括号将它们从周围的文本中分开（例如， ${var} ）。 通过例子来对比下： values = { 'var' : 'foo' } t = string . Template ( \"\"\" Variable : $var Escape : $$ Variable in text: $ {var} iable \"\"\" ) print ( 'TEMPLATE:' , t . substitute ( values )) s = \"\"\" Variable : %(var)s Escape : %% Variable in text: %(var)s iable \"\"\" print ( 'INTERPOLATION:' , s % values ) s = \"\"\" Variable : {var} Escape : {{}} Variable in text: {var} iable \"\"\" print ( 'FORMAT:' , s . format ( ** values )) TEMPLATE : Variable : foo Escape : $ Variable in text : fooiable INTERPOLATION : Variable : foo Escape : % Variable in text : fooiable FORMAT : Variable : foo Escape : {} Variable in text : fooiable 前两种情况，触发字符（ $ 和 % ）需要重复两次来转义。对于第三种格式化语法， { 和 } 都需要重复才能转义。 Template 没有可用的格式化选项。例如，无法控制用来表示浮点数的数字的个数。 使用 safe_substitute() 方法可以带来一个好处，那就是如果模板需要的值没有全部作为参数提供给模板的话可以避免发生异常。 values = { 'var' : 'foo' } t = string . Template ( \"$var is here but $missing is not provided\" ) try : print ( 'substitute() :' , t . substitute ( values )) except KeyError as err : print ( 'ERROR:' , str ( err )) print ( 'safe_substitute():' , t . safe_substitute ( values )) ERROR: 'missing' safe_substitute(): foo is here but $missing is not provided 因为在 values 字典中没有值提供给 missing , 所以 substitute() 会抛出一个 KeyError 异常。而 safe_substitute() 将捕捉这个异常并将变量表达式单独留在文本中而不是抛出异常。 string.Template 缺省语法可以通过改变正则表达式模式来调整，这个正则表达式一般是用来寻找模板内容内变量名字的。 简单的方法是通过改变 delimiter 和 idpattern 的类属性来做调整。 class MyTemplate ( string . Template ): delimiter = '%' idpattern = '[a-z]+_[a-z]+' template_text = ''' Delimiter : %% Replaced : %with_underscore Ignored : %notunderscored ''' d = { 'with_underscore' : 'replaced' , 'notunderscored' : 'not replaced' , } t = MyTemplate ( template_text ) print ( 'Modified ID pattern:' ) print ( t . safe_substitute ( d )) Modified ID pattern : Delimiter : % Replaced : replaced Ignored : % notunderscored 在这个示例里，替换规则进行了变更，分隔符用 % 来替代了 $ 并且变量名字中必须包含下划线。 %notunderscored 模式并没有被替换，因为它不包括下划线字符。 对于更复杂的改变，可以通过覆写 pattern 属性和定义一个全新的正则表达式来实现。覆写的模式必须提供四个命名组来获取未识别的分隔符、命名的变量、大括号模式的变量名称、和无效的分隔符模式。 t.pattern 的值是编译好的正则表达式，但是原始字符串可以通过它的 pattern 属性来获取 t = string . Template ( '$var' ) print ( t . pattern . pattern ) \\$(?: (?P<escaped>\\$) | # Escape sequence of two delimiters (?P<named>(?a:[_a-z][_a-z0-9]*)) | # delimiter and a Python identifier {(?P<braced>(?a:[_a-z][_a-z0-9]*))} | # delimiter and a braced identifier (?P<invalid>) # Other ill-formed delimiter exprs ) 下面的示例定义了一个新的模式来生成一种新的模板，使用 {{var}} 作为变量语法。 import re import string class MyTemplate ( string . Template ): delimiter = '{{' pattern = r ''' \\{\\{(?: (?P<escaped>\\{\\{)| (?P<named>[_a-z][_a-z0-9]*)\\}\\}| (?P<braced>[_a-z][_a-z0-9]*)\\}\\}| (?P<invalid>) ) ''' t = MyTemplate ( ''' {{{{ {{var}} ''' ) print ( 'MATCHES:' , t . pattern . findall ( t . template )) print ( 'SUBSTITUTED:' , t . safe_substitute ( var = 'replacement' )) MATCHES: [('{{', '', '', ''), ('', 'var', '', '')] SUBSTITUTED: {{ replacement named 和 braced 两个模式都必须单独提供，虽然它们都是一样的。 Formatter Formatter 类的执行效果与 str 的 format() 方法一致，它的特征包括型态转换，排列，属性以及字段引用，已命名特定位置的模板参数， 以及特定类型的格式化选项。通常 format() 方法对于这些特征是最便捷的接口，但 Formatter 提供了建立子类的方法，在需要多态情况下使用。 常量 string 模块包含了与 ASCII 、数字字符相关的一系列常量。这些常量在处理 ASCII 数据时是非常有效的，但是现在大家会越来越多的遇到 Unicode 类型的非 ASCII 文本，在这个情况下的这些常量的作用就很有限了。 import inspect import string def is_str ( value ): return isinstance ( value , str ) for name , value in inspect . getmembers ( string , is_str ): if name . startswith ( '_' ): continue print ( ' %s = %r \\n ' % ( name , value )) ascii_letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ascii_lowercase = 'abcdefghijklmnopqrstuvwxyz' ascii_uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' digits = '0123456789' hexdigits = '0123456789abcdefABCDEF' octdigits = '01234567' printable = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\' () *+ , - . / :; <=>?@ [ \\\\ ] ^ _ ` { | } ~ \\ t \\ n \\ r \\ x0b \\ x0c ' punctuation=' ! \" # $ %& \\ '()*+,-./:;<=>?@[\\\\]^_`{|}~' whitespace = ' \\t\\n\\r\\x0b\\x0c'","text_tokens":["浮点","字","转义","10","substitute","matches","最","'","%%","two","findall","调整","interpolation","不","*","+_","字典","hexdigits","分隔","in","对于","段","分开","-.","64","不是","转换","{","substituted","子类","是","0123456789abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz","格式",";","not","四个","文本","表达式","并","python","实现","digits","sequence","3","两种","替换","周围","and","包括","来","ill","语法","数字","is","有效","n",")","underscore","。","escape","error","的","exprs","特定","识别","了"," ","捕捉","<","+","字符串","处理","这个","unicode","将","使用","delimiter","!","but","便捷","%","a","octdigits","被","那","很","它","value","里","}","amd64","系列","\\","startswith","获取","lowercase","try","printable","未","三种","改变","重复","因为","_","和","位置","提供","单独","对比","中","必须","多态","缺省","做","留在","示例","continue","一种","uppercase","而","str","3.7","简单","z","isinstance","whitespace","好","，","可用","与","]","建立","print","没有","都","mytemplate","越来越","接口","划线","两次","string","getmembers","替代","=","多","import","正则表达式","format","并且","ascii","变更","就","给","escaped","of","用","err","点数","的话","下面","有","下划线","safe","ignored","包含","formatter","except","带来","两个","(","前置","例子","名称","用来","参数","s","规则","如果","原始","identifier","idpattern","时","名字","生成","类型","通过","另外","字符","无法控制","msc","正则","variable","控制","全新","%&","前","other","变量","可以","keyerror","好处","named","$","@","template","会","寻找","全部","内","方法","一样","x0c","类","非常","更","属性","[","missing","|","t","值","大家","表达","例如","遇到","provided","一般","进行","name","越来","here","组来","才能","delimiters","windows","^","命名","replaced","个数","foo",":","9","情况","values","bit","特征","0123456789","text","v.1915",".","通常","无效","但是","z0","一个","class","浮点数","letters","\"","这些","if","下划","def","现在","一致","p","编译","需要","（","已","作用","发生","01234567","punctuation","for","虽然","格式化","fooiable","d","括号","invalid","~","inspect","braced","#","它们","模块","0123456789abcdefabcdef","有限","选项","id","replacement","）","re",">","无法","r","、","排列","/","在","?","引用","pattern","一系","但","with","以及","abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz","x0b","abcdefghijklmnopqrstuvwxyz","表示","formed","覆写","-","modified","复杂","：","效果","新","第三种","所以","大括号","就是","notunderscored","型态","一系列","return","相关","异常","`","非","定义","数据","iable","避免","常量","内容",",","模板","执行","从","作为","抛出","下","分隔符","第三","触发","as","var","达式","模式"],"title":"8.1.string","title_tokens":["8.1",".","string"]},{"location":"标准库/8.1.string.html#template","text":"在 string.Template 中，通过前置 $ 来识别变量（例如， $var ）。另外， 如果有需要，可以通过大括号将它们从周围的文本中分开（例如， ${var} ）。 通过例子来对比下： values = { 'var' : 'foo' } t = string . Template ( \"\"\" Variable : $var Escape : $$ Variable in text: $ {var} iable \"\"\" ) print ( 'TEMPLATE:' , t . substitute ( values )) s = \"\"\" Variable : %(var)s Escape : %% Variable in text: %(var)s iable \"\"\" print ( 'INTERPOLATION:' , s % values ) s = \"\"\" Variable : {var} Escape : {{}} Variable in text: {var} iable \"\"\" print ( 'FORMAT:' , s . format ( ** values )) TEMPLATE : Variable : foo Escape : $ Variable in text : fooiable INTERPOLATION : Variable : foo Escape : % Variable in text : fooiable FORMAT : Variable : foo Escape : {} Variable in text : fooiable 前两种情况，触发字符（ $ 和 % ）需要重复两次来转义。对于第三种格式化语法， { 和 } 都需要重复才能转义。 Template 没有可用的格式化选项。例如，无法控制用来表示浮点数的数字的个数。 使用 safe_substitute() 方法可以带来一个好处，那就是如果模板需要的值没有全部作为参数提供给模板的话可以避免发生异常。 values = { 'var' : 'foo' } t = string . Template ( \"$var is here but $missing is not provided\" ) try : print ( 'substitute() :' , t . substitute ( values )) except KeyError as err : print ( 'ERROR:' , str ( err )) print ( 'safe_substitute():' , t . safe_substitute ( values )) ERROR: 'missing' safe_substitute(): foo is here but $missing is not provided 因为在 values 字典中没有值提供给 missing , 所以 substitute() 会抛出一个 KeyError 异常。而 safe_substitute() 将捕捉这个异常并将变量表达式单独留在文本中而不是抛出异常。 string.Template 缺省语法可以通过改变正则表达式模式来调整，这个正则表达式一般是用来寻找模板内容内变量名字的。 简单的方法是通过改变 delimiter 和 idpattern 的类属性来做调整。 class MyTemplate ( string . Template ): delimiter = '%' idpattern = '[a-z]+_[a-z]+' template_text = ''' Delimiter : %% Replaced : %with_underscore Ignored : %notunderscored ''' d = { 'with_underscore' : 'replaced' , 'notunderscored' : 'not replaced' , } t = MyTemplate ( template_text ) print ( 'Modified ID pattern:' ) print ( t . safe_substitute ( d )) Modified ID pattern : Delimiter : % Replaced : replaced Ignored : % notunderscored 在这个示例里，替换规则进行了变更，分隔符用 % 来替代了 $ 并且变量名字中必须包含下划线。 %notunderscored 模式并没有被替换，因为它不包括下划线字符。 对于更复杂的改变，可以通过覆写 pattern 属性和定义一个全新的正则表达式来实现。覆写的模式必须提供四个命名组来获取未识别的分隔符、命名的变量、大括号模式的变量名称、和无效的分隔符模式。 t.pattern 的值是编译好的正则表达式，但是原始字符串可以通过它的 pattern 属性来获取 t = string . Template ( '$var' ) print ( t . pattern . pattern ) \\$(?: (?P<escaped>\\$) | # Escape sequence of two delimiters (?P<named>(?a:[_a-z][_a-z0-9]*)) | # delimiter and a Python identifier {(?P<braced>(?a:[_a-z][_a-z0-9]*))} | # delimiter and a braced identifier (?P<invalid>) # Other ill-formed delimiter exprs ) 下面的示例定义了一个新的模式来生成一种新的模板，使用 {{var}} 作为变量语法。 import re import string class MyTemplate ( string . Template ): delimiter = '{{' pattern = r ''' \\{\\{(?: (?P<escaped>\\{\\{)| (?P<named>[_a-z][_a-z0-9]*)\\}\\}| (?P<braced>[_a-z][_a-z0-9]*)\\}\\}| (?P<invalid>) ) ''' t = MyTemplate ( ''' {{{{ {{var}} ''' ) print ( 'MATCHES:' , t . pattern . findall ( t . template )) print ( 'SUBSTITUTED:' , t . safe_substitute ( var = 'replacement' )) MATCHES: [('{{', '', '', ''), ('', 'var', '', '')] SUBSTITUTED: {{ replacement named 和 braced 两个模式都必须单独提供，虽然它们都是一样的。","text_tokens":["例子","发生","名称","浮点","用来","参数","s","规则","如果","它","虽然","转义","格式化","原始","identifier","idpattern","substitute","matches","里","'","}","fooiable","名字","生成","two","\\","findall","d","括号","调整","interpolation","invalid","获取","不","通过","另外","*","字符","无法控制","braced","#","+_","它们","try","未","字典","三种","改变","重复","正则","分隔","因为","_","和","选项","variable","in","id","对于","提供","控制","单独","全新","分开","replacement","）","对比","re","前","中","不是",">","必须","other","变量","可以","无法","{","keyerror","缺省","留在","做","substituted","示例","好处","r","是","、","named","一种","$","template","会","寻找","而","格式","在","全部","str","内","简单","方法","not","一样","类","四个","?","z","更","属性","pattern","文本","[","missing","|","表达式","t","值","好","with","表达","并","python","，","实现","可用","sequence","表示","例如","provided","一般","进行","两种","]","here","组来","才能","替换","周围","delimiters","print","没有","都","and","命名","mytemplate","formed","包括","来","replaced","划线","ill","两次","string","覆写","替代","=","个数","foo","语法","数字",":","-","modified","9","复杂","：","情况","新","is","values","第三种",")","所以","大括号","underscore","就是","import","。","notunderscored","正则表达式","escape","format","并且","error","模式","的","exprs","变更","text","识别",".","给","了","异常","escaped","of","无效","用"," ","err","捕捉","一个","但是","z0","<","class","+","浮点数","点数","字符串","这个","的话","下面","定义","\"","iable","将","避免","有","内容","下划线",",","使用","safe","模板","delimiter","下划","but","ignored","包含","从","%","作为","抛出","except","下","p","分隔符","编译","需要","第三","触发","带来","(","两个","（","a","前置","as","var","被","达式","%%","那"],"title":"Template","title_tokens":["template"]},{"location":"标准库/8.1.string.html#formatter","text":"Formatter 类的执行效果与 str 的 format() 方法一致，它的特征包括型态转换，排列，属性以及字段引用，已命名特定位置的模板参数， 以及特定类型的格式化选项。通常 format() 方法对于这些特征是最便捷的接口，但 Formatter 提供了建立子类的方法，在需要多态情况下使用。","text_tokens":["了","通常","与","参数","它"," ","字","多态","转换","建立","格式化","子类","命名","是","最","包括","接口","排列","格式","类型","str","这些","在","方法","效果","情况","类","使用","引用","模板",")","属性","执行","formatter","便捷","。","型态","下","一致","format","特征","需要","但","以及","(","选项","的","位置","，","特定","对于","提供","已","段"],"title":"Formatter","title_tokens":["formatter"]},{"location":"标准库/8.1.string.html#_1","text":"string 模块包含了与 ASCII 、数字字符相关的一系列常量。这些常量在处理 ASCII 数据时是非常有效的，但是现在大家会越来越多的遇到 Unicode 类型的非 ASCII 文本，在这个情况下的这些常量的作用就很有限了。 import inspect import string def is_str ( value ): return isinstance ( value , str ) for name , value in inspect . getmembers ( string , is_str ): if name . startswith ( '_' ): continue print ( ' %s = %r \\n ' % ( name , value )) ascii_letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ascii_lowercase = 'abcdefghijklmnopqrstuvwxyz' ascii_uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' digits = '0123456789' hexdigits = '0123456789abcdefABCDEF' octdigits = '01234567' printable = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\' () *+ , - . / :; <=>?@ [ \\\\ ] ^ _ ` { | } ~ \\ t \\ n \\ r \\ x0b \\ x0c ' punctuation=' ! \" # $ %& \\ '()*+,-./:;<=>?@[\\\\]^_`{|}~' whitespace = ' \\t\\n\\r\\x0b\\x0c'","text_tokens":["作用","01234567","punctuation","很","for","s","value","时","'","}","系列","\\","类型","startswith","~","lowercase","inspect","字符","*","#","printable","hexdigits","模块","0123456789abcdefabcdef","有限","_","in","%&","-.",">","{","r","是","continue","、","0123456789abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz","$","@","会","/","uppercase","在","str",";","x0c","?","非常","isinstance","文本","[","whitespace","|","t","一系","abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz","大家","x0b","，","digits","abcdefghijklmnopqrstuvwxyz","遇到","name","与","]","越来","print","^","越来越","string","getmembers","=","数字",":","-","情况","is","有效","n",")","多","import","。","一系列","ascii","的","return","0123456789","就","了",".","相关"," ","但是","<","+","letters","`","非","处理","这个","数据","unicode","\"","这些","if","常量",",","!","def","包含","%","现在","下","(","octdigits"],"title":"常量","title_tokens":["常量"]},{"location":"标准库/8.2.textwrap.html","text":"Windows 10 Python 3.7.3 @ MSC v.1915 64 bit (AMD64) import textwrap from tools import Help as H 删除前导空格和后缀空格 删除第一行的前导空格和最后一行的后缀空格， width 参数控制每一行的宽度： sample_text = ''' The textwrap module can be used to format text for output in situations where pretty-printing is desired. It offers programmatic functionality similar to the paragraph wrapping or filling features found in many text editors. ''' print ( sample_text ) print ( textwrap . fill ( sample_text , width = 50 )) The textwrap module can be used to format text for output in situations where pretty - printing is desired . It offers programmatic functionality similar to the paragraph wrapping or filling features found in many text editors . The textwrap module can be used to format text for output in situations where pretty - printing is desired . It offers programmatic functionality similar to the paragraph wrapping or filling features found in many text editors . 结果并不尽如人意。文本现在是左对齐的，只有第一行保留了缩进，但是原来的每一行的末尾和下一行的开头之间仍有空格。 移除所有空格 使用 dedent() 函数可以移去所有行中的空格前缀和后缀： dedented_text = textwrap . dedent ( sample_text ) print ( dedented_text ) The textwrap module can be used to format text for output in situations where pretty-printing is desired. It offers programmatic functionality similar to the paragraph wrapping or filling features found in many text editors. 因为 dedent 是 indent 的反义词， 所以输出结果是一段删除了每一行中都存在的缩进空白的文字。如果某一行比其他行缩进的更多，多出的部分将不会被移除。 print ( textwrap . dedent ( \"\"\" Line one. Line two. Line three. \"\"\" )) Line one. Line two. Line three. 添加前缀 用 indent() 函数在字符串每一行开头加入前缀文本。这个例子非常类似电子邮件回复中被引用的部分，使用 > 符号来做每行文字的前缀。 dedented_text = textwrap . dedent ( sample_text ) wrapped = textwrap . fill ( dedented_text , width = 50 ) wrapped += ' \\n\\n Second paragraph after a blank line.' print ( wrapped ) final = textwrap . indent ( wrapped , '> ' ) print ( 'Quoted block: \\n ' ) print ( final ) The textwrap module can be used to format text for output in situations where pretty - printing is desired . It offers programmatic functionality similar to the paragraph wrapping or filling features found in many text editors . Second paragraph after a blank line . Quoted block : > The textwrap module can be used to format text > for output in situations where pretty - printing is > desired . It offers programmatic functionality > similar to the paragraph wrapping or filling > features found in many text editors . > Second paragraph after a blank line . 一段文字被分成了几行，每一行文字前都加了前缀，然后每行文字重新组成整个文字段落并返回。 要控制特定的一行接受新前缀，给 indent() 的 predicate 参数赋值。该操作会轮流遍历每行的文本，当值为真时将在该行加上前缀。 def should_indent ( line ): print ( 'Indent {!r} ?' . format ( line )) return len ( line . strip ()) % 2 == 0 dedented_text = textwrap . dedent ( sample_text ) wrapped = textwrap . fill ( dedented_text , width = 50 ) final = textwrap . indent ( wrapped , 'EVEN ' , predicate = should_indent ) print ( ' \\n Quoted block: \\n ' ) print ( final ) Indent ' The textwrap module can be used to format text\\n' ? Indent 'for output in situations where pretty-printing is\\n' ? Indent 'desired. It offers programmatic functionality\\n' ? Indent 'similar to the paragraph wrapping or filling\\n' ? Indent 'features found in many text editors.' ? Quoted block : EVEN The textwrap module can be used to format text for output in situations where pretty - printing is EVEN desired . It offers programmatic functionality EVEN similar to the paragraph wrapping or filling EVEN features found in many text editors . 悬挂缩进 同时也可以设置输出段落的宽度，可以单独控制首行的缩进。 dedented_text = textwrap . dedent ( sample_text ) . strip () print ( textwrap . fill ( dedented_text , initial_indent = '' , subsequent_indent = ' ' * 4 , width = 50 , )) The textwrap module can be used to format text for output in situations where pretty-printing is desired. It offers programmatic functionality similar to the paragraph wrapping or filling features found in many text editors. 减短长文本 为了查看长文本的摘要或预览，可以使用 shorten() 。所有的空格，比如制表符、换行符以及一系列的空格都将标准化为单个空格。然后此文本将减短为要求的长度来显示，在字词边界之间，将不包括不完整的词。 dedented_text = textwrap . dedent ( sample_text ) original = textwrap . fill ( dedented_text , width = 50 ) print ( 'Original: \\n ' ) print ( original ) shortened = textwrap . shorten ( original , 100 ) shortened_wrapped = textwrap . fill ( shortened , width = 50 ) print ( ' \\n Shortened: \\n ' ) print ( shortened_wrapped ) Original : The textwrap module can be used to format text for output in situations where pretty - printing is desired . It offers programmatic functionality similar to the paragraph wrapping or filling features found in many text editors . Shortened : The textwrap module can be used to format text for output in situations where pretty - printing [...] 如果非空字元在原文本中被当作减短的部分被移除，他将替换为占位符。默认值 [...] 可以被替换，在 shorten() 中加入 placeholder 参数。 强制换行 每一行超过20个字符就强制换行（可能会导致单词被拆分）： textwrap . wrap ( sample_text , width = 20 ) [' The textwrap', 'module can be used', 'to format text for', 'output in', 'situations where', 'pretty-printing is', 'desired. It offers', 'programmatic', 'functionality', 'similar to the', 'paragraph wrapping', 'or filling features', 'found in many text', 'editors.']","text_tokens":["output","多出","例子","for","赋值","参数","换行","len","如果","结果","尽如","一段","他","10","found","存在","标准","2","'","}","original","该","amd64","系列","前导","two","\\","长度","超过","paragraph","重新","不","原文","默认","原来","字符","second","*","msc","添加","three","should","长","因为","符","去","删除","pretty","_","和","...","单词","in","此","符号","控制","移除","单独","标准化","used","后缀","shortened","一行","64","）","拆分","前","中",">","电子邮件","导致","可以","做","{","占位","函数","部分","blank","第一","r","module","是","similar","加入","整个","制表符","不会","、","加上","词","@","dedent","block","会","can","反义","在","be","3.7","final","对齐","predicate","wrapping","引用","?","tools","首行","非常","开头","更","然后","20","类似","width","printing","文本","[","当作","第一行","要","一系","以及","100","并","为","after","python","，","查看","editors","回复","仍","文字","wrapped","3","完整","加","]","也","where","it","many","quoted","fill","段落","替换","print","返回","windows","都","操作","shorten","strip","当值","电子","包括","50","只有","dedented","邮件","来","字词","placeholder","4","=","左","-",":","or","：","之间","新","is","人意","bit","indent","为了","n","遍历",")","所以","多","situations","import","。","offers","to","functionality","末尾","format","一系列","减短","显示","的","return","空白","特定","one","接受","行","text","就","个字符","v.1915","最后","预览",".","programmatic","宽度","了","line","每行","给","轮流","该行","用"," ","但是","help","h","空格","制表","the","+","features","filling","缩进","输出","前缀","字符串","保留","desired","设置","减","这个","其他","几行","边界","单个","强制","\"","textwrap","将","subsequent","所有","换行符","有","0","同时","wrap",",","使用","比","!","摘要","或","行中","悬挂","initial","def","%","even","本中","可能","现在","要求","下","非空字","默认值","某","移","真时","比如","尽如人意","(","每","a","（","from","短长","as","反义词","被","元","组成","分成","sample"],"title":"8.2.textwrap","title_tokens":["textwrap",".","8.2"]},{"location":"标准库/8.2.textwrap.html#_1","text":"删除第一行的前导空格和最后一行的后缀空格， width 参数控制每一行的宽度： sample_text = ''' The textwrap module can be used to format text for output in situations where pretty-printing is desired. It offers programmatic functionality similar to the paragraph wrapping or filling features found in many text editors. ''' print ( sample_text ) print ( textwrap . fill ( sample_text , width = 50 )) The textwrap module can be used to format text for output in situations where pretty - printing is desired . It offers programmatic functionality similar to the paragraph wrapping or filling features found in many text editors . The textwrap module can be used to format text for output in situations where pretty - printing is desired . It offers programmatic functionality similar to the paragraph wrapping or filling features found in many text editors . 结果并不尽如人意。文本现在是左对齐的，只有第一行保留了缩进，但是原来的每一行的末尾和下一行的开头之间仍有空格。","text_tokens":["output","for","参数","结果","尽如","found","'","前导","paragraph","不","原来","删除","pretty","_","和","in","控制","used","后缀","一行","第一","module","是","similar","can","be","对齐","wrapping","开头","width","printing","文本","第一行","并","，","editors","仍","where","it","many","fill","print","50","只有","=","左","-","or","：","之间","is","人意",")","situations","。","offers","to","functionality","末尾","format","的","text","最后",".","programmatic","宽度","了"," ","但是","空格","the","features","filling","缩进","保留","desired","textwrap","有",",","现在","下","尽如人意","(","每","sample"],"title":"删除前导空格和后缀空格","title_tokens":["删除","和","前导","空格","后缀"]},{"location":"标准库/8.2.textwrap.html#_2","text":"使用 dedent() 函数可以移去所有行中的空格前缀和后缀： dedented_text = textwrap . dedent ( sample_text ) print ( dedented_text ) The textwrap module can be used to format text for output in situations where pretty-printing is desired. It offers programmatic functionality similar to the paragraph wrapping or filling features found in many text editors. 因为 dedent 是 indent 的反义词， 所以输出结果是一段删除了每一行中都存在的缩进空白的文字。如果某一行比其他行缩进的更多，多出的部分将不会被移除。 print ( textwrap . dedent ( \"\"\" Line one. Line two. Line three. \"\"\" )) Line one. Line two. Line three.","text_tokens":["output","多出","for","如果","结果","一段","found","存在","two","paragraph","three","因为","去","删除","pretty","_","和","in","移除","used","后缀","一行","中","可以","函数","部分","module","是","similar","不会","dedent","can","反义","be","wrapping","更","printing","，","editors","文字","where","it","many","print","都","dedented","=","-","or","：","is","indent",")","所以","多","situations","。","offers","to","functionality","format","的","空白","one","行","text",".","programmatic","了","line"," ","空格","the","features","filling","输出","缩进","前缀","desired","其他","\"","textwrap","将","所有","使用","比","行中","某","移","(","每","反义词","被","sample"],"title":"移除所有空格","title_tokens":["空格","所有","移除"]},{"location":"标准库/8.2.textwrap.html#_3","text":"用 indent() 函数在字符串每一行开头加入前缀文本。这个例子非常类似电子邮件回复中被引用的部分，使用 > 符号来做每行文字的前缀。 dedented_text = textwrap . dedent ( sample_text ) wrapped = textwrap . fill ( dedented_text , width = 50 ) wrapped += ' \\n\\n Second paragraph after a blank line.' print ( wrapped ) final = textwrap . indent ( wrapped , '> ' ) print ( 'Quoted block: \\n ' ) print ( final ) The textwrap module can be used to format text for output in situations where pretty - printing is desired . It offers programmatic functionality similar to the paragraph wrapping or filling features found in many text editors . Second paragraph after a blank line . Quoted block : > The textwrap module can be used to format text > for output in situations where pretty - printing is > desired . It offers programmatic functionality > similar to the paragraph wrapping or filling > features found in many text editors . > Second paragraph after a blank line . 一段文字被分成了几行，每一行文字前都加了前缀，然后每行文字重新组成整个文字段落并返回。 要控制特定的一行接受新前缀，给 indent() 的 predicate 参数赋值。该操作会轮流遍历每行的文本，当值为真时将在该行加上前缀。 def should_indent ( line ): print ( 'Indent {!r} ?' . format ( line )) return len ( line . strip ()) % 2 == 0 dedented_text = textwrap . dedent ( sample_text ) wrapped = textwrap . fill ( dedented_text , width = 50 ) final = textwrap . indent ( wrapped , 'EVEN ' , predicate = should_indent ) print ( ' \\n Quoted block: \\n ' ) print ( final ) Indent ' The textwrap module can be used to format text\\n' ? Indent 'for output in situations where pretty-printing is\\n' ? Indent 'desired. It offers programmatic functionality\\n' ? Indent 'similar to the paragraph wrapping or filling\\n' ? Indent 'features found in many text editors.' ? Quoted block : EVEN The textwrap module can be used to format text for output in situations where pretty - printing is EVEN desired . It offers programmatic functionality EVEN similar to the paragraph wrapping or filling EVEN features found in many text editors .","text_tokens":["例子","output","for","赋值","参数","len","一段","found","2","'","}","该","\\","paragraph","重新","字符","second","should","pretty","_","in","符号","控制","used","一行","前","中",">","电子邮件","做","{","函数","部分","blank","r","module","加入","similar","整个","加上","dedent","block","会","can","在","be","final","predicate","wrapping","引用","?","非常","开头","然后","类似","文本","width","printing","要","并","为","after","，","editors","回复","文字","wrapped","加","where","it","many","quoted","fill","段落","print","返回","都","操作","strip","当值","电子","来","邮件","dedented","50","=",":","-","or","新","is","indent","n","遍历",")","situations","。","offers","to","functionality","format","的","return","特定","接受","text",".","programmatic","了","每行","line","给","轮流","该行","用"," ","the","+","features","filling","前缀","字符串","desired","这个","几行","textwrap","将","0",",","使用","!","def","%","even","真时","(","每","a","被","组成","分成","sample"],"title":"添加前缀","title_tokens":["前缀","添加"]},{"location":"标准库/8.2.textwrap.html#_4","text":"同时也可以设置输出段落的宽度，可以单独控制首行的缩进。 dedented_text = textwrap . dedent ( sample_text ) . strip () print ( textwrap . fill ( dedented_text , initial_indent = '' , subsequent_indent = ' ' * 4 , width = 50 , )) The textwrap module can be used to format text for output in situations where pretty-printing is desired. It offers programmatic functionality similar to the paragraph wrapping or filling features found in many text editors.","text_tokens":["output",".","programmatic","宽度","for","也"," ","where","可以","it","many","fill","段落","print","the","features","输出","缩进","module","strip","filling","similar","50","found","dedented","设置","单独","'","desired","dedent","4","=","can","-","paragraph","textwrap","be","subsequent","or","is","同时","indent","首行",",","wrapping","*",")","initial","situations","width","printing","。","offers","to","functionality","format","pretty","_","(","的","in","，","editors","控制","text","used","sample"],"title":"悬挂缩进","title_tokens":["悬挂","缩进"]},{"location":"标准库/8.2.textwrap.html#_5","text":"为了查看长文本的摘要或预览，可以使用 shorten() 。所有的空格，比如制表符、换行符以及一系列的空格都将标准化为单个空格。然后此文本将减短为要求的长度来显示，在字词边界之间，将不包括不完整的词。 dedented_text = textwrap . dedent ( sample_text ) original = textwrap . fill ( dedented_text , width = 50 ) print ( 'Original: \\n ' ) print ( original ) shortened = textwrap . shorten ( original , 100 ) shortened_wrapped = textwrap . fill ( shortened , width = 50 ) print ( ' \\n Shortened: \\n ' ) print ( shortened_wrapped ) Original : The textwrap module can be used to format text for output in situations where pretty - printing is desired . It offers programmatic functionality similar to the paragraph wrapping or filling features found in many text editors . Shortened : The textwrap module can be used to format text for output in situations where pretty - printing [...] 如果非空字元在原文本中被当作减短的部分被移除，他将替换为占位符。默认值 [...] 可以被替换，在 shorten() 中加入 placeholder 参数。","text_tokens":["output","for","换行","参数","如果","他","found","标准","'","original","系列","\\","长度","paragraph","不","原文","默认","长","符","pretty","_","...","in","此","移除","标准化","used","shortened","中","可以","占位","部分","module","制表符","、","similar","加入","词","dedent","can","在","be","wrapping","然后","文本","width","printing","[","当作","一系","以及","100","为","查看","，","editors","wrapped","完整","]","where","it","many","替换","fill","print","都","shorten","包括","50","来","dedented","字词","placeholder","=",":","-","or","之间","is","为了","n",")","situations","。","offers","to","functionality","一系列","format","减短","显示","的","text","预览",".","programmatic"," ","制表","空格","the","features","filling","desired","边界","单个","将","textwrap","所有","换行符",",","使用","或","摘要","本中","要求","非空字","默认值","比如","(","被","元","sample"],"title":"减短长文本","title_tokens":["短长","减","文本"]},{"location":"标准库/8.2.textwrap.html#_6","text":"每一行超过20个字符就强制换行（可能会导致单词被拆分）： textwrap . wrap ( sample_text , width = 20 ) [' The textwrap', 'module can be used', 'to format text for', 'output in', 'situations where', 'pretty-printing is', 'desired. It offers', 'programmatic', 'functionality', 'similar to the', 'paragraph wrapping', 'or filling features', 'found in many text', 'editors.']","text_tokens":["output","）","拆分",".","programmatic","for","换行","sample","导致"," ","text","where","it","many","]","the","features","filling","module","similar","found","desired","'","会","强制","=","can","超过","-","paragraph","textwrap","be","or","：","is","wrap",",","wrapping","字符",")","20","situations","width","printing","可能","[","offers","to","functionality","format","单词","pretty","(","_","每","（","in","editors","被","就","used","个字符","一行"],"title":"强制换行","title_tokens":["强制","换行"]},{"location":"标准库/8.3.time.html","text":"Windows 10 Python 3.7.3 @ MSC v.1915 64 bit (AMD64) import time import textwrap import warnings # from tools import Help as H warnings . filterwarnings ( \"ignore\" ) 时间模块 time 提供了几种不同类型时间的方法，每一种对不同目的都有用。 标准系统通过调用 time() （模块）报告系统挂钟时间（\"wall clock\" 一般指程序执行时间）。 单调时钟模块 monotonic() 用于估算长时间运行的程序的运行时间，因为即使系统时间发生了变化，它也保证不会后退。 对于程序测试， perf_counter() （模块） 提供了高分辨率的时钟访问方式，使短时间的测试更准确。 CPU 时间可以通过 clock() 获得，而 process_time() 则会返回处理器时间和系统时间的组合。 各个时钟 时钟的实现细节因平台而异。使用 “get_clock_info ()” 来访问关于当前方式的基本信息，包括时钟的分辨率。 当前Python版本所有可用的时钟如下： available_clocks = [ ( 'clock' , time . clock ), ( 'monotonic' , time . monotonic ), ( 'perf_counter' , time . perf_counter ), ( 'process_time' , time . process_time ), ( 'time' , time . time ), ( 'thread_time' , time . thread_time ), ] for clock_name , func in available_clocks : print ( textwrap . dedent ( ''' \\ {name} : adjustable : {info.adjustable} implementation: {info.implementation} monotonic : {info.monotonic} resolution : {info.resolution} current : {current} ''' ) . format ( name = clock_name , info = time . get_clock_info ( clock_name ), current = func ()) ) clock : adjustable : False implementation : QueryPerformanceCounter () monotonic : True resolution : 1 e - 07 current : 516160.6853218 monotonic : adjustable : False implementation : GetTickCount64 () monotonic : True resolution : 0.015625 current : 1123921.625 perf_counter : adjustable : False implementation : QueryPerformanceCounter () monotonic : True resolution : 1 e - 07 current : 516160.6890105 process_time : adjustable : False implementation : GetProcessTimes () monotonic : True resolution : 1 e - 07 current : 565.125 time : adjustable : True implementation : GetSystemTimeAsFileTime () monotonic : False resolution : 0.015625 current : 1580735857.8439054 thread_time : adjustable : False implementation : GetThreadTimes () monotonic : True resolution : 1 e - 07 current : 528.671875 Windows 10 的输出显示其 perf_counter 和 clocks 模块调用相同的底层。clocks 在Python 3.8会被移除。 挂钟时间——time time 模块的核心函数之一是 time() ，它可以把从 「epoch」 开始之后的秒数以浮点数的格式返回。 print ( 'The time is:' , time . time ()) print ( 'The time is:' , time . time_ns ()) The time is: 1580735857.8729014 The time is: 1580735857877901000 时元 (epoch) 是测量时间的开始，对于 Unix 系统来说，时元是 1970 年 1 月 1 日 0 点。 虽然该数值一直是一个浮点数，但是它的实际精度是依赖于平台的。 虽然浮点表示在存储或者比较日期时非常有效，但是，在生成人类可读的表示时就显得有点力不从心。对于记录或者打印时间， ctime() 可能会更有效。 ctime() 将自epoch以来的时间（以秒为单位）转换为本地时间的字符串。这等效于 asctime(localtime(seconds)) 。如果时间元组不存在，则使用localtime()返回的当前时间。 print ( 'The time is:' , time . ctime ()) The time is: Mon Feb 3 21:17:37 2020 单调时钟——monotonic 因为 time() 函数返回的时间值是系统时钟，并且，为了在多台计算机之间同步时钟，系统时钟可以被用户或者是系统服务更改；所以，在重复调用 time() 函数时产生的时间值可能会有前后波动。在测量持续时间或者使用这些时间进行计算的时候，这可能会导致意料之外的行为。通过使用 monotonic() 函数就可以避免这些情况，因为 monotonic() 函数总是返回前向的时间值。 start = time . monotonic () time . sleep ( 0.1 ) end = time . monotonic () print ( 'start : {:>9.2f} ' . format ( start )) print ( 'end : {:>9.2f} ' . format ( end )) print ( 'span : {:>9.2f} ' . format ( end - start )) start : 1123921.73 end : 1123921.84 span : 0.11 我们并没有定义单调时钟的起始点。因此， 只有在使用其它时钟值进行计算时，单调时钟的返回值才会有用。 在这个例子中，睡眠的持续时间就是用 monotonic() 函数测量的。 处理器时钟时间 time() 函数返回的是挂钟时间， perf_counter() 函数返回的是处理器时钟时间。 perf_counter() 函数的返回值反映了程序运行时使用的实际时间。 for i in range ( 4 ): time . sleep ( 1 ) print ( time . ctime (), ': {:0.3f} {:0.3f} ' . format ( time . time (), time . perf_counter ())) Mon Feb 3 21:17:39 2020 : 1580735859.086 516161.933 Mon Feb 3 21:17:40 2020 : 1580735860.087 516162.934 Mon Feb 3 21:17:41 2020 : 1580735861.088 516163.935 Mon Feb 3 21:17:42 2020 : 1580735862.089 516164.936 如果你想要在自己的系统上运行这个例子，需要想办法增加单次内循环的循环周期或者显著地增加循环的总次数，才可以真正地看到时间差异。（如果循环周期太短，循环次数太少的话，返回的时间值可能还没有来得及变化，整个程序就结束了。） 通常情况下，如果程序什么事情没有做，处理器时钟就不会滴答计时，或者计时量很小。 print ( time . ctime (), ': {:0.3f} {:0.3f} ' . format ( time . time (), time . clock ())) for i in range ( 4 ): print ( 'Sleeping' ) print ( time . ctime (), ': {:0.3f} {:0.3f} ' . format ( time . time (), time . clock ())) Mon Feb 3 21:17:42 2020 : 1580735862.112 516164.959 Sleeping Mon Feb 3 21:17:42 2020 : 1580735862.113 516164.960 Sleeping Mon Feb 3 21:17:42 2020 : 1580735862.113 516164.961 Sleeping Mon Feb 3 21:17:42 2020 : 1580735862.114 516164.961 Sleeping Mon Feb 3 21:17:42 2020 : 1580735862.114 516164.961 性能计数器 有一个高分辨率的单调时钟来衡量性能是非常重要的。要想确定最佳时钟数据源，需要一些特定于平台的知识，这些知识由 Python 中的 perf_counter() 提供。 和 monotonic() 函数一样， perf_counter() 函数的时元（epoch）是未定义的。并且，函数的这些返回值用于比较和计算，而不是用作绝对时间。 struct_time 按秒计数，把秒作为单位来存储时间在某些场合很适用，但有时候程序需要访问的（或者说程序感兴趣的）是日期的不同单位所对应的各个部分（比如，某年、某月等）。为了让日期的各个部分便于访问， time 模块定义了 struct_time ，它以各个部分分离的格式来存储日期和时间值。 有些函数以 struct_time 类型的数值作为参数，而不是浮点型的数值。 gmtime() 函数返回当前 UTC 1 时间（世界标准时间）。 localtime() 函数返回的是与当前时区的当前时间 。 mktime() 接收一个 struct_time 型数值并将其转换为浮点型数值。 print ( time . gmtime ()) print ( \"\" ) print ( time . localtime ()) time . struct_time ( tm_year = 2020 , tm_mon = 2 , tm_mday = 3 , tm_hour = 13 , tm_min = 17 , tm_sec = 42 , tm_wday = 0 , tm_yday = 34 , tm_isdst = 0 ) time . struct_time ( tm_year = 2020 , tm_mon = 2 , tm_mday = 3 , tm_hour = 21 , tm_min = 17 , tm_sec = 42 , tm_wday = 0 , tm_yday = 34 , tm_isdst = 0 ) 与时区相关的工作 确定当前时间的函数依赖于时区设置，时区可以由程序设置，也可以使用系统的默认时区设置。改变时区并不会改变实际的时间，只是改变它的表现方式。 time 模块有4个属性记录了时区的信息： import os def show_zone_info (): print ( ' TZ :' , os . environ . get ( 'TZ' , '(not set)' )) print ( ' tzname:' , str ( time . tzname ) . encode ( 'latin-1' ) . decode ( 'gbk' )) print ( ' Zone : {} ( {} )' . format ( time . timezone , ( time . timezone / 3600 ))) print ( ' DST :' , time . daylight ) print ( ' ALZone : {} ( {} )' . format ( time . altzone , ( time . altzone / 3600 ))) print ( ' Time :' , time . ctime ()) print () show_zone_info () TZ : (not set) tzname: ('中国标准时间', '中国夏令时') Zone : -28800 (-8.0) DST : 0 ALZone : -32400 (-9.0) Time : Mon Feb 3 21:17:42 2020 解析和格式化时间 有两个函数 —— strptime() 和 strftime() —— 可以使时间值在 struct_time 表示和字符串表示之间相互转换。有一个很长的格式说明列表可以用来支持不同格式的输入和输出。完整的列表记录在 time 模块的库文件中。 这个例子将当前时间从字符串格式转换成 struct_time 实例，然后又将其转换为字符串格式。 struct_time → 浮点数时间（秒） struct_time = time . localtime () print ( struct_time ) seconds = time . mktime ( struct_time ) print ( seconds ) time.struct_time(tm_year=2020, tm_mon=2, tm_mday=3, tm_hour=21, tm_min=17, tm_sec=42, tm_wday=0, tm_yday=34, tm_isdst=0) 1580735862.0 浮点数时间 → struct_time 浮点数时间 → 字符串时间 print ( time . time ()) time . ctime ( time . time ()) 1580735862.2027004 'Mon Feb 3 21:17:42 2020' 字符串时间 → struct_time print ( time . ctime ( time . time ())) time . strptime ( time . ctime ( time . time ())) Mon Feb 3 21:17:42 2020 time.struct_time(tm_year=2020, tm_mon=2, tm_mday=3, tm_hour=21, tm_min=17, tm_sec=42, tm_wday=0, tm_yday=34, tm_isdst=-1) struct_time → 字符串时间 print ( time . localtime ()) time . strftime ( \" %a %b %d %H:%M:%S %Y\" , time . localtime ()) time.struct_time(tm_year=2020, tm_mon=2, tm_mday=3, tm_hour=21, tm_min=17, tm_sec=42, tm_wday=0, tm_yday=34, tm_isdst=0) 'Mon Feb 03 21:17:42 2020' time . asctime ( time . localtime ()) 'Mon Feb 3 21:17:42 2020' 0时区的时间是UTC时间，UTC时间和格林威治标准时间（GMT）很接近，大多数情况下两者相互替代不会出问题，但严格来说UTC和GMT并不相等。 ↩","text_tokens":["程序运行","浮点","多数","42","10","持续","'","该","1580735860.087","很长","持续时间","set","表现","不","各个","默认","调用","秒","计数","行为","支持","信息","存储","in","总","对于","这","wall","中国","64","不是","转换","{","对应","部分","是","估算","整个","environ","不会","range","格式","516160.6853218","altzone","产生","not","decode","程序","方式","tools","睡眠","struct","并","python","实现","计数器","0.11","依赖","3","13","短时间","ignore","等效于","32400","很小","访问","严格来说","等","包括","来","相同","报告","工作","处理器","1580735861.088","show","is","更改","库","有效",")","赖于","相等","计算","适用","大多数","。","看到","打印","implementation","基本","m","的","其","特定","因此","某月","列表","getthreadtimes","版本","了","保证"," ","循环","help","h","未定义","兴趣","start","字符串","处理","这个","0.3","latin","以来","实例","将","换成","周期","则","使用","end","tz","辨率","%","多台计算机","比如","time","516161.933","a","格林","大多","被","总是","很","未定","seconds","它","相互","绝对","1580735862.114","1580735862.113","strftime","说明","实际","由","2","ns","}","amd64","挂钟","\\","current","mon","目的","还","后退","sec","办法","输入","改变","重复","因为","_","和","提供","系统","最佳","中","做","解析","516163.935","565.125","函数","当前","hour","增加","；","一种","yday","b","528.671875","dedent","关于","tzname","而","false","str","3.7","2020","少","year","不同","某些","41","516164.960","滴答","区","，","可用","filterwarnings","1580735859.086","与","]","e","衡量","型","timezone","print","单次","没有","都","func","替代","=","即使","接收","我们","场合","来得","mktime","import","sleep","理器","底层","asctime","时候","format","日","epoch","adjustable","并且","分辨","格林威治","就","时区","」","程序执行","力不从心","使","用","1580735862.089","按","the","1","点数","几种","月","设置","8.0","的话","运行","monotonic","「","clock","有","夏令","utc","zone","resolution","变化","0.1","两个","(","或者说","例子","1123921.625","span","daylight","用来","参数","s","如果","→","同步","而异","确定","—","时","结束","生成","类型","才","516162.934","有些","感兴趣","gmtime","严格","于","通过","差异","字符","unix","msc","多台","一些","有用","之一","转换成","07","细节","所","前","数据源","两者","自己","1970","数值","可以","516164.936","“","34","单调","来说","@","会","日期","你","内","1123921.84","方法","一样","非常","更","属性","然后","开始","info","[","有点","太","getprocesstimes","本地","接近","sleeping","要","值","mday","1580735862.2027004","1580735857.8729014","21","为","时钟","1580735862.0","tm","一般","进行","counter","9.0","name","gmt","对","windows","依赖于","反映","warnings","只有","get","4","性能",":","1580735862.112","自","便于","之间","情况","算机","thread","bit","f","为了","分辨率","精度","用作","alzone","重要","服务","显示","高分辨率","因","点","v.1915","问题",".","什么","通常","os","localtime","但是","一个","浮点数","isdst","clocks","0.015625","\"","显著","想要","这些","指","所有","0","返回值","def","只是","想","cpu","516160.6890105","可读","感兴","需要","测量","世界","3600","（","地","文件","计时","process","发生","gbk","for","39","虽然","feb","格式化","存在","之外","标准","个","gettickcount64","有时候","d","意料","测试","true","#","perf","516164.959","模块","把","太短","意料之外","短时","移除","人类","）","比较","起始","40","一直",">","导致","getsystemtimeasfiletime","计算机","用于","事情","用户","、","让","有时","/","显得","在","wday","来得及","available","准确","min","1123921.73","等效","37","上","次数","元组","ctime","组合","但","dst","03","之后","表示","某年","完整","9.2","也","i","高分","返回","秒数","前后","获得","encode","y","记录","17","-","：","长时间","平台","所以","就是","1580735857877901000","量","3.8","分离","queryperformancecounter","其它","相关","如下","真正","又","输出","夏令时","出","单位","向","波动","定义","数据","textwrap","避免","516164.961","↩",",","知识","时间","执行","年","”","从","作为","strptime","以","或者","可能","下","时元","28800","每","1580735857.8439054","from","核心","as"],"title":"8.3.time","title_tokens":[".","8.3","time"]},{"location":"标准库/8.3.time.html#_1","text":"时钟的实现细节因平台而异。使用 “get_clock_info ()” 来访问关于当前方式的基本信息，包括时钟的分辨率。 当前Python版本所有可用的时钟如下： available_clocks = [ ( 'clock' , time . clock ), ( 'monotonic' , time . monotonic ), ( 'perf_counter' , time . perf_counter ), ( 'process_time' , time . process_time ), ( 'time' , time . time ), ( 'thread_time' , time . thread_time ), ] for clock_name , func in available_clocks : print ( textwrap . dedent ( ''' \\ {name} : adjustable : {info.adjustable} implementation: {info.implementation} monotonic : {info.monotonic} resolution : {info.resolution} current : {current} ''' ) . format ( name = clock_name , info = time . get_clock_info ( clock_name ), current = func ()) ) clock : adjustable : False implementation : QueryPerformanceCounter () monotonic : True resolution : 1 e - 07 current : 516160.6853218 monotonic : adjustable : False implementation : GetTickCount64 () monotonic : True resolution : 0.015625 current : 1123921.625 perf_counter : adjustable : False implementation : QueryPerformanceCounter () monotonic : True resolution : 1 e - 07 current : 516160.6890105 process_time : adjustable : False implementation : GetProcessTimes () monotonic : True resolution : 1 e - 07 current : 565.125 time : adjustable : True implementation : GetSystemTimeAsFileTime () monotonic : False resolution : 0.015625 current : 1580735857.8439054 thread_time : adjustable : False implementation : GetThreadTimes () monotonic : True resolution : 1 e - 07 current : 528.671875 Windows 10 的输出显示其 perf_counter 和 clocks 模块调用相同的底层。clocks 在Python 3.8会被移除。","text_tokens":["1123921.625","for","而异","10","'","}","current","\\","gettickcount64","true","调用","perf","模块","_","信息","和","07","in","细节","移除","getsystemtimeasfiletime","{","565.125","当前","“","528.671875","dedent","关于","会","false","在","516160.6853218","available","方式","info","[","getprocesstimes","python","实现","，","可用","时钟","counter","name","]","e","print","windows","访问","func","包括","来","相同","get","=",":","-","：","thread","平台","分辨率",")","。","底层","implementation","3.8","基本","format","queryperformancecounter","adjustable","显示","因","分辨","的","其","getthreadtimes","版本",".","如下"," ","1","输出","clocks","0.015625","monotonic","textwrap","所有","clock",",","使用","”","辨率","resolution","516160.6890105","time","(","1580735857.8439054","被","process"],"title":"各个时钟","title_tokens":["时钟","各个"]},{"location":"标准库/8.3.time.html#time","text":"time 模块的核心函数之一是 time() ，它可以把从 「epoch」 开始之后的秒数以浮点数的格式返回。 print ( 'The time is:' , time . time ()) print ( 'The time is:' , time . time_ns ()) The time is: 1580735857.8729014 The time is: 1580735857877901000 时元 (epoch) 是测量时间的开始，对于 Unix 系统来说，时元是 1970 年 1 月 1 日 0 点。 虽然该数值一直是一个浮点数，但是它的实际精度是依赖于平台的。 虽然浮点表示在存储或者比较日期时非常有效，但是，在生成人类可读的表示时就显得有点力不从心。对于记录或者打印时间， ctime() 可能会更有效。 ctime() 将自epoch以来的时间（以秒为单位）转换为本地时间的字符串。这等效于 asctime(localtime(seconds)) 。如果时间元组不存在，则使用localtime()返回的当前时间。 print ( 'The time is:' , time . ctime ()) The time is: Mon Feb 3 21:17:37 2020","text_tokens":["浮点","seconds","它","如果","虽然","feb","实际","存在","时","'","ns","该","生成","mon","不","字符","unix","秒","模块","把","之一","_","存储","对于","这","人类","系统","）","比较","一直","1970","数值","可以","转换","函数","当前","是","来说","会","显得","格式","在","日期","2020","非常","更","开始","等效","37","有点","本地","元组","ctime","1580735857.8729014","21","为","，","依赖","表示","之后","3","等效于","print","秒数","返回","依赖于","记录","17",":","自","is","平台","有效",")","精度","赖于","1580735857877901000","。","打印","asctime","日","epoch","点","的","就","」","力不从心",".","localtime"," ","但是","一个","the","浮点数","点数","1","字符串","月","单位","以来","将","「","0",",","则","使用","时间","年","从","以","或者","可能","可读","时元","time","测量","(","（","核心"],"title":"挂钟时间——time","title_tokens":["时间","挂钟","—","time"]},{"location":"标准库/8.3.time.html#monotonic","text":"因为 time() 函数返回的时间值是系统时钟，并且，为了在多台计算机之间同步时钟，系统时钟可以被用户或者是系统服务更改；所以，在重复调用 time() 函数时产生的时间值可能会有前后波动。在测量持续时间或者使用这些时间进行计算的时候，这可能会导致意料之外的行为。通过使用 monotonic() 函数就可以避免这些情况，因为 monotonic() 函数总是返回前向的时间值。 start = time . monotonic () time . sleep ( 0.1 ) end = time . monotonic () print ( 'start : {:>9.2f} ' . format ( start )) print ( 'end : {:>9.2f} ' . format ( end )) print ( 'span : {:>9.2f} ' . format ( end - start )) start : 1123921.73 end : 1123921.84 span : 0.11 我们并没有定义单调时钟的起始点。因此， 只有在使用其它时钟值进行计算时，单调时钟的返回值才会有用。 在这个例子中，睡眠的持续时间就是用 monotonic() 函数测量的。","text_tokens":["例子","span","同步","持续","之外","时","'","}","才","意料","持续时间","通过","多台","调用","重复","有用","因为","行为","意料之外","这","系统","起始","前","中",">","导致","计算机","可以","{","函数","用户","是","；","单调","会","在","1123921.84","产生","睡眠","1123921.73","值","并","，","0.11","时钟","进行","9.2","print","返回","没有","前后","只有","=",":","-","之间","情况","算机","更改","f","为了","我们",")","所以","计算","sleep","就是","。","服务","时候","format","并且","其它","点","的","因此","就",".","用"," ","start","这个","向","波动","monotonic","定义","这些","避免","有","返回值","使用","时间","end","多台计算机","或者","可能","0.1","time","测量","(","被","总是"],"title":"单调时钟——monotonic","title_tokens":["monotonic","单调","时钟","—"]},{"location":"标准库/8.3.time.html#_2","text":"time() 函数返回的是挂钟时间， perf_counter() 函数返回的是处理器时钟时间。 perf_counter() 函数的返回值反映了程序运行时使用的实际时间。 for i in range ( 4 ): time . sleep ( 1 ) print ( time . ctime (), ': {:0.3f} {:0.3f} ' . format ( time . time (), time . perf_counter ())) Mon Feb 3 21:17:39 2020 : 1580735859.086 516161.933 Mon Feb 3 21:17:40 2020 : 1580735860.087 516162.934 Mon Feb 3 21:17:41 2020 : 1580735861.088 516163.935 Mon Feb 3 21:17:42 2020 : 1580735862.089 516164.936 如果你想要在自己的系统上运行这个例子，需要想办法增加单次内循环的循环周期或者显著地增加循环的总次数，才可以真正地看到时间差异。（如果循环周期太短，循环次数太少的话，返回的时间值可能还没有来得及变化，整个程序就结束了。） 通常情况下，如果程序什么事情没有做，处理器时钟就不会滴答计时，或者计时量很小。 print ( time . ctime (), ': {:0.3f} {:0.3f} ' . format ( time . time (), time . clock ())) for i in range ( 4 ): print ( 'Sleeping' ) print ( time . ctime (), ': {:0.3f} {:0.3f} ' . format ( time . time (), time . clock ())) Mon Feb 3 21:17:42 2020 : 1580735862.112 516164.959 Sleeping Mon Feb 3 21:17:42 2020 : 1580735862.113 516164.960 Sleeping Mon Feb 3 21:17:42 2020 : 1580735862.113 516164.961 Sleeping Mon Feb 3 21:17:42 2020 : 1580735862.114 516164.961 Sleeping Mon Feb 3 21:17:42 2020 : 1580735862.114 516164.961","text_tokens":["例子","程序运行","for","如果","39","feb","42","1580735862.114","1580735862.113","实际","时","'","}","1580735860.087","结束","挂钟","还","mon","才","516162.934","办法","差异","perf","516164.959","_","太短","总","in","系统","）","40","自己","可以","做","{","516164.936","516163.935","事情","函数","是","增加","整个","不会","range","在","你","内","2020","少","来得及","程序","41","上","次数","太","sleeping","ctime","值","516164.960","滴答","21","，","时钟","3","counter","1580735859.086","i","print","单次","返回","没有","很小","反映","处理器","4","17",":","1580735862.112","1580735861.088","情况","f","来得",")","sleep","。","看到","理器","量","format","的","就","了",".","通常","什么"," ","循环","1580735862.089","真正","1","处理","这个","的话","运行","0.3","显著","想要","516164.961","clock","返回值","周期",",","使用","时间","或者","可能","下","想","变化","需要","time","516161.933","(","地","（","计时"],"title":"处理器时钟时间","title_tokens":["时间","处理","处理器","理器","时钟"]},{"location":"标准库/8.3.time.html#_3","text":"有一个高分辨率的单调时钟来衡量性能是非常重要的。要想确定最佳时钟数据源，需要一些特定于平台的知识，这些知识由 Python 中的 perf_counter() 提供。 和 monotonic() 函数一样， perf_counter() 函数的时元（epoch）是未定义的。并且，函数的这些返回值用于比较和计算，而不是用作绝对时间。","text_tokens":["）","比较","未定","数据源","中","不是","衡量"," ","一个","用于","绝对","高分","确定","未定义","函数","返回","是","来","由","单调","monotonic","定义","而","数据","性能","这些","有","一样","返回值","平台","于","知识","分辨率","时间",")","非常","用作","辨率","一些","计算","。","perf","重要","想","时元","要","epoch","需要","并且","_","高分辨率","分辨","(","的","和","python","，","特定","（","提供","时钟","最佳","counter"],"title":"性能计数器","title_tokens":["计数器","计数","性能"]},{"location":"标准库/8.3.time.html#struct_time","text":"按秒计数，把秒作为单位来存储时间在某些场合很适用，但有时候程序需要访问的（或者说程序感兴趣的）是日期的不同单位所对应的各个部分（比如，某年、某月等）。为了让日期的各个部分便于访问， time 模块定义了 struct_time ，它以各个部分分离的格式来存储日期和时间值。 有些函数以 struct_time 类型的数值作为参数，而不是浮点型的数值。 gmtime() 函数返回当前 UTC 1 时间（世界标准时间）。 localtime() 函数返回的是与当前时区的当前时间 。 mktime() 接收一个 struct_time 型数值并将其转换为浮点型数值。 print ( time . gmtime ()) print ( \"\" ) print ( time . localtime ()) time . struct_time ( tm_year = 2020 , tm_mon = 2 , tm_mday = 3 , tm_hour = 13 , tm_min = 17 , tm_sec = 42 , tm_wday = 0 , tm_yday = 34 , tm_isdst = 0 ) time . struct_time ( tm_year = 2020 , tm_mon = 2 , tm_mday = 3 , tm_hour = 21 , tm_min = 17 , tm_sec = 42 , tm_wday = 0 , tm_yday = 34 , tm_isdst = 0 )","text_tokens":["很","浮点","参数","它","42","标准","2","类型","有时候","有些","mon","sec","感兴趣","gmtime","各个","秒","计数","模块","把","_","和","存储","所","）","不是","数值","转换","对应","部分","函数","当前","hour","是","、","34","让","yday","有时","而","格式","在","wday","日期","2020","year","不同","程序","某些","struct","min","mday","值","但","21","并","为","，","3","tm","某年","13","与","型","print","返回","访问","等","来","17","=","便于","为了","接收","场合",")","mktime","适用","。","时候","分离","的","其","某月","时区","了",".","localtime"," ","一个","按","兴趣","1","isdst","单位","定义","\"","将","0",",","时间","utc","作为","或者","以","感兴","世界","需要","比如","time","(","（","或者说"],"title":"struct_time","title_tokens":["struct","_","time"]},{"location":"标准库/8.3.time.html#_4","text":"确定当前时间的函数依赖于时区设置，时区可以由程序设置，也可以使用系统的默认时区设置。改变时区并不会改变实际的时间，只是改变它的表现方式。 time 模块有4个属性记录了时区的信息： import os def show_zone_info (): print ( ' TZ :' , os . environ . get ( 'TZ' , '(not set)' )) print ( ' tzname:' , str ( time . tzname ) . encode ( 'latin-1' ) . decode ( 'gbk' )) print ( ' Zone : {} ( {} )' . format ( time . timezone , ( time . timezone / 3600 ))) print ( ' DST :' , time . daylight ) print ( ' ALZone : {} ( {} )' . format ( time . altzone , ( time . altzone / 3600 ))) print ( ' Time :' , time . ctime ()) print () show_zone_info () TZ : (not set) tzname: ('中国标准时间', '中国夏令时') Zone : -28800 (-8.0) DST : 0 ALZone : -32400 (-9.0) Time : Mon Feb 3 21:17:42 2020","text_tokens":["gbk","daylight","它","feb","42","确定","实际","时","由","标准","'","}","个","mon","set","表现","默认","改变","模块","_","信息","系统","中国","可以","{","函数","当前","environ","不会","tzname","/","str","altzone","2020","not","decode","程序","方式","属性","info","ctime","dst","区","21","并","，","依赖","3","9.0","也","32400","timezone","print","依赖于","encode","记录","get","4","17",":","-","：","show",")","赖于","alzone","import","。","format","的","时区","了",".","os"," ","1","夏令时","设置","8.0","latin","有","0","夏令",",","使用","时间","tz","def","zone","只是","time","28800","(","3600"],"title":"与时区相关的工作","title_tokens":["相关","工作","与","的","时区"]},{"location":"标准库/8.3.time.html#_5","text":"有两个函数 —— strptime() 和 strftime() —— 可以使时间值在 struct_time 表示和字符串表示之间相互转换。有一个很长的格式说明列表可以用来支持不同格式的输入和输出。完整的列表记录在 time 模块的库文件中。 这个例子将当前时间从字符串格式转换成 struct_time 实例，然后又将其转换为字符串格式。","text_tokens":["例子","使","完整","中","用来"," ","可以","相互","转换","一个","strftime","函数","当前","又","输出","说明","—","字符串","记录","这个","很长","格式","实例","在","将","有","之间","换成","不同","输入","库","字符","时间",")","然后","struct","strptime","从","。","模块","值","time","两个","支持","(","和","_","文件","的","转换成","其","，","为","列表","表示"],"title":"解析和格式化时间","title_tokens":["时间","和","格式化","解析","格式"]},{"location":"标准库/8.3.time.html#struct_time_1","text":"struct_time = time . localtime () print ( struct_time ) seconds = time . mktime ( struct_time ) print ( seconds ) time.struct_time(tm_year=2020, tm_mon=2, tm_mday=3, tm_hour=21, tm_min=17, tm_sec=42, tm_wday=0, tm_yday=34, tm_isdst=0) 1580735862.0","text_tokens":[".","localtime","seconds"," ","42","print","hour","isdst","34","2","yday","17","=","mon","wday","2020","sec","year","0",",",")","mktime","1580735862.0","struct","min","mday","time","_","(","21","3","tm"],"title":"struct_time → 浮点数时间（秒）","title_tokens":["）","浮点","time","_","时间","（"," ","struct","→","秒","浮点数","点数"]},{"location":"标准库/8.3.time.html#struct_time_2","text":"","text_tokens":[],"title":"浮点数时间 → struct_time","title_tokens":["浮点","time","_","时间"," ","→","struct","浮点数","点数"]},{"location":"标准库/8.3.time.html#_6","text":"print ( time . time ()) time . ctime ( time . time ()) 1580735862.2027004 'Mon Feb 3 21:17:42 2020'","text_tokens":[".","time","1580735862.2027004","(","'",")","21"," ","feb","42","17","print","mon",":","3","2020","ctime"],"title":"浮点数时间 → 字符串时间","title_tokens":["浮点","字符串","字符","时间"," ","→","浮点数","点数"]},{"location":"标准库/8.3.time.html#struct_time_3","text":"print ( time . ctime ( time . time ())) time . strptime ( time . ctime ( time . time ())) Mon Feb 3 21:17:42 2020 time.struct_time(tm_year=2020, tm_mon=2, tm_mday=3, tm_hour=21, tm_min=17, tm_sec=42, tm_wday=0, tm_yday=34, tm_isdst=-1)","text_tokens":["."," ","feb","42","print","hour","1","isdst","34","2","yday","17","=","mon",":","wday","-","2020","sec","year","0",",",")","struct","min","strptime","ctime","mday","time","(","_","21","3","tm"],"title":"字符串时间 → struct_time","title_tokens":["字符串","time","字符","时间","_"," ","→","struct"]},{"location":"标准库/8.3.time.html#struct_time_4","text":"print ( time . localtime ()) time . strftime ( \" %a %b %d %H:%M:%S %Y\" , time . localtime ()) time.struct_time(tm_year=2020, tm_mon=2, tm_mday=3, tm_hour=21, tm_min=17, tm_sec=42, tm_wday=0, tm_yday=34, tm_isdst=0) 'Mon Feb 03 21:17:42 2020' time . asctime ( time . localtime ()) 'Mon Feb 3 21:17:42 2020' 0时区的时间是UTC时间，UTC时间和格林威治标准时间（GMT）很接近，大多数情况下两者相互替代不会出问题，但严格来说UTC和GMT并不相等。 ↩","text_tokens":["很","s","多数","42","feb","相互","strftime","标准","2","'","mon","d","sec","不","严格","_","和","）","两者","hour","是","34","不会","yday","b","来说","wday","2020","year","struct","min","接近","mday","但","21","并","03","，","3","tm","gmt","print","严格来说","y","17","=","替代",":","情况",")","相等","大多数","。","asctime","m","格林威治","的","时区","问题",".","localtime"," ","h","isdst","出","\"","0","↩",",","时间","utc","%","下","time","(","a","格林","（","大多"],"title":"struct_time → 字符串时间","title_tokens":["字符串","time","_","字符","时间"," ","struct","→"]},{"location":"标准库/8.4.datetime.html","text":"Windows 10 Python 3.7.3 @ MSC v.1915 64 bit (AMD64) # from tools import Help as H import datetime time：时间 time 实例只保存时间值，而不保存与时间相关的日期值。 t = datetime . time ( hour = 1 , minute = 2 , second = 3 , microsecond = 4 , tzinfo = None ) print ( t ) print ( 'hour :' , t . hour ) print ( 'minute :' , t . minute ) print ( 'second :' , t . second ) print ( 'microsecond:' , t . microsecond ) print ( 'tzinfo :' , t . tzinfo ) 01 : 02 : 03.000004 hour : 1 minute : 2 second : 3 microsecond : 4 tzinfo : None min 和 max 类的属性代表一天内的有效时间范围。 time 的精度（即 time 能够有效表示的最小时间间隔）被限制为1微秒。 print ( \"最小时间\" ) print ( 'min:' , datetime . time . min ) print ( \"最大时间\" ) print ( 'min:' , datetime . time . max ) print ( \"最小刻度单位\" ) print ( 'Resolution:' , datetime . time . resolution ) 最小时间 min: 00:00:00 最大时间 min: 23:59:59.999999 最小刻度单位 Resolution: 0:00:00.000001 其他构造器： datetime.date.today() ： datetime . date . today () datetime.date(2020, 2, 3) date：日期 日历日期可以用 date 类来描述。 date 类实例化后有属性 year ， month ，和 day 。 # 如果参数超出限制范围，抛出ValueError异常 MYdate = datetime . date ( year = 2019 , month = 3 , day = 22 ) print ( MYdate ) print ( 'year :' , MYdate . year ) print ( 'month :' , MYdate . month ) print ( 'day :' , MYdate . day ) print ( \"最小时间\" ) print ( 'min:' , datetime . date . min ) print ( \"最大时间\" ) print ( 'min:' , datetime . date . max ) print ( \"最小刻度单位\" ) print ( 'Resolution:' , datetime . date . resolution ) 2019-03-22 year : 2019 month : 3 day : 22 最小时间 min: 0001-01-01 最大时间 min: 9999-12-31 最小刻度单位 Resolution: 1 day, 0:00:00 其他构造函数 import time t = time . time () 从timestamp构造date datetime . date . fromtimestamp ( t ) datetime.date(2020, 2, 3) 从proleptic Gregorian ordinal构造date datetime . date . fromordinal ( 737140 ) datetime.date(2019, 3, 22) 从ISO格式的日期构造date datetime . date . fromisoformat ( '2019-03-22' ) datetime.date(2019, 3, 22) date → 字符串时间 print ( datetime . date . ctime ( MYdate )) print ( datetime . date . strftime ( MYdate , \" %a %b %d %H:%M:%S %Y\" )) Fri Mar 22 00:00:00 2019 Fri Mar 22 00:00:00 2019 date → struct_time datetime . date . timetuple ( MYdate ) time.struct_time(tm_year=2019, tm_mon=3, tm_mday=22, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=4, tm_yday=81, tm_isdst=-1) 日期函数 Return a 3-tuple containing ISO year, week number, and weekday. datetime . date . isocalendar ( MYdate ) (2019, 12, 5) Return the date formatted according to ISO.This is 'YYYY-MM-DD'. datetime . date . isoformat ( MYdate ) '2019-03-22' \"Return day of the week, where Monday == 1 ... Sunday == 7.\" datetime . date . isoweekday ( MYdate ) 5 \"Return day of the week, where Monday == 0 ... Sunday == 6.\" datetime . date . weekday ( MYdate ) 4 Return proleptic Gregorian ordinal for the year, month and day. datetime . date . toordinal ( MYdate ) 737140 datetime：日期和时间 date_time = datetime . datetime ( year = 2020 , month = 3 , day = 23 , hour = 10 , minute = 15 , second = 30 , microsecond = 4 , tzinfo = None ) 其他构造函数 datetime . datetime . utcnow () datetime . datetime . now () datetime . datetime . today () datetime . datetime . fromisoformat ( '2019-03-22-10:15:30' ) datetime . datetime . fromordinal ( 737140 ) datetime . datetime . fromtimestamp ( time . time ()) datetime . datetime . utcfromtimestamp ( time . time ()) datetime.datetime(2020, 2, 3, 13, 11, 31, 149891) datetime → date date_time = datetime . datetime . now () datetime . datetime . date ( date_time ) datetime.date(2020, 2, 3) datetime → time datetime . datetime . time ( date_time ) datetime.time(21, 11, 31, 172888) date and time → datetime t1 = datetime . date . today () t2 = datetime . time ( hour = 10 , minute = 15 , second = 30 ) datetime . datetime . combine ( t1 , t2 ) datetime.datetime(2020, 2, 3, 10, 15, 30) datetime → time string datetime . datetime . ctime ( date_time ) print ( datetime . datetime . strftime ( date_time , \" %a %b %d %H:%M:%S %Y\" )) Mon Feb 03 21:11:31 2020 time string → datetime datetime . datetime . strptime ( 'Mon Feb 3 19:56:21 2020' , \" %a %b %d %H:%M:%S %Y\" ) datetime.datetime(2020, 2, 3, 19, 56, 21) datetime → timestamp datetime . datetime . timestamp ( date_time ) 1580735491.172888 datetime → timetuple datetime . datetime . timetuple ( date_time ) datetime . datetime . utctimetuple ( date_time ) time.struct_time(tm_year=2020, tm_mon=2, tm_mday=3, tm_hour=21, tm_min=11, tm_sec=31, tm_wday=0, tm_yday=34, tm_isdst=0) 其他函数 datetime . datetime . toordinal ( date_time ) datetime . datetime . isocalendar ( date_time ) datetime . datetime . isoformat ( date_time ) datetime . datetime . isoweekday ( date_time ) datetime . datetime . weekday ( date_time ) datetime . datetime . astimezone ( date_time , tz = None ) datetime . datetime . dst ( date_time ) date_time . astimezone ( tz = None ) datetime.datetime(2020, 2, 3, 21, 11, 31, 172888, tzinfo=datetime.timezone(datetime.timedelta(seconds=28800), '?D1¨²¡À¨º¡Á?¨º¡À??')) ['astimezone', 'dst', 'replace', 'timetz', 'tzname', 'utcoffset'] timedelta 可以使用两个 datetime 对象的基本运算来计算未来和过去的日期，或者是通过将一个 datetime 对象和一个 timedelta 对象相结合的方法来计算。不同的日期相减会产生一个 timedelta ，一个日期加上或者减去一个 timedelta 会产生另一个日期。 timedelta 的内部值以天、秒和微秒的形式存储。 print ( 'microseconds:' , datetime . timedelta ( microseconds = 1 )) print ( 'milliseconds:' , datetime . timedelta ( milliseconds = 1 )) print ( 'seconds :' , datetime . timedelta ( seconds = 1 )) print ( 'minutes :' , datetime . timedelta ( minutes = 1 )) print ( 'hours :' , datetime . timedelta ( hours = 1 )) print ( 'days :' , datetime . timedelta ( days = 1 )) print ( 'weeks :' , datetime . timedelta ( weeks = 1 )) microseconds : 0 : 00 : 00.000001 milliseconds : 0 : 00 : 00.001000 seconds : 0 : 00 : 01 minutes : 0 : 01 : 00 hours : 1 : 00 : 00 days : 1 day , 0 : 00 : 00 weeks : 7 days , 0 : 00 : 00 可以使用 total_seconds() 将 timedelta 的整个持续时间检索为秒数。 for delta in [ datetime . timedelta ( microseconds = 1 ), datetime . timedelta ( milliseconds = 1 ), datetime . timedelta ( seconds = 1 ), datetime . timedelta ( minutes = 1 ), datetime . timedelta ( hours = 1 ), datetime . timedelta ( days = 1 ), datetime . timedelta ( weeks = 1 ), ]: print ( ' {:15} = {:8} seconds' . format ( str ( delta ), delta . total_seconds ()) ) 0 : 00 : 00.000001 = 1 e - 06 seconds 0 : 00 : 00.001000 = 0.001 seconds 0 : 00 : 01 = 1.0 seconds 0 : 01 : 00 = 60.0 seconds 1 : 00 : 00 = 3600.0 seconds 1 day , 0 : 00 : 00 = 86400.0 seconds 7 days , 0 : 00 : 00 = 604800.0 seconds 日期算术运算 one_day = datetime . timedelta ( days = 1 ) today = datetime . date . today () yesterday = today - one_day tomorrow = today + one_day print ( type ( today )) type ( yesterday ) == type ( today ) == type ( tomorrow ) <class 'datetime.date'> True timedelta 对象还支持与整型数、浮点数和其它 timedelta 实例的算术运算。 one_day = datetime . timedelta ( days = 1 ) print ( '1 day :' , one_day ) print ( '5 days :' , one_day * 5 ) print ( '1.5 days :' , one_day * 1.5 ) print ( '1/4 day :' , one_day / 4 ) # 假设午饭时间为 1 小时 work_day = datetime . timedelta ( hours = 7 ) meeting_length = datetime . timedelta ( hours = 1 ) print ( 'meetings per day :' , work_day / meeting_length ) 1 day : 1 day, 0:00:00 5 days : 5 days, 0:00:00 1.5 days : 1 day, 12:00:00 1/4 day : 6:00:00 meetings per day : 7.0 比较数值 print ( 'Times:' ) t1 = datetime . time ( 12 , 55 , 0 ) print ( ' t1:' , t1 ) t2 = datetime . time ( 13 , 5 , 0 ) print ( ' t2:' , t2 ) print ( ' t1 < t2:' , t1 < t2 ) print () print ( 'Dates:' ) d1 = datetime . date . today () print ( ' d1:' , d1 ) d2 = datetime . date . today () + datetime . timedelta ( days = 1 ) print ( ' d2:' , d2 ) print ( ' d1 > d2:' , d1 > d2 ) Times : t1 : 12 : 55 : 00 t2 : 13 : 05 : 00 t1 < t2 : True Dates : d1 : 2020 - 02 - 03 d2 : 2020 - 02 - 04 d1 > d2 : False 格式化和解析 datetime 对象默认的字符串表示法采用的是 ISO-8601 格式 ( YYYY-MM-DDTHH:MM:SS.mmmmmm )。当然也可以使用 strftime() 函数生成其它的格式。 format = \" %a %b %d %H:%M:%S %Y\" today = datetime . datetime . today () print ( 'ISO :' , today ) s = today . strftime ( format ) print ( 'strftime:' , s ) d = datetime . datetime . strptime ( s , format ) print ( 'strptime:' , d . strftime ( format )) ISO : 2020 - 02 - 03 21 : 11 : 31.684806 strftime : Mon Feb 03 21 : 11 : 31 2020 strptime : Mon Feb 03 21 : 11 : 31 2020 相同的格式化代码可以与 Python 的 string formatting mini-language 一起使用，方法是将它们放在格式字符串的字段规范中的 : 后面。 today = datetime . datetime . today () print ( 'ISO :' , today ) print ( 'format(): {: %a %b %d %H:%M:%S %Y}' . format ( today )) ISO : 2020 - 02 - 03 21 : 11 : 31.729803 format (): Mon Feb 03 21 : 11 : 31 2020 每一个 datetime 格式代码均以 % 为前缀，并且后面的冒号被当作是要输出的字符。 符号 含义 例子 %a 星期的简写 'Wed' %A 星期的完整写法 'Wednesday' %w 星期代号 -- 从 0 (周日) 到 6 (周六) '3' %d 月的第几日 (个位数时，十位补 0) '13' %b 月份的简写 'Jan' %B 月份的完整写法 'January' %m 月份 '01' %y 年份的缩写 '16' %Y 年份的完整写法 '2016' %H 小时（ 24 小时制） '17' %I 小时（ 12 小时制） '05' %p AM/PM 'PM' %M 分钟 '00' %S 秒 '00' %f 微秒 '000000' %z 设置时区（适用于对时区敏感的类） '-0500' %Z 时区名 'EST' %j 一年的第几天 '013' %W 一年的第几周 '02' %c 当地当前日期和时间 'Wed Jan 13 17:00:00 2016' %x 当地当前日期 '01/13/16' %X 当地当前时间 '17:00:00' %% 一个 % '%' 时区 在 datetime 中，时区由 tzinfo 的子类表示。由于 tzinfo 是一个抽象基类，因此应用程序需要定义一个子类。为了让这个类能用，应用程序还要为一些方法提供适当的实现。 在 timezone 类中， datetime 确实包含了一个略为简单的实现。它使用 UTC 的固定偏移量，并且不支持一年中不同日期的不同偏移量。比如，使用夏令时的地方或者 UTC 的偏移量会随时间变化的地方。 min6 = datetime . timezone ( datetime . timedelta ( hours =- 6 )) plus6 = datetime . timezone ( datetime . timedelta ( hours = 6 )) d = datetime . datetime . now ( min6 ) print ( min6 , ':' , d ) print ( datetime . timezone . utc , ':' , d . astimezone ( datetime . timezone . utc )) print ( plus6 , ':' , d . astimezone ( plus6 )) # 转换为当前系统时间 d_system = d . astimezone () print ( d_system . tzinfo , ' :' , d_system ) UTC-06:00 : 2020-02-03 07:11:31.756794-06:00 UTC : 2020-02-03 13:11:31.756794+00:00 UTC+06:00 : 2020-02-03 19:11:31.756794+06:00 ?D1¨²¡À¨º¡Á?¨º¡À?? : 2020-02-03 21:11:31.756794+08:00 要想将 datetime 值从一个时区转换到另一个时区，可以使用 astimezone() 函数。在上面的例子中，在 UTC 的两边分别显示了 6 小时的时区，并且还使用 datetime.timezone 中的 utc 实例作为参考。最后的输出行显示系统时区中的值，该值可以通过调用 astimezone() 函数获得，调用时不需要参数。","text_tokens":["²","浮点","字","地方","均","10","过去","持续","'","according","持续时间","不","d1","默认","*","est","秒","个位","调用","delta","支持","weekday","微秒","...","tuple","7","存储","in","符号","000000","段","64","转换","{","该值","子类","是","基类","30","整个","2016","格式","产生","utctimetuple","程序","tools","struct","周日","language","23","python","能够","实现","几周","3","13","规范","检索","where","mini","and","来","相同","737140","0001","month","is","代号","有效",")","计算","适用","。","写法","to","当然","基本","m","56","的","抽象","因此","mmmmmm","isocalendar","了"," ","help","h","个位数","类来","86400.0","<","+","字符串","这个","wednesday","一起","实例","将","59.999999","使用","31.684806","5","tz","utcnow","分别","combine","%","代表","即","比如","time","由于","a","应用程序","被","构造函数","seconds","它","day","containing","1580735491.172888","strftime","当地","º","replace","以天","2","由","}","假设","分钟","amd64","max","还","mon","sec","减去","适当","位数","t1","sunday","week","_","和","提供","0500","系统","8","日历","中","解析","最大","函数","hour","当前","yday","加上","略为","b","tzname","而","false","str","3.7","2020","简单","days","year","work","不同","只","fromtimestamp","z","还要","mm","当作","1.5","区","00","，","2019","ordinal","81","与","¨","]","e","timezone","随","print","dd","内部","刻度","整型","c","jan","string","=","限制","00.000001","含义","import","format","并且","结合","one","时区","数","yesterday","of","用","isoformat","the","1","点数","前缀","today","01","月","设置","none","范围","间隔","timetz","有","times","夏令","¡","fromordinal","utc","包含","j","monday","resolution","相结合","偏移","变化","utcfromtimestamp","两个","(","utcoffset","31.729803","应用","例子","化后","参数","s","fri","如果","到","→","31","microsecond","时","一天","生成","w","0.001","于","通过","formatting","字符","msc","一些","toordinal","描述","午饭","á","采用","一年","缩写","表示法","07","饭时","55","mydate","数值","可以","meetings","microseconds","isoweekday","34","@","会","偏移量","january","00.001000","日期","内","06","d2","方法","类","属性","[","3600.0","hours","t","超出","值","mday","要","21","为","ss","meeting","11","tm","固定","tomorrow","149891","对","total","59","t2","windows","timestamp","astimezone","timedelta","十位","4","相减",":","22","bit","f","为了","length","精度","几天","后面","显示","x","system","午饭时间","12","v.1915","最后",".","敏感","一个","31.756794","第","now","class","浮点数","24","isdst","代码","其他","放在","类能","\"","上面","formatted","0","冒号","8601","制","器","6","想","p","需要","最小","（","08","milliseconds","--","for","第几","构造","mar","feb","number","格式化","172888","04","未来","à","名","weeks","d","pm","保存","15","星期","true","second","算术","7.0","#","它们","plus6","ddthh","timetuple","两边","确实","）","比较","第几天",">","013","、","形式","让","/","wed","在","wday","年份","?","类中","min","ctime","dst","月份","fromisoformat","03","02","gregorian","表示","16","完整","对象","也","i","小时","秒数","05","补","参考","获得","datetime","y","运算","另","简写","proleptic","17","minute","-","：","几日","dates","1.0","19","其它","min6","return","03.000004","604800.0","周六","行","相关","异常","type","date","输出","夏令时","per","单位","定义","minutes","60.0",",","tzinfo","时间","am","从","strptime","作为","抛出","或者","以","yyyy","this","28800","valueerror","每","from","as","9999","iso","%%"],"title":"8.4.datetime","title_tokens":["8.4",".","datetime"]},{"location":"标准库/8.4.datetime.html#time","text":"time 实例只保存时间值，而不保存与时间相关的日期值。 t = datetime . time ( hour = 1 , minute = 2 , second = 3 , microsecond = 4 , tzinfo = None ) print ( t ) print ( 'hour :' , t . hour ) print ( 'minute :' , t . minute ) print ( 'second :' , t . second ) print ( 'microsecond:' , t . microsecond ) print ( 'tzinfo :' , t . tzinfo ) 01 : 02 : 03.000004 hour : 1 minute : 2 second : 3 microsecond : 4 tzinfo : None min 和 max 类的属性代表一天内的有效时间范围。 time 的精度（即 time 能够有效表示的最小时间间隔）被限制为1微秒。 print ( \"最小时间\" ) print ( 'min:' , datetime . time . min ) print ( \"最大时间\" ) print ( 'min:' , datetime . time . max ) print ( \"最小刻度单位\" ) print ( 'Resolution:' , datetime . time . resolution ) 最小时间 min: 00:00:00 最大时间 min: 23:59:59.999999 最小刻度单位 Resolution: 0:00:00.000001 其他构造器： datetime.date.today() ： datetime . date . today () datetime.date(2020, 2, 3)","text_tokens":["构造","microsecond","2","'","一天","max","保存","不","second","和","微秒","）","最大","hour","而","日期","内","2020","只","类","属性","min","23","t","值","为","00","，","02","能够","表示","3","与","print","59","刻度","datetime","4","=","minute",":","限制","：","00.000001","有效",")","精度","。","的","03.000004",".","相关","date"," ","1","today","01","其他","单位","none","范围","间隔","\"","实例","0","59.999999",",","tzinfo","时间","代表","即","resolution","器","time","(","最小","（","被"],"title":"time：时间","title_tokens":["时间","：","time"]},{"location":"标准库/8.4.datetime.html#date","text":"日历日期可以用 date 类来描述。 date 类实例化后有属性 year ， month ，和 day 。 # 如果参数超出限制范围，抛出ValueError异常 MYdate = datetime . date ( year = 2019 , month = 3 , day = 22 ) print ( MYdate ) print ( 'year :' , MYdate . year ) print ( 'month :' , MYdate . month ) print ( 'day :' , MYdate . day ) print ( \"最小时间\" ) print ( 'min:' , datetime . date . min ) print ( \"最大时间\" ) print ( 'min:' , datetime . date . max ) print ( \"最小刻度单位\" ) print ( 'Resolution:' , datetime . date . resolution ) 2019-03-22 year : 2019 month : 3 day : 22 最小时间 min: 0001-01-01 最大时间 min: 9999-12-31 最小刻度单位 Resolution: 1 day, 0:00:00","text_tokens":[".","日历","异常","mydate","化后","参数","用","date"," ","如果","可以","day","print","类来","最大","31","刻度","1","datetime","01","'","单位","范围","max","=","\"","实例",":","限制","日期","-","0001","month","有","0","year","22","类",",","时间",")","属性","#","min","描述","。","抛出","resolution","超出","(","和","valueerror","最小","03","00","，","12","9999","3","2019"],"title":"date：日期","title_tokens":["日期","date","："]},{"location":"标准库/8.4.datetime.html#_1","text":"import time t = time . time () 从timestamp构造date datetime . date . fromtimestamp ( t ) datetime.date(2020, 2, 3) 从proleptic Gregorian ordinal构造date datetime . date . fromordinal ( 737140 ) datetime.date(2019, 3, 22) 从ISO格式的日期构造date datetime . date . fromisoformat ( '2019-03-22' ) datetime.date(2019, 3, 22)","text_tokens":[".","ordinal","date"," ","构造","timestamp","datetime","2","737140","'","proleptic","=","格式","-","日期","2020","22",",","fromtimestamp",")","fromordinal","import","从","t","time","(","fromisoformat","03","的","gregorian","iso","3","2019"],"title":"其他构造函数","title_tokens":["函数","构造函数","其他","构造"]},{"location":"标准库/8.4.datetime.html#date_1","text":"print ( datetime . date . ctime ( MYdate )) print ( datetime . date . strftime ( MYdate , \" %a %b %d %H:%M:%S %Y\" )) Fri Mar 22 00:00:00 2019 Fri Mar 22 00:00:00 2019","text_tokens":[".","mydate","s","date"," ","fri","mar","h","print","strftime","datetime","y","b","\"",":","d","22",",",")","%","ctime","(","m","a","00","2019"],"title":"date → 字符串时间","title_tokens":["字符串","字符","时间","date"," ","→"]},{"location":"标准库/8.4.datetime.html#date-struct_time","text":"datetime . date . timetuple ( MYdate ) time.struct_time(tm_year=2019, tm_mon=3, tm_mday=22, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=4, tm_yday=81, tm_isdst=-1)","text_tokens":[".","mydate","81","date"," ","hour","1","isdst","datetime","yday","4","=","mon","-","wday","0","year","22","sec",",",")","struct","min","mday","time","(","_","timetuple","3","tm","2019"],"title":"date → struct_time","title_tokens":["time","_","date"," ","→","struct"]},{"location":"标准库/8.4.datetime.html#_2","text":"Return a 3-tuple containing ISO year, week number, and weekday. datetime . date . isocalendar ( MYdate ) (2019, 12, 5) Return the date formatted according to ISO.This is 'YYYY-MM-DD'. datetime . date . isoformat ( MYdate ) '2019-03-22' \"Return day of the week, where Monday == 1 ... Sunday == 7.\" datetime . date . isoweekday ( MYdate ) 5 \"Return day of the week, where Monday == 0 ... Sunday == 6.\" datetime . date . weekday ( MYdate ) 4 Return proleptic Gregorian ordinal for the year, month and day. datetime . date . toordinal ( MYdate ) 737140","text_tokens":[".","for","mydate","ordinal","of","date"," ","where","day","containing","number","dd","isoformat","the","1","and","datetime","isoweekday","737140","according","'","proleptic","4","=","\"","-","formatted","month","0","year","is","22",",",")","5","toordinal","sunday","monday","yyyy","to","mm","6","this","week","weekday","(","a","tuple","return","03","3","...","7","gregorian","12","iso","isocalendar","2019"],"title":"日期函数","title_tokens":["函数","日期"]},{"location":"标准库/8.4.datetime.html#datetime","text":"date_time = datetime . datetime ( year = 2020 , month = 3 , day = 23 , hour = 10 , minute = 15 , second = 30 , microsecond = 4 , tzinfo = None )","text_tokens":[".","date"," ","day","10","hour","microsecond","datetime","30","none","4","=","minute","2020","month","15","year",",","tzinfo","second",")","23","time","_","(","3"],"title":"datetime：日期和时间","title_tokens":["datetime","时间","和","日期","："]},{"location":"标准库/8.4.datetime.html#_3","text":"datetime . datetime . utcnow () datetime . datetime . now () datetime . datetime . today () datetime . datetime . fromisoformat ( '2019-03-22-10:15:30' ) datetime . datetime . fromordinal ( 737140 ) datetime . datetime . fromtimestamp ( time . time ()) datetime . datetime . utcfromtimestamp ( time . time ()) datetime.datetime(2020, 2, 3, 13, 11, 31, 149891)","text_tokens":[".","149891"," ","10","now","31","datetime","30","today","737140","'","2","13",":","-","2020","15","22",",","fromtimestamp",")","utcnow","fromordinal","utcfromtimestamp","time","(","fromisoformat","03","11","3","2019"],"title":"其他构造函数","title_tokens":["函数","构造函数","其他","构造"]},{"location":"标准库/8.4.datetime.html#datetime-date","text":"date_time = datetime . datetime . now () datetime . datetime . date ( date_time ) datetime.date(2020, 2, 3)","text_tokens":["datetime",".","time",",","_","(",")","date"," ","2","=","now","3","2020"],"title":"datetime → date","title_tokens":["→","datetime","date"," "]},{"location":"标准库/8.4.datetime.html#datetime-time","text":"datetime . datetime . time ( date_time ) datetime.time(21, 11, 31, 172888)","text_tokens":["datetime",".","time",",","(","_",")","date"," ","21","172888","11","31"],"title":"datetime → time","title_tokens":["→","datetime"," ","time"]},{"location":"标准库/8.4.datetime.html#date-and-time-datetime","text":"t1 = datetime . date . today () t2 = datetime . time ( hour = 10 , minute = 15 , second = 30 ) datetime . datetime . combine ( t1 , t2 ) datetime.datetime(2020, 2, 3, 10, 15, 30)","text_tokens":[".","date"," ","t2","10","hour","datetime","30","today","2","=","minute","2020","15",",","second",")","combine","t1","time","(","3"],"title":"date and time → datetime","title_tokens":["and","datetime","time","date"," ","→"]},{"location":"标准库/8.4.datetime.html#datetime-time-string","text":"datetime . datetime . ctime ( date_time ) print ( datetime . datetime . strftime ( date_time , \" %a %b %d %H:%M:%S %Y\" )) Mon Feb 03 21:11:31 2020","text_tokens":[".","s","date"," ","feb","h","print","strftime","31","datetime","y","b","\"","mon",":","d","2020",",",")","%","ctime","time","(","_","a","m","03","21","11"],"title":"datetime → time string","title_tokens":["datetime","time","string"," ","→"]},{"location":"标准库/8.4.datetime.html#time-string-datetime","text":"datetime . datetime . strptime ( 'Mon Feb 3 19:56:21 2020' , \" %a %b %d %H:%M:%S %Y\" ) datetime.datetime(2020, 2, 3, 19, 56, 21)","text_tokens":[".","s"," ","feb","h","datetime","y","2","'","b","\"","mon",":","d","2020",",",")","strptime","%","19","(","56","21","a","m","3"],"title":"time string → datetime","title_tokens":["datetime","time","string"," ","→"]},{"location":"标准库/8.4.datetime.html#datetime-timestamp","text":"datetime . datetime . timestamp ( date_time ) 1580735491.172888","text_tokens":["datetime",".","time","(","_",")","date"," ","1580735491.172888","timestamp"],"title":"datetime → timestamp","title_tokens":["→","timestamp","datetime"," "]},{"location":"标准库/8.4.datetime.html#datetime-timetuple","text":"datetime . datetime . timetuple ( date_time ) datetime . datetime . utctimetuple ( date_time ) time.struct_time(tm_year=2020, tm_mon=2, tm_mday=3, tm_hour=21, tm_min=11, tm_sec=31, tm_wday=0, tm_yday=34, tm_isdst=0)","text_tokens":[".","date"," ","31","hour","isdst","datetime","34","2","yday","=","mon","wday","2020","sec","year","0",",","utctimetuple",")","struct","min","mday","time","(","_","21","timetuple","11","3","tm"],"title":"datetime → timetuple","title_tokens":["→","datetime"," ","timetuple"]},{"location":"标准库/8.4.datetime.html#_4","text":"datetime . datetime . toordinal ( date_time ) datetime . datetime . isocalendar ( date_time ) datetime . datetime . isoformat ( date_time ) datetime . datetime . isoweekday ( date_time ) datetime . datetime . weekday ( date_time ) datetime . datetime . astimezone ( date_time , tz = None ) datetime . datetime . dst ( date_time ) date_time . astimezone ( tz = None ) datetime.datetime(2020, 2, 3, 21, 11, 31, 172888, tzinfo=datetime.timezone(datetime.timedelta(seconds=28800), '?D1¨²¡À¨º¡Á?¨º¡À??')) ['astimezone', 'dst', 'replace', 'timetz', 'tzname', 'utcoffset']","text_tokens":[".","²","seconds","¨","date"," ","]","timezone","isoformat","172888","31","astimezone","º","à","timedelta","datetime","replace","isoweekday","2","'","none","tzname","=","timetz","2020","d1",",","?","tzinfo","¡",")","tz","toordinal","[","á","time","28800","(","_","weekday","dst","21","utcoffset","3","11","isocalendar"],"title":"其他函数","title_tokens":["函数","其他"]},{"location":"标准库/8.4.datetime.html#timedelta","text":"可以使用两个 datetime 对象的基本运算来计算未来和过去的日期，或者是通过将一个 datetime 对象和一个 timedelta 对象相结合的方法来计算。不同的日期相减会产生一个 timedelta ，一个日期加上或者减去一个 timedelta 会产生另一个日期。 timedelta 的内部值以天、秒和微秒的形式存储。 print ( 'microseconds:' , datetime . timedelta ( microseconds = 1 )) print ( 'milliseconds:' , datetime . timedelta ( milliseconds = 1 )) print ( 'seconds :' , datetime . timedelta ( seconds = 1 )) print ( 'minutes :' , datetime . timedelta ( minutes = 1 )) print ( 'hours :' , datetime . timedelta ( hours = 1 )) print ( 'days :' , datetime . timedelta ( days = 1 )) print ( 'weeks :' , datetime . timedelta ( weeks = 1 )) microseconds : 0 : 00 : 00.000001 milliseconds : 0 : 00 : 00.001000 seconds : 0 : 00 : 01 minutes : 0 : 01 : 00 hours : 1 : 00 : 00 days : 1 day , 0 : 00 : 00 weeks : 7 days , 0 : 00 : 00 可以使用 total_seconds() 将 timedelta 的整个持续时间检索为秒数。 for delta in [ datetime . timedelta ( microseconds = 1 ), datetime . timedelta ( milliseconds = 1 ), datetime . timedelta ( seconds = 1 ), datetime . timedelta ( minutes = 1 ), datetime . timedelta ( hours = 1 ), datetime . timedelta ( days = 1 ), datetime . timedelta ( weeks = 1 ), ]: print ( ' {:15} = {:8} seconds' . format ( str ( delta ), delta . total_seconds ()) ) 0 : 00 : 00.000001 = 1 e - 06 seconds 0 : 00 : 00.001000 = 0.001 seconds 0 : 00 : 01 = 1.0 seconds 0 : 01 : 00 = 60.0 seconds 1 : 00 : 00 = 3600.0 seconds 1 day , 0 : 00 : 00 = 86400.0 seconds 7 days , 0 : 00 : 00 = 604800.0 seconds","text_tokens":["for","seconds","day","过去","未来","持续","以天","'","}","weeks","持续时间","15","0.001","减去","通过","秒","delta","_","和","微秒","7","存储","in","8","可以","{","是","microseconds","、","整个","形式","加上","会","str","00.001000","日期","06","方法","days","产生","不同","[","3600.0","hours","值","为","00","，","检索","对象","]","e","print","total","秒数","内部","timedelta","datetime","来","运算","另","=","相减",":","-","00.000001",")","1.0","计算","。","基本","format","结合","的","604800.0","."," ","一个","86400.0","1","01","minutes","将","60.0","0",",","使用","时间","或者","相结合","两个","(","milliseconds"],"title":"timedelta","title_tokens":["timedelta"]},{"location":"标准库/8.4.datetime.html#_5","text":"one_day = datetime . timedelta ( days = 1 ) today = datetime . date . today () yesterday = today - one_day tomorrow = today + one_day print ( type ( today )) type ( yesterday ) == type ( today ) == type ( tomorrow ) <class 'datetime.date'> True timedelta 对象还支持与整型数、浮点数和其它 timedelta 实例的算术运算。 one_day = datetime . timedelta ( days = 1 ) print ( '1 day :' , one_day ) print ( '5 days :' , one_day * 5 ) print ( '1.5 days :' , one_day * 1.5 ) print ( '1/4 day :' , one_day / 4 ) # 假设午饭时间为 1 小时 work_day = datetime . timedelta ( hours = 7 ) meeting_length = datetime . timedelta ( hours = 1 ) print ( 'meetings per day :' , work_day / meeting_length ) 1 day : 1 day, 0:00:00 5 days : 5 days, 0:00:00 1.5 days : 1 day, 12:00:00 1/4 day : 6:00:00 meetings per day : 7.0","text_tokens":[".","tomorrow","浮点","type",">","对象","与","date"," ","day","print","小时","<","class","+","浮点数","1","点数","meetings","timedelta","datetime","整型","today","、","运算","'","假设","per","/","4","=","还","实例","-",":","days","0","work",",","true","*","时间",")","length","5","算术","7.0","#","。","午饭","6","hours","1.5","其它","支持","_","(","和","为","的","7","00","午饭时间","饭时","one","meeting","12","数","yesterday"],"title":"日期算术运算","title_tokens":["运算","日期","算术"]},{"location":"标准库/8.4.datetime.html#_6","text":"print ( 'Times:' ) t1 = datetime . time ( 12 , 55 , 0 ) print ( ' t1:' , t1 ) t2 = datetime . time ( 13 , 5 , 0 ) print ( ' t2:' , t2 ) print ( ' t1 < t2:' , t1 < t2 ) print () print ( 'Dates:' ) d1 = datetime . date . today () print ( ' d1:' , d1 ) d2 = datetime . date . today () + datetime . timedelta ( days = 1 ) print ( ' d2:' , d2 ) print ( ' d1 > d2:' , d1 > d2 ) Times : t1 : 12 : 55 : 00 t2 : 13 : 05 : 00 t1 < t2 : True Dates : d1 : 2020 - 02 - 03 d2 : 2020 - 02 - 04 d1 > d2 : False","text_tokens":[".",">","date"," ","print","t2","<","+","05","1","04","timedelta","datetime","today","'","=","false",":","d2","-","2020","days","0","times","d1",",","true",")","55","5","dates","t1","time","(","03","00","02","12","13"],"title":"比较数值","title_tokens":["数值","比较"]},{"location":"标准库/8.4.datetime.html#_7","text":"datetime 对象默认的字符串表示法采用的是 ISO-8601 格式 ( YYYY-MM-DDTHH:MM:SS.mmmmmm )。当然也可以使用 strftime() 函数生成其它的格式。 format = \" %a %b %d %H:%M:%S %Y\" today = datetime . datetime . today () print ( 'ISO :' , today ) s = today . strftime ( format ) print ( 'strftime:' , s ) d = datetime . datetime . strptime ( s , format ) print ( 'strptime:' , d . strftime ( format )) ISO : 2020 - 02 - 03 21 : 11 : 31.684806 strftime : Mon Feb 03 21 : 11 : 31 2020 strptime : Mon Feb 03 21 : 11 : 31 2020 相同的格式化代码可以与 Python 的 string formatting mini-language 一起使用，方法是将它们放在格式字符串的字段规范中的 : 后面。 today = datetime . datetime . today () print ( 'ISO :' , today ) print ( 'format(): {: %a %b %d %H:%M:%S %Y}' . format ( today )) ISO : 2020 - 02 - 03 21 : 11 : 31.729803 format (): Mon Feb 03 21 : 11 : 31 2020 每一个 datetime 格式代码均以 % 为前缀，并且后面的冒号被当作是要输出的字符。 符号 含义 例子 %a 星期的简写 'Wed' %A 星期的完整写法 'Wednesday' %w 星期代号 -- 从 0 (周日) 到 6 (周六) '3' %d 月的第几日 (个位数时，十位补 0) '13' %b 月份的简写 'Jan' %B 月份的完整写法 'January' %m 月份 '01' %y 年份的缩写 '16' %Y 年份的完整写法 '2016' %H 小时（ 24 小时制） '17' %I 小时（ 12 小时制） '05' %p AM/PM 'PM' %M 分钟 '00' %S 秒 '00' %f 微秒 '000000' %z 设置时区（适用于对时区敏感的类） '-0500' %Z 时区名 'EST' %j 一年的第几天 '013' %W 一年的第几周 '02' %c 当地当前日期和时间 'Wed Jan 13 17:00:00 2016' %x 当地当前日期 '01/13/16' %X 当地当前时间 '17:00:00' %% 一个 % '%'","text_tokens":["例子","第几","s","字","到","feb","均","格式化","strftime","31","当地","名","时","'","}","分钟","生成","mon","d","pm","w","星期","默认","formatting","于","字符","est","位数","个位","秒","采用","它们","一年","缩写","ddthh","微秒","和","表示法","符号","000000","段","0500","）","中","第几天","可以","{","013","函数","当前","是","2016","b","/","wed","january","格式","日期","2020","方法","年份","类","z","mm","当作","language","周日","要","月份","21","03","为","区","python","，","02","ss","00","11","表示","3","规范","13","16","几周","完整","对象","与","也","i","对","print","小时","补","05","mini","datetime","十位","y","相同","c","jan","string","简写","17","=","-",":","几日","代号","f","含义",")","适用","。","写法","当然","format","几天","并且","其它","后面","m","的","x","周六","mmmmmm","12","时区","."," ","敏感","一个","h","第","个位数","输出","代码","24","前缀","字符串","today","月","01","设置","放在","wednesday","一起","\"","将","0",",","使用","冒号","时间","31.684806","8601","am","%","strptime","从","以","制","j","yyyy","6","p","(","a","31.729803","每","（","被","iso","%%","--"],"title":"格式化和解析","title_tokens":["格式化","解析","格式","和"]},{"location":"标准库/8.4.datetime.html#_8","text":"在 datetime 中，时区由 tzinfo 的子类表示。由于 tzinfo 是一个抽象基类，因此应用程序需要定义一个子类。为了让这个类能用，应用程序还要为一些方法提供适当的实现。 在 timezone 类中， datetime 确实包含了一个略为简单的实现。它使用 UTC 的固定偏移量，并且不支持一年中不同日期的不同偏移量。比如，使用夏令时的地方或者 UTC 的偏移量会随时间变化的地方。 min6 = datetime . timezone ( datetime . timedelta ( hours =- 6 )) plus6 = datetime . timezone ( datetime . timedelta ( hours = 6 )) d = datetime . datetime . now ( min6 ) print ( min6 , ':' , d ) print ( datetime . timezone . utc , ':' , d . astimezone ( datetime . timezone . utc )) print ( plus6 , ':' , d . astimezone ( plus6 )) # 转换为当前系统时间 d_system = d . astimezone () print ( d_system . tzinfo , ' :' , d_system ) UTC-06:00 : 2020-02-03 07:11:31.756794-06:00 UTC : 2020-02-03 13:11:31.756794+00:00 UTC+06:00 : 2020-02-03 19:11:31.756794+06:00 ?D1¨²¡À¨º¡Á?¨º¡À?? : 2020-02-03 21:11:31.756794+08:00 要想将 datetime 值从一个时区转换到另一个时区，可以使用 astimezone() 函数。在上面的例子中，在 UTC 的两边分别显示了 6 小时的时区，并且还使用 datetime.timezone 中的 utc 实例作为参考。最后的输出行显示系统时区中的值，该值可以通过调用 astimezone() 函数获得，调用时不需要参数。","text_tokens":["例子","²","参数","它","地方","到","º","à","时","由","'","还","d","不","d1","通过","适当","#","一些","调用","á","一年","plus6","支持","_","07","提供","两边","确实","系统","中","可以","转换","该值","函数","当前","子类","是","基类","让","略为","会","偏移量","在","日期","06","简单","方法","2020","不同","?","程序","类中","还要","hours","要","值","区","21","为","03","00","，","实现","02","11","表示","13","固定","¨","timezone","随","print","小时","astimezone","timedelta","参考","获得","datetime","另","=","-",":","为了",")","。","19","并且","显示","min6","的","抽象","system","因此","行","时区","最后","了",".","用"," ","一个","31.756794","now","+","输出","夏令时","这个","类能","定义","上面","实例","将","夏令",",","使用","tzinfo","时间","¡","utc","分别","包含","从","作为","或者","6","想","偏移","变化","需要","比如","由于","(","08","应用","应用程序"],"title":"时区","title_tokens":["区","时"]},{"location":"标准库/8.5.calendar.html","text":"Windows 10 Python 3.7.3 @ MSC v.1915 64 bit (AMD64) import calendar from tools import Help as H h = H ( calendar ) d = h . dicts c = calendar . TextCalendar ( calendar . SUNDAY ) c . prmonth ( 2017 , 7 ) H ( calendar . TextCalendar ) . param d = h . dicts module July 2017 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class","text_tokens":["64",".","we","8","28","mo"," ","param","help","h","windows","10","prmonth","1","31","14","24","module","class","su","27","30","c","2","25","@","amd64","13","4","=","textcalendar","17","29","calendar","d","9","3.7","july","15","22","tu","bit",",","26","tools",")","msc","th","5","dicts","20","import","sunday","6","19","23","2017","(","7","fr","sa","21","python","from","as","12","11","3","18","v.1915","16"],"title":"8.5.calendar","title_tokens":["calendar",".","8.5"]},{"location":"计算机基础/1.1.计算机与程序结构.html","text":"CPU 计算机的工作过程就是计算机执行程序的过程。程序是一个指令序列，这个序列明确告诉计算机应该执行什么操作，在什么地方能够找到用来操作的数据。 一旦把程序装入主存储器，计算机就可以自动执行取出指令和执行指令的任务。 专门用来完成此项工作的计算机部件称为中央处理器（Central Processing Unit，CPU） ，做成单片集成电路的CPU通常又称为微处理器（Microprocessor），在一个集成电路中集成了两个 CPU 芯片，称之为双核（dual core）微处理器。现代的个人计算机一般都是使用微处理器作为CPU。 注意：CPU不是指一个特定的某一类东西，而是具有某种功能的部件的总称。所以，不管是何种形态、设计、原理的部件，只要它能具有取出指令、执行指令的功能，它就是CPU。 简而言之， CPU 是用来表示计算机内部元件功能的术语。 下图为陶瓷PGA封装的Intel 80486 DX2 CPU： 计算机工业从1960年代早期开始使用CPU这个术语。迄今为止，CPU从形态、设计到实现都已发生了巨大的变化，但是其基本工作原理却一直没有大的变化。 早期的CPU通常是为大型、特定的应用而定制的。目前，这种为特定应用而设计定制CPU的昂贵方法，在很大程度上已经让位于可大规模生产的通用处理器。这种标准化趋势，诞生于分立晶体管大型计算机（Mainframe）和小型计算机（Minicomputer）年代，并且随着集成电路（IC）的普及而大大加速。 现代的CPU使用集成电路制作，集成电路可以把日益复杂的CPU设计制造在很小的空间里。CPU的小型化和标准化，大大增加了这些数字器件在现代生活中的应用范围，远远超出了专用运算机器这一有限的应用。现代微处理器已经随处可见，从汽车到手机，甚至儿童玩具。 ​ ——参考于 英特尔文档：CPU的功能和组成 CPU和内存由数字集成电路（数字芯片）构成，集成电路通常称为IC（Integrated Circuit），它由晶体管组成，每一个晶体管具有ON/OFF两个状态。 从功能方面来看 ，CPU的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。 寄存器可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有20～100 个寄存器。 控制器负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。 运算器负责运算从内存读入寄存器的数据。 时钟负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。 寄存器的主要种类和功能 根据功能的不同，我们可以将寄存器大致划分为八类。可以看出，==寄存器中存储的内容既可以是指令也可以是数据。其中，数据分为“用于运算的数值”和“表示内存地址的数值”两种。==数据种类不同，存储该数值的寄存器也不同。CPU 中每个寄存器的功能都是不同的。 种类 功能 累加寄存器 accumulator 存储执行运算的数据和运算后的数据 标志寄存器 flag register 存储运算处理后的 CPU 的状态 程序计数器 program counter 存储下一条指令所在内存的地址 基址寄存器 base register 存储数据内存的起始地址 变址寄存器 index register 存储基址寄存器的相对地址 通用寄存器 general purpose register 存储任意数据 指令寄存器 instruction register 存储指令。CPU 内部使用，程序员无法通过程序对该寄存器进行读写操作 栈寄存器 stack register 存储栈区域的起始地址 寄存器对程序员来说比较特殊，因为寄存器是编程中的一个对象，例如在汇编语言中： # 汇编语言编写的程序示例 mov eax, dword ptr [ebp-8] …把数值从内存复制到 eax add eax, dword ptr [ebp-0Ch] …exa 的数值和内存的数值相加 mov dword ptr [ebp-4], eax …把 exa 的数值（上一步的相加结果）存储在内存中 eax 和 ebp 是 CPU 内部的寄存器的名称。内存的存储场所通过地址编号来区分，而寄存器的种类则通过名字来区分。 main memory 通常所说的内存指的是计算机的主存储器（main memory），简称主存。 主存通过控制芯片等与 CPU 相连， 主要负责存储指令和数据。 主存由可读写的元素构成，每个字节（1 Byte = 8 bit ）都带有一个地址编号。 CPU 可以通过该地址读取主存中的指令和数据，以及写入数据。 如何通过内存索引数据？ 内存的构成单位是一个字节（8位），每一个字节都有一个地址编号，这个地址编号是它的逻辑地址。 CPU中的寄存器（基址寄存器、变址寄存器）会储存中被运算的数据的编号地址。CPU寄存器的空间大小决定了CPU能识别多大的内存。 比如说，一个32位的寄存器，它能表示的最大数为$2^{32}-1=4294967295$（十进制数，从0开始；换成16进制数就是FFFFFFFF）。也就是说它能表示$2^{32}=4294967296$种状态。而4g的内存一共有$4\\times1024\\times1024\\times1024=4294967296$个byte，也就是说一个具有32位的寄存器的CPU最多能识别4g的内存。 通过基址寄存器和变址寄存器，我们可以对主内存上特定的内存区域进行划分。首先，我们用十六进制数 将计算机内存上 00000000～FFFFFFFF的地址划分出来。那么，凡是该范围的内存区域，只要有一个 32 位的 寄存器，即可查看全部的内存地址。 CPU所生成的地址通常称为逻辑地址(logical address)，而内存单元所看到的地址（即加载到内存地址寄存器(memory-address register)中的地址）通常称为物理地址(physical address) 。 逻辑地址与物理地址的对应关系并不是固定不变的，这取决于执行的地址绑定方案。因此，逻辑地址又称为虚拟地址。虚拟地址通过 映射 与物理地址对应起来。完成这种映射的硬件设备是 内存管理单元 (memory-management unit, MMU)，完成映射的方法有多种，也就是地址绑定方案有多种。程序无法访问物理地址，只能基于虚拟地址进行操作。","text_tokens":["分立","dx2","虚拟地址","指令寄存器","地方","central","最多能","一类","指令和数据","该","控制器","大小","ebp","即可","多种","读取","计数","4294967296","address","看作","dword","比如说","这一","存储","0ch","每个","管理","这","内存地址","off","定制","不是","大致","总称","此项","circuit","{","对应","看出","规模","部分","所说","东西","是","整个","此项工作","integrated","为止","加速","四个","程序","日益","mmu","负责","单元","读入","instruction","主存储器","100","只能","大型","并","查看","processing","能够","实现","复制","计数器","趋势","也就是说","工业","flag","两种","如何","甚至","很小","访问","基址","等","一共","来","工作","取决","ffffffff","处理器","汇编语言","数字","程序员",")","对主","中央","计算","。","看到","eax","存储器","基本","装入","十进制","的","其","特定","因此","minicomputer","识别","了","mainframe","编号"," ","通用寄存器","映射","汽车","微处理器","儿童","处理","这个","连通","主要","远远","设备","将","换成","使用","则","程度","做成","即","多大","序列","某","～","比如","一条","元素","被","普及","它","可见","大","而是","元件","相互","无法访问","外部","由","里","2","}","4294967295","任务","\\","小型化","原理","生活","…","物理地址","logical","因为","和","专门","术语","大规模","何种","简称","8","状态","pga","中","年代","信号","写入","取决于","示例","最大","增加","；","一种","种","而","其中","大大增加","不同","随着","取出","首先","寄存器","随处可见","机器","特尔","80486","位于","栈","方面","方案","00000000","手机","，","芯片","dual","可用","与","]","index","最大数","没有","内部","都","标志","晶体管","编写","功能","=","就是说","我们","运算器","告诉","理器","并且","物理","就","复制到","数","区域","而言","之为","用","microprocessor","十六","不管","1","那么","范围","集成","生产","有","注意","变化","​","自动","封装","两个","(","大规","1960","应用","名称","构成","相加","用来","一步","到","迄今为止","制造","—","晶体","exa","编程","执行程序","名字","生成","称之为","指令","有些","变址","储存","很大","于","通过","硬件","只要","各","？","大数","intel","电流","设计","控制","标准化","地址","所","种类","数值","可以","读写","八类","随处","单片","“","$","形态","来说","会","全部","方法","发出","分为","accumulator","开始","[","超出","位","为","不过","集成电路","称为","时钟","例如","一般","进行","counter","固定","对","诞生","昂贵","操作","^","4","之间","purpose","算机","mov","bit","电路","主存","main","部件","制作","4g","base","过程","一旦","寄存","双核","完成","什么","通常","可","general","但是","一个","逻辑","register","小型","unit","索引","这些","指","文档","0","找到","大增","空间","program","专用","通用","任意","cpu","内存","ic","（","已","计时","具有","相对","汇编","发生","32","十六进制","应该","却","结果","physical","虚拟","后","关系","标准","累加","个","划分","core","现代","根据","特殊","management","#","来看","大大","on","把","所在","有限","stack","不变","）","起始","比较","场所","一直","暂存","无法","计算机","器件","用于","字节","明确","能","绑定","相连","起来","、","让","儿童玩具","/","add","在","行程","下图","20","凡是","上","巨大","byte","英特尔","以及","读写操作","ptr","表示","16","对象","既","也","区分","中央处理器","语言","这种","参考","迄今","运算","-","决定","复杂","：","目前","所以","就是","存储栈","陶瓷","最多","带有","早期","进制","基于","出来","算器","个人","简而言之","又","times1024","已经","加载","单位","数据","内容",",","执行","”","作为","从","玩具","某种","下","memory","每","成电","英特","组成"],"title":"1.1.计算机与程序结构","title_tokens":["算机",".","程序","与","计算机","1.1","计算","结构","程序结构"]},{"location":"计算机基础/1.1.计算机与程序结构.html#cpu","text":"计算机的工作过程就是计算机执行程序的过程。程序是一个指令序列，这个序列明确告诉计算机应该执行什么操作，在什么地方能够找到用来操作的数据。 一旦把程序装入主存储器，计算机就可以自动执行取出指令和执行指令的任务。 专门用来完成此项工作的计算机部件称为中央处理器（Central Processing Unit，CPU） ，做成单片集成电路的CPU通常又称为微处理器（Microprocessor），在一个集成电路中集成了两个 CPU 芯片，称之为双核（dual core）微处理器。现代的个人计算机一般都是使用微处理器作为CPU。 注意：CPU不是指一个特定的某一类东西，而是具有某种功能的部件的总称。所以，不管是何种形态、设计、原理的部件，只要它能具有取出指令、执行指令的功能，它就是CPU。 简而言之， CPU 是用来表示计算机内部元件功能的术语。 下图为陶瓷PGA封装的Intel 80486 DX2 CPU： 计算机工业从1960年代早期开始使用CPU这个术语。迄今为止，CPU从形态、设计到实现都已发生了巨大的变化，但是其基本工作原理却一直没有大的变化。 早期的CPU通常是为大型、特定的应用而定制的。目前，这种为特定应用而设计定制CPU的昂贵方法，在很大程度上已经让位于可大规模生产的通用处理器。这种标准化趋势，诞生于分立晶体管大型计算机（Mainframe）和小型计算机（Minicomputer）年代，并且随着集成电路（IC）的普及而大大加速。 现代的CPU使用集成电路制作，集成电路可以把日益复杂的CPU设计制造在很小的空间里。CPU的小型化和标准化，大大增加了这些数字器件在现代生活中的应用范围，远远超出了专用运算机器这一有限的应用。现代微处理器已经随处可见，从汽车到手机，甚至儿童玩具。 ​ ——参考于 英特尔文档：CPU的功能和组成 CPU和内存由数字集成电路（数字芯片）构成，集成电路通常称为IC（Integrated Circuit），它由晶体管组成，每一个晶体管具有ON/OFF两个状态。 从功能方面来看 ，CPU的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。 寄存器可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有20～100 个寄存器。 控制器负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。 运算器负责运算从内存读入寄存器的数据。 时钟负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。","text_tokens":["分立","发生","普及","构成","dx2","应该","用来","它","地方","到","迄今为止","却","而是","元件","大","central","可见","制造","相互","结果","外部","—","一类","晶体","标准","由","里","执行程序","任务","控制器","个","称之为","指令","core","有些","现代","小型化","根据","很大","原理","生活","于","来看","大大","看作","on","把","只要","有限","和","这一","各","专门","存储","intel","电流","设计","控制","标准化","off","术语","大规模","何种","）","定制","状态","pga","种类","中","不是","年代","一直","信号","暂存","计算机","可以","此项","总称","器件","随处","circuit","不过","明确","能","规模","部分","东西","单片","是","增加","、","一种","此项工作","整个","让","儿童玩具","形态","integrated","会","/","为止","而","加速","在","方法","大大增加","发出","手机","不同","行程","下图","四个","程序","日益","随着","20","取出","负责","寄存器","随处可见","开始","机器","特尔","上","80486","巨大","位于","超出","英特尔","读入","方面","主存储器","100","为","大型","并","processing","，","能够","实现","集成电路","芯片","dual","趋势","称为","工业","可用","表示","时钟","一般","对象","也","诞生","中央处理器","甚至","很小","没有","内部","昂贵","操作","都","这种","参考","迄今","晶体管","等","来","运算","工作","处理器","功能","数字","复杂","：","之间","算机","电路","运算器","告诉","目前","所以","主存","中央","计算","就是","。","理器","存储器","基本","陶瓷","部件","并且","制作","装入","组成","的","其","过程","一旦","特定","寄存","就","minicomputer","双核","而言","完成","什么","了","通常","mainframe","早期","可","之为"," ","microprocessor","但是","一个","算器","不管","个人","简而言之","又","汽车","微处理器","已经","小型","儿童","处理","这个","连通","unit","范围","远远","数据","集成","生产","这些","将","指","文档","有","使用","找到","大增","程度","注意","空间","做成","执行","专用","通用","作为","从","玩具","某种","变化","序列","自动","cpu","某","​","封装","两个","内存","～","ic","（","1960","大规","成电","应用","每","已","计时","英特","具有"],"title":"CPU","title_tokens":["cpu"]},{"location":"计算机基础/1.1.计算机与程序结构.html#_1","text":"根据功能的不同，我们可以将寄存器大致划分为八类。可以看出，==寄存器中存储的内容既可以是指令也可以是数据。其中，数据分为“用于运算的数值”和“表示内存地址的数值”两种。==数据种类不同，存储该数值的寄存器也不同。CPU 中每个寄存器的功能都是不同的。 种类 功能 累加寄存器 accumulator 存储执行运算的数据和运算后的数据 标志寄存器 flag register 存储运算处理后的 CPU 的状态 程序计数器 program counter 存储下一条指令所在内存的地址 基址寄存器 base register 存储数据内存的起始地址 变址寄存器 index register 存储基址寄存器的相对地址 通用寄存器 general purpose register 存储任意数据 指令寄存器 instruction register 存储指令。CPU 内部使用，程序员无法通过程序对该寄存器进行读写操作 栈寄存器 stack register 存储栈区域的起始地址 寄存器对程序员来说比较特殊，因为寄存器是编程中的一个对象，例如在汇编语言中： # 汇编语言编写的程序示例 mov eax, dword ptr [ebp-8] …把数值从内存复制到 eax add eax, dword ptr [ebp-0Ch] …exa 的数值和内存的数值相加 mov dword ptr [ebp-4], eax …把 exa 的数值（上一步的相加结果）存储在内存中 eax 和 ebp 是 CPU 内部的寄存器的名称。内存的存储场所通过地址编号来区分，而寄存器的种类则通过名字来区分。","text_tokens":["名称","相加","一步","指令寄存器","结果","后","exa","编程","累加","该","名字","划分","指令","变址","根据","ebp","特殊","…","通过","#","计数","把","所在","因为","dword","stack","和","存储","0ch","每个","内存地址","地址","种类","）","起始","状态","比较","8","中","场所","大致","数值","无法","可以","用于","读写","八类","看出","示例","是","“","来说","add","而","在","其中","分为","不同","程序","accumulator","寄存器","[","上","instruction","栈","汇编","为","复制","，","计数器","读写操作","ptr","表示","例如","进行","counter","flag","两种","既","对象","]","也","区分","index","对","语言","内部","都","标志","基址","操作","来","运算","编写","4","功能","=","汇编语言","-","：","purpose","mov","我们","程序员","。","eax","存储栈","base","的","寄存","复制到","区域","general","编号"," ","一个","通用寄存器","register","处理","数据","将","内容",",","使用","则","program","执行","通用","”","从","下","任意","cpu","内存","（","一条","相对"],"title":"寄存器的主要种类和功能","title_tokens":["种类","和","的","主要","寄存器","寄存","功能"]},{"location":"计算机基础/1.1.计算机与程序结构.html#main-memory","text":"通常所说的内存指的是计算机的主存储器（main memory），简称主存。 主存通过控制芯片等与 CPU 相连， 主要负责存储指令和数据。 主存由可读写的元素构成，每个字节（1 Byte = 8 bit ）都带有一个地址编号。 CPU 可以通过该地址读取主存中的指令和数据，以及写入数据。","text_tokens":["简称","）","8","通常","构成","可","编号","中","与"," ","字节","计算机","一个","可以","读写","写入","所说","1","都","是","等","相连","指令和数据","由","该","主要","=","数据","指令","指","算机","bit","通过","负责","主存","计算","。","读取","memory","main","存储器","cpu","byte","内存","以及","主存储器","（","的","存储","，","每个","带有","芯片","控制","元素","地址"],"title":"main memory","title_tokens":["memory","main"," "]},{"location":"计算机基础/1.1.计算机与程序结构.html#_2","text":"内存的构成单位是一个字节（8位），每一个字节都有一个地址编号，这个地址编号是它的逻辑地址。 CPU中的寄存器（基址寄存器、变址寄存器）会储存中被运算的数据的编号地址。CPU寄存器的空间大小决定了CPU能识别多大的内存。 比如说，一个32位的寄存器，它能表示的最大数为$2^{32}-1=4294967295$（十进制数，从0开始；换成16进制数就是FFFFFFFF）。也就是说它能表示$2^{32}=4294967296$种状态。而4g的内存一共有$4\\times1024\\times1024\\times1024=4294967296$个byte，也就是说一个具有32位的寄存器的CPU最多能识别4g的内存。 通过基址寄存器和变址寄存器，我们可以对主内存上特定的内存区域进行划分。首先，我们用十六进制数 将计算机内存上 00000000～FFFFFFFF的地址划分出来。那么，凡是该范围的内存区域，只要有一个 32 位的 寄存器，即可查看全部的内存地址。 CPU所生成的地址通常称为逻辑地址(logical address)，而内存单元所看到的地址（即加载到内存地址寄存器(memory-address register)中的地址）通常称为物理地址(physical address) 。 逻辑地址与物理地址的对应关系并不是固定不变的，这取决于执行的地址绑定方案。因此，逻辑地址又称为虚拟地址。虚拟地址通过 映射 与物理地址对应起来。完成这种映射的硬件设备是 内存管理单元 (memory-management unit, MMU)，完成映射的方法有多种，也就是地址绑定方案有多种。程序无法访问物理地址，只能基于虚拟地址进行操作。","text_tokens":["32","构成","十六进制","虚拟地址","它","到","physical","最多能","无法访问","虚拟","关系","2","}","该","4294967295","生成","个","\\","划分","变址","储存","大小","通过","即可","物理地址","management","logical","多种","address","4294967296","硬件","只要","比如说","和","大数","不变","管理","这","内存地址","地址","所","）","8","状态","中","不是","字节","无法","可以","计算机","{","对应","取决于","最大","能","绑定","是","起来","；","、","$","会","种","而","全部","方法","程序","mmu","单元","首先","凡是","寄存器","开始","上","byte","位","只能","为","并","00000000","查看","，","方案","也就是说","称为","表示","进行","16","固定","与","也","最大数","访问","都","^","基址","这种","操作","一共","运算","取决","ffffffff","4","=","-","就是说","决定","算机","我们",")","对主","就是","计算","。","看到","最多","十进制","4g","的","物理","特定","因此","寄存","数","区域","完成","识别","了","通常","编号","进制","基于","用","出来"," ","一个","十六","逻辑","1","又","times1024","映射","register","那么","这个","加载","单位","范围","unit","设备","数据","将","有","0","换成",",","空间","执行","从","即","memory","多大","cpu","内存","比如","～","(","（","每","被","具有"],"title":"如何通过内存索引数据？","title_tokens":["内存","通过","如何","？","索引","数据"]},{"location":"计算机基础/1.2.基本概念.html","text":"程序和编程语言 程序（Program） 告诉计算机应如何完成一个计算任务，这里的计算可以是数学运算，比如解方程，也可以是符号运算，比如查找和替换文档中的某个单词。从根本上说，==计算机是由数字电路组成的运算机器，只能对数字做运算，程序之所以能做符号运算，是因为符号在计算机内部也是用数字表示的。==此外，程序还可以处理声音和图像，声音和图像在计算机内部必然也是用数字表示的，这些数字经过专门的硬件设备转换成人可以听到、看到的声音和图像。 程序由一系列 指令（Instruction） 组成，指令是指示计算机做某种运算的命令，通常包括以下几类： 输入（Input）：从键盘、文件或者其它设备获取数据。 输出（Output）：把数据显示到屏幕，或者存入一个文件，或者发送到其它设备。 基本运算：执行最基本的数学运算（加减乘除）和数据存取。 测试和分支：测试某个条件，然后根据不同的测试结果执行不同的后续指令。 循环：重复执行一系列操作。 对于程序来说，有上面这几类指令就足够了。你曾用过的任何一个程序，不管它有多么复杂，都是由这几类指令组成的。程序是那么的复杂，而编写程序可以用的指令却只有这么简单的几种，这中间巨大的落差就要由程序员去填了，所以编写程序理应是一件相当复杂的工作。 编写程序可以说就是这样一个过程：把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。 编程语言 ：编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。 机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，==语句是计算机指令的抽象表示。==举个例子，同样一个语句用C语言、汇编语言和机器语言分别表示如下： 低级编程语言使用计算机指令编写程序； 高级编程语言使用语句编写程序。 计算机只能对数字做运算，符号、声音、图像在计算机内部都要用数字表示，指令也不例外，上表中的机器语言完全由十六进制数字组成。最早的程序员都是直接用机器语言编程，但是很麻烦，需要查大量的表格来确定每个数字表示什么意思，编写出来的程序很不直观，而且容易出错，于是有了==汇编语言，把机器语言中一组一组的数字用助记符（Mnemonic）表示，直接用这些助记符写出汇编程序，然后让汇编器（Assembler）去查表把助记符替换成数字，也就把汇编语言翻译成了机器语言。 从上面的例子可以看出，==汇编语言和机器语言的指令是一一对应的，汇编语言有三条指令，机器语言也有三条指令，汇编器就是做一个简单的替换工作 ，例如在第一条指令中，把 movl ?,%eax 这种格式的指令替换成机器码 a1 ? ，?表示一个地址，在汇编指令中是 0x804a01c ，转换成机器码之后是 1c a0 04 08 （这是指令中的十六进制数的小端表示，小端表示将在 第 5.1 节 “目标文件” 介绍）。 从上面的例子还可以看出，==高级语言的语句和低级语言的指令之间不是简单的一一对应关系，==一条 a=b+1; 语句要翻译成三条汇编或机器指令，这个过程称为 编译（Compile） ，由编译器（Compiler）来完成，显然编译器的功能比汇编器要复杂得多。用高级语言编写的程序必须经过编译转成机器指令才能被计算机执行，编译需要花一些时间，这是用高级语言编程的一个缺点，然而更多的是优点。首先，用高级语言编程更容易，写出来的代码更紧凑，可读性更强，出了错也更容易改正。其次，高级语言是可移植的（Portable）或者称为平台无关的（Platform Independent）。 平台 这个词有很多种解释，可以指计算机体系结构（Architecture），也可以指操作系统（Operating System），也可以指开发平台（编译器、链接器等）。不同的计算机体系结构有不同的指令集（Instruction Set），可以识别的机器指令格式是不同的，直接用某种体系结构的汇编或机器指令写出来的程序只能在这种体系结构的计算机上运行，然而各种体系结构的计算机都有各自的C编译器，可以把C程序编译成各种不同体系结构的机器指令，这意味着用C语言写的程序只需稍加修改甚至不用修改就可以在各种不同的计算机上编译运行。各种高级语言都具有C语言的这些优点，所以绝大部分程序是用高级语言编写的，只有和硬件关系密切的少数程序（例如驱动程序）才会用到低级语言。还要注意一点，即使在相同的体系结构和操作系统下，用不同的C编译器（或者同一个C编译器的不同版本）编译同一个程序得到的结果也有可能不同，C语言有些语法特性在C标准中并没有明确规定，各编译器有不同的实现，编译出来的指令的行为特性也会不同，应该尽量避免使用不可移植的语法特性。 总结一下编译执行的过程，首先你用文本编辑器写一个C程序，然后保存成一个文件，例如 program.c （通常C程序的文件名后缀是 .c ），这称为源代码（Source Code）或源文件，然后运行编译器对它进行编译，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，再加上一些描述信息，生成一个新的文件，例如 a.out ，这称为可执行文件，可执行文件可以被操作系统加载运行，计算机执行该文件中由编译器生成的指令，如下图所示： 有些高级语言以解释（Interpret）的方式执行，解释执行过程和C语言的编译执行过程很不一样。例如编写一个Shell脚本 script.sh ，内容如下： #! /bin/sh VAR = 1 VAR = $(( $VAR + 1 )) echo $VAR 定义Shell变量 VAR 的初始值是1，然后自增1，然后打印 VAR 的值。用Shell程序 /bin/sh 解释执行这个脚本，结果如下： $ / bin / sh script . sh 2 这里的 /bin/sh 称为解释器（Interpreter），它把脚本中的每一行当作一条命令解释执行，而不需要先生成包含机器指令的可执行文件再执行。如果把脚本中的这三行当作三条命令直接敲到Shell提示符下，也能得到同样的结果： $ VAR = 1 $ VAR = $ (( $ VAR + 1 )) $ echo $ VAR 2 编程语言仍在发展演化。以上介绍的机器语言称为第一代语言（1GL，1st Generation Programming Language），汇编语言称为第二代语言（2GL，2nd Generation Programming Language），C、C++、Java、Python等可以称为第三代语言（3GL，3rd Generation Programming Language）。目前已经有了4GL（4th Generation Programming Language）和5GL（5th Generation Programming Language）的概念。3GL的编程语言虽然是用语句编程而不直接用指令编程，但语句也分为输入、输出、基本运算、测试分支和循环等几种，和指令有直接的对应关系。而4GL以后的编程语言更多是描述要做什么（Declarative）而不描述具体一步一步怎么做（Imperative），具体一步一步怎么做完全由编译器或解释器决定，例如SQL语言（SQL，Structured Query Language，结构化查询语言）就是这样的例子。 解释执行的语言相比编译执行的语言有什么优缺点？ 这是我们的第一个思考题。本书的思考题通常要求读者系统地总结当前小节的知识，结合以前的知识，并经过一定的推理，然后作答。本书强调的是基本概念，读者应该抓住概念的定义和概念之间的关系来总结，比如本节介绍了很多概念：程序由语句或指令组成，计算机只能执行 低级语言 中的指令（汇编语言的指令要先转成机器码才能执行），高级语言要执行就必须先翻译成低级语言，翻译的方法有两种：编译和解释，虽然有这样的不便，但高级语言有一个好处是平台无关性。什么是平台？一种平台，就是一种体系结构，就是一种指令集，就是一种机器语言，这些都可看作是一一对应的，上文并没有用“一一对应”这个词，但读者应该能推理出这个结论，而高级语言和它们不是一一对应的，因此高级语言是平台无关的，概念之间像这样的数量对应关系尤其重要。那么编译和解释的过程有哪些不同？主要的不同在于什么时候翻译和什么时候执行。 现在回答这个思考题，根据编译和解释的不同原理，你能否在执行效率和平台无关性等方面做一下比较？ 程序的调试 编程是一件复杂的工作，因为是人做的事情，所以难免经常出错。据说有这样一个典故：早期的计算机体积都很大，有一次一台计算机不能正常工作，工程师们找了半天原因最后发现是一只臭虫钻进计算机中造成的。从此以后，程序中的错误被叫做臭虫（Bug），而找到这些Bug并加以纠正的过程就叫做调试（Debug）。有时候调试是一件非常复杂的工作，要求程序员概念明确、逻辑清晰、性格沉稳，还需要一点运气。调试的技能我们在后续的学习中慢慢培养，但首先我们要区分清楚程序中的Bug分为哪几类。 编译时错误 编译器只能翻译语法正确的程序，否则将导致编译失败，无法生成可执行文件。对于自然语言来说，一点语法错误不是很严重的问题，因为我们仍然可以读懂句子。而编译器就没那么宽容了，只要有哪怕一个很小的语法错误，编译器就会输出一条错误提示信息然后罢工，你就得不到你想要的结果。虽然大部分情况下编译器给出的错误提示信息就是你出错的代码行，但也有个别时候编译器给出的错误提示信息帮助不大，甚至会误导你。在开始学习编程的前几个星期，你可能会花大量的时间来纠正语法错误。等到有了一些经验之后，还是会犯这样的错误，不过会少得多，而且你能更快地发现错误原因。等到经验更丰富之后你就会觉得，语法错误是最简单最低级的错误，编译器的错误提示也就那么几种，即使错误提示是有误导的也能够立刻找出真正的错误原因是什么。相比下面两种错误，语法错误解决起来要容易得多。 运行时错误 编译器检查不出这类错误，仍然可以生成可执行文件，但在运行时会出错而导致程序崩溃。对于我们接下来的几章将编写的简单程序来说，运行时错误很少见，到了后面的章节你会遇到越来越多的运行时错误。读者在以后的学习中要时刻 注意区分编译时和运行时（Run-time）这两个概念 ，不仅在调试时需要区分这两个概念，在学习C语言的很多语法时都需要区分这两个概念，有些事情在编译时做，有些事情则在运行时做。 逻辑错误和语义错误 第三类错误是逻辑错误和语义错误。如果程序里有逻辑错误，编译和运行都会很顺利，看上去也不产生任何错误信息，但是程序没有干它该干的事情，而是干了别的事情。当然不管怎么样，计算机只会按你写的程序去做，问题在于你写的程序不是你真正想要的，这意味着程序的意思（即语义）是错的。找到逻辑错误在哪需要十分清醒的头脑，要通过观察程序的输出回过头来判断它到底在做什么。 调试的过程可能会让你感到一些沮丧，但调试也是编程中最需要动脑的、最有挑战和乐趣的部分。从某种角度看调试就像侦探工作，根据掌握的线索来推断是什么原因和过程导致了你所看到的结果。调试也像是一门实验科学，每次想到哪里可能有错，就修改程序然后再试一次。如果假设是对的，就能得到预期的正确结果，就可以接着调试下一个Bug，一步一步逼近正确的程序；如果假设错误，只好另外再找思路再做假设。“当你把不可能的全部剔除，剩下的——即使看起来再怎么不可能——就一定是事实。”（即使你没看过福尔摩斯也该看过柯南吧）。 也有一种观点认为，编程和调试是一回事，编程的过程就是逐步调试直到获得期望的结果为止。你应该总是从一个能正确运行的小规模程序开始，每做一步小的改动就立刻进行调试，这样的好处是总有一个正确的程序做参考：如果正确就继续编程，如果不正确，那么一定是刚才的小改动出了问题。例如，Linux操作系统包含了成千上万行代码，但它也不是一开始就规划好了内存管理、设备管理、文件系统、网络等等大的模块，一开始它仅仅是Linus Torvalds用来琢磨Intel 80386芯片而写的小程序。据Larry Greenfield 说，“Linus的早期工程之一是编写一个交替打印AAAA和BBBB的程序，这玩意儿后来进化成了Linux。”（引自The Linux User's Guide Beta1版）在后面的章节中会给出更多关于调试和编程实践的建议。 变量及其行为 变量（Variable）是编程语言最重要的概念之一。 变量是计算机存储器中的一块命名的空间，可以在里面存储一个值（Value），存储的值是可以随时变的，比如这次存个字符 'a' 下次存个字符 'b' ，正因为变量的值可以随时变所以才叫变量。 也就是说，变量有一个储存地址，该地址储存的值是可以改变的。或者说，变量是一种使用方便的占位符，用于引用计算机内存地址，变量创建后会占用一定的内存空间。 不要弄混变量和变量名，变量名是标识符的一种。 占位符 ：先占住一个固定的位置，等待值添加到该位置的符号。 变量的类型决定了它所占的存储空间的大小。 变量的行为一共有四种：声明、定义、初始化、赋值。 声明 ：告诉编译器/解析器有这个变量的存在，这个行为不分配内存空间。 定义 ：为变量分配内存空间。 实际上，从广义的角度来说，声明有两种： 引用性声明（defining declaration）：不需要建立储存空间的声明，例如 extern in a 中的变量 a 已经在别的文件中被定义。 定义性声明（referencing declaration）：需要建立储存空间的声明，例如 int a 在声明时就建立了 a 的储存空间。 可见从广义的角度来说，声明包含了定义，而并非所有的声明都是定义。一般的情况下我们常常这样叙述，把建立空间的声明称之为\"定义\"，而把不需要建立存储空间称之为\"声明\"。 定义和声明的本质区别就是：定义会给变量分配内存空间，而声明则不会。 初始化 ：在定义变量之后，系统为变量分配的内存空间内并没有值，此时值是不确定的。为保证程序的安全性和确定性，需要对这个内存空间进行初始化。初始化一般伴随着定义而产生。初始化是从无到有的过程。 如果变量的定义没有初始化，那这个最初分配的空间的值是随机的（空间上原来存储的值）。不经过初始化的变量可能会为程序带来不安全与不确定性。 赋值 ：赋值是变量值得刷新操作。赋值是从旧到新的过程。 基本术语解释 assignment ：Assignments do not copy data — they just bind names to objects. assignment操作不会拷贝，只是把名字和对象做一个绑定。也就是assignment语句是起一个绑定或重绑定的作用（bind or rebind）。函数调用的参数传递是传引用，不是拷贝。 引用（reference ） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。因此，引用亦常被称为==该资料==的 指标 或 位址 。 标识符（identifier，缩写为ID） ：又称为识别码，是一个用来识别不同对象的名称。 在编程语言中，标识符就是程序员自己规定的具有特定含义的词，比如函数名、方法名、类名，变量名、常量名等。 对象（object） ：是一个记忆体位址，其中拥有值，这个位址可能有标识符指向此处。台湾译作物件。对象是某个类的实例。我们将数据和对数据的操作融为一体，形成具有静态信息和动态行为的对象。 每个对象都具有一个ID、一个类型、一个值。对象一旦建立，ID便不会改变。这里所说的ID是是对象在内存中的地址，而不是identifier。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 标识符并不是对象的属性，一个对象可以指向不同的标识符。而管理这些名字（标识符）的事物就是“命名空间”。 命名空间（Namespace） ：名字（标识符）到对象的==映射==。 A namespace is a mapping from names to objects. 各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。 现今 Python 的大部分命名空间是通过字典来实现的，也即一个命名空间就是名字到对象的映射，标识符是键，对象则是值。 与命名空间相对的一个概念就是“作用域” 。 作用域（Scope） ：本质是一块文本区域，Python 通过该文本区域可以 直接访问 相应的命名空间。 直接访问 ：Python 中不加 . 的访问为直接访问，反之为属性访问。 命名空间与作用域的联系 ：作用域是 Python 的一块文本区域，即一块代码区域，需要代码区域引用名字（标识符）来访问变量，那么作用域与命名空间之间就有了联系。 名字作用域 ：名字可以影响到的代码文本区域。 命名空间的作用域 ：就是这个命名空间可以影响到的代码文本区域。 显然可以存在这样的一个代码文本区域，它可以被多个命名空间影响。 面向对象编程 ：基于对象概念来分析问题和设计解法，这就是面向对象编程（object-orientation programming，简称OOP）。通过OOP所得到的程序是一个由很多对象组成的系统，可以向对象发送消息来实现对数据的处理，全体对象通过相互协作来完成程序的数据处理功能。 面向过程编程 ：得到的程序是一组对数据进行操作的过程，通过按顺序执行这些过程来实现程序功能。 类的概念 类是类型概念的发展。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 用计算机解决问题时，首先需要明确问题中涉及哪些数据，并在程序中将这些数据用编程语言提供的数据类型表示出来，然后再去考虑需要对这些数据执行何种操作。 为了表示数据，编程语言一般提供若干 基本数据类型 （如Python的int、float、str和list等类型） ，并为这些基本类型提供相应的基本操作（如Python中对int、float、str和list都提供了+运算，尽管含义不同）。 然而，实际问题中往往涉及很复杂的数据，不能用基本数据类型直接表示。为了表示复杂数据，大体有两种办法： 一种是将复杂数据分解成若干个简单数据项，以便每个数据项可以用基本类型表示 另一种是由用户自定义新的数据类型，以便对复杂数据进行直接的、整体的表示。 例如，如果要表示一个学生的姓名，可以简单地用一个字符串数据表示；如果要表示一个学生的年龄，可以简单地用一个整数数据表示。但如果要整体表示一个“学生”，包括该学生的姓名、年龄、地址等信息，就没法用基本数据类型直接表示了。 一种解决办法是将整体的“学生”分解成姓名、年龄、地址等简单数据，并通过分别处理这些简单数据而达到处理“学生”数据的目的。但这不是好办法，因为这种表示法丢失了数据的整体性，在维护姓名、年龄、地址等数据间的联系时很麻烦。 另一种解决办法是将学生整体视为一个数据值，并为这种数据值定义新的数据类型（因为编程语言中没有现成的类型能够表示该数据）。 假设我们要为“学生“数据定义一个新的数据类型S，那么S应该是由若干更简单的数据项构成的（如学号、姓名等），我们称这些构成S的成员数据为S的属性。除了定义S类型数据的属性，还需要定义能对S数据执行什么操作（如修改姓名或年龄、读取地址等）。可以利用编程语言提供的基本类型和新类型定义机制来实现S，例如用str类型表示姓名和学号，用int类型表示年龄之类，用函数实现对S数据的操作。定义了S，就好像为编程语言添加了一个新的数据类型，应用程序就可以像使用整数、字符串等基本类型一样去使用S。 由此，我们从传统的数据类型概念发展出了“类”的概念。类（class）是广义的数据类型，能够定义复杂数据的特性，包括静态特性（即数据）和动态特性（即对数据的操作方法）。 类的值就是“对象”，也称为类的实例。 对象 vs 变量 python的入门者可能很容易把变量和对象混为一谈。在Python中，变量的准确说法应该name（名字）。 在python中，对象属于某一个类型，而名字是没有类型的。所有的名字都是内存中一个对象的“引用”，也就是说名字对应着对象的地址，而不是储存了对象本身。 例如： nfoo = 1 #一个指向int数据类型的nfoo（再次提醒，nfoo没有类型），在这里，具有类型的是1 lstFoo = [ 1 ] #一个指向list类型的lstFoo，这个list中包含一个整数1","text_tokens":["若干","assignment","进化","赋值","落差","还是","举个","紧凑","效率","版","最","工程师","beta1","号","接着","'","钻进","解析器","该","只好","汇编器","指标","先占住","确定性","数学","set","assignments","1gl","丰富","此外","大小","相互协作","不","各个","指令集","基本操作","初始值","level","帮助","回事","链接","混为","多种","bin","调用","句子","读取","填","copy","字典","看作","符","行为","信息","考题","传","所示","修改","规划","每个","管理","对于","符号","这","思路","存储","内存地址","in","后缀","一行","declaration","不是","方程","否则","转换","对应","正确","看出","规模","特性","部分","所说","给出","若干个","第一","之类","是","不会","福尔","当","code","一门","明确规定","剔除","本质","条件","orientation","以便","为止","格式","某个",";","declarative","产生","叫","not","拷贝","缺点","面向对象编程","程序","方式","实体","这样","objects","初始","译成","文本","曾","language","译作","不到","instruction","体性","机器指令","叫做","一组","错误","greenfield","只能","bind","并","一台","python","介绍","实现","能够","三代","也就是说","查询","小规模","清晰","operating","imperative","不仅","尤其","沉稳","相当","两种","提示信息","如何","怎么样","替换","分解","namespace","甚至","结构","很小","十分","总有","访问","再","2gl","再试一次","等","优点","包括","来","之所以","相同","工作","一共","基本概念","纠正","汇编语言","每次","语法","数字","portable","成千","lstfoo","is","程序员","转成",")","同一","计算","整体","。","看到","一件","eax","哪怕","打印","当然","时刻","存储器","基本","文件名","to","generation","存取","并非","融为","现成","的","抽象","程式","特定","因此","得到","哪","以下","版本","编写程序","了","识别","低级语言","script","作用域","保证"," ","循环","很多","普通","中间","这里","+","数据处理","映射","仅仅","消息","过头","同一个","中不加","字符串","处理","这个","体系结构","主要","设备","先","实例","将","丢失","直到","换成","考虑","使用","则","定性","比","或","!","玩意","便","分别","定义新","尽管","%","是从","要求","即","reference","第一代","怎么","建议","等到","层层","某","比如","time","更强","a","一条","属于","时会","应用程序","物件","被","总是","占","后来","那","造成","很","这是","一一","经验","它","可见","大","而是","value","相互","中将","找出","等待","4th","实际","显然","由","2","里","除了","假设","动态","系列","任务","入门者","数字电路","还","大量","目的","查表","获取","原理","aaaa","输入","办法","原来","发送","传递","添加","据说","运气","就要","传统","混为一谈","改变","重复","等等","因为","网络","和","作答","驱动程序","专门","位置","开发","罢工","数据表示","第一条","提供","movl","rebind","中要","不用","声音","系统","据","术语","一一对","简称","c语言","何种","培养","想到","中","必须","学号","文本编辑","做","解析","compile","函数","当前","演化","释器","；","最有","学生","一种","总结","加上","b","关于","一般而言","中一","摩斯","反之","而","维护","str","简单","其中","逼近","错","不同","解释器","只","值得","可执行文件","顺利","首先","还要","2nd","机器","当作","解决","类名","好","从此以后","说","几类","方面","重名","失败","，","沮丧","芯片","下来","继续","福尔摩斯","思考题","事实","实验","与","]","编译成","弄混","建立","接下","guide","编辑","larry","没有","内部","非常复杂","章节","structured","都","常","大部","数字电","c","越来越","错误信息","they","分解成","顺序","编写","看起来","涉及","=","功能","到底","广义","就是说","变","随机","即使","or","names","多么","而且","密切","我们","告诉","体积","debug","含义","多","machine","经过","使用方便","面向","占住","事物","机器码","系统地","时候","动脑","3rd","如","结合","整数","读懂","器写","间接","整体性","达到","线索","第二","就","数","区域","而言","三条","解法","给","第一个","没法用","用","之为","现今","十六","技能","按","不管","发现错误","崩溃","成千上万","the","节","掌握","伴随","1","分配","实际上","不确定性","那么","稍加","机器语言","几种","误导","把子","千上万","运行","不可","下面","提醒","标识","多个","几个","高级","out","有","找","替换成","人","回过头来","1c","注意","尽量避免","不要","缩写","区别","包含","torvalds","上万","操作方法","一下","c++","台湾","协作","安全","带来","两个","(","正常","观点","花","乘除","少数","足够","里面","或者说","platform","思考","sh","结构化","查找","获取数据","用到","源代码","典故","体系","及其","output","例子","这次","名称","构成","根本","一步","用来","s","参数","到","如果","编程语言","原因","几章","成","半天","确定","identifier","柯南","形成","—","high","编程","时","自然","执行程序","看过","名字","生成","小","data","需","不出","才","指令","有些","储存","类型","称之为","年龄","如学","很大","助记","上文","于","通过","另外","字符","scope","转","亦","利用","科学","一些","头脑","描述","硬件","很少","数据类型","初始化","只会","随时","只要","吧","单词","之一","转换成","各","？","旧到","最早","intel","variable","回答","影响","表示法","看上去","一只","设计","改正","5.1","写出","地址","所","前","自己","无关","变量","可以","键盘","低级","a1","别的","defining","input","好处","自增","快","“","们","independent","推断","图像","交替","会为","其次","$","数量","来说","得不到","会","run","全部","你","内","方法","一样","从根本上","分为","从无到有","分配内存","类","非常","更","属性","然后","目标","能否","开始","读者","于是","[","相比","词有","相应","要","值","汇编程序","或重","命令","提示","为","说法","不过","难免","感到","会少","过","称为","仍","自定","例如","源文件","容易","进行","遇到","固定","一般","以上","上去","起","name","查询语言","float","存入","任何","越来","入门","对","才能","0x804a01c","数据表","优缺点","操作","移植","图","可移植","一点","本书","只有","interpret","命名","此处","在于","学习","像是","4gl","assembly","一代","mnemonic","从此","清醒","之间","情况","算机","电路","这么","自然语言","为了","第二代","调试","本","本身","像","linux","臭虫","重要","哪些","显示","echo","后面","创建","各种","system","称","过程","语义","一旦","意思","assembler","个别","指向","视为","个字符","问题","完成","成人","最后","表格","通常","一对","什么",".","一定","可","误信","user","占用","但是","一个","慢慢","第","例外","编译器","意味着","经常","逻辑","statement","角度看","由此","extern","代码","class","看上","其他","\"","听到","上面","想要","这些","分支","通过观察","位址","文档","指","推理","所有","下次","可读性","语法错误","解决问题","解决办法","program","找到","空间","标识符","叙述","vs","接下来","这类","性","现在","只是","直观","器","a0","应","编译","可读","内存","需要","5th","（","文件","08","地","以后","后续","出错","干","just","强调","觉得","资料","间","好像","送到","内存空间","清楚","具有","汇编","5gl","作用","相对","list","十六进制","加减乘除","应该","linus","却","查","结果","虽然","int","认为","nfoo","理应","不能","04","完全","名","操作系统","一体","后","关系","函数调用","存在","标准","屏幕","姓名","是因为","得","全体","有时候","成员","query","见","根据","保存","星期","测试","声明","期望","会犯","三类","#","分析","它们","子","角度","模块","把","存","剩下","去","规定","抓住","id","java","乐趣","助记符","看起","解释","）","比较","数据项","加以","shell","会花","导致","应用","尽量","计算机","无法","玩意儿","用于","本质区别","事情","明确","解方程","能","各自","占位","常常","sql","绑定","用户","object","起来","、","行文","正","让","词","没法","有时","/","驱动","存储空间","在","绝大","侦探","参数传递","脚本","拥有","变量名","行程","?","第三代","引用","编程序","小端","绝大部分","准确","刚才","compiler","上","bbbb","此时","大体","意味","巨大","立刻","一系","但","哪里","概念","oop","中是","发现","安全性","独立","刷新","80386","表示","之后","同样","改动","翻译","source","对象","1st","也","区分","再次","语言","发送到","观察","发展","第三类","这种","参考","获得","一块","运算","然而","最初","另","先生","键","宽容","加减","architecture","引自","-","具体","low","决定","复杂","：","二代","挑战","机制","新","平台","逐步","检查","直接","目前","预期","do","所以","结论","就是","方便","语句","联系","翻译成","回过","提示符","静态","一系列","指示","其它","严重","没","行","一一对应","琢磨","性格","上表","早期","进制","基于","如下","小节","出来","真正","判断","mapping","又","输出","不加","四种","工程","已经","出","一次","referencing","必然","以前","记忆","加载","往往","向","写","定义","数据","类型定义","避免","不便","一","内容","常量","自定义",",","知识","时间","文件系统","仍然","电脑","三行","执行","programming","”","从","bug","某种","或者","可能","以","下","大部分","实践","记忆体","麻烦","interpreter","第三","地用","每","3gl","敲到","识别码","from","着","var","装置","融为一体","关系密切","组成","数传"],"title":"1.2.基本概念","title_tokens":["基本",".","1.2","概念","基本概念"]},{"location":"计算机基础/1.2.基本概念.html#_1","text":"程序（Program） 告诉计算机应如何完成一个计算任务，这里的计算可以是数学运算，比如解方程，也可以是符号运算，比如查找和替换文档中的某个单词。从根本上说，==计算机是由数字电路组成的运算机器，只能对数字做运算，程序之所以能做符号运算，是因为符号在计算机内部也是用数字表示的。==此外，程序还可以处理声音和图像，声音和图像在计算机内部必然也是用数字表示的，这些数字经过专门的硬件设备转换成人可以听到、看到的声音和图像。 程序由一系列 指令（Instruction） 组成，指令是指示计算机做某种运算的命令，通常包括以下几类： 输入（Input）：从键盘、文件或者其它设备获取数据。 输出（Output）：把数据显示到屏幕，或者存入一个文件，或者发送到其它设备。 基本运算：执行最基本的数学运算（加减乘除）和数据存取。 测试和分支：测试某个条件，然后根据不同的测试结果执行不同的后续指令。 循环：重复执行一系列操作。 对于程序来说，有上面这几类指令就足够了。你曾用过的任何一个程序，不管它有多么复杂，都是由这几类指令组成的。程序是那么的复杂，而编写程序可以用的指令却只有这么简单的几种，这中间巨大的落差就要由程序员去填了，所以编写程序理应是一件相当复杂的工作。 编写程序可以说就是这样一个过程：把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。 编程语言 ：编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。 机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，==语句是计算机指令的抽象表示。==举个例子，同样一个语句用C语言、汇编语言和机器语言分别表示如下： 低级编程语言使用计算机指令编写程序； 高级编程语言使用语句编写程序。 计算机只能对数字做运算，符号、声音、图像在计算机内部都要用数字表示，指令也不例外，上表中的机器语言完全由十六进制数字组成。最早的程序员都是直接用机器语言编程，但是很麻烦，需要查大量的表格来确定每个数字表示什么意思，编写出来的程序很不直观，而且容易出错，于是有了==汇编语言，把机器语言中一组一组的数字用助记符（Mnemonic）表示，直接用这些助记符写出汇编程序，然后让汇编器（Assembler）去查表把助记符替换成数字，也就把汇编语言翻译成了机器语言。 从上面的例子可以看出，==汇编语言和机器语言的指令是一一对应的，汇编语言有三条指令，机器语言也有三条指令，汇编器就是做一个简单的替换工作 ，例如在第一条指令中，把 movl ?,%eax 这种格式的指令替换成机器码 a1 ? ，?表示一个地址，在汇编指令中是 0x804a01c ，转换成机器码之后是 1c a0 04 08 （这是指令中的十六进制数的小端表示，小端表示将在 第 5.1 节 “目标文件” 介绍）。 从上面的例子还可以看出，==高级语言的语句和低级语言的指令之间不是简单的一一对应关系，==一条 a=b+1; 语句要翻译成三条汇编或机器指令，这个过程称为 编译（Compile） ，由编译器（Compiler）来完成，显然编译器的功能比汇编器要复杂得多。用高级语言编写的程序必须经过编译转成机器指令才能被计算机执行，编译需要花一些时间，这是用高级语言编程的一个缺点，然而更多的是优点。首先，用高级语言编程更容易，写出来的代码更紧凑，可读性更强，出了错也更容易改正。其次，高级语言是可移植的（Portable）或者称为平台无关的（Platform Independent）。 平台 这个词有很多种解释，可以指计算机体系结构（Architecture），也可以指操作系统（Operating System），也可以指开发平台（编译器、链接器等）。不同的计算机体系结构有不同的指令集（Instruction Set），可以识别的机器指令格式是不同的，直接用某种体系结构的汇编或机器指令写出来的程序只能在这种体系结构的计算机上运行，然而各种体系结构的计算机都有各自的C编译器，可以把C程序编译成各种不同体系结构的机器指令，这意味着用C语言写的程序只需稍加修改甚至不用修改就可以在各种不同的计算机上编译运行。各种高级语言都具有C语言的这些优点，所以绝大部分程序是用高级语言编写的，只有和硬件关系密切的少数程序（例如驱动程序）才会用到低级语言。还要注意一点，即使在相同的体系结构和操作系统下，用不同的C编译器（或者同一个C编译器的不同版本）编译同一个程序得到的结果也有可能不同，C语言有些语法特性在C标准中并没有明确规定，各编译器有不同的实现，编译出来的指令的行为特性也会不同，应该尽量避免使用不可移植的语法特性。 总结一下编译执行的过程，首先你用文本编辑器写一个C程序，然后保存成一个文件，例如 program.c （通常C程序的文件名后缀是 .c ），这称为源代码（Source Code）或源文件，然后运行编译器对它进行编译，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，再加上一些描述信息，生成一个新的文件，例如 a.out ，这称为可执行文件，可执行文件可以被操作系统加载运行，计算机执行该文件中由编译器生成的指令，如下图所示： 有些高级语言以解释（Interpret）的方式执行，解释执行过程和C语言的编译执行过程很不一样。例如编写一个Shell脚本 script.sh ，内容如下： #! /bin/sh VAR = 1 VAR = $(( $VAR + 1 )) echo $VAR 定义Shell变量 VAR 的初始值是1，然后自增1，然后打印 VAR 的值。用Shell程序 /bin/sh 解释执行这个脚本，结果如下： $ / bin / sh script . sh 2 这里的 /bin/sh 称为解释器（Interpreter），它把脚本中的每一行当作一条命令解释执行，而不需要先生成包含机器指令的可执行文件再执行。如果把脚本中的这三行当作三条命令直接敲到Shell提示符下，也能得到同样的结果： $ VAR = 1 $ VAR = $ (( $ VAR + 1 )) $ echo $ VAR 2 编程语言仍在发展演化。以上介绍的机器语言称为第一代语言（1GL，1st Generation Programming Language），汇编语言称为第二代语言（2GL，2nd Generation Programming Language），C、C++、Java、Python等可以称为第三代语言（3GL，3rd Generation Programming Language）。目前已经有了4GL（4th Generation Programming Language）和5GL（5th Generation Programming Language）的概念。3GL的编程语言虽然是用语句编程而不直接用指令编程，但语句也分为输入、输出、基本运算、测试分支和循环等几种，和指令有直接的对应关系。而4GL以后的编程语言更多是描述要做什么（Declarative）而不描述具体一步一步怎么做（Imperative），具体一步一步怎么做完全由编译器或解释器决定，例如SQL语言（SQL，Structured Query Language，结构化查询语言）就是这样的例子。","text_tokens":["落差","举个","紧凑","最","该","汇编器","数学","set","1gl","此外","不","指令集","初始值","level","链接","多种","bin","填","行为","信息","所示","修改","每个","对于","符号","这","后缀","一行","不是","方程","转换","对应","看出","特性","部分","第一","是","code","明确规定","条件","格式","某个",";","declarative","缺点","程序","方式","这样","初始","译成","文本","曾","language","instruction","机器指令","一组","只能","并","python","介绍","实现","三代","查询","operating","imperative","相当","如何","替换","分解","甚至","结构","再","2gl","等","优点","包括","来","之所以","相同","工作","汇编语言","语法","数字","portable","程序员",")","同一","计算","。","看到","一件","eax","打印","基本","文件名","generation","存取","的","抽象","得到","以下","版本","编写程序","了","识别","低级语言","script"," ","循环","中间","这里","+","同一个","处理","这个","体系结构","设备","将","直到","换成","使用","比","或","!","分别","%","第一代","怎么","层层","比如","更强","a","一条","属于","被","很","这是","一一","它","而是","4th","显然","由","2","系列","任务","数字电路","还","大量","查表","获取","输入","发送","就要","重复","因为","和","驱动程序","专门","开发","第一条","movl","不用","声音","系统","一一对","c语言","中","必须","文本编辑","做","compile","演化","释器","；","总结","加上","b","而","简单","错","不同","解释器","只","可执行文件","首先","还要","2nd","机器","当作","说","几类","，","编译成","编辑","没有","内部","structured","都","大部","数字电","c","分解成","编写","=","功能","即使","多么","而且","密切","告诉","多","machine","经过","机器码","3rd","器写","第二","就","数","三条","用","十六","不管","节","1","那么","稍加","机器语言","几种","把子","运行","不可","高级","out","有","替换成","1c","注意","尽量避免","包含","一下","c++","(","花","乘除","少数","足够","platform","sh","结构化","查找","获取数据","用到","源代码","体系","output","例子","根本","一步","到","如果","编程语言","成","确定","high","编程","执行程序","生成","需","才","指令","有些","助记","转","一些","描述","硬件","单词","转换成","各","最早","改正","5.1","写出","地址","无关","变量","可以","键盘","低级","a1","input","自增","“","independent","图像","其次","$","来说","会","全部","你","一样","从根本上","分为","更","然后","目标","于是","词有","要","值","汇编程序","命令","提示","过","称为","仍","例如","源文件","容易","进行","以上","查询语言","存入","任何","对","才能","0x804a01c","操作","移植","图","可移植","一点","只有","interpret","4gl","assembly","一代","mnemonic","之间","算机","电路","这么","第二代","显示","echo","各种","system","过程","意思","assembler","完成","成人","最后","表格","通常","一对","什么",".","但是","一个","第","例外","编译器","意味着","statement","代码","听到","上面","这些","分支","文档","指","可读性","program","直观","器","a0","应","编译","可读","需要","5th","（","文件","08","以后","后续","出错","送到","具有","汇编","5gl","十六进制","加减乘除","应该","却","查","结果","虽然","理应","04","完全","操作系统","关系","标准","屏幕","是因为","得","query","根据","保存","测试","#","子","把","去","规定","java","助记符","解释","）","shell","尽量","计算机","明确","解方程","能","各自","sql","、","行文","让","/","驱动","在","绝大","脚本","行程","?","第三代","编程序","小端","绝大部分","compiler","上","意味","巨大","一系","但","概念","中是","表示","之后","同样","翻译","source","1st","也","语言","发送到","发展","这种","运算","然而","先生","加减","architecture","-","具体","low","决定","复杂","：","二代","新","平台","直接","目前","所以","就是","语句","翻译成","提示符","一系列","指示","其它","一一对应","上表","进制","如下","出来","输出","已经","出","必然","加载","写","定义","数据","避免","内容",",","时间","三行","执行","programming","”","从","某种","或者","可能","以","下","大部分","麻烦","interpreter","第三","每","3gl","敲到","var","关系密切","组成"],"title":"程序和编程语言","title_tokens":["编程","程序","和","编程语言","语言"]},{"location":"计算机基础/1.2.基本概念.html#_2","text":"这是我们的第一个思考题。本书的思考题通常要求读者系统地总结当前小节的知识，结合以前的知识，并经过一定的推理，然后作答。本书强调的是基本概念，读者应该抓住概念的定义和概念之间的关系来总结，比如本节介绍了很多概念：程序由语句或指令组成，计算机只能执行 低级语言 中的指令（汇编语言的指令要先转成机器码才能执行），高级语言要执行就必须先翻译成低级语言，翻译的方法有两种：编译和解释，虽然有这样的不便，但高级语言有一个好处是平台无关性。什么是平台？一种平台，就是一种体系结构，就是一种指令集，就是一种机器语言，这些都可看作是一一对应的，上文并没有用“一一对应”这个词，但读者应该能推理出这个结论，而高级语言和它们不是一一对应的，因此高级语言是平台无关的，概念之间像这样的数量对应关系尤其重要。那么编译和解释的过程有哪些不同？主要的不同在于什么时候翻译和什么时候执行。 现在回答这个思考题，根据编译和解释的不同原理，你能否在执行效率和平台无关性等方面做一下比较？","text_tokens":["这是","一一","应该","虽然","效率","关系","由","指令","根据","上文","原理","指令集","它们","看作","抓住","作答","考题","和","？","回答","解释","系统","一一对","）","比较","中","不是","必须","无关","计算机","低级","做","对应","能","好处","当前","第一","是","“","一种","总结","词","数量","而","在","你","方法","不同","程序","这样","然后","能否","机器","译成","读者","要","但","方面","只能","概念","并","介绍","，","翻译","尤其","思考题","两种","才能","语言","结构","没有","都","等","本书","来","在于","基本概念","汇编语言","：","之间","算机","平台","我们","转成","结论","经过","计算","本","语句","。","就是","像","翻译成","重要","哪些","系统地","基本","机器码","时候","结合","的","过程","因此","就","一一对应","一对","了","什么","第一个","通常","一定","低级语言","可","小节","用"," ","很多","一个","节","那么","机器语言","出","以前","这个","体系结构","主要","定义","先","这些","高级","不便","推理","有","知识","或","执行","”","性","现在","要求","一下","编译","比如","（","强调","思考","组成","体系","汇编"],"title":"解释执行的语言相比编译执行的语言有什么优缺点？","title_tokens":["编译","什么","缺点","？","的","执行","语言","解释","优缺点","相比","有"]},{"location":"计算机基础/1.2.基本概念.html#_3","text":"编程是一件复杂的工作，因为是人做的事情，所以难免经常出错。据说有这样一个典故：早期的计算机体积都很大，有一次一台计算机不能正常工作，工程师们找了半天原因最后发现是一只臭虫钻进计算机中造成的。从此以后，程序中的错误被叫做臭虫（Bug），而找到这些Bug并加以纠正的过程就叫做调试（Debug）。有时候调试是一件非常复杂的工作，要求程序员概念明确、逻辑清晰、性格沉稳，还需要一点运气。调试的技能我们在后续的学习中慢慢培养，但首先我们要区分清楚程序中的Bug分为哪几类。 编译时错误 编译器只能翻译语法正确的程序，否则将导致编译失败，无法生成可执行文件。对于自然语言来说，一点语法错误不是很严重的问题，因为我们仍然可以读懂句子。而编译器就没那么宽容了，只要有哪怕一个很小的语法错误，编译器就会输出一条错误提示信息然后罢工，你就得不到你想要的结果。虽然大部分情况下编译器给出的错误提示信息就是你出错的代码行，但也有个别时候编译器给出的错误提示信息帮助不大，甚至会误导你。在开始学习编程的前几个星期，你可能会花大量的时间来纠正语法错误。等到有了一些经验之后，还是会犯这样的错误，不过会少得多，而且你能更快地发现错误原因。等到经验更丰富之后你就会觉得，语法错误是最简单最低级的错误，编译器的错误提示也就那么几种，即使错误提示是有误导的也能够立刻找出真正的错误原因是什么。相比下面两种错误，语法错误解决起来要容易得多。 运行时错误 编译器检查不出这类错误，仍然可以生成可执行文件，但在运行时会出错而导致程序崩溃。对于我们接下来的几章将编写的简单程序来说，运行时错误很少见，到了后面的章节你会遇到越来越多的运行时错误。读者在以后的学习中要时刻 注意区分编译时和运行时（Run-time）这两个概念 ，不仅在调试时需要区分这两个概念，在学习C语言的很多语法时都需要区分这两个概念，有些事情在编译时做，有些事情则在运行时做。 逻辑错误和语义错误 第三类错误是逻辑错误和语义错误。如果程序里有逻辑错误，编译和运行都会很顺利，看上去也不产生任何错误信息，但是程序没有干它该干的事情，而是干了别的事情。当然不管怎么样，计算机只会按你写的程序去做，问题在于你写的程序不是你真正想要的，这意味着程序的意思（即语义）是错的。找到逻辑错误在哪需要十分清醒的头脑，要通过观察程序的输出回过头来判断它到底在做什么。 调试的过程可能会让你感到一些沮丧，但调试也是编程中最需要动脑的、最有挑战和乐趣的部分。从某种角度看调试就像侦探工作，根据掌握的线索来推断是什么原因和过程导致了你所看到的结果。调试也像是一门实验科学，每次想到哪里可能有错，就修改程序然后再试一次。如果假设是对的，就能得到预期的正确结果，就可以接着调试下一个Bug，一步一步逼近正确的程序；如果假设错误，只好另外再找思路再做假设。“当你把不可能的全部剔除，剩下的——即使看起来再怎么不可能——就一定是事实。”（即使你没看过福尔摩斯也该看过柯南吧）。 也有一种观点认为，编程和调试是一回事，编程的过程就是逐步调试直到获得期望的结果为止。你应该总是从一个能正确运行的小规模程序开始，每做一步小的改动就立刻进行调试，这样的好处是总有一个正确的程序做参考：如果正确就继续编程，如果不正确，那么一定是刚才的小改动出了问题。例如，Linux操作系统包含了成千上万行代码，但它也不是一开始就规划好了内存管理、设备管理、文件系统、网络等等大的模块，一开始它仅仅是Linus Torvalds用来琢磨Intel 80386芯片而写的小程序。据Larry Greenfield 说，“Linus的早期工程之一是编写一个交替打印AAAA和BBBB的程序，这玩意儿后来进化成了Linux。”（引自The Linux User's Guide Beta1版）在后面的章节中会给出更多关于调试和编程实践的建议。","text_tokens":["进化","还是","版","工程师","最","beta1","接着","'","钻进","该","只好","丰富","不","帮助","回事","句子","信息","修改","规划","管理","对于","这","思路","不是","否则","正确","规模","部分","给出","是","福尔","当","一门","剔除","为止","产生","程序","这样","不到","叫做","错误","greenfield","只能","一台","并","能够","小规模","清晰","不仅","沉稳","提示信息","两种","怎么样","甚至","很小","十分","总有","再","再试一次","来","工作","纠正","每次","语法","成千","程序员","计算","一件","。","哪怕","看到","当然","打印","时刻","的","得到","哪","了"," ","很多","仅仅","过头","设备","将","直到","则","玩意","要求","即","怎么","建议","等到","time","一条","时会","被","总是","后来","造成","很","经验","它","大","而是","找出","里","假设","还","大量","aaaa","据说","运气","等等","因为","网络","和","罢工","中要","系统","据","c语言","培养","想到","中","做","最有","；","一种","关于","摩斯","而","简单","逼近","错","可执行文件","顺利","首先","解决","好","从此以后","说","几类","失败","，","沮丧","芯片","下来","继续","福尔摩斯","事实","实验","接下","guide","larry","章节","没有","非常复杂","都","大部","越来越","错误信息","编写","看起来","到底","即使","而且","体积","我们","debug","多","时候","动脑","读懂","线索","就","技能","按","发现错误","崩溃","不管","成千上万","the","掌握","那么","几种","误导","千上万","下面","运行","几个","有","找","人","回过头来","注意","包含","torvalds","上万","两个","正常","观点","典故","一步","用来","s","到","如果","原因","几章","半天","成","柯南","—","编程","时","自然","看过","生成","小","不出","有些","很大","通过","另外","科学","一些","头脑","很少","只会","只要","吧","之一","intel","看上去","一只","所","前","可以","低级","别的","好处","快","“","们","推断","交替","得不到","来说","会","run","全部","你","分为","非常","更","然后","开始","读者","相比","要","提示","不过","难免","感到","会少","例如","遇到","容易","进行","上去","任何","越来","对","操作","一点","在于","学习","像是","从此","清醒","情况","算机","自然语言","调试","像","linux","臭虫","后面","过程","语义","意思","个别","问题","最后","什么","误信","一定","user","但是","一个","慢慢","编译器","经常","逻辑","意味着","角度看","代码","看上","想要","这些","通过观察","语法错误","找到","接下来","这类","编译","内存","需要","（","文件","地","干","以后","后续","出错","觉得","清楚","应该","linus","结果","虽然","认为","不能","操作系统","得","有时候","见","根据","星期","期望","会犯","三类","角度","模块","把","剩下","去","乐趣","看起","）","加以","会花","导致","无法","计算机","玩意儿","事情","明确","能","起来","、","行文","让","有时","在","侦探","刚才","bbbb","意味","立刻","但","哪里","概念","发现","80386","之后","改动","翻译","也","区分","语言","观察","第三类","参考","获得","宽容","引自","-","挑战","复杂","：","逐步","检查","预期","所以","就是","回过","严重","没","行","琢磨","性格","早期","真正","判断","输出","工程","一次","出","写","一","时间","文件系统","仍然","执行","bug","”","从","可能","某种","实践","下","大部分","第三","每"],"title":"程序的调试","title_tokens":["程序","调试","的"]},{"location":"计算机基础/1.2.基本概念.html#_4","text":"变量（Variable）是编程语言最重要的概念之一。 变量是计算机存储器中的一块命名的空间，可以在里面存储一个值（Value），存储的值是可以随时变的，比如这次存个字符 'a' 下次存个字符 'b' ，正因为变量的值可以随时变所以才叫变量。 也就是说，变量有一个储存地址，该地址储存的值是可以改变的。或者说，变量是一种使用方便的占位符，用于引用计算机内存地址，变量创建后会占用一定的内存空间。 不要弄混变量和变量名，变量名是标识符的一种。 占位符 ：先占住一个固定的位置，等待值添加到该位置的符号。 变量的类型决定了它所占的存储空间的大小。 变量的行为一共有四种：声明、定义、初始化、赋值。 声明 ：告诉编译器/解析器有这个变量的存在，这个行为不分配内存空间。 定义 ：为变量分配内存空间。 实际上，从广义的角度来说，声明有两种： 引用性声明（defining declaration）：不需要建立储存空间的声明，例如 extern in a 中的变量 a 已经在别的文件中被定义。 定义性声明（referencing declaration）：需要建立储存空间的声明，例如 int a 在声明时就建立了 a 的储存空间。 可见从广义的角度来说，声明包含了定义，而并非所有的声明都是定义。一般的情况下我们常常这样叙述，把建立空间的声明称之为\"定义\"，而把不需要建立存储空间称之为\"声明\"。 定义和声明的本质区别就是：定义会给变量分配内存空间，而声明则不会。 初始化 ：在定义变量之后，系统为变量分配的内存空间内并没有值，此时值是不确定的。为保证程序的安全性和确定性，需要对这个内存空间进行初始化。初始化一般伴随着定义而产生。初始化是从无到有的过程。 如果变量的定义没有初始化，那这个最初分配的空间的值是随机的（空间上原来存储的值）。不经过初始化的变量可能会为程序带来不安全与不确定性。 赋值 ：赋值是变量值得刷新操作。赋值是从旧到新的过程。","text_tokens":["这次","赋值","它","到","如果","int","可见","编程语言","value","确定","等待","后","最","存在","实际","编程","时","'","解析器","该","才","类型","储存","先占住","称之为","确定性","大小","不","声明","原来","字符","添加","改变","角度","初始化","存","因为","符","之一","行为","把","旧到","和","存储","variable","位置","in","符号","内存地址","系统","地址","所","declaration","）","中","变量","计算机","可以","用于","别的","解析","defining","占位","常常","本质区别","是","、","一种","正","不会","会为","b","占","来说","会","/","本质","而","存储空间","在","内","产生","叫","变量名","从无到有","分配内存","引用","程序","值得","这样","初始","此时","上","值","概念","为","并","，","安全性","也就是说","刷新","之后","例如","一般","进行","固定","两种","与","对","弄混","建立","语言","没有","都","操作","命名","一共","一块","最初","广义","就是说","变","决定","随机","：","情况","算机","新","我们","告诉","所以","计算","就是","方便","使用方便","。","经过","占住","重要","存储器","创建","并非","的","过程","就","个字符","了","占用","给","一定","之为","保证"," ","一个","编译器","不确定性","伴随","实际上","分配","extern","四种","已经","referencing","这个","定义","标识","\"","所有","有","下次","使用","则","标识符","定性","空间","叙述","不要","区别","包含","从","或者","性","可能","是从","下","编译","内存","比如","需要","安全","带来","（","a","文件","里面","或者说","随时","着","被","内存空间","那"],"title":"变量及其行为","title_tokens":["及其","变量","行为"]},{"location":"计算机基础/1.2.基本概念.html#_5","text":"assignment ：Assignments do not copy data — they just bind names to objects. assignment操作不会拷贝，只是把名字和对象做一个绑定。也就是assignment语句是起一个绑定或重绑定的作用（bind or rebind）。函数调用的参数传递是传引用，不是拷贝。 引用（reference ） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。因此，引用亦常被称为==该资料==的 指标 或 位址 。 标识符（identifier，缩写为ID） ：又称为识别码，是一个用来识别不同对象的名称。 在编程语言中，标识符就是程序员自己规定的具有特定含义的词，比如函数名、方法名、类名，变量名、常量名等。 对象（object） ：是一个记忆体位址，其中拥有值，这个位址可能有标识符指向此处。台湾译作物件。对象是某个类的实例。我们将数据和对数据的操作融为一体，形成具有静态信息和动态行为的对象。 每个对象都具有一个ID、一个类型、一个值。对象一旦建立，ID便不会改变。这里所说的ID是是对象在内存中的地址，而不是identifier。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 标识符并不是对象的属性，一个对象可以指向不同的标识符。而管理这些名字（标识符）的事物就是“命名空间”。 命名空间（Namespace） ：名字（标识符）到对象的==映射==。 A namespace is a mapping from names to objects. 各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。 现今 Python 的大部分命名空间是通过字典来实现的，也即一个命名空间就是名字到对象的映射，标识符是键，对象则是值。 与命名空间相对的一个概念就是“作用域” 。 作用域（Scope） ：本质是一块文本区域，Python 通过该文本区域可以 直接访问 相应的命名空间。 直接访问 ：Python 中不加 . 的访问为直接访问，反之为属性访问。 命名空间与作用域的联系 ：作用域是 Python 的一块文本区域，即一块代码区域，需要代码区域引用名字（标识符）来访问变量，那么作用域与命名空间之间就有了联系。 名字作用域 ：名字可以影响到的代码文本区域。 命名空间的作用域 ：就是这个命名空间可以影响到的代码文本区域。 显然可以存在这样的一个代码文本区域，它可以被多个命名空间影响。 面向对象编程 ：基于对象概念来分析问题和设计解法，这就是面向对象编程（object-orientation programming，简称OOP）。通过OOP所得到的程序是一个由很多对象组成的系统，可以向对象发送消息来实现对数据的处理，全体对象通过相互协作来完成程序的数据处理功能。 面向过程编程 ：得到的程序是一组对数据进行操作的过程，通过按顺序执行这些过程来实现程序功能。","text_tokens":["作用","名称","assignment","用来","参数","它","到","相互","编程语言","identifier","不能","形成","名","一体","—","被","函数调用","关系","存在","编程","显然","由","该","动态","名字","全体","data","指标","类型","储存","assignments","相互协作","各个","于","通过","scope","亦","传递","发送","分析","调用","copy","字典","改变","数据类型","把","缩写","规定","行为","和","信息","传","影响","每个","id","管理","这","设计","rebind","系统","地址","所","简称","）","不是","中","自己","变量","做","可以","函数","所说","部分","绑定","是","object","“","、","不会","让","词","本质","会","一般而言","中一","反之","orientation","而","在","某个","参数传递","方法","其中","not","拷贝","拥有","不同","变量名","类","一样","引用","程序","实体","objects","这样","面向对象编程","属性","文本","相应","译作","类名","值","重名","但","或重","一组","bind","概念","为","并","oop","python","，","实现","独立","称为","一般","进行","起","对象","与","任何","也","对","建立","namespace","语言","没有","访问","操作","常","都","大部","命名","等","此处","来","一块","they","顺序","键","=","功能","广义","-","or","：","names","之间","is","含义","程序员","我们","直接","do","所以","就是","联系","语句","。","面向","事物","to","静态","存取","融为","间接","组成","的","程式","特定","因此","一旦","过程","指向","得到","视为","就","区域","而言","问题","识别",".","了","解法","完成","基于","作用域","现今"," ","普通","很多","一个","按","这里","mapping","又","不加","映射","代码","数据处理","那么","消息","中不加","记忆","处理","这个","其他","向","标识","数据","位址","实例","多个","这些","将","常量","有","则","标识符","电脑","空间","或","便","执行","programming","”","只是","可能","某种","reference","记忆体","大部分","即","台湾","内存","协作","比如","需要","（","a","识别码","属于","from","just","物件","资料","融为一体","装置","具有","数传","相对"],"title":"基本术语解释","title_tokens":["基本","解释","术语"]},{"location":"计算机基础/1.2.基本概念.html#_6","text":"类是类型概念的发展。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 用计算机解决问题时，首先需要明确问题中涉及哪些数据，并在程序中将这些数据用编程语言提供的数据类型表示出来，然后再去考虑需要对这些数据执行何种操作。 为了表示数据，编程语言一般提供若干 基本数据类型 （如Python的int、float、str和list等类型） ，并为这些基本类型提供相应的基本操作（如Python中对int、float、str和list都提供了+运算，尽管含义不同）。 然而，实际问题中往往涉及很复杂的数据，不能用基本数据类型直接表示。为了表示复杂数据，大体有两种办法： 一种是将复杂数据分解成若干个简单数据项，以便每个数据项可以用基本类型表示 另一种是由用户自定义新的数据类型，以便对复杂数据进行直接的、整体的表示。 例如，如果要表示一个学生的姓名，可以简单地用一个字符串数据表示；如果要表示一个学生的年龄，可以简单地用一个整数数据表示。但如果要整体表示一个“学生”，包括该学生的姓名、年龄、地址等信息，就没法用基本数据类型直接表示了。 一种解决办法是将整体的“学生”分解成姓名、年龄、地址等简单数据，并通过分别处理这些简单数据而达到处理“学生”数据的目的。但这不是好办法，因为这种表示法丢失了数据的整体性，在维护姓名、年龄、地址等数据间的联系时很麻烦。 另一种解决办法是将学生整体视为一个数据值，并为这种数据值定义新的数据类型（因为编程语言中没有现成的类型能够表示该数据）。 假设我们要为“学生“数据定义一个新的数据类型S，那么S应该是由若干更简单的数据项构成的（如学号、姓名等），我们称这些构成S的成员数据为S的属性。除了定义S类型数据的属性，还需要定义能对S数据执行什么操作（如修改姓名或年龄、读取地址等）。可以利用编程语言提供的基本类型和新类型定义机制来实现S，例如用str类型表示姓名和学号，用int类型表示年龄之类，用函数实现对S数据的操作。定义了S，就好像为编程语言添加了一个新的数据类型，应用程序就可以像使用整数、字符串等基本类型一样去使用S。 由此，我们从传统的数据类型概念发展出了“类”的概念。类（class）是广义的数据类型，能够定义复杂数据的特性，包括静态特性（即数据）和动态特性（即对数据的操作方法）。 类的值就是“对象”，也称为类的实例。","text_tokens":["若干","list","很","构成","应该","s","如果","int","编程语言","中将","不能","号","实际","除了","时","编程","由","姓名","假设","该","动态","还","类型","目的","成员","年龄","如学","办法","基本操作","通过","字符","利用","添加","读取","传统","数据类型","尽管","因为","去","和","信息","表示法","修改","每个","数据表示","提供","这","地址","何种","）","数据项","中","不是","学号","可以","计算机","明确","能","若干个","函数","特性","用户","之类","是","学生","；","“","、","一种","没法","以便","而","在","str","简单","方法","一样","不同","类","程序","更","属性","然后","首先","解决","大体","相应","体性","要","值","好","但","概念","并","为","python","，","能够","实现","自定","称为","表示","例如","一般","进行","两种","对象","float","也","对","分解","语言","数据表","没有","发展","再","操作","都","这种","等","包括","来","运算","然而","分解成","另","涉及","广义","机制","复杂","：","算机","新","为了","含义","我们","直接","计算","联系","就是","整体","。","像","哪些","基本","静态","如","现成","整数","的","称","整体性","因此","达到","视为","就","问题","了","维护","什么","没法用","用","出来"," ","普通","一个","class","+","由此","那么","字符串","出","往往","处理","定义","数据","实例","这些","将","丢失","类型定义","有","考虑","自定义","解决问题","解决办法","使用","或","执行","分别","定义新","”","从","某种","即","操作方法","麻烦","需要","地用","（","属于","应用","好像","应用程序","间"],"title":"类的概念","title_tokens":["概念","的","类"]},{"location":"计算机基础/1.2.基本概念.html#vs","text":"python的入门者可能很容易把变量和对象混为一谈。在Python中，变量的准确说法应该name（名字）。 在python中，对象属于某一个类型，而名字是没有类型的。所有的名字都是内存中一个对象的“引用”，也就是说名字对应着对象的地址，而不是储存了对象本身。 例如： nfoo = 1 #一个指向int数据类型的nfoo（再次提醒，nfoo没有类型），在这里，具有类型的是1 lstFoo = [ 1 ] #一个指向list类型的lstFoo，这个list中包含一个整数1","text_tokens":["）","很","了","list","中","对象","应该","name","不是","入门"," ","变量","int","一个","再次","]","nfoo","对应","没有","这里","1","都","具有","是","“","这个","名字","入门者","=","提醒","而","数据","类型","在","就是说","储存","所有","：","lstfoo","引用","混为","准确","”","就是","#","本身","。","可能","[","包含","混为一谈","数据类型","某","把","内存","整数","和","（","说法","的","属于","python","，","也就是说","着","指向","例如","地址","容易"],"title":"对象  vs  变量","title_tokens":["对象","变量"," ","vs"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html","text":"编译型语言和解释型语言的优缺点对比 编程语言可以分为：完全的编译型，纯粹的解释型或者两者相互混合的编程语言。实际上，大部分现有的编程语言都同时拥有其编译型和解释型版本。 编译型语言和解释型语言分别有其各自的优势和不足。下面从编译型语言开始介绍。 编译型语言： 编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%。 编译型程序比解释型程序消耗的内存更少。 不利的一面——编译器比解释器要难写得多。 编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置。 可执行的编译型代码要比相同的解释型代码大许多。例如，C/C++的.exe文件要比同样功能的Java的.class文件大很多。 编译型程序是面向特定平台的因而是平台依赖的。 编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的） 由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。 解释型语言： 解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的。 另一个优势是解释器比编译器容易实现 解释型语言最大的优势之一是其平台独立性 解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的 中间语言代码的大小比编译型可执行代码小很多 平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素。 解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存。 由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多。 解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。 原文链接： http://www.codeproject.com/Articles/1825/The-Common-Language-Runtime-CLR-and-Java-Runtime-E Pros and cons of compiled and interpreted languages Languages can be developed either as fully-compiled, pure-interpreted, or hybrid compiled-interpreted. As a matter of fact, most of the current programming languages have both a compiled and interpreted versions available. Both compiled and interpreted approaches have their advantages and disadvantages. I will start with the compiled languages. Compiled languages One of the biggest advantages of Compiled languages is their execution speed. A program written in C/C++ runs 30-70 % faster then an equivalent program written in Java. Compiled code also takes less memory as compared to an interpreted program. On the down side - a compiler is much more difficult to write than an interpreter. A compiler does not provide much help in debugging a program - how many times have you received a \"Null pointer exception\" in your C code and have spent hours trying to figure out where in your source code did the exception occurred. The executable Compiled code is much bigger in size than an equivalent interpreted code e.g. a C/C++ .exe file is much bigger than an equivalent Java .class file Compiled programs are targeted towards a particular platform and hence are platform dependent. Compiled programs do not allow security to be implemented with in the code - e.g. a compiled program can access any area of the memory, and can do whatever it wants with your PC (most of the viruses are made in compiled languages). Due to loose security and platform dependence - a compiled language is not particularly suited to be used to develop Internet or web-based applications. Interpreted languages Interpreted language provides excellent debugging support. A Java programmer only spends a few minutes fixing a \"Null pointer exception\", because Java runtime not only specifies the nature of exception but also gives the exact line number and function call sequence (the famous stack trace information) where the exception occurred. This facility is something that a compiled language can never provide. Another advantage is that Interpreters are much easier to build then a compiler. One of the biggest advantages of Interpreters is that they make platform-independence possible. Interpreted language also allow high degree of security - something badly needed for an Internet application. An intermediate language code size is much smaller than a compiled executable code. Platform independence, and tight security are the two most important factors that make an interpreted language ideally suited for Internet and web-based applications. Interpreted languages have some serious drawbacks. The interpreted applications take up more memory and CPU resources. This is because in order to run a program written in interpreted language; the corresponding interpreter must be run first. Interpreters are sophisticated, intelligent and resource hungry programs and they take up lot of CPU cycles and RAM. Due to interpreted application's decode-fetch-execute cycle; they are much slower than compiled programs. Interpreters also do lot of code-optimization, security violation checking at run-time; these extra steps take up even more resources and further slows the application down.","text_tokens":["程序运行","approaches","指明","made","联网","ideally","最","lot","'","two","大小","不","帮助","链接","调用","语言所","智能","area","纯粹","支持","信息","in","degree","steps","runtime","空","部分","给出","是","hence","30","code","成为","be","develop",";","cycle","not","缺点","decode","程序","额外","violation","这样","sophisticated","function","does","com","language","错误","因而是","30%","代码优化","并","介绍","好几","实现","applications","sequence","依赖","不仅","exact","where","many","访问","particularly","and","gives","相同","来","现有","important","70","is","you","程序员","性质",")","fixing","。","to","intelligent","资源","的","其","特定","make","因特","版本","interpreters","消耗","了","line","build","保证"," ","很多","more","help","中间","programmer","something","trying","start","implemented","than","exception","严密","周期","使用","fully","比","分别","but","order","%","developed","checking","interpreted","time","由于","a","几分钟","corresponding","disadvantages","codeproject","at","好几个","further","exe","这是","side","独立性","它","相互","大","而是","比用","biggest","实际","70%","versions","2","slows","分钟","current","大量","原文","written","occurred","定位","因为","bigger","和","许多","位置","开发","提供","对比","c语言","中","必须","做","最大","函数","释器","；","an","cons","迫切需要","少","解释器","只","optimization","首先","dependent","难","1825","specifies","，","几分","then","e","型","都","大部","c","only","they","顺序","编写","功能","到底","factors","or","write","pc","allow","而且","多","面向","spent","并且","抓取","web","one","up","就","因素","区域","使","any","of","matter","用","the","that","实际上","resource","因特网","execute","下面","运行","几个","ram","languages","依赖性","有","faster","out","times","runs","extra","fact","不了","also","c++","viruses","安全","http","(","speed","应用","hungry","platform","access","did","一步","s","support","编程语言","—","high","编程","时","received","dependence","null","小","hybrid","needed","一些","tight","particular","高度","intermediate","clr","because","之一","provides","call","towards","两者","可以","another","information","迫切","快","“","次","badly","会","your","run","can","their","你","分为","混合","更","either","花费","pros","application","开始","hours","要","based","targeted","例如","遇到","容易","much","famous","are","任何","it","对","进一步","slower","优缺点","easier","advantages","trace","must",":","修复","为了","nature","down","指针","调试","most","重要","due","programs","互联网","these","什么",".","占用","可","一个","编译器","class","never","代码","compared","www","\"","这些","因而","program","不利","不太","debugging","even","堆栈","想","size","cpu","编译","内存","需要","resources","文件","（","速度","发生","for","环境","降低","executable","number","慢","完全","execution","函数调用","存在","first","得","smaller","个","步骤","fetch","security","不足","一名","它们","how","take","on","stack","java","both","解释","used","一面","）","无法","调试程序","事情","明确","各自","极佳","pointer","independence","possible","/","互联","在","松散","拥有","available","优势","figure","pure","advantage","compiler","few","g","with","以及","drawbacks","安全性","独立","have","理想","同样","equivalent","source","compiled","也","便利","i","语言","小时","suited","优化","另","-","具体","复杂","：","平台","检查","will","do","就是","wants","takes","严重","serious","适合","spends","解码","相关","异常","行号","基于","whatever","facility","著名","loose","多少","病毒","some","写","minutes","excellent","difficult","同时","跟踪","less",",","file","articles","执行","programming","”","从","或者","大部分","memory","interpreter","this","internet","provide","cycles","common","as"],"title":"1.3.编译型语言和解释型语言的优缺点对比","title_tokens":[".","编译","对比","缺点","和","的","型","语言","解释","优缺点","1.3"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#_1","text":"编程语言可以分为：完全的编译型，纯粹的解释型或者两者相互混合的编程语言。实际上，大部分现有的编程语言都同时拥有其编译型和解释型版本。 编译型语言和解释型语言分别有其各自的优势和不足。下面从编译型语言开始介绍。","text_tokens":["两者"," ","可以","型","编程语言","相互","语言","部分","完全","各自","实际上","都","大部","实际","编程","现有","下面","：","有","分为","同时","拥有","优势","不足","混合","分别","从","开始","或者","。","大部分","编译","纯粹","和","的","其","介绍","，","解释","版本"],"title":"编译型语言和解释型语言的优缺点对比","title_tokens":["编译","对比","缺点","和","的","型","语言","解释","优缺点"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#_2","text":"编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%。 编译型程序比解释型程序消耗的内存更少。 不利的一面——编译器比解释器要难写得多。 编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置。 可执行的编译型代码要比相同的解释型代码大许多。例如，C/C++的.exe文件要比同样功能的Java的.class文件大很多。 编译型程序是面向特定平台的因而是平台依赖的。 编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的） 由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。","text_tokens":["程序运行","exe","它","大","而是","比用","—","70%","时","得","不","帮助","之一","支持","和","许多","位置","开发","java","提供","解释","一面","c语言","）","中","可以","做","调试程序","空","事情","最大","明确","部分","快","是","释器","“","次","/","在","你","少","松散","解释器","优势","程序","更","速度","花费","难","要","错误","因而是","30%","，","好几","实现","安全性","依赖","例如","遇到","同样","任何","型","对","语言","小时","访问","大部","c","相同","来","编写","功能","到底","-","pc","平台","多","指针","就是","调试","。","面向","并且","web","的","其","适合","特定","因特","区域","消耗","什么",".","异常","可","基于","用"," ","很多","一个","编译器","class","代码","多少","病毒","因特网","运行","写","几个","依赖性","有","因而","使用","比","不了","执行","不利","”","不太","或者","大部分","想","c++","编译","内存","需要","安全","由于","文件","（","应用","好几个"],"title":"编译型语言：","title_tokens":["编译","语言","：","型"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#_3","text":"解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的。 另一个优势是解释器比编译器容易实现 解释型语言最大的优势之一是其平台独立性 解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的 中间语言代码的大小比编译型可执行代码小很多 平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素。 解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存。 由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多。 解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。 原文链接： http://www.codeproject.com/Articles/1825/The-Common-Language-Runtime-CLR-and-Java-Runtime-E","text_tokens":["发生","这是","指明","一步","独立性","环境","降低","慢","联网","最","—","函数调用","存在","时","2","分钟","小","个","大量","大小","步骤","fetch","原文","链接","调用","一些","一名","它们","语言所","高度","智能","定位","clr","因为","之一","支持","和","信息","位置","java","提供","解释","）","runtime","必须","无法","可以","做","空","最大","函数","迫切","给出","是","“","释器","；","极佳","成为","会","互联","/","迫切需要","解释器","只","优势","程序","缺点","decode","这样","额外","更","首先","com","language","1825","以及","代码优化","并","，","实现","安全性","独立","理想","几分","不仅","容易","也","便利","e","型","进一步","语言","优化","and","另","顺序","编写","-","具体",":","复杂","：","修复","平台","为了","而且","程序员","检查","性质","多","指针","调试","。","重要","并且","抓取","web","严重","资源","的","其","适合","就","互联网","因素","使","了","占用","相关","异常","可","行号","消耗","解码",".","保证"," ","很多","一个","著名","中间","编译器","the","代码","www","execute","运行","这些","跟踪","严密","周期","articles","比","执行","”","堆栈","cpu","编译","内存","需要","安全","由于","http","（","common","几分钟","应用","codeproject","速度"],"title":"解释型语言：","title_tokens":["语言","：","解释","型"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#pros-and-cons-of-compiled-and-interpreted-languages","text":"Languages can be developed either as fully-compiled, pure-interpreted, or hybrid compiled-interpreted. As a matter of fact, most of the current programming languages have both a compiled and interpreted versions available. Both compiled and interpreted approaches have their advantages and disadvantages. I will start with the compiled languages. Compiled languages One of the biggest advantages of Compiled languages is their execution speed. A program written in C/C++ runs 30-70 % faster then an equivalent program written in Java. Compiled code also takes less memory as compared to an interpreted program. On the down side - a compiler is much more difficult to write than an interpreter. A compiler does not provide much help in debugging a program - how many times have you received a \"Null pointer exception\" in your C code and have spent hours trying to figure out where in your source code did the exception occurred. The executable Compiled code is much bigger in size than an equivalent interpreted code e.g. a C/C++ .exe file is much bigger than an equivalent Java .class file Compiled programs are targeted towards a particular platform and hence are platform dependent. Compiled programs do not allow security to be implemented with in the code - e.g. a compiled program can access any area of the memory, and can do whatever it wants with your PC (most of the viruses are made in compiled languages). Due to loose security and platform dependence - a compiled language is not particularly suited to be used to develop Internet or web-based applications. Interpreted languages Interpreted language provides excellent debugging support. A Java programmer only spends a few minutes fixing a \"Null pointer exception\", because Java runtime not only specifies the nature of exception but also gives the exact line number and function call sequence (the famous stack trace information) where the exception occurred. This facility is something that a compiled language can never provide. Another advantage is that Interpreters are much easier to build then a compiler. One of the biggest advantages of Interpreters is that they make platform-independence possible. Interpreted language also allow high degree of security - something badly needed for an Internet application. An intermediate language code size is much smaller than a compiled executable code. Platform independence, and tight security are the two most important factors that make an interpreted language ideally suited for Internet and web-based applications. Interpreted languages have some serious drawbacks. The interpreted applications take up more memory and CPU resources. This is because in order to run a program written in interpreted language; the corresponding interpreter must be run first. Interpreters are sophisticated, intelligent and resource hungry programs and they take up lot of CPU cycles and RAM. Due to interpreted application's decode-fetch-execute cycle; they are much slower than compiled programs. Interpreters also do lot of code-optimization, security violation checking at run-time; these extra steps take up even more resources and further slows the application down.","text_tokens":["approaches","did","side","exe","for","s","made","support","executable","number","ideally","execution","lot","biggest","high","versions","received","dependence","first","'","slows","smaller","null","current","two","hybrid","fetch","security","written","needed","occurred","how","particular","tight","take","on","because","bigger","area","intermediate","stack","provides","in","java","both","degree","used","call","steps","towards","runtime","another","information","hence","30","pointer","code","independence","possible","badly","/","your","run","can","an","their","be","develop",";","cycle","not","available","decode","violation","figure","either","pure","function","application","dependent","does","advantage","sophisticated","optimization","compiler","few","language","hours","g","with","specifies","based","applications","drawbacks","sequence","have","targeted","equivalent","then","much","compiled","source","exact","famous","are","i","e","where","many","it","suited","slower","particularly","easier","and","gives","c","advantages","only","they","trace","must","factors","important","-","or","write","70","is","you","pc","allow",")","will","do","down","fixing","nature","most","wants","takes","to","due","spent","web","intelligent","serious","programs","one","spends","up","make","these","interpreters",".","any","line","whatever","of","matter","build"," ","facility","more","help","programmer","something","loose","the","class","that","never","trying","start","implemented","resource","compared","than","some","execute","minutes","\"","ram","languages","excellent","difficult","out","faster","times","exception","runs","less",",","fact","fully","program","file","extra","but","programming","debugging","%","also","order","even","developed","checking","memory","size","interpreted","c++","interpreter","viruses","provide","internet","this","cpu","cycles","time","(","resources","a","speed","corresponding","hungry","disadvantages","platform","as","access","at","further"],"title":"Pros and cons of compiled and interpreted languages","title_tokens":["and","compiled","of"," ","pros","cons","languages","interpreted"]},{"location":"计算机基础/1.4.字符编码.html","text":"相对于数字，字符串比较特殊的是还有一个编码问题。 一般，计算机的系统结构是基于数字信号来搭建的，计算机中的计算基于数字电路。在计算机内部，所有信息最终都是一个二进制值。计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。 每一个二进制位（bit）有 0 和 1 两种状态，最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），因此一个字节可以表示256种状态（$2^8=256$），每一个状态对应一个符号，就是256个符号，从 00000000 到 11111111 。一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是 65535 ，4个字节可以表示的最大整数是 4294967295 。 ASCII码 因为计算机是美国人发明的，所以在上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。ASCII 码一共规定了128个字符的编码，比如空格 SPACE 是32（二进制 00100000 ），大写的字母 A 是65（二进制 01000001 ）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为 0 。 非ASCII码 英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的 é 的编码为130（二进制 10000010 ）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了 é ，在希伯来语编码中却代表了字母 Gimel ( ג )，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。 GB2312码 汉字多达10万左右，要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了 GB2312 编码，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 可以想得到的是，全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。 Unicode 正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode就像它的名字都表示的，这是一种所有符号的编码。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，可以查询 unicode.org ，或者专门的 汉字对应表 。 Unicode 的问题 需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。（ 这里说的储存是储存在 ROM 中，比如说硬盘。 ） 比如，汉字 严 的 Unicode 是十六进制数 4E25 ，转换成二进制数足足有15位（ 100111000100101 ），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0 ，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 因此不能用Unicode码直接储存文件。 它们造成的结果是： 出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。 Unicode 在很长一段时间内无法推广，直到互联网的出现。 UTF-8 互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。 ==强调一下Unicode和UTF-8的区别：UTF-8是Unicode的一种储存形式，但计算机只能读取二进制的内容，因此计算机读取UTF-8编码的文件，需要将文件转码为Unicode（Unicode是完全二进制的形式）。也就是说，文件以UTF-8的形式储存在硬盘上，以Unicode的形式储存在内存（Ram）中。==例如： 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。很多网页的源码上会有类似 <meta charset=\"UTF-8\" /> 的信息，表示该网页正是用的UTF-8编码。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为 0 ，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于 n 字节的符号（ n > 1 ），第一个字节的前 n 位都设为 1 ，第 n + 1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母 x 表示可用编码的位。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是 0 ，则这个字节单独就是一个字符；如果第一位是 1 ，则连续有多少个 1 ，就表示当前字符占用多少个字节。 下面，还是以汉字 严 为例，演示如何实现 UTF-8 编码。 严 的 Unicode 是 4E25 （ 100111000100101 ），根据上表，可以发现 4E25 处在第三行的范围内（ 0000 0800 - 0000 FFFF ），因此 严 的 UTF-8 编码需要三个字节，即格式是 1110xxxx 10xxxxxx 10xxxxxx 。然后，从 严 的最后一个二进制位开始，依次从后向前填入格式中的 x ，多出的位补 0 。这样就得到了， 严 的 UTF-8 编码是 11100100 10111000 10100101 ，转换成十六进制就是 E4B8A5 。 UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。 参考 字符编码笔记：ASCII，Unicode 和 UTF-8","text_tokens":["英文字","多数","还是","务器","kr","10xxxxxx","10","联网","e4b8a5","最","130","该","127","很长","长度","比特","大小","不","多种","读取","0xxxxxxx","支持","比如说","信息","7","英文","存储","每个","这","符号","对于","位补","还有","韩文","中国","shift","不是","电子邮件","多万","否则","转换","对应","0010","规模","部分","所说","第一","是","呢","不会","当","格式","收信人","毫无","万个","发信","四个","方式","额外","这样","类似","文本","100111000100101","错误","只能","100","实现","也就是说","查询","文字","单字节","--------------------+---------------------------------------------","3","两种","如何","ג","甚至","结构","正是","再","一共","电子","包括","来","邮件","文本文件","相同","工作","集合","最高","三个","数字","11111111","0001","国家","n",")","同一","007f","计算","大多数","。","哪怕","统一","打印","基本","十进制","怎样","的","因此","得到","不断","打开","了","制定","码是","euc"," ","很多","这里","<","+","足足","一节","字符串","同一个","非常简单","处理","这个","先","unicode","将","直到","换成","使用","则","向前","或","分别","一套","代表","韩国","要求","特点","怎么","即","比如","二进制","二三","256","a","本文","大多","10111000","被","多出","不够","造成","很","这是","普及","记事","它","一段","10100101","从后","浏览","实际","显然","2","里","动态","4294967295","上会","数字电路","还","大量","数字信号","大写","足足有","01000001","最广","硬盘","因为","_","和","传输","许多","专门","单独","不用","系统","8","状态","255","中","年代","信号","必须","space","做","charset","最大","世纪","当前","；","日文","只用","一种","总结","处在","种","编入","而","出现","简单","不同","只","ffff","10000010","11100100","收信","源码","说","00000000","连续","，","汉字编码","可用","设","继续","笔记","与","编辑","没有","内部","都","gb2312","全世界","数字电","00100000","集","=","一位","想得到","就是说","历史","而且","我们","位设","多","转码","时候","ascii","jis","整数","第二","就","数","强烈","第一个","用","十六","一律","不管","二条","07ff","1","俄语","推广","实际上","那么","0080","不可","范围","下面","多个","从文件","ram","美国","有","人","1110xxxx","注意","区别","常用","一下","变化","前面","正如","为什么","两个","(","欧洲","系统结构","用到","体系","一部","用来","规则","一部分","如果","到","编程语言","成","偏僻","时","编程","名字","生成","gimel","应运而生","储存","一来","很大","于","字符","利用","上个","一些","采用","冲突","多达","不可避免","转换成","？","上方","最早","汉字","60","设计","控制","软件","前","无关","可以","变长","好处","$","来说","会","设为","全部","内","一样","上个世纪","类","混合","é","更","非常","然后","开始","于是","百种","|","要","值","位","128","至少","为","不过","毫无关系","网页","称为","例如","一般","后文","才能","对","第三行","操作","^","只有","4","不管怎样","之间","算机","浏览器","bit","电路","服务器","这样一来","像","闲置","服务","位为","后面","显示","二进制位","x","接受","互联网","个字符","有二到","问题","完成","最后","什么","占用",".","表","但是","一个","第","代码","填入","其他","一段时间","万左右","\"","依次","这些","编","所有","多万个","0","第二个","至今","容纳","乱码","许多种","编码方式","提及","只是","应运","中文","现在","法语","想","英语","世界","内存","需要","（","地","文件","11110xxx","知道","强调","0800","相对","--","32","4e25","十六进制","应该","字母","却","虽然","结果","不能","完全","操作系统","后","关系","极大","存在","段时间","标准","强烈要求","gb","个","现代","根据","保存","org","15","特殊","~","它们","下表","把","剩下","规定","看成","解释","）","比较","一直","65536",">","字节","无法","计算机","常常","能","记事本","meta","形式","互联","/","在","二个","音符","上","utf","编码","二三倍","rom","byte","但","码","单字","发现","表示","16","为例","也","严","语言","发展","参考","发信人","另","希伯来","-","更大","决定","：","新","直接","注音","再有","所以","大出","就是","注音符号","65","最多","严重","理论","65535","上表","演示","进制","基于","浪费","出来","空格","又","多少","已经","发明","非","必然","遗留","两位","跟据","110xxxxx","希伯来语","避免","最终","左右","沿用","内容","各国","解读","时间","第一位","三行","搭建","作为","从","或者","可能","以","下","沿用至今","第三","每","日本","就够","着","英文字母","三倍","0000"],"title":"1.4.字符编码","title_tokens":["字符",".","编码","1.4"]},{"location":"计算机基础/1.4.字符编码.html#ascii","text":"因为计算机是美国人发明的，所以在上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。ASCII 码一共规定了128个字符的编码，比如空格 SPACE 是32（二进制 00100000 ），大写的字母 A 是65（二进制 01000001 ）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为 0 。","text_tokens":["32","字母","不能","最","关系","个","大写","01000001","字符","上个","因为","规定","7","这","60","符号","控制","）","年代","一直","space","字节","计算机","做","世纪","是","在","上个世纪","只","编码","位","128","为","码","，","称为","与","对","00100000","一共","包括","一位","之间","算机","所以","计算","。","65","统一","打印","ascii","后面","二进制位","的","个字符","了","占用","制定","进制","出来"," ","一个","空格","发明","美国","沿用","0","至今","人","一套","沿用至今","前面","英语","比如","二进制","（","a","被"],"title":"ASCII码","title_tokens":["码","ascii"]},{"location":"计算机基础/1.4.字符编码.html#ascii_1","text":"英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的 é 的编码为130（二进制 10000010 ）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了 é ，在希伯来语编码中却代表了字母 Gimel ( ג )，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。","text_tokens":["不够","用来","字母","它","却","一段","130","个","127","gimel","一来","不","利用","一些","它们","上方","这","符号","）","255","中","字节","无法","可以","是","会","编入","出现","在","一样","不同","音符","方式","这样","é","10000010","于是","编码","位","128","为","码","，","表示","ג","语言","都","另","最高","希伯来","决定","不管怎样","国家","新","注音",")","这样一来","。","注音符号","哪怕","闲置","ascii","最多","怎样","的","因此","就","问题","了","进制","用"," ","但是","一个","不管","这里","又","俄语","其他","希伯来语","这些","所有","有","0","使用","编码方式","只是","代表","法语","英语","比如","二进制","(","256","（","欧洲","就够","体系","--"],"title":"非ASCII码","title_tokens":["非","码","ascii"]},{"location":"计算机基础/1.4.字符编码.html#gb2312","text":"汉字多达10万左右，要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了 GB2312 编码，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 可以想得到的是，全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。","text_tokens":["不够","到","虽然","结果","kr","不能","10","最","关系","显然","标准","里","gb","还","个","冲突","多达","把","不可避免","_","和","汉字","符号","韩文","中国","shift","8","中","65536","无关","字节","可以","是","日文","会","出现","在","毫无","类","混合","文本","上","utf","百种","编码","要","至少","，","毫无关系","汉字编码","表示","后文","与","语言","都","gb2312","全世界","=","-","想得到","而且","所以","多","就是","。","ascii","jis","显示","的","x","理论","得到","就","了","制定","用","euc"," ","但是","出来","一个","处理","不可","万左右","unicode","多个","避免","左右","编","有","各国","使用","乱码","中文","韩国","世界","需要","两个","256","地","日本"],"title":"GB2312码","title_tokens":["码","gb2312"]},{"location":"计算机基础/1.4.字符编码.html#unicode","text":"正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode就像它的名字都表示的，这是一种所有符号的编码。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，可以查询 unicode.org ，或者专门的 汉字对应表 。","text_tokens":["这是","它","到","如果","多数","编程语言","成","偏僻","操作系统","最","存在","标准","编程","里","名字","个","应运而生","现代","org","很大","不","字符","多种","把","因为","支持","和","？","专门","汉字","每个","符号","解释","系统","）","电子邮件","必须","字节","多万","可以","否则","对应","常常","规模","所说","是","一种","不会","会","出现","收信人","在","万个","一样","不同","发信","方式","这样","非常","文本","上","编码","收信","要","错误","但","100","，","查询","表示","也","语言","发展","都","操作","电子","邮件","文本文件","发信人","集合","4","数字","直接","同一","再有","就是","大多数","。","像","统一","的","因此","不断","就","打开","问题","什么","了",".","表","进制","用"," ","一个","一节","同一个","unicode","所有","多万个","容纳","解读","使用","乱码","编码方式","应运","现在","一套","或者","常用","想","世界","正如","需要","为什么","两个","二进制","文件","本文","（","大多","知道","着","被","用到"],"title":"Unicode","title_tokens":["unicode"]},{"location":"计算机基础/1.4.字符编码.html#unicode_1","text":"需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。（ 这里说的储存是储存在 ROM 中，比如说硬盘。 ） 比如，汉字 严 的 Unicode 是十六进制数 4E25 ，转换成二进制数足足有15位（ 100111000100101 ），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0 ，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 因此不能用Unicode码直接储存文件。 它们造成的结果是： 出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。 Unicode 在很长一段时间内无法推广，直到互联网的出现。","text_tokens":["4e25","造成","十六进制","英文字","这是","应该","字母","用来","它","却","如果","结果","一段","不能","联网","极大","段时间","2","个","很长","储存","大小","15","足足有","多种","它们","硬盘","规定","比如说","转换成","和","？","许多","英文","存储","汉字","每个","这","符号","对于","）","前","中","不是","字节","无法","计算机","转换","可以","第一","是","只用","呢","来说","会","互联","而","格式","出现","在","二个","内","不同","只","四个","方式","更","文本","二三倍","rom","100111000100101","位","说","至少","码","，","也就是说","文字","表示","3","如何","才能","严","甚至","没有","都","文本文件","集","4","三个","就是说","更大","：","算机","我们","直接","大出","多","就是","计算","。","统一","ascii","严重","的","因此","接受","第二","就","互联网","数","有二到","问题","了","第一个","进制","浪费","用"," ","一个","十六","这里","推广","代码","足足","那么","已经","必然","这个","其他","一段时间","unicode","有","第二个","换成","0","直到","时间","注意","或","许多种","区别","分别","只是","可能","或者","怎么","需要","比如","两个","二进制","二三","（","本文","文件","知道","就够","英文字母","三倍"],"title":"Unicode 的问题","title_tokens":["的","问题","unicode"," "]},{"location":"计算机基础/1.4.字符编码.html#utf-8","text":"互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。 ==强调一下Unicode和UTF-8的区别：UTF-8是Unicode的一种储存形式，但计算机只能读取二进制的内容，因此计算机读取UTF-8编码的文件，需要将文件转码为Unicode（Unicode是完全二进制的形式）。也就是说，文件以UTF-8的形式储存在硬盘上，以Unicode的形式储存在内存（Ram）中。==例如： 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。很多网页的源码上会有类似 <meta charset=\"UTF-8\" /> 的信息，表示该网页正是用的UTF-8编码。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为 0 ，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于 n 字节的符号（ n > 1 ），第一个字节的前 n 位都设为 1 ，第 n + 1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母 x 表示可用编码的位。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是 0 ，则这个字节单独就是一个字符；如果第一位是 1 ，则连续有多少个 1 ，就表示当前字符占用多少个字节。 下面，还是以汉字 严 为例，演示如何实现 UTF-8 编码。 严 的 Unicode 是 4E25 （ 100111000100101 ），根据上表，可以发现 4E25 处在第三行的范围内（ 0000 0800 - 0000 FFFF ），因此 严 的 UTF-8 编码需要三个字节，即格式是 1110xxxx 10xxxxxx 10xxxxxx 。然后，从 严 的最后一个二进制位开始，依次从后向前填入格式中的 x ，多出的位补 0 。这样就得到了， 严 的 UTF-8 编码是 11100100 10111000 10100101 ，转换成十六进制就是 E4B8A5 。 UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。","text_tokens":["多出","32","4e25","很","普及","十六进制","记事","一部","规则","字母","它","到","如果","一部分","还是","务器","10100101","10xxxxxx","10","完全","联网","从后","浏览","e4b8a5","后","强烈要求","实际","里","2","动态","该","生成","上会","还","个","长度","大量","储存","根据","保存","~","字符","最广","读取","下表","0xxxxxxx","硬盘","把","剩下","支持","看成","转换成","和","传输","信息","7","汉字","对于","符号","位补","单独","不用","软件","）","8","前","中",">","字节","计算机","转换","可以","变长","0010","charset","记事本","最大","好处","部分","当前","第一","meta","是","；","一种","形式","总结","当","处在","会","互联","/","设为","而","格式","出现","在","全部","内","简单","不同","四个","只","方式","ffff","额外","这样","非常","然后","类似","开始","上","utf","|","11100100","编码","100111000100101","源码","位","但","只能","为","码","不过","，","实现","单字","连续","也就是说","可用","网页","发现","单字节","表示","例如","设","--------------------+---------------------------------------------","16","继续","为例","如何","严","第三行","正是","编辑","没有","再","都","包括","只有","相同","工作","4","=","三个","一位","-","就是说","0001","：","算机","浏览器","历史","服务器","n","位设",")","所以","转码","007f","就是","计算","。","统一","服务","位为","基本","时候","ascii","后面","二进制位","的","x","因此","得到","就","互联网","强烈","完成","最后","了","上表","第一个","占用","演示","进制","码是","用"," ","很多","一个","一律","十六","第","二条","07ff","<","+","1","实际上","填入","多少","0080","非常简单","遗留","这个","其他","下面","范围","两位","跟据","110xxxxx","unicode","\"","依次","将","ram","从文件","内容","有","0","换成","解读","使用","则","1110xxxx","第一位","向前","或","三行","区别","编码方式","提及","从","以","或者","特点","要求","即","下","一下","变化","英语","内存","需要","第三","两个","二进制","(","（","文件","10111000","11110xxx","强调","被","0800","0000"],"title":"UTF-8","title_tokens":["-","utf","8"]},{"location":"计算机基础/1.4.字符编码.html#_1","text":"字符编码笔记：ASCII，Unicode 和 UTF-8","text_tokens":["8","笔记","ascii","字符","和"," ","，","unicode","-","utf","：","编码"],"title":"参考","title_tokens":["参考"]}]}