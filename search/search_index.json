{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Python基础/2.1.python基本语法.html","text":"交互模式 Python是一种解释型语言，Python解释器通过一次执行一条语句的方式运行程序。从 tty 读取命令时, 我们称解释器工作于交互模式 (interactive mode)。可以在cmd窗口通过 python 命令启动CPython解释器的交互模式，交互模式下CPython通过主提示符 (primary prompt) 提示下一条命令, 主提示符为 >>> ，而从提示符 ··· 提示一条命令的续行。 加强的交互式解释器(IPython)的提示符是一种编号的风格，如 In[2] ，而不是标准的 >>> 。 python保留字 保留字（又称为关键字）， 不能把它们用作任何标识符名称 。Python的标准库提供了一个keyword模块，可以输出当前版本的所有关键字： import keyword keyword . kwlist print ( keyword . kwlist ) ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 注释 Python中单行注释以 # 开头。多行注释则使用： ''' 或者 \"\"\" 。实际上python只有单行注释。多行注释的本质是字符串对象。 # 这是单行注释 ''' 这是多行注释 这是多行注释 ''' 代码块 python最具特色的就是使用缩进来表示代码块，不是使用大括号{}。而冒号表示一段缩进代码块的开始，其后所有相同层次的代码必须保持相同的缩进量，缩进量则可以随意，直至代码块结束。 一般约定俗成使用4个空格的缩进。 if True : print ( \"True\" ) else : print ( \"False\" ) True 代码续行 如果语句很长，可以使用反斜杠 \\ 来续行，例如： a = 3 + \\ 4 + \\ 5 a 12 在 [] , {} , 或 () 中的多行语句 1 ，不需要使用反斜杠 \\ ，例如： total = [ 'item_one' , 'item_two' , 'item_three' , 'item_four' , 'item_five' ] total ['item_one', 'item_two', 'item_three', 'item_four', 'item_five'] 同一行书写多条语句 Python可以在同一行中使用多条语句，语句之间使用半角分号 ; 分隔。但这样的做法一般不推荐，因为会使代码的可读性变差。 空行 函数、类方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同， 空行并不是Python语法的一部分。 书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。空行也是程序代码的一部分。 Print 输出 print函数默认输出是换行的，如果要实现不换行打印，需要更改print函数的 end 参数： # 换行输出 print ( \"a\" ) print ( \"b\" ) print ( '-' * 10 ) # 不换行输出 print ( \"a\" , end = \" \" ) print ( \"b\" , end = \" \" ) print () a b ---------- a b import 与 from...import 在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块 ( module ) 导入： import somemodule 从某个模块中导入某个函数： from somemodule import somefunction 从某个模块中导入多个函数： from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入： from somemodule import * 转义符 \\ 如果要在字符串中输入一些特殊的字符（这些字符特殊之处在于不能直接输出），这就需要“转义符”。所谓转义，就是不采用符号原先的含义，而采用另外一含义。在Pyhton中， \\ 代表转义符。 下面表格中列出常用的转义符： 转义字符 描述 \\ 在字符串行尾的续行符 \\\\ 反斜杠符号 \\' 单引号 \\\" 双引号 \\a 蜂鸣器响铃（不是喇叭发声），现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效 \\b 退格（Backspace），将光标位置移到前一列 \\e 转义 \\000 空 \\n 换行符 \\v 纵向制表符 \\t 横向制表符，即 Tab 键，一般相当于四个空格 \\r 回车符 \\f 换页 \\oyy 八进制数，yy代表字符，例如： \\o12 代表换行 \\xyy 十六进制数，yy代表字符，例如： \\x0a 代表换行 \\other 其它的字符以普通格式输出 有时候，字符串包含了很多 \\ ，Python默认将'\\'作为转义符处理，但实际上我们想输出的是反斜杠符号 \\ ，（例如输入文件路径）。此时，自然可以在反斜杠前加上转义符 \\ ，但是这样未免太麻烦。Python提供了一个简化的操作，Pyhon允许用 r'字符串内容' 表示 '字符串内容' 内部的字符串默认不转义： print ( ' \\\\\\t\\\\ ' ) print ( '-' * 10 ) print ( r ' \\\\ \\t \\\\ ' ) \\ \\ ---------- \\\\\\t\\\\ name与object 提到编程语言，常常会提起变量这个概念，但在Python中，变量一词更准确的说法应该是name（名字）。有观点认为Python不存在变量这个概念，也有观点认为Python存在变量的概念（即name），只不过Python的变量的行为和其他编程语言有所区别。但在这里不深入探究，在本系列的文章中， 变量 和 名字（name） 具有等同的内涵； 变量值（变量的值） 和 对象（object） 具有等同的内涵。 Python是动态类型的语言，变量不需要声明、定义和初始化，变量会在赋值时被创建。 Objects 所有Python对象都有: 一个惟一的 identity （由id(x)返回的一个整数，注意：identity 不是 identifier） 一个类型（由type(x)返回） 一些值 无法改变对象的identity，也不能改变对象的类型。 改变位于某一地址的对象的引用与类型是不可能的，只能把对象销毁，然后重新创建。 Note 在CPython2.2及更新的版本中，你可以在相当有限的情况下更改对象的类型。 一些对象允许你改变它们的值（在不改变它们的identity和type的情况下），这种对象被称为 mutable object ；而一些对象并不允许你改变它们的值，它们被称为 immutable object 。 类型由 类对象 表示（类对象往往知道类的对象要占多少内存，有什么方法等等）。 一个对象可以有： 零个或多个方法（由类对象提供） 零个或多个 名字 某些对象具有允许你更改对象内容（即对其进行修改）的方法。某些对象仅具有允许您访问内容而不更改内容的方法。一些对象没有任何方法。即使对象具有方法，你也不能改变它们的类型或者identity。 Names name不是object的属性，object并不知道它们的name（名字）。 所有name在创建时必须关联（bind）到一个object，否则在需要引用该name时会报错。 name可以在创建以后指向任何一个object（包括不同类型），所以name本身没有类别，但name关联的object是有类别的。 在python中可以使用type（name）来查看name关联的object的类型。 一个对象可以关联（bind）多个名字，也可以没有名字。 Name存在于namespace（命名空间），例如模块命名空间、实例命名空间、函数的局部命名空间等等。 assignment Python也有assignment这个英文概念，它的中文或许译为 分配 或者 命名 更为恰当，因为在Python中，assignment语句会改动namespace，而不是改动了object。 换而言之，如果在python中有一个assignment statement如下： a = 10 这个assignment语句表示将名称a添加到namespace，并且namespace的a键 2 所对应的value为10。 如果名称已经存在，assignment语句将替换原始名称： a = 10 a = 20 这意味着首先要将名称a添加到namespace，并使其指向包含值10的整数对象。然后再使a其指向包含值20的整数对象。原来的整数对象10不受此操作的影响。 如果这样做： a = [] a . append （ 1 ） 第一条语句将 a 关联到一个空列表对象，这会修改命名空间，第二条语句修改了该列表的内容，这并不会触及namespace。 综上所述，assignment statement在python中有两个作用： 用于（重新）将名称绑定到对象 修改可变对象的属性（内容） 单引号与双引号 在Python中单引号和双引号都可以用来表示一个字符串，比如： str1 = 'python' str2 = \"python\" str1和str2是没有任何区别的。 Python以其易用性而著名，但单引号和双引号却不仅仅是为了方便。想想I'm a big fans of Python.这个字符串应该怎么定义？可以这样写： str3 = 'I \\' m a big fan of Python.' 那么We all know that 'A' and 'B' are two capital letters.又该怎么定义呢？ str4 = 'We all know that \\' A \\' and \\' B \\' are two capital letters.' 显然太多的转义符看起来并不好看，而且容易出错了。那么，在Python中，还可以这样写： str4 = \"We all know that 'A' and 'B' are two capital letters.\" 这样就人性化多了，这就是Python支持双引号和单引号都能用来定义字符串的原因。反之，如果字符串中有双引号，为了避免使用转义符，你可以使用单引号来定义这个字符串。比如： str5 = 'The teacher said: \"Practice makes perfect\" is a very famous proverb.' 这就是Python易用性和人性化的一个极致体现，当你用单引号' '定义字符串的时候，它就会认为你字符串里面的双引号\" \"是普通字符，从而不需要转义。反之当你用双引号定义字符串的时候，就会认为你字符串里面的单引号是普通字符无需转义。 Lambdas 正常创建函数（使用 def ）会自动将其赋值给变量，这与创建其他对象（例如字符串和整数）不同，后者可以动态创建，而无需将它们分配给变量。但只要使用lambda语法创建函数，函数也可以这样做，以这种方式创建的函数称为匿名（anonymous）函数。将简单函数作为参数传递给另一个函数时，最常使用此方法。语法如下： # my_func是正常创建的函数（named function） def my_func ( f , arg ): return f ( arg ) my_func ( lambda x : 2 * x * x , 5 ) 50 在上面的代码中，我们动态创建了一个匿名函数，并使用参数调用它。Lambda函数没有命名函数（named function）那么强大。Lambda函数只能包含一个表达式，通常相当于一行代码。实际上，Lambda函数可以分配给变量，并像普通函数一样使用。但是，很少有充分的理由这样做。通常使用 def 来定义函数通常更好。 double = lambda x : x * 2 print ( double ( 7 )) 14 运算符 算术运算符 运算符 描述 + 加 - 减 * 乘 / 除 % 取模 ** 幂 // 取整除 比较运算符 运算符 描述 == 等于 != 不等于 > 大于 < 小于 >= 大于等于 <= 小于等于 赋值运算符 运算符 描述 = 简单的赋值运算符 += 加法赋值运算符 -= 减法赋值运算符 *= 乘法赋值运算符 /= 除法赋值运算符 %= 取模赋值运算符 **= 幂赋值运算符 //= 取整除赋值运算符 位运算符 运算符 描述 & 按位与运算符：参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为0 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 ~ 按位取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1。 ~x 类似于 -x-1 << 左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数指定移动的位数，高位丢弃，低位补0 >> 右移动运算符：把 > 左边的运算数的各二进位全部右移若干位， >> 右边的数指定移动的位数 111 & 100 100 111 | 100 111 111 ^ 100 11 逻辑运算符 运算符 逻辑表达式 描述 and x and y x、y同时为真，则结果为真，否则为假 or x or y x、y两者有一个为真，则结果为真，否则为假 not not x x为真，结果为假；x为假，结果为真 成员运算符 运算符 描述 in 如果在指定的序列中找到值返回 True，否则返回 False not in 如果在指定的序列中没有找到值返回 True，否则返回 False 身份运算符 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b) 。如果引用的不是同一个对象则返回结果 True，否则返回 False 运算符优先级 运算符 描述 (expressions...), [expressions...], {key: value...}, {expressions...} 表示绑定或元组、表示列表、表示字典、表示集合 x[index], x[index:index], x(arguments...), xattribute 下标、切片、调用、属性引用 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +\\@ 和 -\\@) * / % // 乘，除，取模和取整除 + - 加法减法 >> << 右移，左移运算符 & 位 ‘AND’ ^ 按位异或运算符 <= < > >= 比较运算符 == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 and or not 逻辑运算符 if - else 条件表达式 lambda Lambda 表达式 具有相同优先级的运算符将从左至右的方式依次进行。用小括号 () 可以改变运算顺序。 包括函数、类的定义。 ↩ 目前Python的命名空间使用字典实现，但日后可能会改变。 ↩","text_tokens":["1","~","由",">","时","fans","不过","查看","后者","index","斜杠","同时","普通","对","相同","type","000","从而","加","输入","简单","探究","关键字","name","属性","显然","或许","写","新","实例","匿名","窗口","5","说法","objects","这种","50","capital","人性化","已经","函数","20","分","包含","|","释器","翻转","arg","通常","作用","称","编号","pass","还","换行","0","充分","tab","arguments","模块","作为","取反","在","or","假","很长","前","内涵","a","一种","算术","指定","可读","none","主","true","一般","量值","keyword","制表","即","换","当","自","secondfunc","原始","表达","未免太","原来","你","is","practice","‘","7","也","可以","销毁","and","多行","其它","多","能","把","其后","无需","行尾","默认","回车符","标识符","f","做","高位","原先","序列","实际上","b","简化","若干","4","声明","这里","触及","mutable","给","用作","直至","通过","传递","backspace","anonymous","·","代码","mode","、","the","入口","@","一部","用","<","初始","它","这会","就","右","程序","somefunction","冒号","无法","逻辑","层次","v","此","认为","；"," ","100","判断","名为","中文","相当","开始","对象","try","多个","expressions","中有","一词","实现","列表","↩","break","文章","具有","所有","有效","麻烦","另","five","第一条","加号","及","primary","#","’","while","左","使用","最具","id","import","\"","括号","方法","一个","用来","没有","i","names","此时","十六进制","变差","？","换行符","退格","teacher","位数","字典","知道","从","double","幂","观点",":","标识","等同","并不知道","以","note","第一","all","元组","减法","结束","好看","表达式","想","one","two","自然","真","注释","以后","达式","空格","在于","极致","程序代码","这个","def","现在","比较","r","end","下标","避免","允许","不仅","出错","位于","_","型","finally","这样","光标","突出","注意","第二条","两个","引号","库","转义","综上","类别","of","上面","算符","缩进","一条","thirdfunc","that","不带","二条","very","右边","异或","优先","该位","tty","却","object","理由","修改","somemodule","绑定","插入","您","/","续行符","访问","整个","four","综上所述","移到","%","到","python","某些","打印","指向","概念","str1","大于","if","o12","提示","但是","地址","参数","from","xattribute","准确","更好","制表符","减","动态","不同","补","任何","由类","读取","3","有所区别","&","就是","identity","proverb","module","某一","big","很多","fan","提示符","另外","做法","不知","又","当于","将","操作","namespace","否则","关联","号","来","减号",";","被","运算符","class","需要","乘法","item","占","单行","横向","看起来","左移","解释","we","print","...","书写","=","一些","易用","x0a","左边",",","只有","回车","集合","如下","方便","内存","特色","return","所以","语法","所谓","e","str5","保留","数","类型","乘","正常","全部","时会","进行","二进制位","执行","保持","所述","量","不能","类","nonlocal","直接","输出","in","深入","部分","关键","makes","什么","多少","切片","随意","下面","一列","转义字符","区别","+","人性","里面","返回","然后","半角","我们","not","位置","引用","一元","中","命名","之间","assignment","赋值","本","本质","整数","则","append","译","with","大括号","动态创建","除","著名","else","某个","符","如果","若干位","更为","statement","其他","含义","目前","太多","二个","并且","my","影响","使","算机","x","字符串","即使","块","易用性","等等","路径","标准","并","async","{","y","英文","留字","二进制","语言","同一个","会","处理","自动","提到","最后","缩","体现","之","进制","等于","更","语句","第二","该","except","可读性","分隔","未免","取模","变为","这些","交互","支持","一行","为了","推荐","丢弃","了","“","维护","而言","一段","当前","两段","双引号","容易","yy","各","恰当","str4","famous","原因","*","不仅仅","改变","不受","func","喇叭","只要","一","n","编程","个","更新","小于","这是","右移","内部","-","意味","pyhon","进来","那么","名字","它们","参与","纵向","采用","pyhton","identifier","很少","情况","特殊","加法","小括号","]","例如","惟一","yield","空","内容","响铃","时候","格式","替换","只不过","其","看起",".","14","存在","必须","know","与","因为","工作","本身","行","assert","低位","称为","，","最高","del","像","参数传递",")","这","2","下","bind","计算机","两","常用","常常","每个","用于","cmd","kwlist","重构","符号","创建","于","\\","代表","表格","键","对应","比如","方式","不","应该","而","lambda","风格","调用","换页","提起","111","分配","日后","意味着","最","false","但","str3","两者","名称","定义","可能","!","}","取","immutable","行为","往往","raise","四个","想想","有限","找到","功能","约定俗成","进位","有时候","提供","命令","'","版本","约定","m","位","整除","八进制","是","强大","重新","加上","都","oyy","数传","除法","开头","启动","await","同一","系列","global","添加","(","如","elif","结果","变量值","相应","反之","一部分","仅仅","再","value","11","续行","导入","可变","相异","类似","起来","as","按位","firstfunc","更改","身份","至","初始化","total","局部","10","依次","首先","said","prompt","指数","行中","要","怎么","单引号","所","保留字","xyy","cpython2.2","不会","常","^","编程语言","列出","只能","function","仅","一定","解释器","相当于","[","是不是","实际","空间","和","表示","空行","蜂鸣器","二进位","包括","发声","值","perfect","12","ipython","。","运算","报错","key","便于","（","数据","）","多条","而且","顺序","有所","t","named","或","lambdas","加强","一样","other","有时","优先级","文件","：","str2","移动","interactive","处","的","运行","模式","continue","十六","改动","three","for","以其","are","呢","计算","交互式","有","一次","cpython","反","或者","零个","字符","成员","描述","变量","为","”","letters","不是","条件"],"title":"2.1.python基本语法","title_tokens":["语法","基本","python",".","2.1"]},{"location":"Python基础/2.1.python基本语法.html#_1","text":"Python是一种解释型语言，Python解释器通过一次执行一条语句的方式运行程序。从 tty 读取命令时, 我们称解释器工作于交互模式 (interactive mode)。可以在cmd窗口通过 python 命令启动CPython解释器的交互模式，交互模式下CPython通过主提示符 (primary prompt) 提示下一条命令, 主提示符为 >>> ，而从提示符 ··· 提示一条命令的续行。 加强的交互式解释器(IPython)的提示符是一种编号的风格，如 In[2] ，而不是标准的 >>> 。","text_tokens":["解释","可以","交互","一条","提示","cmd","时",">","加强","prompt","在","命令",",","]","于","tty","读取","是","一种","我们","标准","方式","通过","interactive","而","启动","提示符","风格","的","primary","窗口","运行","(","主","mode","·","解释器","语言","模式","如","[","工作","为","程序","交互式","一次","，","型","cpython","python","ipython","。","执行","释器",")","续行","2","下","从","称"," ","编号","语句","in","不是"],"title":"交互模式","title_tokens":["模式","交互"]},{"location":"Python基础/2.1.python基本语法.html#python","text":"保留字（又称为关键字）， 不能把它们用作任何标识符名称 。Python的标准库提供了一个keyword模块，可以输出当前版本的所有关键字： import keyword keyword . kwlist print ( keyword . kwlist ) ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']","text_tokens":["标识","关键","kwlist","not","关键字","lambda","def","false","with","else","名称","finally","pass","raise","库","提供","模块","'","or","版本","标准","async","await","none","global","(","留字","true","elif","keyword","python","as","is","if","except","可以","and","把","from","标识符","了","任何","当前","保留字","用作","又","[","。","class"," ","（","）","它们","try","print",",","break","]","：","yield","所有","的","return",".","while","continue","保留","import","for","一个","assert","称为","，","del",")","不能","nonlocal","in","输出"],"title":"python保留字","title_tokens":["python","保留字","保留","留字"]},{"location":"Python基础/2.1.python基本语法.html#_2","text":"Python中单行注释以 # 开头。多行注释则使用： ''' 或者 \"\"\" 。实际上python只有单行注释。多行注释的本质是字符串对象。 # 这是单行注释 ''' 这是多行注释 这是多行注释 '''","text_tokens":["多行","对象","以","'","只有","实际上","字符串","：","是","注释","开头","中","的","本质","#","则","使用","实际","\"","python","或者","。","字符","这是"," ","单行"],"title":"注释","title_tokens":["注释"]},{"location":"Python基础/2.1.python基本语法.html#_3","text":"python最具特色的就是使用缩进来表示代码块，不是使用大括号{}。而冒号表示一段缩进代码块的开始，其后所有相同层次的代码必须保持相同的缩进量，缩进量则可以随意，直至代码块结束。 一般约定俗成使用4个空格的缩进。 if True : print ( \"True\" ) else : print ( \"False\" ) True","text_tokens":["进来","缩进",":","可以","开始","print","其后","约定俗成","随意","一段","约定","结束","4","块","相同","直至","所有","就是","而","{","空格","特色","的","代码","true","(","则","一般","使用","必须","最具","false","大括号","括号","表示","\"","else","，","个","python","冒号","缩","。","}","保持",")","层次","量","if"," ","不是"],"title":"代码块","title_tokens":["块","代码"]},{"location":"Python基础/2.1.python基本语法.html#_4","text":"如果语句很长，可以使用反斜杠 \\ 来续行，例如： a = 3 + \\ 4 + \\ 5 a 12 在 [] , {} , 或 () 中的多行语句 1 ，不需要使用反斜杠 \\ ，例如： total = [ 'item_one' , 'item_two' , 'item_three' , 'item_four' , 'item_five' ] total ['item_one', 'item_two', 'item_three', 'item_four', 'item_five']","text_tokens":["total","可以","1","多行","或","=","在","'",",","+","很长","斜杠","]","\\","例如","4","：","3","a","one","two","不","five","{","中","的","(","5","使用","[","three","four","来","，","反","12","_","如果","续行","}",")","需要"," ","item","语句"],"title":"代码续行","title_tokens":["续行","代码"]},{"location":"Python基础/2.1.python基本语法.html#_5","text":"Python可以在同一行中使用多条语句，语句之间使用半角分号 ; 分隔。但这样的做法一般不推荐，因为会使代码的可读性变差。","text_tokens":["可以","推荐","在","行中","使","半角","不","可读","之间","同一","的","做法","代码","一般","使用","因为","会","但","号","，","分","python","变差","。",";","这样","多条"," ","语句","可读性","分隔"],"title":"同一行书写多条语句","title_tokens":["同一","书写","语句","行","多条"]},{"location":"Python基础/2.1.python基本语法.html#_6","text":"函数、类方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同， 空行并不是Python语法的一部分。 书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。空行也是程序代码的一部分。","text_tokens":["也","缩进","解释","开始","部分","但是","一行","以","含义","功能","或","时","书写","重构","维护","不同","一段","两段","是","并","不","不会","之间","新","的","在于","语法","代码","运行","日后","、","插入","入口","解释器","程序代码","一部","用","与","和","表示","方法","空行","函数","一部分","程序","出错","，","python","。","释器","作用","突出"," ","便于","类","不是","分隔"],"title":"空行","title_tokens":["空行"]},{"location":"Python基础/2.1.python基本语法.html#print","text":"print函数默认输出是换行的，如果要实现不换行打印，需要更改print函数的 end 参数： # 换行输出 print ( \"a\" ) print ( \"b\" ) print ( '-' * 10 ) # 不换行输出 print ( \"a\" , end = \" \" ) print ( \"b\" , end = \" \" ) print () a b ---------- a b","text_tokens":["换行","10","print","参数","默认","=","实现","'",",","要","b","是","：","a","不","*","的","(","#","end","\"","函数","，","如果",")","打印","需要","更改"," ","-","输出"],"title":"Print 输出","title_tokens":[" ","print","输出"]},{"location":"Python基础/2.1.python基本语法.html#import-fromimport","text":"在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块 ( module ) 导入： import somemodule 从某个模块中导入某个函数： from somemodule import somefunction 从某个模块中导入多个函数： from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入： from somemodule import *","text_tokens":["多个","thirdfunc","...","from","模块","在",",","：","module","*","中","的","somemodule","(","将","用","import","相应","整个","函数","来","某个","secondfunc","全部","python","somefunction","或者","导入","。",")","firstfunc","从"," "],"title":"import 与 from...import","title_tokens":["...","from","与","import"," "]},{"location":"Python基础/2.1.python基本语法.html#_7","text":"如果要在字符串中输入一些特殊的字符（这些字符特殊之处在于不能直接输出），这就需要“转义符”。所谓转义，就是不采用符号原先的含义，而采用另外一含义。在Pyhton中， \\ 代表转义符。 下面表格中列出常用的转义符： 转义字符 描述 \\ 在字符串行尾的续行符 \\\\ 反斜杠符号 \\' 单引号 \\\" 双引号 \\a 蜂鸣器响铃（不是喇叭发声），现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效 \\b 退格（Backspace），将光标位置移到前一列 \\e 转义 \\000 空 \\n 换行符 \\v 纵向制表符 \\t 横向制表符，即 Tab 键，一般相当于四个空格 \\r 回车符 \\f 换页 \\oyy 八进制数，yy代表字符，例如： \\o12 代表换行 \\xyy 十六进制数，yy代表字符，例如： \\x0a 代表换行 \\other 其它的字符以普通格式输出 有时候，字符串包含了很多 \\ ，Python默认将'\\'作为转义符处理，但实际上我们想输出的是反斜杠符号 \\ ，（例如输入文件路径）。此时，自然可以在反斜杠前加上转义符 \\ ，但是这样未免太麻烦。Python提供了一个简化的操作，Pyhon允许用 r'字符串内容' 表示 '字符串内容' 内部的字符串默认不转义： print ( ' \\\\\\t\\\\ ' ) print ( '-' * 10 ) print ( r ' \\\\ \\t \\\\ ' ) \\ \\ ---------- \\\\\\t\\\\","text_tokens":["常用","以","下面","符号","一列","转义字符","斜杠","\\","代表","表格","键","普通","想","000","我们","位置","自然","输入","不","而","中","空格","在于","换页","直接","现在","r","但","允许","符","如果","包含","这样","光标","引号","四个","转义","换行","含义","不带","tab","有时候","作为","提供","在","'","前","算机","字符串","八进制","是","a","路径","加上","都","oyy","(","一般","续行符","处理","制表","即","移到","python","未免太","续行","不是","之","进制","未免","o12","可以","这些","其它","但是","10","行尾","默认","回车符","f","了","“","制表符","原先","要","b","实际上","简化","双引号","yy","单引号","就是","xyy","backspace","列出","很多","*","另外","喇叭","一定","当于","相当于","将","用","实际","操作","就","表示","一","蜂鸣器","n","发声","。","需要","v"," ","内部","-","（","横向","）","pyhon","相当","纵向","采用","pyhton","t","print","一些","other","有时","x0a","特殊","回车","例如","文件","：","空","有效","麻烦","内容","响铃","时候","处","格式","的","所以","所谓","e","十六","\"","数","一个","计算","，","反","十六进制","此时",")","这","退格","字符","换行符","描述","不能","计算机","”","输出"],"title":"转义符\\","title_tokens":["符","转义","\\"]},{"location":"Python基础/2.1.python基本语法.html#nameobject","text":"提到编程语言，常常会提起变量这个概念，但在Python中，变量一词更准确的说法应该是name（名字）。有观点认为Python不存在变量这个概念，也有观点认为Python存在变量的概念（即name），只不过Python的变量的行为和其他编程语言有所区别。但在这里不深入探究，在本系列的文章中， 变量 和 名字（name） 具有等同的内涵； 变量值（变量的值） 和 对象（object） 具有等同的内涵。 Python是动态类型的语言，变量不需要声明、定义和初始化，变量会在赋值时被创建。","text_tokens":["也","观点","名字","常常","其他","等同","对象","有所","时","一词","准确","不过","在","创建","动态","区别","具有","文章","声明","内涵","是","这里","object","有所区别","不","应该","探究","编程语言","name","中","只不过","赋值","的","本","提起","系列","说法","、","深入","语言","量值","存在","这个","初始","变量值","会","和","类型","即","但","提到","有","编程","值","，","定义","python","。","被","概念","行为","变量","需要","认为","；"," ","更","（","初始化","）"],"title":"name与object","title_tokens":["name","与","object"]},{"location":"Python基础/2.1.python基本语法.html#objects","text":"所有Python对象都有: 一个惟一的 identity （由id(x)返回的一个整数，注意：identity 不是 identifier） 一个类型（由type(x)返回） 一些值 无法改变对象的identity，也不能改变对象的类型。 改变位于某一地址的对象的引用与类型是不可能的，只能把对象销毁，然后重新创建。 Note 在CPython2.2及更新的版本中，你可以在相当有限的情况下更改对象的类型。 一些对象允许你改变它们的值（在不改变它们的identity和type的情况下），这种对象被称为 mutable object ；而一些对象并不允许你改变它们的值，它们被称为 immutable object 。 类型由 类对象 表示（类对象往往知道类的对象要占多少内存，有什么方法等等）。 一个对象可以有： 零个或多个方法（由类对象提供） 零个或多个 名字 某些对象具有允许你更改对象内容（即对其进行修改）的方法。某些对象仅具有允许您访问内容而不更改内容的方法。一些对象没有任何方法。即使对象具有方法，你也不能改变它们的类型或者identity。","text_tokens":[":","由","note","多少","什么","创建","返回","然后","对","type","引用","不","而","中","整数","这种","允许","位于","可能","immutable","注意","往往","有限","提供","在","版本","即使","x","是","object","等等","重新","都","修改","并","(","您","访问","即","python","某些","你","更改","也","可以","销毁","地址","把","要","任何","由类","mutable","identity","某一","cpython2.2","只能","改变","仅","和","表示","值","更新","无法","。","被","；"," ","占","（","）","相当","名字","它们","对象","多个","或","identifier","情况","一些","具有","：","惟一","所有","内容","内存","及","的","其","id","与","类型","方法","一个","没有","有","称为","，","进行","或者",")","零个","下","知道","不能","类","不是"],"title":"Objects","title_tokens":["objects"]},{"location":"Python基础/2.1.python基本语法.html#names","text":"name不是object的属性，object并不知道它们的name（名字）。 所有name在创建时必须关联（bind）到一个object，否则在需要引用该name时会报错。 name可以在创建以后指向任何一个object（包括不同类型），所以name本身没有类别，但name关联的object是有类别的。 在python中可以使用type（name）来查看name关联的object的类型。 一个对象可以关联（bind）多个名字，也可以没有名字。 Name存在于namespace（命名空间），例如模块命名空间、实例命名空间、函数的局部命名空间等等。","text_tokens":["也","局部","可以","名字","它们","并不知道","对象","多个","时","该","模块","创建","在","查看","不同","任何","于","例如","是","object","type","等等","所有","引用","以后","name","属性","中","命名","实例","的","不知","所以","、","存在","必须","使用","空间","类型","本身","namespace","否则","一个","但","关联","函数","包括","没有","有","来","，","到","时会","python","。","不是","指向","知道","需要","报错","bind"," ","（","类别","）"],"title":"Names","title_tokens":["names"]},{"location":"Python基础/2.1.python基本语法.html#assignment","text":"Python也有assignment这个英文概念，它的中文或许译为 分配 或者 命名 更为恰当，因为在Python中，assignment语句会改动namespace，而不是改动了object。 换而言之，如果在python中有一个assignment statement如下： a = 10 这个assignment语句表示将名称a添加到namespace，并且namespace的a键 2 所对应的value为10。 如果名称已经存在，assignment语句将替换原始名称： a = 10 a = 20 这意味着首先要将名称a添加到namespace，并使其指向包含值10的整数对象。然后再使a其指向包含值20的整数对象。原来的整数对象10不受此操作的影响。 如果这样做： a = [] a . append （ 1 ） 第一条语句将 a 关联到一个空列表对象，这会修改命名空间，第二条语句修改了该列表的内容，这并不会触及namespace。 综上所述，assignment statement在python中有两个作用： 用于（重新）将名称绑定到对象 修改可变对象的属性（内容）","text_tokens":["1","用于","第一","然后","键","对应","而","属性","assignment","命名","或许","中","整数","分配","意味着","这个","append","译","已经","20","名称","如果","包含","这样","作用","第二条","两个","更为","statement","综上","一条","二条","并且","在","影响","使","a","object","重新","修改","并","添加","英文","绑定","会","换","再","综上所述","value","原始","到","python","可变","指向","原来","概念","之","第二","语句","该","也","10","首先","做","了","而言","要","所","触及","恰当","不会","不受","将","[","它","操作","这会","表示","namespace","空间","关联","值","。","此"," ","意味","（","）","中文","对象","中有","=","列表","]","：","空","内容","如下","替换","第一条","的","其",".","存在","改动","因为","一个","有","，","或者","所述","这","2","为","不是"],"title":"assignment","title_tokens":["assignment"]},{"location":"Python基础/2.1.python基本语法.html#_8","text":"在Python中单引号和双引号都可以用来表示一个字符串，比如： str1 = 'python' str2 = \"python\" str1和str2是没有任何区别的。 Python以其易用性而著名，但单引号和双引号却不仅仅是为了方便。想想I'm a big fans of Python.这个字符串应该怎么定义？可以这样写： str3 = 'I \\' m a big fan of Python.' 那么We all know that 'A' and 'B' are two capital letters.又该怎么定义呢？ str4 = 'We all know that \\' A \\' and \\' B \\' are two capital letters.' 显然太多的转义符看起来并不好看，而且容易出错了。那么，在Python中，还可以这样写： str4 = \"We all know that 'A' and 'B' are two capital letters.\" 这样就人性化多了，这就是Python支持双引号和单引号都能用来定义字符串的原因。反之，如果字符串中有双引号，为了避免使用转义符，你可以使用单引号来定义这个字符串。比如： str5 = 'The teacher said: \"Practice makes perfect\" is a very famous proverb.' 这就是Python易用性和人性化的一个极致体现，当你用单引号' '定义字符串的时候，它就会认为你字符串里面的双引号\" \"是普通字符，从而不需要转义。反之当你用双引号定义字符串的时候，就会认为你字符串里面的单引号是普通字符无需转义。","text_tokens":[":","makes","fans","all","区别","人性","里面","好看","\\","普通","two","比如","从而","不","应该","而","中","显然","写","极致","这个","capital","人性化","避免","但","不仅","著名","str3","出错","定义","符","如果","这样","引号","转义","of","想想","还","that","very","太多","在","'","m","字符串","却","是","a","易用性","都","并","会","反之","仅仅","当","python","体现","起来","str1","你","practice","is","该","可以","多","and","支持","能","为了","无需","said","了","b","任何","容易","双引号","怎么","单引号","就是","proverb","str4","famous","原因","big","不仅仅","fan","又","the","用","它","和","表示","就","来","perfect","。","需要","认为"," ","看起来","而且","那么","we","中有","=","易用","：","str2","时候","方便","的","看起",".","str5","使用","know","\"","以其","呢","are","一个","用来","没有","i","，","？","这","teacher","字符","letters"],"title":"单引号与双引号","title_tokens":["引号","单引号","与","双引号"]},{"location":"Python基础/2.1.python基本语法.html#lambdas","text":"正常创建函数（使用 def ）会自动将其赋值给变量，这与创建其他对象（例如字符串和整数）不同，后者可以动态创建，而无需将它们分配给变量。但只要使用lambda语法创建函数，函数也可以这样做，以这种方式创建的函数称为匿名（anonymous）函数。将简单函数作为参数传递给另一个函数时，最常使用此方法。语法如下： # my_func是正常创建的函数（named function） def my_func ( f , arg ): return f ( arg ) my_func ( lambda x : 2 * x * x , 5 ) 50 在上面的代码中，我们动态创建了一个匿名函数，并使用参数调用它。Lambda函数没有命名函数（named function）那么强大。Lambda函数只能包含一个表达式，通常相当于一行代码。实际上，Lambda函数可以分配给变量，并像普通函数一样使用。但是，很少有充分的理由这样做。通常使用 def 来定义函数通常更好。 double = lambda x : x * 2 print ( double ( 7 )) 14","text_tokens":[":","以","时","创建","后者","表达式","普通","我们","方式","简单","而","lambda","达式","中","匿名","命名","赋值","调用","整数","分配","5","这种","最","50","def","动态创建","函数","但","_","定义","包含","这样","arg","通常","上面","其他","充分","作为","my","在","x","字符串","是","强大","理由","并","数传","(","会","自动","表达","7","也","可以","但是","一行","参数","无需","做","f","了","更好","动态","不同","实际上","给","常","传递","*","func","只能","function","anonymous","代码","当于","只要","相当于","将","它","实际","和","来","。","此"," ","（","）","相当","那么","它们","对象","named","print","很少","=","一样",",","例如","：","另","如下","其","的","语法","return","#","14","使用","与","方法","一个","没有","有","正常","，","称为","像","参数传递",")","这","字符","2","变量","double"],"title":"Lambdas","title_tokens":["lambdas"]},{"location":"Python基础/2.1.python基本语法.html#_9","text":"","text_tokens":[],"title":"运算符","title_tokens":["运算符","运算","算符"]},{"location":"Python基础/2.1.python基本语法.html#_10","text":"运算符 描述 + 加 - 减 * 乘 / 除 % 取模 ** 幂 // 取整除","text_tokens":["取模","%","整除","除","取","运算","描述","运算符","加","/","幂"," ","-","减","+","*","乘","算符"],"title":"算术运算符","title_tokens":["运算","运算符","算术","算符"]},{"location":"Python基础/2.1.python基本语法.html#_11","text":"运算符 描述 == 等于 != 不等于 > 大于 < 小于 >= 大于等于 <= 小于等于","text_tokens":["等于","小于","!","不","运算",">","描述","运算符","<","=","大于"," ","算符"],"title":"比较运算符","title_tokens":["比较","运算符","运算","算符"]},{"location":"Python基础/2.1.python基本语法.html#_12","text":"运算符 描述 = 简单的赋值运算符 += 加法赋值运算符 -= 减法赋值运算符 *= 乘法赋值运算符 /= 除法赋值运算符 %= 取模赋值运算符 **= 幂赋值运算符 //= 取整除赋值运算符","text_tokens":["取模","=","减法","+","加法","整除","简单","除法","*","赋值","的","/","%","取","运算","描述","运算符","乘法"," ","-","幂","算符"],"title":"赋值运算符","title_tokens":["运算符","赋值","运算","算符"]},{"location":"Python基础/2.1.python基本语法.html#_13","text":"运算符 描述 & 按位与运算符：参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为0 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 ~ 按位取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1。 ~x 类似于 -x-1 << 左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数指定移动的位数，高位丢弃，低位补0 >> 右移动运算符：把 > 左边的运算数的各二进位全部右移若干位， >> 右边的数指定移动的位数 111 & 100 100 111 | 100 111 111 ^ 100 11","text_tokens":["两","1","~","每个","由",">","时","于","对应","对","111","则","如果","|","若干位","两个","算符","0","进位","二个","取反","右边","异或","位","该位","x","指定","都","二进制","结果","相应","即","当","11","类似","相异","按位","进制","变为","把","丢弃","高位","补","若干","各","&","^","只要","<","右","就","否则","二进位","值","。","运算","运算符","右移"," ","100","-","数据","左移","参与","或","左边","：","移动","的","左","与","数","一个","有","低位","，","全部","二进制位","位数","描述","为"],"title":"位运算符","title_tokens":["运算符","位","运算","算符"]},{"location":"Python基础/2.1.python基本语法.html#_14","text":"运算符 逻辑表达式 描述 and x and y x、y同时为真，则结果为真，否则为假 or x or y x、y两者有一个为真，则结果为真，否则为假 not not x x为真，结果为假；x为假，结果为真","text_tokens":["and","or","假","x","同时","表达式","not","真","达式","y","则","、","结果","否则","一个","两者","有"," ","表达","，","逻辑","运算","描述","运算符","；","为","算符"],"title":"逻辑运算符","title_tokens":["运算符","逻辑","运算","算符"]},{"location":"Python基础/2.1.python基本语法.html#_15","text":"运算符 描述 in 如果在指定的序列中找到值返回 True，否则返回 False not in 如果在指定的序列中没有找到值返回 True，否则返回 False","text_tokens":["找到","在","序列","返回","指定","not","中","的","true","false","否则","没有","值","，","如果","运算","描述","运算符"," ","in","算符"],"title":"成员运算符","title_tokens":["运算","运算符","成员","算符"]},{"location":"Python基础/2.1.python基本语法.html#_16","text":"运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b) 。如果引用的不是同一个对象则返回结果 True，否则返回 False","text_tokens":["标识","对象","=","标识符",",","不同","b","x","返回","是","a","not","引用","同一","实例","y","的","(","true","则","同一个","id","结果","是不是","false","否则","is","一个","自","，","如果","!","类似",")","。","运算","描述","运算符","两个"," ","判断","不是","算符"],"title":"身份运算符","title_tokens":["身份","运算符","运算","算符"]},{"location":"Python基础/2.1.python基本语法.html#_17","text":"运算符 描述 (expressions...), [expressions...], {key: value...}, {expressions...} 表示绑定或元组、表示列表、表示字典、表示集合 x[index], x[index:index], x(arguments...), xattribute 下标、切片、调用、属性引用 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +\\@ 和 -\\@) * / % // 乘，除，取模和取整除 + - 加法减法 >> << 右移，左移运算符 & 位 ‘AND’ ^ 按位异或运算符 <= < > >= 比较运算符 == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 and or not 逻辑运算符 if - else 条件表达式 lambda Lambda 表达式 具有相同优先级的运算符将从左至右的方式依次进行。用小括号 () 可以改变运算顺序。 包括函数、类的定义。 ↩ 目前Python的命名空间使用字典实现，但日后可能会改变。 ↩","text_tokens":[":","~","切片",">","元组","index","减法","+","\\","表达式","相同","not","引用","方式","一元","lambda","属性","达式","命名","赋值","调用","日后","下标","比较","除","函数","但","else","定义","可能","!","}","取","翻转","两个","算符","目前","arguments","or","优先","异或","x","整除","位","{","(","绑定","/","会","value","%","最后","表达","python","按位","is","等于","if","身份","‘","至","取模","可以","and","依次","xattribute","指数","&","^","*","改变","、","@","将","[","<","用","右","和","表示","空间","包括","减号","。","逻辑","运算","运算符","右移"," ","key","-","名为","左移","顺序","expressions","...","或","=","实现","列表",",","加法","↩","优先级","]","具有","小括号","集合","加号","的","’","左","使用","方法","括号","乘","最高","，","进行",")","字典","成员","描述","从","类","in","条件"],"title":"运算符优先级","title_tokens":["优先","优先级","运算","运算符","算符"]},{"location":"Python基础/2.2.语句.html","text":"语句 if 语句 if 语句的语法如下： age = 20 if age >= 18 : print ( 'your age is' , age ) print ( 'adult' ) else : print ( 'your age is' , age ) print ( 'teenager' ) your age is 20 adult 注意不要少写了冒号 : 。 类似R语言的else if，在python中则是使用 elif ： kid elif 是 else if 的缩写，使用缩写是为了避免过度缩进。完全可以有多个 elif ，所以 if 语句的完整形式就是： if < 条件判断1 > : < 执行1 > elif < 条件判断2 > : < 执行2 > elif < 条件判断3 > : < 执行3 > else : < 执行4 > if 判断条件还可以简写，比如写： if True : print ( 'True' ) True 在python中， False 、 0 、 '' 、 [] 、 () 、 {} 都视作False，否则为True。 注意，负值也是被判断为真。 断言 断言语句检查条件是否满足，如果不满足，就引发 AssertionError 异常（并可提供错误消息）。语法如下： assert condition 等价于 if not condition : crash program 例子： assert age >= 12 , 'Children under the age of 12 are not allowed' ---------------------------------------------------------------------------AssertionError Traceback (most recent call last)<ipython-input-1-7c799b440abf> in <module> ----> 1 assert age >= 12, 'Children under the age of 12 are not allowed' AssertionError: Children under the age of 12 are not allowed 循环 Python的循环有两种: for 循环 while 循环 for语句 for 循环， 依次把可迭代对象中的每个元素迭代出来 ，可包含 else 子句。看例子： # 执行这段代码，会依次打印`names`的每一个元素 names = [ 'Michael' , 'Bob' , 'Tracy' ] for name in names : print ( name ) Michael Bob Tracy 所以 for x in ... 循环就是把每个元素代入变量 x ，然后执行缩进块的语句。 while语句 while 语句用于在指定条件为真时反复地执行（循环），条件不满足时退出循环， 比如我们要计算100以内所有奇数之和，可以用while循环实现： sum = 0 n = 99 # 在循环内部变量`n`不断自减，直到变为`-1`时，不再满足while条件，循环退出 while n > 0 : sum = sum + n n = n - 2 print ( sum ) 2500 break 在循环中， break 语句可以提前退出循环。例如 注意 break语句只能用于循环中。 i = 1 while i < 100 : i = i + 1 print ( \"结束循环\" ) break print ( i ) 结束循环 break 的作用是退出当前循环， print(i) 语句不会执行。 continue continue 语句：跳过当前的这次循环，直接开始下一次循环。 注意 continue 语句只能用于循环中。 n = 0 while n < 10 : n = n + 1 print ( n , end = \" \" ) 1 2 3 4 5 6 7 8 9 10 上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用 continue 语句跳过某些循环： n = 0 while n < 10 : n = n + 1 if n % 2 == 0 : # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print ( n , end = \" \" ) 1 3 5 7 9 执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。 循环中的 else 子句 else 子句不仅可以用在 if 语句，还可以用在循环语句。循环语句中的 else 子句在循环迭代完成时、执行条件为 false （对于 while ）时执行，但循环被 break 中止的情况下不会执行。 # for循环 i = 1 for i in range ( 1 , 10 , 2 ): print ( i , end = \" \" ) else : print ( \"i=\" , i ) # while循环 i = 1 while i < 5 : print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) # break子句直接结束循环，循环语句一次也没有执行，此时else子句不会执行。 # 注意，这与while子句中条件为false，循环语句没有执行不同 i = 1 for i in range ( 1 , 10 , 2 ): break print ( i , end = \" \" ) else : print ( \"i=\" , i ) i = 1 while i < 5 : break print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) 1 3 5 7 9 i= 9 1 2 3 4 i= 5 小结 break 、 continue 语句通常都配合 if 语句使用。 要特别注意，不要滥用 break 和 continue 语句。 break 和 continue 会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到 break 和 continue 语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉 break 和 continue 语句。 pass 语句 pass 语句什么也不做。它用于那些语法上必须要有什么语句，但程序什么也不做的场合，例如: # 死循环 while True : pass # Busy-wait for keyboard interrupt (Ctrl+C) # 创建最小结构的类: class MyEmptyClass : pass return 语句 return 语句结束函数的执行并返回一个值。如果没有指定值，将返回 None 。示例： 注意 return 语句只能用于函数中。 def func1 (): return 4 , 2 def func2 (): return print ( func1 ()) print ( func2 ()) (4, 2) None","text_tokens":["call",":","1","18","简写","每个","代入","用于","什么",">","时","退出","ctrl","9","滥用","创建","+","interrupt","子句","结束","于","然后","返回","想","比如","我们","not","不","真","奇数","name","中","teenager","写","用到","5","负值","后续","分叉","def","r","false","end","代码执行","避免","20","消息","不仅","但","多数","函数","else","出错","继续","如果","wait","traceback","}","包含","迭代","myemptyclass","通常","作用","注意","真时","两个","pass","以内","上面","并不需要","michael","of","缩进","还","0","造成","只","提供","循环","跳过","在","'","most","`","例子","缩写","x","func1","是","块","指定","两种","不断","都","修改","并","adult","assertionerror","busy","{","上","none","(","true","不再","语言","elif","会","func2","%","python","可","某些","类似","打印","之","if","is","最小","语句","your","变为","7","也","场合","死循环","可以","10","但是","依次","看到","那些","把","为了","last","做","了","每","看","去掉","99","不同","要","under","当前","容易","4","是否","3","crash","就是","module","自减","condition","不会","通过","只能","一轮","代码","the","、","input","～","中止","将","<","[","用","元素","6","配合","它","kid","就","和","否则","allowed","程序","age","n","值","12","满足","冒号","过度","。","被","ipython","tracy","sum","program","逻辑","结构","需要","class","段"," ","100","判断","-","（","内部","提前","）","过多","引发","断言","出来","开始","对象","多个","视作","出","print","...","中则","c","range","recent","=","情况","实现","完整",",","而是","完成","少写","示例","]","children","break","例如","：","反复","偶数","检查","等价","bob","所有","改写","如下","的","所以","语法","7c799b440abf","直到","#","大多","return","while","continue","使用","错误","必须","对于","keyboard","2500","与","\"","for","are","一个","计算","异常","小结","没有","assert","有","names","i","，","一次","此时","特别","大多数","或者",")","执行","不要","这","2","地","变量","这次","下","8","形式","完全","为","类","in","直接","条件"],"title":"2.2.语句","title_tokens":["语句",".","2.2"]},{"location":"Python基础/2.2.语句.html#_1","text":"","text_tokens":[],"title":"语句","title_tokens":["语句"]},{"location":"Python基础/2.2.语句.html#if","text":"if 语句的语法如下： age = 20 if age >= 18 : print ( 'your age is' , age ) print ( 'adult' ) else : print ( 'your age is' , age ) print ( 'teenager' ) your age is 20 adult 注意不要少写了冒号 : 。 类似R语言的else if，在python中则是使用 elif ： kid elif 是 else if 的缩写，使用缩写是为了避免过度缩进。完全可以有多个 elif ，所以 if 语句的完整形式就是： if < 条件判断1 > : < 执行1 > elif < 条件判断2 > : < 执行2 > elif < 条件判断3 > : < 执行3 > else : < 执行4 > if 判断条件还可以简写，比如写： if True : print ( 'True' ) True 在python中， False 、 0 、 '' 、 [] 、 () 、 {} 都视作False，否则为True。 注意，负值也是被判断为真。","text_tokens":[":","1","18","简写",">","比如","真","中","teenager","写","负值","r","false","避免","20","else","}","注意","缩进","还","0","在","'","缩写","是","都","adult","{","(","true","语言","elif","python","类似","if","is","语句","your","也","可以","为了","了","4","3","就是","、","<","[","kid","否则","age","冒号","过度","。","被"," ","判断","多个","视作","print","中则","=","完整",",","少写","]","：","如下","的","所以","语法","使用","有","，",")","执行","不要","2","形式","完全","为","条件"],"title":"if 语句","title_tokens":[" ","语句","if"]},{"location":"Python基础/2.2.语句.html#_2","text":"断言语句检查条件是否满足，如果不满足，就引发 AssertionError 异常（并可提供错误消息）。语法如下： assert condition 等价于 if not condition : crash program 例子： assert age >= 12 , 'Children under the age of 12 are not allowed' ---------------------------------------------------------------------------AssertionError Traceback (most recent call last)<ipython-input-1-7c799b440abf> in <module> ----> 1 assert age >= 12, 'Children under the age of 12 are not allowed' AssertionError: Children under the age of 12 are not allowed","text_tokens":["call","引发",":","1","-","of",">","recent","提供","=","last","'","most",",","under","例子","children","于","是否","：","if","检查","crash","等价","not","module","并","不","condition","assertionerror","如下","7c799b440abf","语法","(","the","input","错误","<","就","消息","are","allowed","异常","age","assert","，","12","满足","可","如果","ipython","。","traceback",")","program","断言"," ","语句","in","（","条件","）"],"title":"断言","title_tokens":["断言"]},{"location":"Python基础/2.2.语句.html#_3","text":"Python的循环有两种: for 循环 while 循环","text_tokens":["有",":","的","python","while","两种","for"," ","循环"],"title":"循环","title_tokens":["循环"]},{"location":"Python基础/2.2.语句.html#for","text":"for 循环， 依次把可迭代对象中的每个元素迭代出来 ，可包含 else 子句。看例子： # 执行这段代码，会依次打印`names`的每一个元素 names = [ 'Michael' , 'Bob' , 'Tracy' ] for name in names : print ( name ) Michael Bob Tracy 所以 for x in ... 循环就是把每个元素代入变量 x ，然后执行缩进块的语句。","text_tokens":["缩进",":","出来","对象","依次","代入","每个","把","print","...","=","每","循环","看","'",",","`","子句","例子","]","x","然后","：","块","bob","就是","name","中","的","所以","代码","(","#","[","元素","会","for","一个","else","names","，","可","包含","。","执行","迭代","这","打印","tracy",")","变量","段"," ","语句","in","michael"],"title":"for语句","title_tokens":["for","语句"]},{"location":"Python基础/2.2.语句.html#while","text":"while 语句用于在指定条件为真时反复地执行（循环），条件不满足时退出循环， 比如我们要计算100以内所有奇数之和，可以用while循环实现： sum = 0 n = 99 # 在循环内部变量`n`不断自减，直到变为`-1`时，不再满足while条件，循环退出 while n > 0 : sum = sum + n n = n - 2 print ( sum ) 2500","text_tokens":[":","可以","内部","1","0","print","用于","-","退出","时",">","=","实现","循环","在","99","要","`","+","反复","：","比如","指定","我们","所有","不断","自减","不","奇数","直到","(","#","不再","while","用","2500","以内","和","计算","n","变为"," ","，","满足","执行",")","sum","2","地","变量","真时","之","为","100","语句","（","条件","）"],"title":"while语句","title_tokens":["语句","while"]},{"location":"Python基础/2.2.语句.html#break","text":"在循环中， break 语句可以提前退出循环。例如 注意 break语句只能用于循环中。 i = 1 while i < 100 : i = i + 1 print ( \"结束循环\" ) break print ( i ) 结束循环 break 的作用是退出当前循环， print(i) 语句不会执行。","text_tokens":[":","可以","1","print","用于","退出","=","循环","在","+","当前","结束","break","例如","100","是","不会","只能","中","的","(","while","<","\"","i","，","。",")","执行","作用","注意"," ","提前","语句"],"title":"break","title_tokens":["break"]},{"location":"Python基础/2.2.语句.html#continue","text":"continue 语句：跳过当前的这次循环，直接开始下一次循环。 注意 continue 语句只能用于循环中。 n = 0 while n < 10 : n = n + 1 print ( n , end = \" \" ) 1 2 3 4 5 6 7 8 9 10 上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用 continue 语句跳过某些循环： n = 0 while n < 10 : n = n + 1 if n % 2 == 0 : # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print ( n , end = \" \" ) 1 3 5 7 9 执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。","text_tokens":[":","可以","1","开始","0","10","出","但是","print","看到","用于","只","=","9","循环","跳过",",","+","而是","当前","偶数","4","：","3","想","是","我们","不会","奇数","只能","中","上面","的","一轮","(","代码","5","#","后续","～","while","continue","<","用","不再","6","end","\"","会","程序","n","一次","，","%","继续","如果","某些","。",")","执行","8","打印","2","这次","下","注意","if"," ","语句","直接","7"],"title":"continue","title_tokens":["continue"]},{"location":"Python基础/2.2.语句.html#else","text":"else 子句不仅可以用在 if 语句，还可以用在循环语句。循环语句中的 else 子句在循环迭代完成时、执行条件为 false （对于 while ）时执行，但循环被 break 中止的情况下不会执行。 # for循环 i = 1 for i in range ( 1 , 10 , 2 ): print ( i , end = \" \" ) else : print ( \"i=\" , i ) # while循环 i = 1 while i < 5 : print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) # break子句直接结束循环，循环语句一次也没有执行，此时else子句不会执行。 # 注意，这与while子句中条件为false，循环语句没有执行不同 i = 1 for i in range ( 1 , 10 , 2 ): break print ( i , end = \" \" ) else : print ( \"i=\" , i ) i = 1 while i < 5 : break print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) 1 3 5 7 9 i= 9 1 2 3 4 i= 5","text_tokens":["也",":","可以","还","1","7","10","print","时","range","=","情况","9","循环","在",",","+","不同","完成","子句","结束","break","4","3","不会","中","的","(","#","5","、","中止","直接","while","<","用","对于","与","false","end","为","for","\"","但","不仅","没有","else","i","一次","，","此时","。","执行","被","迭代",")","2","下","这","注意","if"," ","语句","in","（","条件","）"],"title":"循环中的else子句","title_tokens":["else","的","子句","循环","中"]},{"location":"Python基础/2.2.语句.html#_4","text":"break 、 continue 语句通常都配合 if 语句使用。 要特别注意，不要滥用 break 和 continue 语句。 break 和 continue 会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到 break 和 continue 语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉 break 和 continue 语句。","text_tokens":["可以","造成","滥用","循环","去掉","要","容易","break","两个","例子","都","条件","修改","通过","改写","上面","用到","大多","的","代码","、","continue","使用","分叉","配合","代码执行","会","和","多数","出错","，","特别","大多数","或者","。","执行","逻辑","不要","通常","需要","注意","if"," ","语句","并不需要","过多"],"title":"小结","title_tokens":["小结"]},{"location":"Python基础/2.2.语句.html#pass","text":"pass 语句什么也不做。它用于那些语法上必须要有什么语句，但程序什么也不做的场合，例如: # 死循环 while True : pass # Busy-wait for keyboard interrupt (Ctrl+C) # 创建最小结构的类: class MyEmptyClass : pass","text_tokens":["也","场合",":","那些","什么","用于","-","ctrl","c","做","循环","创建","要","+","interrupt","例如","不","busy","类","上","的","语法","true","(","#","while","必须","keyboard","它","for","程序","但","有","，","wait","。",")","myemptyclass","结构","class","pass"," ","最小","语句","死循环"],"title":"pass 语句","title_tokens":[" ","语句","pass"]},{"location":"Python基础/2.2.语句.html#return","text":"return 语句结束函数的执行并返回一个值。如果没有指定值，将返回 None 。示例： 注意 return 语句只能用于函数中。 def func1 (): return 4 , 2 def func2 (): return print ( func1 ()) print ( func2 ()) (4, 2) None","text_tokens":[":","print","用于",",","结束","示例","返回","func1","4","：","指定","并","只能","中","return","的","none","(","将","def","一个","函数","func2","没有","值","，","如果","。","执行",")","2","注意"," ","语句"],"title":"return 语句","title_tokens":[" ","语句","return"]},{"location":"Python基础/2.3.List.html","text":"列表的方 法 描 述 aList.append(obj) 等同于aList[len(aList):len(aList)] = [obj] aList.clear() 删除aList的所有元素 aList.count(obj) 返回aList中与obj相等的元素个数 aList.copy() 返回aList的副本。请注意，这是浅复制，即不会复制元素 aList.extend(sequence) 等同于aList[len(aList):len(aList)] = sequence aList.index(obj) 返回aList中第一个与obj相等的元素的索引；如果没有这样的元素，就引发 ValueError异常 aList.insert(index, obj) 如果index >= 0，就等同于aList[index:index] = [obj]；如果index < 0，就 将指定的对象加入到列表开头 aList.pop([index]) 删除并返回指定索引（默认为-1 )处的元素 aList.remove(obj) 等同于del aList[aList.index(obj)] aList.reverse。 就地按相反的顺序排列列表的元素 aList.sort([cmp][,key][,reverse]) 就地对aList的元素进行排序（稳定排序）。可通过提供比较函数cmp、键函数 key (创建用户排序的键）和降序标志reverse (—个布尔值）进行定制 list的方法 创建一个list # 查看list的方法、属性 [ method for method in dir ( list ()) if not method . startswith ( \"_\" )] ['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] 修改list元素的值 修改现有list的值，通过索引、切片来完成。 list_1 = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] # 修改某个索引对应元素的值 list_1 [ 0 ] = 12 ; list_1 [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 修改某个连续区域的值 # 切片的长度 和 用于赋值的列表长度 可以不同，如下： list_1 [ 0 : 5 ] = [ 11 , 12 , 13 , 14 , 15 , 16 , 17 ]; list_1 [11, 12, 13, 14, 15, 16, 17, 5, 6, 7, 8, 9, 10] 添加一个新元素到末尾 append 方法每次只能添加一个新元素 list_1 = list ( range ( 4 )); print ( list_1 ) list_1 . append ( 12 ); print ( list_1 ) [0, 1, 2, 3] [0, 1, 2, 3, 12] 添加任意个新元素到末尾 extend 方法允许我们通过另一个list来扩充当前的list。实际上，这看起来像是用 + 拼接list，但 extend 方法会直接修改原列表，不返回副本。 list_1 = list ( range ( 4 )) list_2 = [ '0' , '00' , '000' ] list_1 + list_2 # 此时list_1没有被修改 print ( \"使用+运算符：\" , list_1 ) list_1 . extend ( list_2 ) # 此时list_1被修改 print ( \"使用extend方法：\" , list_1 ) 使用+运算符： [0, 1, 2, 3] 使用extend方法： [0, 1, 2, 3, '0', '00', '000'] 可以看出，使用 + 拼接list会创建一个新对象，显然拼接的效率回比 extend 方法的效率低。 还可以借助切片来扩充list，像这样： list_1 = list ( range ( 4 )) list_2 = [ '0' , '00' , '000' ] # 这样做可读性不高 list_1 [ len ( list_1 ):] = list_2 list_1 [0, 1, 2, 3, '0', '00', '000'] 在任意位置插入新元素 insert 方法将一个对象插入指定位置 list_1 = list ( range ( 4 )); print ( \"原列表：\" , list_1 ) list_1 . insert ( 0 , \"新元素\" ); print ( \"新列表：\" , list_1 ) 原列表： [0, 1, 2, 3] 新列表： ['新元素', 0, 1, 2, 3] 当然，也可以借助切片在任意位置插入元素。注意的是，对一个list使用切片，必定会得到一个list，这就需要用一个list对切片赋值。 # 这样虽然巧妙，但是可读性比不上insert。 list_1 = list ( range ( 4 )); print ( \"原列表：\" , list_1 ) list_1 [ 0 : 0 ] = [ \"新元素\" ]; print ( \"新列表：\" , list_1 ) 原列表： [0, 1, 2, 3] 新列表： ['新元素', 0, 1, 2, 3] 删除\\取出最后一个（任意位置的）元素 list_2 = [ '0' , '00' , '000' ] # 注意，pop是list中唯一一个修改原列表，并且有返回值的方法 list_2 . pop () '000' list_2 = [ '0' , '00' , '000' ] # pop默认删除最后一个元素，但是也可以输入索引值，指定删除元素的位置 list_2 . pop ( 0 ) list_2 ['00', '000'] 删除第一次出现的元素 list_1 = [ 1 , 2 , 3 , 1 ] list_1 . remove ( 1 ) list_1 [2, 3, 1] 反序排序 list_1 = [ 1 , 2 , 3 ] list_1 . reverse () list_1 [3, 2, 1] 排序 方法 sort 接受两个可选参数： key 和 reverse 。将 key 设置为一个用于排序的**函数。然而，不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。对于另一个关键字参数 reverse ，只需将其指定为 True 或 False ，以指出是否要按相反的顺序对列表进行排序。 list_3 = [ 'aardvark' , 'abalone' , 'acme' , 'add' , 'aerate' ] list_3 . sort ( key = len ) list_3 ['add', 'acme', 'aerate', 'abalone', 'aardvark'] # 按照长度降序排序 list_3 . sort ( key = len , reverse = True ) list_3 ['aardvark', 'abalone', 'aerate', 'acme', 'add'] 统计元素出现的次数 list_1 = [ 1 , 2 , 3 , 1 ] list_1 . count ( 1 ) 2 得到某个值第一次出现时对应的索引值 list_1 = [ 1 , 2 , 3 , 1 ] list_1 . index ( 1 ) 0 深拷贝列表 list_1 = [ 1 , 2 , 3 ] list_4 = list_1 list_1 [ 0 ] = \"修改了\" print ( \"list_1：\" , list_1 ) print ( \"list_4：\" , list_4 ) list_1： ['修改了', 2, 3] list_4： ['修改了', 2, 3] # 深拷贝 list_1 = [ 1 , 2 , 3 ] list_5 = list_1 . copy () list_1 [ 0 ] = \"修改了\" print ( \"list_1：\" , list_1 ) print ( \"list_5：\" , list_5 ) list_1： ['修改了', 2, 3] list_5： [1, 2, 3] 清空列表 list_1 . clear () list_1 []","text_tokens":[":","第一个","1","用户","等同","布尔值","关键","以","相等","每个","用于","切片",">","insert","第一","时","9","len","回比","alist","创建","index","查看","深","+","拷贝","方","返回","\\","键","对应","对","清空","复制","我们","000","13","not","看出","位置","输入","不","第一次","关键字","sequence","排序","中","属性","显然","赋值","新","5","15","述","比较","这个","17","append","false","新元素","布尔","根据","函数","允许","但","某个","_","如果","cmp","比不上","出现","add","00","这样","注意","两个","像是","等同于","选","算符","还","区域","0","aerate","只","提供","索引","reverse","原","当然","并且","在","'","acme","必定会","—","16","是","浅","指定","现有","修改","并","可读","开头","末尾","添加","副本","(","true","sort","插入","extend","统计","按","描","会","即","连续","再","11","新元","到","最后","可","然而","按照","count","copy","加入","起来","虽然","需","指出","if","标志","顺序排列","7","可读性","obj","也","巧妙","可以","这些","10","但是","参数","唯一","默认","删除","做","了","设置","不同","要","请","实际上","取出","当前","4","是否","定会","3","扩充","低","clear","不会","排列","通过","长度","同于","valueerror","降序","只能","*","比","返回值","稳定","、","将","[","<","用","元素","dir","6","实际","就","和","不高","它","每次","来","pop","相反","值","法","个","12","。",";","被","运算","拼接","运算符","需要","定制","；"," ","key","-","判断","（","看起来","）","引发","接受","小","顺序","对象","method","abalone","print","或","range","=","借助","remove","列表",",","startswith","而是","完成","反序","]","：","所有","任意","另","如下","处","得到","次数","的","其","看起","#",".","个数","14","使用","对于","与","方法","for","\"","一个","异常","没有","效率","有","一次","，","此时","del","进行","像",")","这","8","list","地","2","必定","为","in","直接","aardvark"],"title":"2.3.List","title_tokens":["list",".","2.3"]},{"location":"Python基础/2.3.List.html#list","text":"创建一个list # 查看list的方法、属性 [ method for method in dir ( list ()) if not method . startswith ( \"_\" )] ['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']","text_tokens":["method","insert","reverse","remove","创建","查看","'","startswith",",","index","]","not","clear","属性","的","(","#",".","、","sort","extend","[","dir","append","方法","for","\"","一个","pop","_",")","copy","list","count","if"," ","in"],"title":"list的方法","title_tokens":["list","的","方法"]},{"location":"Python基础/2.3.List.html#list_1","text":"修改现有list的值，通过索引、切片来完成。 list_1 = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] # 修改某个索引对应元素的值 list_1 [ 0 ] = 12 ; list_1 [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 修改某个连续区域的值 # 切片的长度 和 用于赋值的列表长度 可以不同，如下： list_1 [ 0 : 5 ] = [ 11 , 12 , 13 , 14 , 15 , 16 , 17 ]; list_1 [11, 12, 13, 14, 15, 16, 17, 5, 6, 7, 8, 9, 10]","text_tokens":[":","可以","1","区域","0","10","用于","切片","=","9","索引","列表",",","不同","完成","16","]","4","对应","3","：","现有","13","修改","长度","通过","如下","赋值","的","5","#","、","15","14","[","元素","6","17","和","连续","来","值","某个","，","_","12","11","。",";","8","list","2"," ","7"],"title":"修改list元素的值","title_tokens":["值","的","list","元素","修改"]},{"location":"Python基础/2.3.List.html#_1","text":"append 方法每次只能添加一个新元素 list_1 = list ( range ( 4 )); print ( list_1 ) list_1 . append ( 12 ); print ( list_1 ) [0, 1, 2, 3] [0, 1, 2, 3, 12]","text_tokens":["1","0","print","range","=",",","]","4","3","只能","添加","(",".","[","元素","append","新元素","方法","一个","每次","新元","_","12",")",";","list","2"," "],"title":"添加一个新元素到末尾","title_tokens":["末尾","新元","添加","到","元素","新元素","一个"]},{"location":"Python基础/2.3.List.html#_2","text":"extend 方法允许我们通过另一个list来扩充当前的list。实际上，这看起来像是用 + 拼接list，但 extend 方法会直接修改原列表，不返回副本。 list_1 = list ( range ( 4 )) list_2 = [ '0' , '00' , '000' ] list_1 + list_2 # 此时list_1没有被修改 print ( \"使用+运算符：\" , list_1 ) list_1 . extend ( list_2 ) # 此时list_1被修改 print ( \"使用extend方法：\" , list_1 ) 使用+运算符： [0, 1, 2, 3] 使用extend方法： [0, 1, 2, 3, '0', '00', '000'] 可以看出，使用 + 拼接list会创建一个新对象，显然拼接的效率回比 extend 方法的效率低。 还可以借助切片来扩充list，像这样： list_1 = list ( range ( 4 )) list_2 = [ '0' , '00' , '000' ] # 这样做可读性不高 list_1 [ len ( list_1 ):] = list_2 list_1 [0, 1, 2, 3, '0', '00', '000']","text_tokens":[":","1","切片","len","创建","+","返回","我们","000","看出","不","显然","新","但","允许","_","00","这样","像是","算符","还","0","原","'","修改","可读","副本","(","extend","会","起来","可读性","可以","做","实际上","当前","4","扩充","3","低","通过","[","用","不高","实际","来","。","被","运算","拼接","运算符"," ","看起来","对象","print","range","=","借助","列表",",","]","：","另","的","看起","#",".","使用","方法","\"","一个","没有","效率","，","此时","像",")","这","list","2","回比","直接"],"title":"添加任意个新元素到末尾","title_tokens":["末尾","新元","添加","个","到","元素","任意","新元素"]},{"location":"Python基础/2.3.List.html#_3","text":"insert 方法将一个对象插入指定位置 list_1 = list ( range ( 4 )); print ( \"原列表：\" , list_1 ) list_1 . insert ( 0 , \"新元素\" ); print ( \"新列表：\" , list_1 ) 原列表： [0, 1, 2, 3] 新列表： ['新元素', 0, 1, 2, 3] 当然，也可以借助切片在任意位置插入元素。注意的是，对一个list使用切片，必定会得到一个list，这就需要用一个list对切片赋值。 # 这样虽然巧妙，但是可读性比不上insert。 list_1 = list ( range ( 4 )); print ( \"原列表：\" , list_1 ) list_1 [ 0 : 0 ] = [ \"新元素\" ]; print ( \"新列表：\" , list_1 ) 原列表： [0, 1, 2, 3] 新列表： ['新元素', 0, 1, 2, 3]","text_tokens":["也",":","可以","1","对象","0","但是","print","切片","insert","range","=","借助","原","当然","在","'","列表",",","必定会","]","4","定会","：","3","是","对","指定","位置","任意","可读","得到","新","的","赋值","(","#",".","插入","将","[","使用","用","元素","方法","\"","新元素","就","一个","_","新元","，","比不上","。",")",";","这","list","2","这样","需要","虽然","注意","必定"," ","可读性","巧妙"],"title":"在任意位置插入新元素","title_tokens":["新元","插入","元素","位置","任意","新元素","在"]},{"location":"Python基础/2.3.List.html#_4","text":"list_2 = [ '0' , '00' , '000' ] # 注意，pop是list中唯一一个修改原列表，并且有返回值的方法 list_2 . pop () '000' list_2 = [ '0' , '00' , '000' ] # pop默认删除最后一个元素，但是也可以输入索引值，指定删除元素的位置 list_2 . pop ( 0 ) list_2 ['00', '000']","text_tokens":["也","可以","0","但是","唯一","默认","=","删除","索引","原","并且","'","列表",",","]","返回","是","000","指定","位置","修改","输入","中","返回值","的","(","#",".","[","元素","方法","一个","有","pop","值","_","，","最后",")","list","2","00","注意"," "],"title":"删除\\取出最后一个（任意位置的）元素","title_tokens":["取出","的","最后","\\","元素","删除","任意","位置","一个","（","）"]},{"location":"Python基础/2.3.List.html#_5","text":"list_1 = [ 1 , 2 , 3 , 1 ] list_1 . remove ( 1 ) list_1 [2, 3, 1]","text_tokens":["1","_","]","(",".","3",")","list","[","2","="," ","remove",","],"title":"删除第一次出现的元素","title_tokens":["一次","的","出现","第一","第一次","删除","元素"]},{"location":"Python基础/2.3.List.html#_6","text":"list_1 = [ 1 , 2 , 3 ] list_1 . reverse () list_1 [3, 2, 1]","text_tokens":["1","_","]","(",".","3",")","list","[","2","=","reverse"," ",","],"title":"反序排序","title_tokens":["反序","排序"]},{"location":"Python基础/2.3.List.html#_7","text":"方法 sort 接受两个可选参数： key 和 reverse 。将 key 设置为一个用于排序的**函数。然而，不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。对于另一个关键字参数 reverse ，只需将其指定为 True 或 False ，以指出是否要按相反的顺序对列表进行排序。 list_3 = [ 'aardvark' , 'abalone' , 'acme' , 'add' , 'aerate' ] list_3 . sort ( key = len ) list_3 ['add', 'acme', 'aerate', 'abalone', 'aardvark'] # 按照长度降序排序 list_3 . sort ( key = len , reverse = True ) list_3 ['aardvark', 'abalone', 'aerate', 'acme', 'add']","text_tokens":["关键","以","每个","用于","len","创建","键","对","关键字","排序","这个","false","根据","函数","_","add","两个","选","只","reverse","'","acme","指定","true","(","sort","按","再","然而","可","按照","需","指出","这些","参数","设置","要","是否","3","不会","长度","*","降序","比","将","[","aerate","元素","它","和","来","相反","。","key"," ","判断","接受","小","顺序","abalone","或","=","列表",",","而是","]","：","另","的","其","#",".","使用","对于","方法","一个","，","进行",")","list","为","直接","aardvark"],"title":"排序","title_tokens":["排序"]},{"location":"Python基础/2.3.List.html#_8","text":"list_1 = [ 1 , 2 , 3 , 1 ] list_1 . count ( 1 ) 2","text_tokens":["1","_","]","(",".","3",")","count","list","[","2","="," ",","],"title":"统计元素出现的次数","title_tokens":["次数","的","出现","统计","元素"]},{"location":"Python基础/2.3.List.html#_9","text":"list_1 = [ 1 , 2 , 3 , 1 ] list_1 . index ( 1 ) 0","text_tokens":["1","_","]","(","0",".","3",")","list","[","2","="," ","index",","],"title":"得到某个值第一次出现时对应的索引值","title_tokens":["得到","值","某个","一次","的","出现","对应","时","第一","第一次","索引"]},{"location":"Python基础/2.3.List.html#_10","text":"list_1 = [ 1 , 2 , 3 ] list_4 = list_1 list_1 [ 0 ] = \"修改了\" print ( \"list_1：\" , list_1 ) print ( \"list_4：\" , list_4 ) list_1： ['修改了', 2, 3] list_4： ['修改了', 2, 3] # 深拷贝 list_1 = [ 1 , 2 , 3 ] list_5 = list_1 . copy () list_1 [ 0 ] = \"修改了\" print ( \"list_1：\" , list_1 ) print ( \"list_5：\" , list_5 ) list_1： ['修改了', 2, 3] list_5： [1, 2, 3]","text_tokens":["1","0","print","=","了","'","深",",","拷贝","]","4","：","3","修改","(","#","5",".","[","\"","_",")","copy","list","2"," "],"title":"深拷贝列表","title_tokens":["深","列表","拷贝"]},{"location":"Python基础/2.3.List.html#_11","text":"list_1 . clear () list_1 []","text_tokens":["1","_","(","]",".",")","list","[","clear"," "],"title":"清空列表","title_tokens":["清空","列表"]},{"location":"Python基础/2.4.String.html","text":"多行字符串 str_1 = \"\"\" 这是一个多行字符串 这是第二行 \"\"\" print ( str_1 ) str_1 = \"这是一个多行字符串 \\n 这是第二行\" print ( str_1 ) 这是一个多行字符串 这是第二行 这是一个多行字符串 这是第二行 转义 如果要在字符串里面输入特殊字符，需要使用转义符\\，例如输入转义符本身： str_2 = \"12 \\\\ 14\" print ( str_2 ) 12\\14 字符编码 Python有两种不同的字符串，一种存储文本，一种存储字节。对于文本，Python内部采用Unicode存储，而字节字符串显示原始字节序列或者ASCII。在Python3当中，文本字符串类型（使用Unicode数据存储）被命名为 str , 字节字符串类型被命名为 bytes 。但在python2中，文本字符串类型叫做 unicode ，字节字符串类型叫做 str 。也就是说： $$ \\begin{align } Python\\ 3\\ \\mathbf{str} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{unicode} \\ Python\\ 3\\ \\mathbf{str} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{unicode} \\end{align } $$ 所以，如果想将以unicode形式储存的字符串转换为二进制类型的字符串，需要将unicode字符串编码，反之，则需要解码。 编码：在python中，编码指的是将Unicode字符按照编码规则（如UTF-8）编成二进制序列。 在python3中实例化一个字符串 str_3 = \"中国\" print ( str_3 ) # 编码str_5 str_3 . encode () # 创建一个二进制字符串 str_4 = b ' \\xe4\\xb8\\xad\\xe5\\x9b\\xbd ' # 解码str_6 str_4 . decode () 中国 '中国' 前缀 在Python中，字符串可以添加前缀 r\\R 、 b 、 u\\U 。 r\\R：表示非转义的原始字符串，常用于正则表达式。 b：Python3里默认的str是(Python2里的)unicode, bytes是(Python2)的str,b前缀代表的就是bytes。Python2里, b前缀没什么具体意义，只是为了兼容Python3的这种写法 。 u\\U：表示unicode字符串，代表是对字符串进行unicode编码。一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。建议所有编码方式采用UTF-8。 格式化 C printf 样式的格式化 字符串具有一种特殊的内置操作：使用 % (取模)运算符，可以格式化字符串，此时 % 也被称为字符串的格式化运算符或插值运算符。对于format % values(其中format为一个字符串)，在format中的 % 转换标记符将被替换为零个或多个values条目。 其效果类似于在C语言中使用sprintf()。 'Hello, %s ' % 'world' # 省略括号 'Hello, world' 'Hi, %s , you have $ %d ' % ( 'Michael' , 10000.58 ) 'Hi, Michael, you have $10000' 转换标记符 包含两个或更多字符，由以下元素组成，且必须遵循此处规定的顺序： % 字符，用于标记转换符的起始。 映射键（可选），由加圆括号的字符序列组成(例如(somename))。 转换标志（可选） - - 表示左对齐 - + 表示转换后的内容前方加上正负号 - 空格 表示正数前方保留一个空格 - - 0 表示如果转换位置位数不够时，用0填充 最小字段宽度（可选），转换后字段的最小宽度，如果不足自动用空格补齐；如果最小字段宽度值为 * ，则从元组中读取。 5.精度（可选），在 . 之后加精度值的形式给出。如果指定为为 * ，则从元组中读取。 长度修饰符（可选）。 转换类型。 Conversion Meaning d 格式化整数 i 格式化整数 o 8 进制 u 格式化无符号整型(已过时) x 16 进制， 小写字母 X 16 进制， 大写字母 e 浮点指数格式， 小写字母 E 浮点指数格式， 大写字母 f 浮点数 F 浮点数 g 浮点数， 如果指数小于 -4 或小于精度， 则使用小写指数格式， 否则使用小数格式 G 浮点数， 类似 g , 使用大写指数 c 单个字符， 格式化字符及其 ASCII 码 r 字符串， 使用 repr() 转换任何 Python 对象 s 字符串， 使用 str() 转换任何 Python 对象 % % 字符 # + term=True # 最小字段宽度 ' %2s ' % 123456 ' %8s ' % 123456 ' %*s ' % ( 10 , 123456 ) # 精度 ' %.2f ' % 100.256 ' %.*f ' % ( 2 , 100.256 ) # 转换标志 ' %-8d ' % 123456 ' %+8d ' % 123456 ' %08d ' % 123456 # 映射键 ## 如果值是一个字典，那么必须使用映射键. 如： ' %(num)d ' % { \"num\" : 10 } '10' format方法 < 模板字符串 >. format ( < 逗号分隔的参数 > ) <模板字符串> 由一系列的槽 {} 组成，用来控制修改字符串中嵌入值出现的位置，其基本思想是将format()方法的 <逗号分隔的参数> 中的参数按照序号关系替换到 <模板字符串> 的槽中。如果大括号中没有序号，则按照出现顺序替换。该方法会创建新字符串对象，不会修改原值。 {}中指定顺序，按指定的顺序替换 print ( \" {2} : {1} : {0} \" . format ( \"1\" , \"2\" , \"3\" )) 3 : 2 : 1 没有指定顺序，按出现的顺序依次替换 print ( \" {} : {} : {} \" . format ( \"1\" , \"2\" , \"3\" )) 1 : 2 : 3 format()方法中 <模板字符串> 的槽除了包括参数序号，还可以包括格式控制信息。此时，槽的内部样式如下： 替换字段 - replacement_field ::= \"{\" [ field_name ] [ \"!\" conversion ] [ \":\" format_spec ] \"}\" 字段名 - field_name ::= arg_name ( \".\" attribute_name | \"[\" element_index \"]\" ) * 参数名 - arg_name ::= [ identifier | integer ] 属性名 - attribute_name ::= identifier 元素索引 - element_index ::= integer | index_string 索引字符串 - index_string ::= < any source character except \"]\" > + 转换字段 - conversion ::= \"r\" | \"s\" 格式规范说明符 - format_spec ::= < described in the next section > 注意事项： 参数名 可以为 整数 或 关键字 。整数为位置参数， 关键字为命名关键字参数。 如果整数类似于 {0}{1}{2}, 则可以省略， 即： {}{}{} 等价于 {0}{1}{2}. 如果参数存在属性， 可以通过 arg_name.attribute_name 的形式获取属性值。 如果参数为可迭代对象， 可以通过 arg_name[integer|index_string] 的形式获取索引位置的元素。 转换字段 由 ! 开始， r 代表调用 repr(), s 代表调用 str(). 格式规范说明符 由 : 开始。 其中， <格式控制标记> 用来控制参数显示时的格式，可以使用的参数如下： format_spec ::= [ [fill ] align ] [ sign ][ # ][ 0 ][ width ][ grouping_option ][ .precision ][ type ] fill ::= < any character > align ::= \"<\" | \">\" | \"=\" | \"^\" sign ::= \"+\" | \"-\" | \" \" width ::= digit + grouping_option ::= \"_\" | \",\" precision ::= digit + type ::= \"b\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" | \"g\" | \"G\" | \"n\" | \"o\" | \"s\" | \"x\" | \"X\" | \"%\" 填充字符 ：如果指定了对齐选项，则可以使用填充字符。默认为空格. 对齐选项 ：默认右对齐，各种对齐选项的含义如下： 选项 意义 '<' 强制字段在可用空间内左对齐（这是大多数对象的默认值）。 '>' 强制字段在可用空间内右对齐（这是数字的默认值）。 '=' 强制将填充放置在符号（如果有）之后但在数字之前。这用于以“+000000120”形式打印字段。此对齐选项仅对数字类型有效。当'0'紧接在字段宽度之前时，它成为默认值。 '^' 强制字段在可用空间内居中。 sign ：仅对数字类型有效，可以是以下之一： 选项 意义 '+' 表示标志应该用于正数和负数。 '-' 表示标志应仅用于负数（这是默认行为）。 space 表示应在正数上使用前导空格，在负数上使用减号。 # ：仅适用于数字参数，同时仅适用于2、8、16进制的数字。会在输出的数字前添加 0b、0o、0x前缀。 宽度 ：指定最小字段宽度。 千位分隔符 ：只能使用 _ 或 , 作为千位分隔符。 精度 ： 类型 ：该选项决定了数据应该如何呈现。 可用的字符串表示类型： Type Meaning s 字符串格式， 字符串的默认类型， 可省略 None 同 s 可用的整数表示类型： Type Meaning b 输出为 2 进制整数 c 输出为为相应的 unicode 字符 d 输出为 10 进制整数 o 输出为 8 进制整数 x 输出为 16 进制整数， 使用小写字母 X 输出为 16 进制整数， 使用大写字母 n 类似 d , 会使用当前区域设置插入适当的数字分隔符 None 同 d 可用的浮点数和小数值表示类型： Type Meaning e 指数表示法， 使用字母 e 以科学记数法打印数字， 默认进度为 6 E 类似 e , 使用字母 E f 浮点数， 默认进度为 6 F 浮点数， 同 f g 一般形式， 受 precision 选项影响 G 类似 g , 当使用指数表示法时， 使用 E 而不是 e n 和 g 相同， 会使用当前区域设置插入适当的数字分隔符 % 百分数表示 None 同 g # 填充、对齐、符号、宽度、分组选项、精度 \" {0:*^+20.2f} \" . format ( 120 ) # 填充*号、居中、正号标记、2精度 '******+120.00*******' \"{0:*^+20_.2f}\" . format ( 12000 ) # 填充*号、居中、正号标记、_分隔符、2精度 '*****+12_000.00*****' \" {0:*^+20,.2f} \" . format ( 12000 ) # 填充*号、居中、正号标记、,分隔符、2精度 '*****+12,000.00*****' \" {0:*<+20.2f} \" . format ( - 120 ) # 填充*号、左对齐、正号标记、2精度 '-120.00*************' \" {0:*>-20.2f} \" . format ( - 120 ) # 填充*号、左对齐、负号标记、2精度 '*************-120.00' bytes字符 文本字符类型在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把 str 变为以字节为单位的 bytes 。 Python3对 bytes 类型的数据用带 b 前缀的单引号或双引号表示。 bytes_8 = b \"ABC\" bytes_8 b'ABC' 要注意的是：bytes字面值中只允许ASCII字符（无论源代码声明的编码为何）。任何超出127的二进制值必须使用相应的转义序列形式加入bytes字面值。 例如，可以对str（unicode类型）对象使用 encode() 方法，编码为bytes的形式（16进制表示）。 '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 要注意的是， encode 的对象不能超出指定编码的范围，例如不能对中文字符使用 .encode(\"ascii\") ，因为中文不在ascii码的范围内。 '中文' . encode ( 'ascii' ) ---------------------------------------------------------------------------UnicodeEncodeError Traceback (most recent call last)<ipython-input-1-76f41cd8dafa> in <module> ----> 1 '中文'.encode('ascii') UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) 纯英文的str可以用ASCII编码为bytes，内容是一样的，但无法显示为ASCII字符的字节，用 \\x 显示（16进制转义表示）。 'ABC' . encode ( 'ascii' ) b'ABC' '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用 decode() 方法： b 'ABC' . decode ( 'ascii' ) 'ABC' b ' \\xe4\\xb8\\xad\\xe6\\x96\\x87 ' . decode ( 'utf-8' ) '中文' 如果bytes中包含无法解码的字节， decode() 方法会报错： b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' ) ---------------------------------------------------------------------------UnicodeDecodeError Traceback (most recent call last)<ipython-input-1-cd8de1b11dcd> in <module> ----> 1 b'\\xe4\\xb8\\xad\\xff'.decode('utf-8') UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte 但是，如果bytes中只有一小部分无效的字节，可以传入 errors = 'ignore' 忽略错误的字节： \"中\" . encode ( \"utf-8\" ) # 中 原来的编码 b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' , errors = 'ignore' ) '中' 在对str和bytes互相转换时，为了避免乱码问题，应该使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： # !/usr/bin/env python3 # -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释。第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，在源代码中写的中文输出可能会有乱码。 但是申明了UTF-8编码只是让Python解释器按UTF-8的编码规则读取源代码，并不意味着源代码一定是使用UT8-8编码保存的，必须并且要确保文本编辑器正在使用UTF-8编码。 方法","text_tokens":["1","env","由","紧接在",">","时","选项","index","写字","128","conversion","小写","同时","组成","对","相同","fill","type","兼容","加","输入","不足","x96","关键字","name","互相","属性","写","实例","新","5","这种","规则","前导","精度","20","values","出现","包含","|","释器","迭代","用带","arg","通常","由于","选","之后","8s","建议","还","码","0","槽","作为","索引","在","非","string","前","一种","指定","其中","windows","byte","字","none","分数","true","一小部分","一般","position","即","获取","当","特殊字符","原始","表达","读到","原来","表明","你","如何","标志","也","可以","多","多行","somename","把","默认","f","序列","b","小数","文本文件","若干","4","声明","申明","格式化","浮点","储存","x9b","通过","xe4","行程","xff","代码","the","、","input","_.","<","用","6","它","右","就","之一","characters","程序","begin","无法","正数","此","；"," ","字节","中文","分组","后","开始","对象","多个","ordinal","c","百分","section","12000","思想","具有","abc","所有","有效","记数","无论","cd8de1b11dcd","#","进度","左","使用","\"","括号","方法","一个","用来","没有","i","此时","invalid","字典","0o","位数","标记","形式","从","precision",":","及其","模板","以","规定","第一","且","元组","磁盘","让","分隔符","表达式","想","也就是说","负数","character","can","注释","达式","空格","适用","%+","解码","字段","乱码","这个","写法","r","end","编码方式","避免","source","允许","点数","120","_","说明","源代码","traceback","中以","注意","两个","引号","转义","format","算符","小部","小写字母","000.00","紧接","给出","不带","事项","76f41cd8dafa","解析","控制参数","16","中写","文本编辑","修改","说明符","coding","叫做","插入","按","/","只是","可用","%","到","python","可","打印","加入","ascii","单个","可执行程序","但是","参数","内置","浮点数","xe6","存储","不同","任何","为何","读取","0x","3","printf","文本","hi","具体","显示","就是","&","module","space","控制","基本","xe5","字段名","linux","将","元素","操作","否则","之前","号","第二行","当中","内","减号","被","百分数","运算符","需要","ignore","mathbf","解释","前方","print","二行","=",",","正负号","只有","xb8","term","$","纯","以下","等价","转换","如下","正","内存","关系","所以","修饰","e","科学","保留","类型","integer","正常","进行","大多数","执行","8","值为","不能","in","输出","call","部分","关键","什么","告诉","+","后字","里面","2s","我们","位置","d","not","unicode","中","命名","8d","受","整数","一系列","grouping","则","option","条目","正则","放置","大括号","any","一旦","g","系统","宽度","符","如果","xbd","嵌入","无","成为","区域","含义","described","指","并且","影响","此处","meaning","most","codec","x","字符串","123456","注意事项","并","确保","{","适当","过来","上","英文","转义序列","二进制","无效","语言","正在","会","自动","str","务必","width","进制","hello","第二","更","最小","一系","该","遵循","分隔","except","取模","变为","强制","逗号","一行","为了","第一行","符将","10000","last","了","整型","“","面值","设置","当前","2f","双引号","呈现","python2","默认值","长度","repr","*","world","负号","流","决定","0b","接在","next","n","正负","ut8","小于","000000120","记数法","本文","传入","这是","digit","内部","-","对齐","field","意味","那么","千位","反过来","采用","identifier","range","recent","应仅","特殊","]","例如","忽略","编成","内容","时候","格式","替换","化","其","大多","原值","bytes",".","14","存在","必须","错误","对于","因为","本身","sprintf","unicodeencodeerror","字母","称为","就是说","，","内右","大写",")","这","2","下","element","序号","u","一小","常用","传输","用于","符号","意义","同","已","创建","信息","%.","s","器","\\","于","代表","键","对应","120.00","居中","过时","方式","不","应该","而","效果","调用","由加","意味着","大写字母","最","c语言","问题","多数","但","xad","usr","可能","!","}","表示法","行为","michael","have","名","20.2","除了","只","'","start","正则表达式","样式","不够","o","you","是","errors","没什么","spec","两种","加上","都","开头","longleftrightarrow","系列","添加","插值","(","如","应","相应","反之","encode","范围","单位","类似","按照","需","127","数字","补齐","decode","os","保存","08d","10","填充","依次","小字","attribute","10000.58","指数","起始","超出","要","所","单引号","不会","^","数值","若干个","只能","省略","仅","utf","一定","解释器","[","空间","和","表示","两行","num","包括","值","12","ipython","。","运算","报错","段","数据","（","里","）","编码","映射","各种","replacement","小","顺序","反过","t","或","align","中国","一样","文件","：","前缀","规范","0xff","python3","修饰符","编辑","的","x87","sign","圆括号","网络","##","有","或者","bin","零个","字符","unicodedecodeerror","为","”","不是","100.256"],"title":"2.4.String","title_tokens":["string",".","2.4"]},{"location":"Python基础/2.4.String.html#_1","text":"str_1 = \"\"\" 这是一个多行字符串 这是第二行 \"\"\" print ( str_1 ) str_1 = \"这是一个多行字符串 \\n 这是第二行\" print ( str_1 ) 这是一个多行字符串 这是第二行 这是一个多行字符串 这是第二行","text_tokens":["1","多行","print","二行","=","字符串","\\","(","\"","一个","n","str","第二行","_",")","字符","这是"," ","第二"],"title":"多行字符串","title_tokens":["多行","字符串","字符"]},{"location":"Python基础/2.4.String.html#_2","text":"如果要在字符串里面输入特殊字符，需要使用转义符\\，例如输入转义符本身： str_2 = \"12 \\\\ 14\" print ( str_2 ) 12\\14","text_tokens":["print","=","在","要","特殊","里面","字符串","\\","例如","：","输入","(","14","使用","\"","本身","str","特殊字符","，","_","12","符","如果",")","字符","2","需要"," ","转义"],"title":"转义","title_tokens":["转义"]},{"location":"Python基础/2.4.String.html#_3","text":"Python有两种不同的字符串，一种存储文本，一种存储字节。对于文本，Python内部采用Unicode存储，而字节字符串显示原始字节序列或者ASCII。在Python3当中，文本字符串类型（使用Unicode数据存储）被命名为 str , 字节字符串类型被命名为 bytes 。但在python2中，文本字符串类型叫做 unicode ，字节字符串类型叫做 str 。也就是说： $$ \\begin{align } Python\\ 3\\ \\mathbf{str} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{unicode} \\ Python\\ 3\\ \\mathbf{str} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{unicode} \\end{align } $$ 所以，如果想将以unicode形式储存的字符串转换为二进制类型的字符串，需要将unicode字符串编码，反之，则需要解码。 编码：在python中，编码指的是将Unicode字符按照编码规则（如UTF-8）编成二进制序列。 在python3中实例化一个字符串 str_3 = \"中国\" print ( str_3 ) # 编码str_5 str_3 . encode () # 创建一个二进制字符串 str_4 = b ' \\xe4\\xb8\\xad\\xe5\\x9b\\xbd ' # 解码str_6 str_4 . decode () 中国 '中国'","text_tokens":["以","创建","\\","想","也就是说","而","unicode","中","命名","实例","解码","则","5","规则","end","但","xad","_","如果","xbd","}","指","在","'","字符串","是","一种","两种","叫做","{","longleftrightarrow","(","二进制","如","反之","str","encode","原始","python","按照","ascii","进制","decode","存储","不同","序列","b","4","3","文本","python2","显示","就是","&","储存","x9b","xe4","utf","xe5","将","6","begin","当中","。","被","需要"," ","内部","字节","-","数据","（","编码","mathbf","）","采用","print","align","中国","=",",","xb8","$","：","转换","编成","python3","化","的","所以","#","bytes",".","使用","对于","类型","\"","一个","有","，","就是说","或者",")","8","字符","2","形式","为"],"title":"字符编码","title_tokens":["编码","字符"]},{"location":"Python基础/2.4.String.html#_4","text":"在Python中，字符串可以添加前缀 r\\R 、 b 、 u\\U 。 r\\R：表示非转义的原始字符串，常用于正则表达式。 b：Python3里默认的str是(Python2里的)unicode, bytes是(Python2)的str,b前缀代表的就是bytes。Python2里, b前缀没什么具体意义，只是为了兼容Python3的这种写法 。 u\\U：表示unicode字符串，代表是对字符串进行unicode编码。一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。建议所有编码方式采用UTF-8。","text_tokens":["常用","什么","意义","\\","于","表达式","代表","对","兼容","方式","unicode","达式","中","这种","乱码","正则","写法","r","一旦","编码方式","出现","转义","建议","不带","在","非","正则表达式","解析","字符串","是","没什么","都","添加","英文","(","一般","只是","会","str","原始","表达","python","需","表明","可以","但是","为了","默认","b","所","python2","具体","就是","基本","utf","、","就","表示","否则","。","；"," ","-","里","编码","中文","各种","采用",",","：","前缀","所有","转换","python3","的","所以","bytes","使用","必须","正常","，","进行",")","8","字符","下","u"],"title":"前缀","title_tokens":["前缀"]},{"location":"Python基础/2.4.String.html#_5","text":"","text_tokens":[],"title":"格式化","title_tokens":["格式","格式化"]},{"location":"Python基础/2.4.String.html#c-printf","text":"字符串具有一种特殊的内置操作：使用 % (取模)运算符，可以格式化字符串，此时 % 也被称为字符串的格式化运算符或插值运算符。对于format % values(其中format为一个字符串)，在format中的 % 转换标记符将被替换为零个或多个values条目。 其效果类似于在C语言中使用sprintf()。 'Hello, %s ' % 'world' # 省略括号 'Hello, world' 'Hi, %s , you have $ %d ' % ( 'Michael' , 10000.58 ) 'Hi, Michael, you have $10000' 转换标记符 包含两个或更多字符，由以下元素组成，且必须遵循此处规定的顺序： % 字符，用于标记转换符的起始。 映射键（可选），由加圆括号的字符序列组成(例如(somename))。 转换标志（可选） - - 表示左对齐 - + 表示转换后的内容前方加上正负号 - 空格 表示正数前方保留一个空格 - - 0 表示如果转换位置位数不够时，用0填充 最小字段宽度（可选），转换后字段的最小宽度，如果不足自动用空格补齐；如果最小字段宽度值为 * ，则从元组中读取。 5.精度（可选），在 . 之后加精度值的形式给出。如果指定为为 * ，则从元组中读取。 长度修饰符（可选）。 转换类型。 Conversion Meaning d 格式化整数 i 格式化整数 o 8 进制 u 格式化无符号整型(已过时) x 16 进制， 小写字母 X 16 进制， 大写字母 e 浮点指数格式， 小写字母 E 浮点指数格式， 大写字母 f 浮点数 F 浮点数 g 浮点数， 如果指数小于 -4 或小于精度， 则使用小写指数格式， 否则使用小数格式 G 浮点数， 类似 g , 使用大写指数 c 单个字符， 格式化字符及其 ASCII 码 r 字符串， 使用 repr() 转换任何 Python 对象 s 字符串， 使用 str() 转换任何 Python 对象 % % 字符 # + term=True # 最小字段宽度 ' %2s ' % 123456 ' %8s ' % 123456 ' %*s ' % ( 10 , 123456 ) # 精度 ' %.2f ' % 100.256 ' %.*f ' % ( 2 , 100.256 ) # 转换标志 ' %-8d ' % 123456 ' %+8d ' % 123456 ' %08d ' % 123456 # 映射键 ## 如果值是一个字典，那么必须使用映射键. 如： ' %(num)d ' % { \"num\" : 10 } '10'","text_tokens":[":","及其","由","用于","规定","时","且","符号","元组","已","+","后字","写字","%.","s","conversion","小写","于","2s","组成","键","位置","d","加","不足","过时","中","空格","效果","8d","由加","整数","5","则","%+","大写字母","条目","c语言","最","r","精度","g","点数","宽度","符","values","如果","包含","}","两个","选","之后","format","michael","have","算符","8s","无","小写字母","码","0","给出","在","'","此处","meaning","不够","o","x","字符串","you","16","123456","是","一种","指定","加上","其中","{","插值","(","true","如","语言","自动","str","%","可","python","类似","单个","ascii","进制","hello","更","最小","标志","补齐","遵循","也","取模","可以","08d","多","10","填充","somename","小字","内置","浮点数","符将","10000.58","10000","起始","整型","指数","f","序列","小数","任何","2f","4","读取","hi","格式化","浮点","长度","repr","*","world","负号","省略","用","元素","操作","表示","否则","num","正负","值","小于","。","被","正数","运算","运算符","段"," ","；","-","（","映射","对齐","）","后","那么","顺序","前方","多个","对象","或","c","=",",","正负号","特殊","term","具有","例如","$","：","以下","转换","内容","格式","替换","修饰符","的","其","修饰","#","圆括号",".","e","左","使用","必须","对于","##","保留","括号","类型","\"","一个","sprintf","i","字母","称为","，","此时","大写",")","字典","零个","字符","位数","标记","值为","8","2","从","形式","为","u","100.256"],"title":"C printf 样式的格式化","title_tokens":["样式","的","printf","格式化","c"," ","格式"]},{"location":"Python基础/2.4.String.html#format","text":"< 模板字符串 >. format ( < 逗号分隔的参数 > ) <模板字符串> 由一系列的槽 {} 组成，用来控制修改字符串中嵌入值出现的位置，其基本思想是将format()方法的 <逗号分隔的参数> 中的参数按照序号关系替换到 <模板字符串> 的槽中。如果大括号中没有序号，则按照出现顺序替换。该方法会创建新字符串对象，不会修改原值。 {}中指定顺序，按指定的顺序替换 print ( \" {2} : {1} : {0} \" . format ( \"1\" , \"2\" , \"3\" )) 3 : 2 : 1 没有指定顺序，按出现的顺序依次替换 print ( \" {} : {} : {} \" . format ( \"1\" , \"2\" , \"3\" )) 1 : 2 : 3 format()方法中 <模板字符串> 的槽除了包括参数序号，还可以包括格式控制信息。此时，槽的内部样式如下： 替换字段 - replacement_field ::= \"{\" [ field_name ] [ \"!\" conversion ] [ \":\" format_spec ] \"}\" 字段名 - field_name ::= arg_name ( \".\" attribute_name | \"[\" element_index \"]\" ) * 参数名 - arg_name ::= [ identifier | integer ] 属性名 - attribute_name ::= identifier 元素索引 - element_index ::= integer | index_string 索引字符串 - index_string ::= < any source character except \"]\" > + 转换字段 - conversion ::= \"r\" | \"s\" 格式规范说明符 - format_spec ::= < described in the next section > 注意事项： 参数名 可以为 整数 或 关键字 。整数为位置参数， 关键字为命名关键字参数。 如果整数类似于 {0}{1}{2}, 则可以省略， 即： {}{}{} 等价于 {0}{1}{2}. 如果参数存在属性， 可以通过 arg_name.attribute_name 的形式获取属性值。 如果参数为可迭代对象， 可以通过 arg_name[integer|index_string] 的形式获取索引位置的元素。 转换字段 由 ! 开始， r 代表调用 repr(), s 代表调用 str(). 格式规范说明符 由 : 开始。 其中， <格式控制标记> 用来控制参数显示时的格式，可以使用的参数如下： format_spec ::= [ [fill ] align ] [ sign ][ # ][ 0 ][ width ][ grouping_option ][ .precision ][ type ] fill ::= < any character > align ::= \"<\" | \">\" | \"=\" | \"^\" sign ::= \"+\" | \"-\" | \" \" width ::= digit + grouping_option ::= \"_\" | \",\" precision ::= digit + type ::= \"b\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" | \"g\" | \"G\" | \"n\" | \"o\" | \"s\" | \"x\" | \"X\" | \"%\" 填充字符 ：如果指定了对齐选项，则可以使用填充字符。默认为空格. 对齐选项 ：默认右对齐，各种对齐选项的含义如下： 选项 意义 '<' 强制字段在可用空间内左对齐（这是大多数对象的默认值）。 '>' 强制字段在可用空间内右对齐（这是数字的默认值）。 '=' 强制将填充放置在符号（如果有）之后但在数字之前。这用于以“+000000120”形式打印字段。此对齐选项仅对数字类型有效。当'0'紧接在字段宽度之前时，它成为默认值。 '^' 强制字段在可用空间内居中。 sign ：仅对数字类型有效，可以是以下之一： 选项 意义 '+' 表示标志应该用于正数和负数。 '-' 表示标志应仅用于负数（这是默认行为）。 space 表示应在正数上使用前导空格，在负数上使用减号。 # ：仅适用于数字参数，同时仅适用于2、8、16进制的数字。会在输出的数字前添加 0b、0o、0x前缀。 宽度 ：指定最小字段宽度。 千位分隔符 ：只能使用 _ 或 , 作为千位分隔符。 精度 ： 类型 ：该选项决定了数据应该如何呈现。 可用的字符串表示类型： Type Meaning s 字符串格式， 字符串的默认类型， 可省略 None 同 s 可用的整数表示类型： Type Meaning b 输出为 2 进制整数 c 输出为为相应的 unicode 字符 d 输出为 10 进制整数 o 输出为 8 进制整数 x 输出为 16 进制整数， 使用小写字母 X 输出为 16 进制整数， 使用大写字母 n 类似 d , 会使用当前区域设置插入适当的数字分隔符 None 同 d 可用的浮点数和小数值表示类型： Type Meaning e 指数表示法， 使用字母 e 以科学记数法打印数字， 默认进度为 6 E 类似 e , 使用字母 E f 浮点数， 默认进度为 6 F 浮点数， 同 f g 一般形式， 受 precision 选项影响 G 类似 g , 当使用指数表示法时， 使用 E 而不是 e n 和 g 相同， 会使用当前区域设置插入适当的数字分隔符 % 百分数表示 None 同 g # 填充、对齐、符号、宽度、分组选项、精度 \" {0:*^+20.2f} \" . format ( 120 ) # 填充*号、居中、正号标记、2精度 '******+120.00*******' \"{0:*^+20_.2f}\" . format ( 12000 ) # 填充*号、居中、正号标记、_分隔符、2精度 '*****+12_000.00*****' \" {0:*^+20,.2f} \" . format ( 12000 ) # 填充*号、居中、正号标记、,分隔符、2精度 '*****+12,000.00*****' \" {0:*<+20.2f} \" . format ( - 120 ) # 填充*号、左对齐、正号标记、2精度 '-120.00*************' \" {0:*>-20.2f} \" . format ( - 120 ) # 填充*号、左对齐、负号标记、2精度 '*************-120.00'","text_tokens":["1","由","紧接在",">","时","选项","index","写字","conversion","同时","小写","组成","对","相同","fill","type","关键字","name","属性","新","前导","精度","20","出现","|","迭代","arg","之后","还","槽","0","作为","索引","在","string","前","指定","其中","字","none","分数","一般","即","获取","当","如何","标志","可以","默认","f","b","浮点","通过","the","、","_.","<","6","它","右","之一","正数","此"," ","分组","开始","对象","c","百分","section","12000","思想","有效","记数","#","进度","左","使用","方法","括号","\"","用来","没有","此时","0o","标记","形式","precision",":","模板","以","分隔符","负数","character","空格","适用","字段","r","source","点数","120","_","说明","注意","format","小写字母","000.00","紧接","事项","控制参数","16","修改","说明符","插入","按","可用","%","到","可","打印","参数","浮点数","0x","3","显示","space","控制","基本","字段名","将","元素","之前","号","内","减号","百分数","print","=",",","以下","等价","转换","如下","正","关系","e","科学","类型","integer","大多数","8","in","输出","关键","+","位置","d","unicode","中","命名","受","整数","一系列","grouping","则","option","放置","大括号","any","g","宽度","如果","嵌入","成为","区域","含义","described","影响","meaning","x","字符串","注意事项","{","适当","上","会","str","width","进制","一系","该","except","分隔","强制","逗号","了","“","设置","当前","2f","呈现","默认值","repr","*","负号","决定","0b","接在","next","n","000000120","记数法","digit","这是","内部","-","对齐","field","千位","identifier","应仅","]","格式","替换","其","大多","原值",".","存在","字母","内右","，","大写",")","这","2","element","序号","用于","符号","意义","同","创建","信息","s","于","代表","120.00","居中","应该","而","调用","大写字母","最","多数","但","!","}","表示法","行为","名","20.2","除了","'","样式","o","是","spec","系列","添加","(","应","相应","类似","按照","数字","10","填充","依次","attribute","小字","指数","不会","^","数值","只能","省略","仅","[","空间","和","表示","包括","值","12","。","段","（","数据","）","replacement","各种","小","顺序","或","align","：","前缀","规范","的","sign","有","字符","为","”","不是"],"title":"format方法","title_tokens":["format","方法"]},{"location":"Python基础/2.4.String.html#bytes","text":"文本字符类型在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把 str 变为以字节为单位的 bytes 。 Python3对 bytes 类型的数据用带 b 前缀的单引号或双引号表示。 bytes_8 = b \"ABC\" bytes_8 b'ABC' 要注意的是：bytes字面值中只允许ASCII字符（无论源代码声明的编码为何）。任何超出127的二进制值必须使用相应的转义序列形式加入bytes字面值。 例如，可以对str（unicode类型）对象使用 encode() 方法，编码为bytes的形式（16进制表示）。 '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 要注意的是， encode 的对象不能超出指定编码的范围，例如不能对中文字符使用 .encode(\"ascii\") ，因为中文不在ascii码的范围内。 '中文' . encode ( 'ascii' ) ---------------------------------------------------------------------------UnicodeEncodeError Traceback (most recent call last)<ipython-input-1-76f41cd8dafa> in <module> ----> 1 '中文'.encode('ascii') UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) 纯英文的str可以用ASCII编码为bytes，内容是一样的，但无法显示为ASCII字符的字节，用 \\x 显示（16进制转义表示）。 'ABC' . encode ( 'ascii' ) b'ABC' '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用 decode() 方法： b 'ABC' . decode ( 'ascii' ) 'ABC' b ' \\xe4\\xb8\\xad\\xe6\\x96\\x87 ' . decode ( 'utf-8' ) '中文' 如果bytes中包含无法解码的字节， decode() 方法会报错： b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' ) ---------------------------------------------------------------------------UnicodeDecodeError Traceback (most recent call last)<ipython-input-1-cd8de1b11dcd> in <module> ----> 1 b'\\xe4\\xb8\\xad\\xff'.decode('utf-8') UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte 但是，如果bytes中只有一小部分无效的字节，可以传入 errors = 'ignore' 忽略错误的字节： \"中\" . encode ( \"utf-8\" ) # 中 原来的编码 b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' , errors = 'ignore' ) '中' 在对str和bytes互相转换时，为了避免乱码问题，应该使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： # !/usr/bin/env python3 # -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释。第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，在源代码中写的中文输出可能会有乱码。 但是申明了UTF-8编码只是让Python解释器按UTF-8的编码规则读取源代码，并不意味着源代码一定是使用UT8-8编码保存的，必须并且要确保文本编辑器正在使用UTF-8编码。","text_tokens":["call","传输",":","1","部分","以","env",">","时","第一","告诉","磁盘","128","器","让","\\","对应","对","我们","not","x96","不","应该","can","unicode","互相","注释","中","写","意味着","解码","乱码","问题","这个","规则","避免","xad","允许","但","系统","_","usr","可能","源代码","如果","!","traceback","中以","包含","释器","用带","通常","注意","由于","引号","转义","小部","码","0","只","并且","76f41cd8dafa","在","'","most","start","codec","16","x","中写","是","errors","文本编辑","指定","并","windows","byte","确保","字","开头","coding","过来","上","英文","转义序列","二进制","(","一小部分","无效","正在","按","position","/","只是","相应","会","str","encode","当","到","单位","范围","python","务必","读到","原来","加入","ascii","127","按照","你","进制","第二","变为","decode","也","os","保存","可执行程序","可以","但是","一行","把","为了","第一行","xe6","last","了","超出","面值","要","b","序列","文本文件","任何","若干","双引号","声明","为何","单引号","读取","3","文本","申明","显示","就是","module","若干个","xe4","*","行程","xff","流","代码","utf","input","解释器","linux","输出","一定","<","用","它","就","表示","characters","和","两行","程序","否则","ut8","值","第二行","内","ipython","。","无法","本文","传入","需要","报错","ignore","这是"," ","字节","-","（","数据","意味","）","编码","中文","那么","解释","对象","ordinal","反过","反过来","t","或","二行","range","recent","=","一样",",","只有","xb8","abc","例如","纯","：","文件","前缀","忽略","转换","内容","0xff","时候","无论","内存","python3","cd8de1b11dcd","的","所以","编辑","x87","#","bytes",".","必须","使用","错误","网络","因为","类型","\"","方法","一个","unicodeencodeerror","有","，","进行","或者","invalid",")","这","8","字符","bin","执行","unicodedecodeerror","形式","不能","为","从","in","一小"],"title":"bytes字符","title_tokens":["bytes","字符"]},{"location":"Python基础/2.4.String.html#_6","text":"","text_tokens":[],"title":"方法","title_tokens":["方法"]},{"location":"Python基础/2.5.Tuple.html","text":"tuple是一种一维的，定长的、不可变的Python对象序列，元素写在小括号 () 里，元素之间用逗号隔开，元组中的元素类型可以不相同。 不可变的tuple有什么意义？ 因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 Tuple的陷阱——1个元素的Tuple 定义个一个Tuple，需要传入一个iterable对象。 tuple ( \"123\" ) ('1', '2', '3') 如果需要定义一个空的Tuple，则可以这样定义： # 通过tuple类来定义 a = tuple () type ( a ) # 或者用 () 定义 a = () type ( a ) # 是的，通过()可以定义一个空tuple tuple 但是如果要定义一个只有一个元素的tuple，就得要注意了。如果我们这样定义，则是错误的： b = ( \"123\" ) type ( b ) str 定义只有一个元素的tuple，需要这样定义： b = ( \"123\" ,) type ( b ) tuple 或者这样定义： b = tuple ([ \"123\" ]) type ( b ) tuple 为什么会这样呢？因为 () 在python中可以表示运算符的 () ，也可以表示Tuple。这就不可避免地产生了歧义，为了消除歧义，Python规定括号里面只有一个元素时，按运算符的 () 进行解析。 Tuple的陷阱——“可变的”Tuple 前面说过，Tuple是一种不可变的对象。但是有时我们又会发现Tuple是“可变的”。 c = ( 'a' , 'b' , [ 'A' , 'B' ]) print ( \"原始的Tuple：\" , c ) c [ 2 ][ 0 ] = 'X' c [ 2 ][ 1 ] = 'Y' print ( \"修改后的Tuple：\" , c ) 原始的Tuple： ('a', 'b', ['A', 'B']) 修改后的Tuple： ('a', 'b', ['X', 'Y']) 前面说过tuple一旦定义后就不可变，那上面的c怎么就改变了呢？其实，c的元素并没有改变，改变的只是list中的元素，tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素的指向永远不变。即指向 a ，就不能改成指向 b ，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 所以要创建一个内容也不变的tuple，那就必须保证tuple的每一个元素本身也不能变。 Tuple的方法 因为Tuple是一个不可变的列表，没有用于修改列表的方法，所以Tuple对象的方法很少。 d = ( 0 , 1 , 2 , 3 , 4 , 4 ) [ method for method in dir ( d ) if not method . startswith ( \"_\" )] ['count', 'index'] 统计元素出现的次数 d . count ( 4 ) 2 元素第一次出现时对应的索引值 d . index ( 4 ) 4","text_tokens":["1","123","每个","什么","规定","用于","时","第一","意义","为什么","元组","创建","别的","index","tuple","里面","产生","对应","相同","比如","type","我们","第一次","not","能用","d","不","说","中","之间","写","则","这个","避免","一旦","但","发现","歧义","代替","_","可能","定义","如果","出现","包含","隔开","这样","注意","上面","算符","0","其他","变","索引","在","安全","'","解析","定长","—","x","是","a","一种","前面","修改","并","改成","y","！","(","统计","按","只是","会","即","str","那","原始","python","可变","陷阱","指向","虽然","count","不变","if","更","也","消除","可以","逗号","但是","不可","为了","了","“","每","序列","要","b","4","怎么","3","不可避免","永远","通过","改变","代码","又","、","一维","用","[","元素","dir","它","就","表示","一","过","值","个","。","运算","传入","需要","运算符"," ","里","后","开始","对象","method","print","很少","c","=","有时","列表",",","只有","startswith","小括号","]","：","空","内容","保证","iterable","次数","的","所以","所谓","#",".","错误","必须","因为","括号","类型","\"","呢","一个","本身","方法","for","没有","得","有","一次","，","进行","其实","或者","？",")","类来","这","list","2","地","不能","尽量","”","in"],"title":"2.5.Tuple","title_tokens":["tuple",".","2.5"]},{"location":"Python基础/2.5.Tuple.html#tuple1tuple","text":"定义个一个Tuple，需要传入一个iterable对象。 tuple ( \"123\" ) ('1', '2', '3') 如果需要定义一个空的Tuple，则可以这样定义： # 通过tuple类来定义 a = tuple () type ( a ) # 或者用 () 定义 a = () type ( a ) # 是的，通过()可以定义一个空tuple tuple 但是如果要定义一个只有一个元素的tuple，就得要注意了。如果我们这样定义，则是错误的： b = ( \"123\" ) type ( b ) str 定义只有一个元素的tuple，需要这样定义： b = ( \"123\" ,) type ( b ) tuple 或者这样定义： b = tuple ([ \"123\" ]) type ( b ) tuple 为什么会这样呢？因为 () 在python中可以表示运算符的 () ，也可以表示Tuple。这就不可避免地产生了歧义，为了消除歧义，Python规定括号里面只有一个元素时，按运算符的 () 进行解析。","text_tokens":["1","123","什么","规定","时","为什么","tuple","里面","产生","type","我们","中","则","避免","歧义","定义","如果","这样","注意","算符","在","'","解析","是","a","(","按","会","str","python","也","消除","可以","但是","不可","为了","了","要","b","3","不可避免","通过","[","用","元素","就","表示","个","。","运算","传入","需要","运算符"," ","对象","=",",","只有","]","：","空","iterable","的","#","错误","因为","\"","呢","括号","一个","得","，","进行","或者","？",")","类来","这","2","地"],"title":"Tuple的陷阱——1个元素的Tuple","title_tokens":["tuple","—","的","1","个","陷阱","元素"]},{"location":"Python基础/2.5.Tuple.html#tupletuple","text":"前面说过，Tuple是一种不可变的对象。但是有时我们又会发现Tuple是“可变的”。 c = ( 'a' , 'b' , [ 'A' , 'B' ]) print ( \"原始的Tuple：\" , c ) c [ 2 ][ 0 ] = 'X' c [ 2 ][ 1 ] = 'Y' print ( \"修改后的Tuple：\" , c ) 原始的Tuple： ('a', 'b', ['A', 'B']) 修改后的Tuple： ('a', 'b', ['X', 'Y']) 前面说过tuple一旦定义后就不可变，那上面的c怎么就改变了呢？其实，c的元素并没有改变，改变的只是list中的元素，tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素的指向永远不变。即指向 a ，就不能改成指向 b ，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 所以要创建一个内容也不变的tuple，那就必须保证tuple的每一个元素本身也不能变。","text_tokens":["1","每个","创建","别的","tuple","我们","说","中","这个","一旦","但","发现","定义","上面","0","其他","变","'","x","是","a","一种","前面","修改","并","改成","y","！","(","只是","会","即","那","原始","可变","指向","不变","也","但是","不可","了","“","每","要","b","怎么","永远","改变","又","[","元素","就","一","过","。"," ","后","开始","对象","print","c","=","有时",",","]","：","内容","保证","的","所以","所谓","必须","\"","本身","呢","一个","没有","，","其实","？",")","2","list","不能","”"],"title":"Tuple的陷阱——“可变的”Tuple","title_tokens":["tuple","—","的","可变","陷阱","“","”"]},{"location":"Python基础/2.5.Tuple.html#tuple","text":"因为Tuple是一个不可变的列表，没有用于修改列表的方法，所以Tuple对象的方法很少。 d = ( 0 , 1 , 2 , 3 , 4 , 4 ) [ method for method in dir ( d ) if not method . startswith ( \"_\" )] ['count', 'index']","text_tokens":["1","对象","0","method","不可","用于","很少","变","=","'","列表",",","startswith","tuple","index","]","4","是","3","not","d","修改","的","所以","(",".","[","dir","因为","方法","for","\"","一个","没有","，","_","。",")","count","2","if"," ","in"],"title":"Tuple的方法","title_tokens":["tuple","的","方法"]},{"location":"Python基础/2.5.Tuple.html#_1","text":"d . count ( 4 ) 2","text_tokens":["(","4",".",")","count","2","d"," "],"title":"统计元素出现的次数","title_tokens":["次数","的","出现","统计","元素"]},{"location":"Python基础/2.5.Tuple.html#_2","text":"d . index ( 4 ) 4","text_tokens":["(","4",".",")","d"," ","index"],"title":"元素第一次出现时对应的索引值","title_tokens":["值","一次","的","出现","对应","时","第一","元素","第一次","索引"]},{"location":"Python基础/2.6.Dict.html","text":"映射（mapping）是通过名称来访问其各个值的数据结构。字典是Python中唯一的内置映射类型，其中的值不按顺序排列，而是存储在键下。键可能是数、字符串或元组。 创建dict 字典以类似于下面的方式表示： phonebook = { 'Alice' : '2341' , 'Beth' : '9102' , 'Cecil' : '3258' } 字典由键及其相应的值组成，这种键--值对称为项（item）。每个键与其值之间都用冒号 : 分隔，item之间用逗号分隔，而整个字典放在花括号内。空字典（没有任何项）用两个花括号 {} 表示。 注意 在字典（以及其他映射类型）中，键必须是独一无二的，而字典中的值无需如此。 可使用dict类从其他映射（如其他字典）或键–值对序列创建字典。 items = [( 'name' , 'Gumby' ), ( 'age' , 42 )] dict ( items ) {'name': 'Gumby', 'age': 42} 还可使用关键参数，如下所示： dict ( name = 'Gumby' , age = 42 ) {'name': 'Gumby', 'age': 42} Dict的方法 字典的基本行为在很多方面都类似于序列。 len(d)返回字典d包含的项（键--值对）数。 d[k]返回与键k相关联的值。 d[k] = v将值v关联到键k。 del d[k]删除键为k的项。 k in d检查字典d是否包含键为k的项。 虽然字典和列表有多个相同之处，但也有一些重要的不同之处。 自动添加。 dict可以给不存在的项赋值，即是字典中原本没有的键，也可以给它赋值。而如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值。 成员资格。 表达式k in d (其中d是一个字典）査找的是键而不是值；而表达式v in 1 (其中1是一个列表）查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自然。毕竟如果字典包含指定的键，检查相应的值就很容易。 clear 删除所有的字典项 要注意的是，clear是清除了一个字典对象，而不是解除了名称与字典对象的绑定。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a a . clear () # 可以看到，a、b都变成了字典 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {} b的值: {} copy 浅拷贝 a = { \"a\" : 1 , \"b\" : 2 , \"c\" :[ 1 , 2 ]} b = a . copy () b [ \"c\" ][ 0 ] = 10 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {'a': 1, 'b': 2, 'c': [10, 2]} b的值: {'a': 1, 'b': 2, 'c': [10, 2]} fromkeys dict . fromkeys ( key , value ) 方法 fromkeys 创建一个新字典，其中包含指定的键，且每个键对应的值都是None，也可以指定值， dict . fromkeys ([ \"a\" , \"b\" ]) {'a': None, 'b': None} dict . fromkeys ([ \"a\" , \"b\" ], 10 ) {'a': 10, 'b': 10} get 方法 get 为访问字典项提供了宽松的环境。通常，如果你试图访问字典中没有的项，将引发错误。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a [ \"d\" ] ---------------------------------------------------------------------------KeyError Traceback (most recent call last)<ipython-input-1-b0ca58477f0c> in <module> 1 a = {\"a\":1,\"b\": 2,\"c\":3} ----> 2 a[\"d\"] KeyError: 'd' 而使用 get 不会这样 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . get ( \"d\" ) # 默认返回None，也可以指定返回值 a . get ( \"d\" , \"N/A\" ) 'N/A' items 方法 items 返回一个包含所有字典项的列表，其中每个元素都为 (key, value) 的形式。字典项在列表中的排列顺序不确定。返回值属于一种名为字典视图的特殊类型。字典视图可用于迭代。另外，你还可确定其长度以及对其执行成员资格检查。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . items () dict_items([('a', 1), ('b', 2), ('c', 3)]) # dict_items类型 type ( a . items ()) dict_items # 迭代 for i in a . items (): print ( i ) ('a', 1) ('b', 2) ('c', 3) # 迭代 for key , value in a . items (): print ( key , end = \" \" ) print ( value ) a 1 b 2 c 3 # 检查成员资格 ( \"a\" , 1 ) in a . items () True keys 和 values 方法 keys 返回一个字典视图，其中包含字典中的键。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . keys () dict_keys(['a', 'b', 'c']) 方法 values 返回一个字典视图，其中包含字典中的键。 a . values () dict_values([1, 2, 3]) pop 方法pop可用于获取与指定键相关联的值，并将该键-值对从字典中删除。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a . pop ( \"a\" ) print ( \"b的值\" , b ) print ( \"a的值\" , a ) b的值 1 a的值 {'b': 2, 'c': 3} popitem 方法 popitem 类似于 list.pop ，但 list.pop 弹出列表中的最后一个元素，而 popitem 随机地弹出一个字典项，因为字典项的顺序是不确定的，没有“最后一个元素”的概念。如果你要以高效地方式 逐个 删除并处理所有字典项，这可能很有用，因为这样无需先获取键列表。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . popitem () ('c', 3) a {'a': 1, 'b': 2} setdefault 方法 setdefault 有点像get，因为它也获取与指定键相关联的值，但除此之外，setdefault还在字典不包含指定的键时，在字典中添加指定的键-值对。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . setdefault ( \"a\" ) a a . setdefault ( \"d\" ) a {'a': 1, 'b': 2, 'c': 3, 'd': None} 如你所见，指定的键不存在时，setdefault返回指定的值并相应地更新字典。如果指定的键存在，就返回其值，并保持字典不变。与 get 一样，值是可选的，如果没有指定，默认为None。 update 方法update使用一个字典中的项来更新另一个字典。对于通过参数提供的字典，将其项添加到当前字典中。如果当前字典包含键相同的项，就替换它。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . update ({ \"d\" : 4 }) a {'a': 1, 'b': 2, 'c': 3, 'd': 4} 可像调用本章前面讨论的函数dict（类型构造函数）那样调用方法update。这意味着调用update时，可向它提供一个映射、一个由键-值对组成的序列（或其他可迭代对象）或关键字参数。 a . update ( zip ([ \"e\" , \"f\" ],[ 5 , 6 ])) a {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}","text_tokens":["1","毕竟","k",">","时","len","将值","拷贝","组成","对","相同","type","关键字","name","新","项来","5","这种","属于","函数","或键","资格","确定","values","可向","包含","迭代","通常","keyerror","还","0","索引","在","a","一种","指定","其中","mapping","none","相关联","先","true","即","获取","表达","zip","copy","你","也","可以","视图","无需","默认","f","序列","b","试图","42","4","是否","不同之处","给","通过","可像","各个","input","、","如此","用","<","所示","它","6","就","之处","popitem","相关","有点像","那样","冒号","独一","v","；"," ","名为","相当","后","对象","多个","c","除此","列表","习惯","以及","花","所有","另","#","使用","括号","方法","\"","一个","没有","i","数据结构","有用","字典","从","形式","解除","一致",":","及其","以","且","元组","表达式","自然","达式","3258","fromkeys","end","_","放在","项","get","traceback","这样","注意","两个","前面","弹","绑定","不太","按","/","访问","整个","到","python","可","dict","虽然","概念","不变","可选","顺序排列","keys","参数","内置","删除","存储","不同","任何","3","相同之处","clear","module","讨论","很多","另外","地弹","基本","将","元素","关联","来","内","键为","item","出","print","=","看似","一些",",","逐个","如下","e","类型","数","执行","保持","地","不能","类","in","call","关键","cecil","下面","方面","返回","其值","d","中","构造函数","之间","赋值","append","如果","其他","most","字符串","beth","并","查找","{","会","处理","自动","环境","最后","9102","本章","分隔","逗号","看到","last","了","“","当前","容易","update","排列","长度","age","n","pop","更新","到键","随机","结构","-","意味","引发","recent","特殊","]","2341","检查","空","找","替换","–","其","与其",".","存在","必须","错误","对于","与","因为","高效","称为","，","变成","del",")","这","2","下","list","独一无二","很","setdefault","每个","用于","创建","于","键","对应","方式","不","而","调用","意味着","phonebook","该键","但","査","名称","可能","}","除此之外","行为","其项","有点","构造","提供","'","之外","是","浅","都","添加","(","如","相应","宽松","items","b0ca58477f0c","value","类似","10","唯一","要","清除","不会","返回值","原本","gumby","[","和","表示","值","ipython","。","key","（","数据","映射","）","由键","顺序","或","一样","而是","：","觉得","的","所见","重要","for","有","alice","成员","字符","与键","为","”","不是"],"title":"2.6.Dict","title_tokens":["dict",".","2.6"]},{"location":"Python基础/2.6.Dict.html#dict","text":"字典以类似于下面的方式表示： phonebook = { 'Alice' : '2341' , 'Beth' : '9102' , 'Cecil' : '3258' } 字典由键及其相应的值组成，这种键--值对称为项（item）。每个键与其值之间都用冒号 : 分隔，item之间用逗号分隔，而整个字典放在花括号内。空字典（没有任何项）用两个花括号 {} 表示。 注意 在字典（以及其他映射类型）中，键必须是独一无二的，而字典中的值无需如此。 可使用dict类从其他映射（如其他字典）或键–值对序列创建字典。 items = [( 'name' , 'Gumby' ), ( 'age' , 42 )] dict ( items ) {'name': 'Gumby', 'age': 42} 还可使用关键参数，如下所示： dict ( name = 'Gumby' , age = 42 ) {'name': 'Gumby', 'age': 42}","text_tokens":[":","及其","关键","以","每个","cecil","下面","创建","于","组成","键","对","方式","而","name","中","3258","之间","phonebook","这种","或键","放在","项","}","注意","两个","还","其他","在","'","是","beth","都","{","(","如","相应","items","整个","可","类似","9102","dict","分隔","逗号","参数","无需","序列","任何","42","gumby","如此","用","[","所示","表示","age","值","冒号","内","。","独一"," ","item","-","（","映射","）","由键","=",",","以及","]","2341","：","花","空","如下","–","的","与其","必须","使用","括号","类型","没有","称为","alice","，",")","字典","从","类","独一无二"],"title":"创建dict","title_tokens":["dict","创建"]},{"location":"Python基础/2.6.Dict.html#dict_1","text":"字典的基本行为在很多方面都类似于序列。 len(d)返回字典d包含的项（键--值对）数。 d[k]返回与键k相关联的值。 d[k] = v将值v关联到键k。 del d[k]删除键为k的项。 k in d检查字典d是否包含键为k的项。 虽然字典和列表有多个相同之处，但也有一些重要的不同之处。 自动添加。 dict可以给不存在的项赋值，即是字典中原本没有的键，也可以给它赋值。而如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值。 成员资格。 表达式k in d (其中d是一个字典）査找的是键而不是值；而表达式v in 1 (其中1是一个列表）查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自然。毕竟如果字典包含指定的键，检查相应的值就很容易。","text_tokens":["一致","1","毕竟","k","len","方面","将值","于","返回","表达式","键","对","相同","自然","d","不","而","达式","中","赋值","append","但","査","资格","如果","项","包含","行为","其他","索引","在","是","指定","都","其中","查找","相关联","添加","(","不太","会","相应","即","自动","表达","类似","虽然","dict","你","也","可以","删除","不同","序列","容易","是否","不同之处","给","相同之处","很多","原本","基本","[","元素","它","和","之处","就","关联","相关","值","到键","。","v","键为","；"," ","-","（","）","相当","后","多个","或","=","看似","一些","列表","习惯","]","检查","找","觉得","的","重要","存在","使用","数","方法","一个","没有","有","，","del",")","字典","成员","这","与键","不能","in","不是","很"],"title":"Dict的方法","title_tokens":["dict","的","方法"]},{"location":"Python基础/2.6.Dict.html#clear","text":"要注意的是，clear是清除了一个字典对象，而不是解除了名称与字典对象的绑定。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a a . clear () # 可以看到，a、b都变成了字典 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {} b的值: {}","text_tokens":[":","可以","1","对象","看到","print","c","=","了",",","要","b","是","清除","a","3","都","clear","而","{","的","(","绑定",".","#","、","与","\"","一个","值","，","名称","变成","。","}","字典",")","2","注意"," ","解除","不是"],"title":"clear删除所有的字典项","title_tokens":["的","项","字典","所有","删除","clear"]},{"location":"Python基础/2.6.Dict.html#copy","text":"a = { \"a\" : 1 , \"b\" : 2 , \"c\" :[ 1 , 2 ]} b = a . copy () b [ \"c\" ][ 0 ] = 10 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {'a': 1, 'b': 2, 'c': [10, 2]} b的值: {'a': 1, 'b': 2, 'c': [10, 2]}","text_tokens":[":","1","0","10","print","c","=","'",",","b","]","a","{","的","(",".","[","\"","值","}",")","copy","2"," "],"title":"copy浅拷贝","title_tokens":["浅","拷贝","copy"]},{"location":"Python基础/2.6.Dict.html#fromkeys","text":"dict . fromkeys ( key , value ) 方法 fromkeys 创建一个新字典，其中包含指定的键，且每个键对应的值都是None，也可以指定值， dict . fromkeys ([ \"a\" , \"b\" ]) {'a': None, 'b': None} dict . fromkeys ([ \"a\" , \"b\" ], 10 ) {'a': 10, 'b': 10}","text_tokens":["也",":","可以","10","每个","且","创建","'",",","b","]","键","对应","是","a","指定","都","其中","{","新","的","none","(","fromkeys",".","[","方法","\"","一个","value","值"," ","，","包含",")","字典","}","dict","key"],"title":"fromkeys","title_tokens":["fromkeys"]},{"location":"Python基础/2.6.Dict.html#get","text":"方法 get 为访问字典项提供了宽松的环境。通常，如果你试图访问字典中没有的项，将引发错误。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a [ \"d\" ] ---------------------------------------------------------------------------KeyError Traceback (most recent call last)<ipython-input-1-b0ca58477f0c> in <module> 1 a = {\"a\":1,\"b\": 2,\"c\":3} ----> 2 a[\"d\"] KeyError: 'd' 而使用 get 不会这样 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . get ( \"d\" ) # 默认返回None，也可以指定返回值 a . get ( \"d\" , \"N/A\" ) 'N/A'","text_tokens":["也","call","引发",":","可以","1","c",">","默认","recent","提供","=","last","了","'","most",",","b","试图","]","keyerror","返回","3","a","指定","d","module","不会","而","中","{","返回值","的","none","(","ipython","input",".","#","将","错误","[","<","使用","/","访问","方法","\"","宽松","b0ca58477f0c","n","没有","环境","，"," ","项","如果","get","。","字典","}","traceback","2",")","通常","这样","你","为","-","in"],"title":"get","title_tokens":["get"]},{"location":"Python基础/2.6.Dict.html#items","text":"方法 items 返回一个包含所有字典项的列表，其中每个元素都为 (key, value) 的形式。字典项在列表中的排列顺序不确定。返回值属于一种名为字典视图的特殊类型。字典视图可用于迭代。另外，你还可确定其长度以及对其执行成员资格检查。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . items () dict_items([('a', 1), ('b', 2), ('c', 3)]) # dict_items类型 type ( a . items ()) dict_items # 迭代 for i in a . items (): print ( i ) ('a', 1) ('b', 2) ('c', 3) # 迭代 for key , value in a . items (): print ( key , end = \" \" ) print ( value ) a 1 b 2 c 3 # 检查成员资格 ( \"a\" , 1 ) in a . items () True","text_tokens":[":","还","1","顺序","视图","每个","print","用于","c","=","在","'","列表",",","特殊","b","以及","]","返回","3","对","一种","a","检查","type","所有","都","其中","排列","不","长度","中","{","另外","返回值","的","其","(","true","#",".","[","元素","key","属于","方法","类型","\"","items","一个","for","end","i","value"," ","，","_","资格","确定","项","可","包含",")","字典","。","迭代","执行","成员","2","}","你","dict","形式","为","in","名为"],"title":"items","title_tokens":["items"]},{"location":"Python基础/2.6.Dict.html#keysvalues","text":"方法 keys 返回一个字典视图，其中包含字典中的键。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . keys () dict_keys(['a', 'b', 'c']) 方法 values 返回一个字典视图，其中包含字典中的键。 a . values () dict_values([1, 2, 3])","text_tokens":[":","1","视图","keys","c","=","'",",","b","]","返回","键","3","a","其中","{","中","的","(",".","[","\"","方法","一个","，","_","values","包含","。","字典","}",")","2","dict"," "],"title":"keys和values","title_tokens":["values","keys","和"]},{"location":"Python基础/2.6.Dict.html#pop","text":"方法pop可用于获取与指定键相关联的值，并将该键-值对从字典中删除。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a . pop ( \"a\" ) print ( \"b的值\" , b ) print ( \"a的值\" , a ) b的值 1 a的值 {'b': 2, 'c': 3}","text_tokens":[":","1","print","用于","c","删除","=","'",",","b","键","3","对","a","指定","并","中","{","的","相关联","(",".","将","与","该键","方法","\"","获取","关联","相关","pop","值","，","可","。","}","字典",")","2","从"," ","-"],"title":"pop","title_tokens":["pop"]},{"location":"Python基础/2.6.Dict.html#popitem","text":"方法 popitem 类似于 list.pop ，但 list.pop 弹出列表中的最后一个元素，而 popitem 随机地弹出一个字典项，因为字典项的顺序是不确定的，没有“最后一个元素”的概念。如果你要以高效地方式 逐个 删除并处理所有字典项，这可能很有用，因为这样无需先获取键列表。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . popitem () ('c', 3) a {'a': 1, 'b': 2}","text_tokens":[":","1","顺序","出","以",")","无需","c","}","删除","=","“","'","列表",",","要","b","于","是","键","a","3","所有","逐个","方式","不","并","而","中","{","弹","地弹","的","先","(",".","元素","因为","方法","处理","有用","\"","一个","但","popitem","获取","没有","高效","pop","，","最后","可能","确定","项","如果","类似","随机","字典","。","这","list","概念","地","这样","你","2"," ","”","很"],"title":"popitem","title_tokens":["popitem"]},{"location":"Python基础/2.6.Dict.html#setdefault","text":"方法 setdefault 有点像get，因为它也获取与指定键相关联的值，但除此之外，setdefault还在字典不包含指定的键时，在字典中添加指定的键-值对。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . setdefault ( \"a\" ) a a . setdefault ( \"d\" ) a {'a': 1, 'b': 2, 'c': 3, 'd': None} 如你所见，指定的键不存在时，setdefault返回指定的值并相应地更新字典。如果指定的键存在，就返回其值，并保持字典不变。与 get 一样，值是可选的，如果没有指定，默认为None。","text_tokens":["也",":","还","setdefault","1","c","时","默认","=","除此","一样","在","'",",","之外","b","为","返回","键","3","对","a","是","指定","其值","d","并","不","中","{","的","相关联","添加","(","none","所见",".","如","存在","因为","它","方法","与","\"","相应","但","获取","关联","相关","就","没有","有点像","值","，","更新","如果","get","包含","字典","除此之外","。","2","}",")","地","你","保持","不变","可选"," ","-","有点"],"title":"setdefault","title_tokens":["setdefault"]},{"location":"Python基础/2.6.Dict.html#update","text":"方法update使用一个字典中的项来更新另一个字典。对于通过参数提供的字典，将其项添加到当前字典中。如果当前字典包含键相同的项，就替换它。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . update ({ \"d\" : 4 }) a {'a': 1, 'b': 2, 'c': 3, 'd': 4} 可像调用本章前面讨论的函数dict（类型构造函数）那样调用方法update。这意味着调用update时，可向它提供一个映射、一个由键-值对组成的序列（或其他可迭代对象）或关键字参数。 a . update ( zip ([ \"e\" , \"f\" ],[ 5 , 6 ])) a {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}","text_tokens":[":","1","关键","时","组成","键","对","相同","d","关键字","中","构造函数","项来","调用","意味着","5","函数","可向","如果","项","包含","}","迭代","其项","构造","其他","提供","'","a","前面","{","添加","(","到","可","zip","dict","本章","参数","f","序列","b","当前","4","3","update","讨论","通过","可像","、","将","[","6","它","就","值","那样","更新","。"," ","-","意味","（","映射","）","由键","对象","或","c","=",",","]","另","替换","的","e",".","使用","对于","方法","\"","类型","一个","，",")","字典","这","2"],"title":"update","title_tokens":["update"]},{"location":"Python基础/2.7.推导式.html","text":"import pprint 列表推导式 列表推导式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的推导式。 运用列表推导式， 可以写出非常简洁的代码 。 举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 可以用 list(range(1, 11)) ： list ( range ( 1 , 11 )) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成 [1x1, 2x2, 3x3, ..., 10x10] 怎么做？方法一是循环： L = [] for x in range ( 1 , 11 ): L . append ( x * x ) pprint . pprint ( L ) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表推导式则可以用一行语句代替循环生成上面的list： [ x * x for x in range ( 1 , 11 )] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 写列表推导式时，把 要生成的元素 x * x 放到前面 ，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： [ x * x for x in range ( 1 , 11 ) if x % 2 == 0 ] [4, 16, 36, 64, 100] 还可以使用两层循环，可以生成全排列： [ m + n for m in 'ABC' for n in 'XYZ' ] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 三层和三层以上的循环就很少用到了。 for 循环其实可以同时使用两个甚至多个变量，比如 dict 的 items() 可以同时迭代key和value： d = { 'x' : 'A' , 'y' : 'B' , 'z' : 'C' } for k , v in d . items (): print ( k , '=' , v ) x = A y = B z = C 因此，列表推导式也可以使用两个变量来生成list： d = { 'x' : 'A' , 'y' : 'B' , 'z' : 'C' } [ k + '=' + v for k , v in d . items ()] ['x=A', 'y=B', 'z=C'] 最后把一个list中所有的字符串变成小写： L = [ 'Hello' , 'World' , 'IBM' , 'Apple' ] [ s . lower () for s in L ] ['hello', 'world', 'ibm', 'apple'] 字典推导式 字典推导式和列表推导式是类似的： { key : value for key , value in enumerate ( range ( 4 ))} {0: 0, 1: 1, 2: 2, 3: 3}","text_tokens":[":","太","1","k","时","举个","9","ay","z","写出","创建","+","小写","同时","s","比如","cy","我们","d","简单","而","中","写","用到","5","则","这种","append","熟悉","筛选","pprint","甚至","但","代替","如果","三层","}","迭代","这样","bz","64","两个","上面","还","0","后面","3x3","循环","'","m","16","例子","x","字符串","却","是","强大","a","加上","前面","by","enumerate","平方","{","y","l","(","即","items","全","11","%","value","最后","python","类似","comprehensions","dict","apple","if","hello","语句","lower","7","也","可以","10","但是","多写","一行","把","内置","做","了","要","b","2x2","4","怎么","3","放到","推导","排列","*","运用","world","代码","1x1","36","49","[","用","元素","6","就","和","n","az","来","。","两层","生成","v","ax","简洁","10x10"," ","100","繁琐","十分","几次","判断","cx","以上","key","出来","多个","非常简单","print","...","很少","c","range","=","列表",",","]","偶数","abc","xyz","：","因此","所有","很快","式","的","25","语法","非常",".","bx","使用","ibm","import","方法","for","一是","一个","用来","，","cz","变成","有用","其实","？",")","字典","8","字符","list","2","变量","出仅","跟","81","in"],"title":"2.7.推导式","title_tokens":[".","式","推导","2.7"]},{"location":"Python基础/2.7.推导式.html#_1","text":"列表推导式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的推导式。 运用列表推导式， 可以写出非常简洁的代码 。 举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 可以用 list(range(1, 11)) ： list ( range ( 1 , 11 )) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成 [1x1, 2x2, 3x3, ..., 10x10] 怎么做？方法一是循环： L = [] for x in range ( 1 , 11 ): L . append ( x * x ) pprint . pprint ( L ) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表推导式则可以用一行语句代替循环生成上面的list： [ x * x for x in range ( 1 , 11 )] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 写列表推导式时，把 要生成的元素 x * x 放到前面 ，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： [ x * x for x in range ( 1 , 11 ) if x % 2 == 0 ] [4, 16, 36, 64, 100] 还可以使用两层循环，可以生成全排列： [ m + n for m in 'ABC' for n in 'XYZ' ] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 三层和三层以上的循环就很少用到了。 for 循环其实可以同时使用两个甚至多个变量，比如 dict 的 items() 可以同时迭代key和value： d = { 'x' : 'A' , 'y' : 'B' , 'z' : 'C' } for k , v in d . items (): print ( k , '=' , v ) x = A y = B z = C 因此，列表推导式也可以使用两个变量来生成list： d = { 'x' : 'A' , 'y' : 'B' , 'z' : 'C' } [ k + '=' + v for k , v in d . items ()] ['x=A', 'y=B', 'z=C'] 最后把一个list中所有的字符串变成小写： L = [ 'Hello' , 'World' , 'IBM' , 'Apple' ] [ s . lower () for s in L ] ['hello', 'world', 'ibm', 'apple']","text_tokens":[":","太","1","k","时","举个","9","ay","z","写出","创建","+","小写","同时","s","比如","cy","我们","d","简单","而","中","写","用到","5","则","这种","append","熟悉","筛选","pprint","甚至","但","代替","如果","三层","}","迭代","这样","bz","64","两个","上面","还","0","后面","3x3","循环","'","m","16","例子","x","字符串","却","是","强大","a","加上","前面","by","平方","{","y","l","(","即","items","全","11","%","value","最后","python","comprehensions","dict","apple","if","hello","语句","lower","7","也","可以","10","但是","多写","一行","把","内置","做","了","要","b","2x2","4","怎么","3","放到","推导","排列","*","运用","world","代码","1x1","36","49","[","用","元素","6","就","和","n","az","来","。","两层","生成","v","ax","简洁","10x10"," ","100","繁琐","十分","几次","判断","cx","以上","key","出来","多个","非常简单","print","...","很少","c","range","=","列表",",","]","偶数","abc","xyz","：","因此","所有","很快","式","的","25","语法","非常",".","bx","使用","ibm","方法","for","一是","一个","用来","，","cz","变成","有用","其实","？",")","8","字符","list","2","变量","出仅","跟","81","in"],"title":"列表推导式","title_tokens":["式","列表","推导"]},{"location":"Python基础/2.7.推导式.html#_2","text":"字典推导式和列表推导式是类似的： { key : value for key , value in enumerate ( range ( 4 ))} {0: 0, 1: 1, 2: 2, 3: 3}","text_tokens":[":","1","0","range","列表",",","4","是","：","3","推导","enumerate","{","式","的","(","和","for","value"," ","类似",")","字典","}","2","key","in"],"title":"字典推导式","title_tokens":["式","字典","推导"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html","text":"赋值 引用（reference） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。 一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。因此，引用亦常被称为该资料的指标或位址。 Python的赋值都是传引用，即name是value的引用。 在python里面，一个变量保存的值是某个对象的引用。Python赋值语句将左侧的符号名称与右侧的值 相关联 。在Python中，我们说名称引用值，或者名称是对值的引用。 下次我们使用这个名称时，便得到与名称相关联的值。 assignment永远不会复制数据，并且多个name可以引用同一个value。 当值具有多个名称时，很容易混淆并将其视为两个名称和两个值。： x = 23 y = x 但将已有的变量赋值给新变量时，Python永远不会复制值。分配只是使左侧的名称引用右侧的值。在这种情况下，我们只有一个23， x 和 y 都引用它，就像我们在上图中看到的那样。 名称是独立于其他名称重新分配的。 如果两个名称引用相同的值，则不会链接这两个名称。重新分配其中一个不会导致另一个也被重新分配： x = 23 y = x x = 12 如果上面嵌入的网页失效，可以参考以下动图： 值一直存在，直到没有名称引用它。 Python会跟踪每个值有多少引用，并自动清除没有引用的值。这被称为“垃圾收集”，意味着你不必清楚值，当它们不再需要时它们会自行消失。 mutable 和 immutable Python的数据类型可以分为原子类型和容器类器： 原子类型：string、number 容器类型：list、tuple、dict、set 原子类型只能保存一个值；容器类型则可以保存多个值。 虽然string可以包含多个字符，但Python中没有字符类型，因此字符串也属于原子类型。 Python对原子类型和容器类型的赋值方式都是一样的： 对于原子类型，name直接指向object 对于容器类器，name指向容器类型对象，容器的每一个元素指向各个元素对象 Python的数据类型还可以分为 immutable 和 mutable ： immutable object : string、tuple、number mutable object : list、dict、set 所谓的mutable、immutable是指name指向的object可不可以在原地址被修改。如果不可以在原地址修改，就只能在新地址创建新对象，name指向新对象（旧对象若没有引用，则会被内存回收机制销毁）： name = 10 print ( \"name的id：\" , id ( name )) name = 20 print ( \"name的id：\" , id ( name )) name的id： 140724285510752 name的id： 140724285511072 如果可以在原地址被修改，那么name的指向就不会改变（容器类型的对象实际上保存的是元素的引用）： name = [ 1 , 2 , 3 , 4 , 5 ] print ( \"name的值:\" , name , \" \" , \"name的id：\" , id ( name )) for num , i in enumerate ( name ): print ( f \"第 {num} 个元素的id\" , id ( i )) name [ 0 ] = 20 print ( \"name的值:\" , name , \" \" , \"name的id：\" , id ( name )) for num , i in enumerate ( name ): print ( f \"第 {num} 个元素的id\" , id ( i )) name的值: [1, 2, 3, 4, 5] name的id： 1441647216520 第0个元素的id 140724285510464 第1个元素的id 140724285510496 第2个元素的id 140724285510528 第3个元素的id 140724285510560 第4个元素的id 140724285510592 name的值: [20, 2, 3, 4, 5] name的id： 1441647216520 第0个元素的id 140724285511072 第1个元素的id 140724285510496 第2个元素的id 140724285510528 第3个元素的id 140724285510560 第4个元素的id 140724285510592 immutable的本质 神话：Python以不同的方式分配可变和不可变的值。 因为mutable对象是可变的，immutable对象不可变，人们可能会觉得mutable对象和immutable对象的值分配方式不一样。但事实上，mutable对象和immutable对象所有的赋值的方式都是一样的。 mutable、immutable只是python语言的一个规定。 从硬件角度说，硬件提供给用户的接口是按照规定设定好的。比如说，操作内存的方式是固定的，不存在可变和不可变。实现python的mutable、immutable就是调用了不同的底层API，或者是不同底层API相互组合来实现的。python将这些规定以python语法的形式提供给用户使用，最后还是编译成0、1去让计算机执行。对于用户来说，可变和不可变对象是语言提供的一个特性，可以完成一些功能，但是对于计算机其实是没区别的。 因此，mutable和immutable的本质区别是Python有没有提供修改值的方法。 不管是可变对象还是不可变对象，Python的赋值方式都是一样的，都是将对象绑定到名字（参见上面的图示和示例代码）。 赋值陷阱——浅拷贝和深拷贝 神话：值是有范围的。 在python中存在作用域这样的概念，人们可能会觉得作用域指的是值（对象）的作用范围，但事实上， 值是没有范围的，作用域指的是名称的作用范围。 我们可以定义一个简单的函数与验证这点。 def check_name_space_range ( x ): print ( \"x的内存地址是：\" + str ( id ( x ))) # 先在最外层的作用域赋值，并打印地址 a = 10 print ( \"a的内存地址是：\" + str ( id ( a ))) check_name_space_range ( a ) a的内存地址是：140724285510752 x的内存地址是：140724285510752 很明显，在内外层作用域的值都是同一个。 陷阱：因为值没有范围，并且赋值不会复制值，这就可能出现可变对象被意外地改变： def variable_change ( x ): x [ 0 ] = 10 return x a = [ 1 , 2 , 3 ] a_other = variable_change ( a ) print ( a ) print ( a_other ) [10, 2, 3] [10, 2, 3] 可以看到， a 、 a_other 都被改变了，因为 a 、 a_other 都是同一个对象。 print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) a的内存地址是：1441620592200 a_other的内存地址是：1441620592200 因此，如果要在函数里面更改可变对象参数的值，最好复制一个副本。 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ] = 10 else : pass return x a = [ 1 , 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [1, 2, 3] [10, 2, 3] a的内存地址是：1441623564040 a_other的内存地址是：1441647218056 a 的值并没有改变，上面的结果看似是没问题的，但还是会有新的”惊喜“。 我们来修改一下 variable_change_shallow 函数 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ][ 0 ] = 10 else : pass return x a = [[ 1 , 2 ], 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [[10, 2], 2, 3] [[10, 2], 2, 3] a的内存地址是：1441667197256 a_other的内存地址是：1441648401544 ”惊喜“就是 a 的值也改变了。因为 x.copy() 只是浅拷贝。 在python里面有三种方式去引用某个值： 引用另一个变量 浅拷贝 深拷贝 这三种方式是有区别的。 import copy a = [ 1 , 2 ,[ 1 , 2 ]] a_reference = a a_shallow = copy . copy ( a ) a_deep_copy = copy . deepcopy ( a ) 变量 a 和 a_reference 都是同一个对象的名称。 浅拷贝得到变量 a_shallow ，它是一个新对象，但 a_shallow 的第三个元素 a_shallow[2] 却是一个已经存在的对象，这和 a 、 a_reference 一样。 深拷贝得到变量 a_deep_copy ，它是一个新对象，并且它的每一个元素也是新的对象。 如果浅拷贝的对象包含了mutable对象，则mutable对象不会拷贝；而深拷贝则会完整拷贝对象。 赋值陷阱——引用不仅仅限于名称 以上所有示例都使用名称作为值的引用，但引用也可以是其他东西。 Python有许多复合数据结构，每个结构都包含对值的引用：列表元素，字典键和值，对象属性等。 其中每一个都可以在赋值符号的左侧使用，以上所有细节都适用于它们。 任何可以出现在赋值语句左侧的内容都是引用 ，在本文中说“名称”的任何地方都可以用“引用”替换。 在上面的示意图中，数字被显示为元素，但实际上，每个元素都是对数字的引用，因此它应该像这样绘制： nums = [ 1 , 2 , 3 ] 但这很快变得复杂，所以上面的绘图用了视觉速记： 如果你有列表元素引用其他可变值，例如子列表，请务必记住列表元素只是对值的引用。 这是一些其他assignment的例子。这些左侧中的每一个都是引用（reference）： my_obj . attr = 23 # 类属性 my_dict [ key ] = 24 # 字典 my_list [ index ] = 25 # 列表 my_obj . attr [ key ][ index ] . attr = \"etc, etc\" # 多个对象嵌套 i = x 指定了名称 i ，但 i[0] = x 并不是指定名称 i ，而是指定了 i 的值的第一个元素。 很多东西都是Assignment。 正如上面所说，许多东西都可以作为引用，python里面有很多东西可以作为assignments。 这些行中的每一行都是名称 X 的赋值： X = ... for X in ... [ ... for X in ... ] ( ... for X in ... ) { ... for X in ... } class X ( ... ): def X ( ... ): def fn ( X ): ... ; fn ( 12 ) with ... as X : except ... as X : import X from ... import X import ... as X from ... import ... as X 注意，我并不是说这些语句像assignments，我的意思是这些语句都是赋值。它们都使名称 X 引用某个值。上面所说的关于赋值的所有内容都适用于所有这些赋值。 在大多数情况下，这些语句将 X 定义在与语句相同的作用域内。Python 2和Python 3之间的细节略有不同。但它们都是真正的赋值，而且每个事实都是关于赋值适用于所有这些。 Python通过赋值来传递函数参数。 让我们来看看这些上面assignment列表中最有趣的一个：调用一个函数。当我定义一个函数时，我将其参数命名为： def my_func ( x , y ): return x + y 这里 x 和 y 是函数 my_func 的参数。当我调用 my_func 时，我提供了实际值作为函数的参数。这些值分配给 参数名称 ，就像使用了赋值语句一样： def my_func ( x , y ): return x + y print ( my_func ( 8 , 9 )) 17 调用 my_func 时，8被赋值给名称 x ，9被赋值给名称 y 。该赋值与我们一直在讨论的简单赋值语句完全相同。名称 x 和 y 是函数的本地名称（local），因此当函数返回时，这些名称就会消失。但是，如果它们引用的值仍然被其他名称引用，则值仍然存在。 就像所有其他赋值一样，可变值可以传递给函数，并且通过其所有名称可以看到对值的更改。这在<浅拷贝和深拷贝>中已经提到。 名称和值的一些细节 任何名称都可以随时引用任何值。 Python是动态类型的，这意味着名称没有类型。任何名称都可以随时引用任何值。名称可以引用整数，然后引用字符串，然后引用函数，然后引用模块。当然，这可能是一个非常混乱的程序，你不应该这样做，但Python语言不会介意。 名称没有类型，值没有范围。 正如名称没有类型一样，值也没有范围。当我们说一个函数有一个局部变量时，我们的意思是该名称的作用域是函数：你不能在函数外部使用该名称，当函数返回时，名称将被销毁。但是正如我们所看到的，如果名称的值具有其他引用，它将继续在函数调用之外。它是本地名称，而不是本地值。 值不能删除，只有名称可以删除。 Python的内存管理对其行为至关重要，你不仅不必删除值，而且无法删除值。 nums = [ 1 , 2 , 3 ] del nums 这不会删除值 nums ，它会删除名称 nums 。该名称将从其范围中删除，然后通常的引用计数开始执行：如果 nums 的值只有一个引用，则将回收该值。但如果它有其他引用，那么它不会被回收。 神话：Python没有变量。 有些人喜欢说，“Python没有变量，它有名字。”这个口号具有误导性。事实是Python有变量，它们的工作方式与C中的变量不同。 名称是Python的变量：它们引用值，并且这些值可以在程序的过程中发生变化（变化）。仅仅因为另一种语言（尽管是一种重要的语言）表现不同，没有理由将Python描述为没有变量。","text_tokens":["用户","1","意图",">","时","index","tuple","拷贝","对","相同","我","简单","本质区别","name","该值","属性","新","5","这种","fn","属于","正如","20","函数","已经","继续","出现","包含","通常","作用","pass","还","0","机制","作为","模块","原","当然","在","string","—","a","一种","指定","其中","变得","140724285511072","先","相关联","一般","即","当","不管","第三个","有些","陷阱","copy","可不","你","参见","也","obj","1441648401544","可以","销毁","etc","f","做","每","事实上","实际上","请","4","这里","给","mutable","函数调用","编译成","储存","通过","神话","传递","各个","代码","许多","、","好","140724285510560","<","用","它","导致","就","程序","相关","本地","那样","无法","；"," ","值有","开始","对象","多个","140724285510528","c","实现","图示","列表","完成","具有","因此","重新分配","所有","过程","另","至关重要","直到","25","#","使用","id","import","\"","方法","细节","一个","没有","i","数据结构","意思","若","字典","独立","并打印","从","形式","清楚","略有不同",":","以","规定","第一","9","assignments","isinstance","让","内存地址","一下","set","适用","示意图","这个","def","三种","不仅","固定","_","这样","传","注意","两个","外层","上面","check","意外","下次","记住","键和值","object","理由","修改","旧","绑定","140724285510592","只是","reference","到","140724285510752","python","deep","装置","指向","链接","dict","虽然","概念","打印","if","视为","api","地址","但是","参数","比如说","nums","from","删除","动态","不同","资料","任何","3","显示","就是","可不可以","讨论","space","很多","地方","真正","将","元素","操作","失效","东西","关联","来","仍然","内","被",";","亦","需要","class","混淆","发生","print","对值","...","=","看似","一些",",","只有","示例","这点","以下","1441647216520","内存","动图","return","所以","语法","所谓","非常","混乱","底层","类型","140724285510464","其实","大多数","执行","垃圾","8","地","不能","完全","计数","类","in","直接","1441620592200","第一个","视觉","多少","示意","区别","+","尽管","里面","返回","然后","便","我们","引用","表现","assignment","中","之间","命名","赋值","本质","整数","则","17","原子","with","else","某个","事实","如果","等","第三","嵌入","其他","复合","并且","一直","指","my","使","算机","x","字符串","误导","并","设定","至关","{","变化","指标","y","上","副本","参考","不再","语言","同一个","会","自动","str","提到","最后","务必","复杂","人","语句","23","该","except","误导性","这些","限于","看到","一行","当值","传递函数","了","“","容器","而言","容易","消失","记忆体","关于","三个","验证","改变","不仅仅","func","电脑","最好","生变","一般而言","介意","shallow","去","所说","个","结构","本文","这是","意味","以上","那么","相互","它们","名字","range","位址","略有","情况","variable","1441667197256","随时","网页","外部","]","例如","口号","内容","很快","来说","替换","其","大多",".","存在","速记","对于","与","因为","间接","没","工作","在内","称为","，","del","像","local",")","这","list","下","2","程式","计算机","很","1441647218056","number","每个","绘图","喜欢","符号","创建","硬件","深","change","于","比如","复制","方式","不","应该","而","说","特性","数据类型","调用","分配","意味着","惊喜","最","问题","多数","它会","但","名称","可能","定义","}","immutable","1441623564040","行为","却是","中说","功能","变","提供","之外","例子","左侧","是","看看","浅","重新","都","第","enumerate","管理","组合","图","同一","(","还是","结果","绘制","仅仅","value","不必","范围","可变","按照","as","更改","数字","局部","保存","10","不可","完全相同","存取","行中","局部变量","要","收集","所","清除","变得复杂","子","常","永远","不会","已有","只能","中一","明显","记忆","特定","140724285510496","24","[","实际","和","num","值","12","。","回收","发生变化","实体","key","（","数据","）","而且","类器","或","attr","一样","完整","other","自行","人们","而是","接口","：","译成","作用域","觉得","右侧","得到","嵌套","的","编译","deepcopy","重要","for","计算","角度","有","有趣","跟踪","或者","分为","有没有","字符","描述","变量","为","”","不是"],"title":"2.8.赋值、immutable、深拷贝","title_tokens":["赋值","拷贝",".","、","immutable","2.8","深"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#_1","text":"引用（reference） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。 一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。因此，引用亦常被称为该资料的指标或位址。 Python的赋值都是传引用，即name是value的引用。 在python里面，一个变量保存的值是某个对象的引用。Python赋值语句将左侧的符号名称与右侧的值 相关联 。在Python中，我们说名称引用值，或者名称是对值的引用。 下次我们使用这个名称时，便得到与名称相关联的值。 assignment永远不会复制数据，并且多个name可以引用同一个value。 当值具有多个名称时，很容易混淆并将其视为两个名称和两个值。： x = 23 y = x 但将已有的变量赋值给新变量时，Python永远不会复制值。分配只是使左侧的名称引用右侧的值。在这种情况下，我们只有一个23， x 和 y 都引用它，就像我们在上图中看到的那样。 名称是独立于其他名称重新分配的。 如果两个名称引用相同的值，则不会链接这两个名称。重新分配其中一个不会导致另一个也被重新分配： x = 23 y = x x = 12 如果上面嵌入的网页失效，可以参考以下动图： 值一直存在，直到没有名称引用它。 Python会跟踪每个值有多少引用，并自动清除没有引用的值。这被称为“垃圾收集”，意味着你不必清楚值，当它们不再需要时它们会自行消失。","text_tokens":["每个","多少","时","符号","里面","让","于","便","相同","复制","我们","引用","name","说","assignment","中","赋值","新","分配","意味着","则","这种","这个","但","某个","名称","如果","传","两个","上面","嵌入","其他","下次","并且","一直","在","使","x","左侧","是","重新","都","并","其中","图","指标","同一","y","相关联","上","参考","一般","不再","同一个","只是","会","即","自动","reference","当","value","不必","python","装置","链接","你","语句","23","该","视为","也","保存","可以","看到","当值","“","存取","而言","资料","收集","容易","清除","给","消失","记忆体","常","储存","永远","不会","已有","电脑","中一","一般而言","记忆","特定","将","它","导致","和","就","失效","关联","相关","值","12","那样","。","被","亦","需要","实体"," ","（","数据","意味","）","值有","它们","混淆","对象","多个","或","对值","位址","=","情况","自行","只有","网页","具有","：","因此","重新分配","以下","另","右侧","得到","动图","的","其","直到","存在","使用","与","间接","一个","没有","称为","，","跟踪","像","或者","垃圾","这","下","变量","独立","程式","”","很","清楚"],"title":"赋值","title_tokens":["赋值"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#mutable-immutable","text":"Python的数据类型可以分为原子类型和容器类器： 原子类型：string、number 容器类型：list、tuple、dict、set 原子类型只能保存一个值；容器类型则可以保存多个值。 虽然string可以包含多个字符，但Python中没有字符类型，因此字符串也属于原子类型。 Python对原子类型和容器类型的赋值方式都是一样的： 对于原子类型，name直接指向object 对于容器类器，name指向容器类型对象，容器的每一个元素指向各个元素对象 Python的数据类型还可以分为 immutable 和 mutable ： immutable object : string、tuple、number mutable object : list、dict、set 所谓的mutable、immutable是指name指向的object可不可以在原地址被修改。如果不可以在原地址修改，就只能在新地址创建新对象，name指向新对象（旧对象若没有引用，则会被内存回收机制销毁）： name = 10 print ( \"name的id：\" , id ( name )) name = 20 print ( \"name的id：\" , id ( name )) name的id： 140724285510752 name的id： 140724285511072 如果可以在原地址被修改，那么name的指向就不会改变（容器类型的对象实际上保存的是元素的引用）： name = [ 1 , 2 , 3 , 4 , 5 ] print ( \"name的值:\" , name , \" \" , \"name的id：\" , id ( name )) for num , i in enumerate ( name ): print ( f \"第 {num} 个元素的id\" , id ( i )) name [ 0 ] = 20 print ( \"name的值:\" , name , \" \" , \"name的id：\" , id ( name )) for num , i in enumerate ( name ): print ( f \"第 {num} 个元素的id\" , id ( i )) name的值: [1, 2, 3, 4, 5] name的id： 1441647216520 第0个元素的id 140724285510464 第1个元素的id 140724285510496 第2个元素的id 140724285510528 第3个元素的id 140724285510560 第4个元素的id 140724285510592 name的值: [20, 2, 3, 4, 5] name的id： 1441647216520 第0个元素的id 140724285511072 第1个元素的id 140724285510496 第2个元素的id 140724285510528 第3个元素的id 140724285510560 第4个元素的id 140724285510592","text_tokens":[":","1","number","创建","tuple","对","引用","方式","不","name","中","数据类型","set","赋值","新","5","则","原子","属于","20","但","如果","包含","}","immutable","还","0","机制","原","指","在","string","字符串","是","object","都","第","修改","enumerate","{","140724285511072","旧","(","140724285510592","会","140724285510752","python","指向","dict","虽然","可不","也","保存","可以","销毁","10","地址","不可","f","每","容器","实际上","4","3","mutable","可不可以","不会","只能","各个","改变","、","140724285510496","140724285510560","[","元素","实际","和","就","num","值","个","。","被","回收","；"," ","（","数据","）","那么","类器","多个","对象","140724285510528","print","=","一样",",","]","：","因此","1441647216520","内存","的","所谓","id","对于","类型","\"","for","一个","140724285510464","没有","i","，","分为","若",")","字符","list","2","in","直接"],"title":"mutable 和 immutable","title_tokens":[" ","mutable","immutable","和"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#immutable","text":"神话：Python以不同的方式分配可变和不可变的值。 因为mutable对象是可变的，immutable对象不可变，人们可能会觉得mutable对象和immutable对象的值分配方式不一样。但事实上，mutable对象和immutable对象所有的赋值的方式都是一样的。 mutable、immutable只是python语言的一个规定。 从硬件角度说，硬件提供给用户的接口是按照规定设定好的。比如说，操作内存的方式是固定的，不存在可变和不可变。实现python的mutable、immutable就是调用了不同的底层API，或者是不同底层API相互组合来实现的。python将这些规定以python语法的形式提供给用户使用，最后还是编译成0、1去让计算机执行。对于用户来说，可变和不可变对象是语言提供的一个特性，可以完成一些功能，但是对于计算机其实是没区别的。 因此，mutable和immutable的本质区别是Python有没有提供修改值的方法。 不管是可变对象还是不可变对象，Python的赋值方式都是一样的，都是将对象绑定到名字（参见上面的图示和示例代码）。","text_tokens":["用户","1","以","规定","硬件","区别","让","比如","方式","不","本质区别","说","特性","赋值","调用","本质","分配","但","固定","事实","可能","immutable","上面","0","功能","变","提供","算机","是","都","修改","设定","组合","绑定","还是","语言","只是","会","不管","最后","到","python","可变","按照","参见","api","可以","这些","但是","不可","比如说","事实上","了","不同","给","mutable","就是","编译成","神话","代码","、","好","将","操作","和","去","来","值","。"," ","（","）","相互","名字","对象","一样","实现","一些","图示","人们","完成","接口","示例","：","因此","所有","译成","觉得","来说","内存","的","语法","编译","存在","底层","使用","对于","因为","方法","没","一个","计算","角度","没有","，","其实","或者","有没有","执行","从","形式","计算机"],"title":"immutable的本质","title_tokens":["本质","的","immutable"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#_2","text":"神话：值是有范围的。 在python中存在作用域这样的概念，人们可能会觉得作用域指的是值（对象）的作用范围，但事实上， 值是没有范围的，作用域指的是名称的作用范围。 我们可以定义一个简单的函数与验证这点。 def check_name_space_range ( x ): print ( \"x的内存地址是：\" + str ( id ( x ))) # 先在最外层的作用域赋值，并打印地址 a = 10 print ( \"a的内存地址是：\" + str ( id ( a ))) check_name_space_range ( a ) a的内存地址是：140724285510752 x的内存地址是：140724285510752 很明显，在内外层作用域的值都是同一个。 陷阱：因为值没有范围，并且赋值不会复制值，这就可能出现可变对象被意外地改变： def variable_change ( x ): x [ 0 ] = 10 return x a = [ 1 , 2 , 3 ] a_other = variable_change ( a ) print ( a ) print ( a_other ) [10, 2, 3] [10, 2, 3] 可以看到， a 、 a_other 都被改变了，因为 a 、 a_other 都是同一个对象。 print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) a的内存地址是：1441620592200 a_other的内存地址是：1441620592200 因此，如果要在函数里面更改可变对象参数的值，最好复制一个副本。 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ] = 10 else : pass return x a = [ 1 , 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [1, 2, 3] [10, 2, 3] a的内存地址是：1441623564040 a_other的内存地址是：1441647218056 a 的值并没有改变，上面的结果看似是没问题的，但还是会有新的”惊喜“。 我们来修改一下 variable_change_shallow 函数 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ][ 0 ] = 10 else : pass return x a = [[ 1 , 2 ], 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [[10, 2], 2, 3] [[10, 2], 2, 3] a的内存地址是：1441667197256 a_other的内存地址是：1441648401544 ”惊喜“就是 a 的值也改变了。因为 x.copy() 只是浅拷贝。 在python里面有三种方式去引用某个值： 引用另一个变量 浅拷贝 深拷贝 这三种方式是有区别的。 import copy a = [ 1 , 2 ,[ 1 , 2 ]] a_reference = a a_shallow = copy . copy ( a ) a_deep_copy = copy . deepcopy ( a ) 变量 a 和 a_reference 都是同一个对象的名称。 浅拷贝得到变量 a_shallow ，它是一个新对象，但 a_shallow 的第三个元素 a_shallow[2] 却是一个已经存在的对象，这和 a 、 a_reference 一样。 深拷贝得到变量 a_deep_copy ，它是一个新对象，并且它的每一个元素也是新的对象。 如果浅拷贝的对象包含了mutable对象，则mutable对象不会拷贝；而深拷贝则会完整拷贝对象。","text_tokens":["1441647218056",":","1441620592200","1","isinstance","深","区别","+","change","里面","拷贝","复制","我们","内存地址","引用","方式","简单","name","一下","而","中","赋值","新","惊喜","则","最","def","问题","三种","但","函数","已经","else","某个","事实","可能","名称","定义","_","出现","如果","包含","这样","1441623564040","作用","pass","第三","外层","上面","却是","0","check","意外","指","并且","在","x","是","a","浅","都","修改","并","同一","先","副本","(","还是","同一个","结果","只是","会","reference","str","第三个","范围","140724285510752","python","deep","可变","打印","陷阱","概念","copy","更改","if","也","1441648401544","可以","10","地址","看到","参数","事实上","了","“","每","要","3","mutable","就是","不会","space","神话","三个","验证","改变","最好","明显","、","[","元素","它","就","和","shallow","去","来","值","。","被","；"," ","（","）","对象","print","range","=","看似","variable","1441667197256","other","一样","完整",",","人们","]","：","因此","这点","作用域","另","觉得","内存","得到","的","return","#",".","deepcopy","存在","id","与","因为","\"","没","import","一个","没有","在内","有","，",")","这","2","地","list","变量","并打印","”","很"],"title":"赋值陷阱——浅拷贝和深拷贝","title_tokens":["赋值","拷贝","—","陷阱","浅","和","深"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#_3","text":"以上所有示例都使用名称作为值的引用，但引用也可以是其他东西。 Python有许多复合数据结构，每个结构都包含对值的引用：列表元素，字典键和值，对象属性等。 其中每一个都可以在赋值符号的左侧使用，以上所有细节都适用于它们。 任何可以出现在赋值语句左侧的内容都是引用 ，在本文中说“名称”的任何地方都可以用“引用”替换。 在上面的示意图中，数字被显示为元素，但实际上，每个元素都是对数字的引用，因此它应该像这样绘制： nums = [ 1 , 2 , 3 ] 但这很快变得复杂，所以上面的绘图用了视觉速记： 如果你有列表元素引用其他可变值，例如子列表，请务必记住列表元素只是对值的引用。 这是一些其他assignment的例子。这些左侧中的每一个都是引用（reference）： my_obj . attr = 23 # 类属性 my_dict [ key ] = 24 # 字典 my_list [ index ] = 25 # 列表 my_obj . attr [ key ][ index ] . attr = \"etc, etc\" # 多个对象嵌套 i = x 指定了名称 i ，但 i[0] = x 并不是指定名称 i ，而是指定了 i 的值的第一个元素。 很多东西都是Assignment。 正如上面所说，许多东西都可以作为引用，python里面有很多东西可以作为assignments。 这些行中的每一行都是名称 X 的赋值： X = ... for X in ... [ ... for X in ... ] ( ... for X in ... ) { ... for X in ... } class X ( ... ): def X ( ... ): def fn ( X ): ... ; fn ( 12 ) with ... as X : except ... as X : import X from ... import X import ... as X from ... import ... as X 注意，我并不是说这些语句像assignments，我的意思是这些语句都是赋值。它们都使名称 X 引用某个值。上面所说的关于赋值的所有内容都适用于所有这些赋值。 在大多数情况下，这些语句将 X 定义在与语句相同的作用域内。Python 2和Python 3之间的细节略有不同。但它们都是真正的赋值，而且每个事实都是关于赋值适用于所有这些。 Python通过赋值来传递函数参数。 让我们来看看这些上面assignment列表中最有趣的一个：调用一个函数。当我定义一个函数时，我将其参数命名为： def my_func ( x , y ): return x + y 这里 x 和 y 是函数 my_func 的参数。当我调用 my_func 时，我提供了实际值作为函数的参数。这些值分配给 参数名称 ，就像使用了赋值语句一样： def my_func ( x , y ): return x + y print ( my_func ( 8 , 9 )) 17 调用 my_func 时，8被赋值给名称 x ，9被赋值给名称 y 。该赋值与我们一直在讨论的简单赋值语句完全相同。名称 x 和 y 是函数的本地名称（local），因此当函数返回时，这些名称就会消失。但是，如果它们引用的值仍然被其他名称引用，则值仍然存在。 就像所有其他赋值一样，可变值可以传递给函数，并且通过其所有名称可以看到对值的更改。这在<浅拷贝和深拷贝>中已经提到。","text_tokens":[":","第一个","1","意图","每个","绘图","视觉",">","时","第一","9","符号","assignments","示意","index","深","+","里面","拷贝","让","于","返回","对","相同","我们","我","引用","应该","简单","说","属性","中","assignment","之间","命名","赋值","调用","适用","分配","则","示意图","最","def","17","fn","正如","with","多数","已经","但","函数","某个","_","名称","定义","事实","如果","出现","包含","}","等","这样","作用","注意","上面","中说","其他","0","复合","提供","作为","my","一直","在","并且","使","记住","键和值","例子","x","左侧","是","看看","浅","指定","都","其中","并","变得","{","y","(","绘制","只是","会","reference","当","提到","python","务必","可变","复杂","dict","as","你","更改","数字","语句","23","except","该","也","obj","可以","这些","但是","看到","一行","etc","参数","from","nums","传递函数","完全相同","每","“","了","行中","不同","实际上","请","任何","3","这里","变得复杂","给","消失","显示","关于","子","讨论","通过","传递","很多","func","地方","真正","许多","24","将","[","用","<","元素","实际","它","东西","和","就","所说","来","值","12","本地","仍然","内","。","被",";","结构","本文","class","这是"," ","key","数据","（","）","以上","而且","它们","对象","多个","print","对值","...","attr","略有","=","情况","一样","一些","列表",",","而是","示例","]","例如","：","因此","所有","内容","作用域","很快","替换","嵌套","的","所以","25","大多","其","#",".","return","存在","使用","速记","与","import","\"","细节","for","一个","i","有","有趣","，","数据结构","意思","像","大多数","local",")","字典","这","8","2","list","下","完全","为","”","类","in","不是","略有不同"],"title":"赋值陷阱——引用不仅仅限于名称","title_tokens":["赋值","—","限于","名称","陷阱","引用","不仅","仅仅","不仅仅"]},{"location":"Python基础/2.8.赋值、immutable、深拷贝.html#_4","text":"任何名称都可以随时引用任何值。 Python是动态类型的，这意味着名称没有类型。任何名称都可以随时引用任何值。名称可以引用整数，然后引用字符串，然后引用函数，然后引用模块。当然，这可能是一个非常混乱的程序，你不应该这样做，但Python语言不会介意。 名称没有类型，值没有范围。 正如名称没有类型一样，值也没有范围。当我们说一个函数有一个局部变量时，我们的意思是该名称的作用域是函数：你不能在函数外部使用该名称，当函数返回时，名称将被销毁。但是正如我们所看到的，如果名称的值具有其他引用，它将继续在函数调用之外。它是本地名称，而不是本地值。 值不能删除，只有名称可以删除。 Python的内存管理对其行为至关重要，你不仅不必删除值，而且无法删除值。 nums = [ 1 , 2 , 3 ] del nums 这不会删除值 nums ，它会删除名称 nums 。该名称将从其范围中删除，然后通常的引用计数开始执行：如果 nums 的值只有一个引用，则将回收该值。但如果它有其他引用，那么它不会被回收。 神话：Python没有变量。 有些人喜欢说，“Python没有变量，它有名字。”这个口号具有误导性。事实是Python有变量，它们的工作方式与C中的变量不同。 名称是Python的变量：它们引用值，并且这些值可以在程序的过程中发生变化（变化）。仅仅因为另一种语言（尽管是一种重要的语言）表现不同，没有理由将Python描述为没有变量。","text_tokens":["1","时","喜欢","尽管","返回","然后","对","我们","引用","方式","不","应该","表现","而","说","该值","中","调用","整数","意味着","则","这个","正如","它会","函数","但","不仅","事实","名称","可能","继续","如果","这样","行为","作用","通常","其他","模块","当然","并且","在","之外","字符串","是","一种","理由","都","误导","管理","至关","变化","语言","仅仅","当","不必","范围","python","有些","你","人","该","也","局部","可以","误导性","这些","销毁","但是","看到","nums","删除","做","“","动态","局部变量","不同","任何","所","3","函数调用","计数","不会","神话","生变","将","[","它","程序","介意","值","本地","无法","。","被","回收","发生变化"," ","意味","（","而且","）","那么","名字","开始","它们","发生","c","=","一样",",","只有","随时","外部","具有","]","：","过程","口号","作用域","另","内存","至关重要","的","其","非常","混乱","重要","使用","与","因为","类型","工作","一个","没有","有","，","del","意思","执行","这","字符","2","描述","变量","不能","从","为","”","不是"],"title":"名称和值的一些细节","title_tokens":["值","的","名称","细节","和","一些"]},{"location":"Python基础/2.9.函数.html","text":"函数 关键字 def 引入了一个函数定义。后面必须跟上函数名和在圆括号里的参数序列。函数体从第一行开始，并且一定要缩进。 def func (): pass 函式体的第一个语句可以是字串。这个字串就是函式的文档字符串，或称为 docstring。有很多能将文档字串自动转换为在线或可打印文档的工具，或让用户在代码中交互地浏览它的工具。 执行函数会引入局部命名空间。所有在函数中被赋值的变量和值都将存储在局部命名空间中。 变量引用会首先在函数的局部命名空间里寻找，然后才是闭包函数的局部命名空间，再然后是全局命名空间，最后是内置命名空间。在函数中可以引用全局变量，但是不可直接赋值 (除非用 global 语句进行声明)。 具体细节参考 命名空间和作用域。 根据其它语言的经验，你可能会指出 fib 不是一个函数，而是一个程序，因为它不返回值。事实上，即使没有写 return 语句的函数也会返回一个值—— None 。如果要唯一输出的值是 None，那么解释器会正当的抑制这次返回。如你实在想看看这个值，可以使用 print() 函数。 return 语句从函式中返回一个值。没有表达式参数的 return 语句返回 None。直到函式结束也没有 return 语句也返回 。 函数传参 刚学Python的人可能会疑惑，Python函数传参，到底是传值，还是传引用？ 答案很直接，Python函数传参永远都是传引用。 实际上，Python函数传参就是赋值，所以传参的行为和赋值的行为是一样的。在对可变对象的参数进行操作前，最好先深拷贝参数的值，否则可能会影响全局变量。 参数 函数有四种参数概念：位置参数、默认参数、关键字参数、可变参数。 函数有三种合法调用形式： 仅给出强制参数 给出所有强制参数和部分可选参数 给出所有参数 位置参数 调用函数时可以省略形参名字，根据函数定义的参数位置来传递参数。传入的参数顺序必须和定义参数的顺序一致，且少一个参数都不可以。 def print_hello ( name , sex ): sex_dict = { 1 : u '先生' , 2 : u '女士' } print ( 'hello %s %s , welcome to python world!' % ( name , sex_dict . get ( sex , u '先生' ))) print_hello ( 'Jack' , 1 ) hello Jack 先生, welcome to python world! 关键字参数 函数调用时，可以通过“键=值”形式指定。这可以让函数更加清晰、容易使用，同时关键字参数不需要按顺序指定。 # 以下是用关键字参数正确调用函数的实例 print_hello ( 'tanggu' , sex = 1 ) print_hello ( name = 'tanggu' , sex = 1 ) print_hello ( sex = 1 , name = 'tanggu' ) hello tanggu 先生, welcome to python world! hello tanggu 先生, welcome to python world! hello tanggu 先生, welcome to python world! # 以下是错误的调用方式 print_hello ( 1 , name = 'tanggu' ) print_hello ( name = 'tanggu' , 1 ) print_hello ( sex = 1 , 'tanggu' ) 通过上面的代码可以发现： 有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序的 。 默认参数 用于定义函数，为参数提供默认值，调用函数时可传可不传该默认参数的值。 注意：所有位置参数必须出现在默认参数前，包括函数定义和调用。 # 正确的默认参数定义方式--> 位置参数在前，默认参数在后 def print_hello ( name , sex = 1 ): .... # 错误的定义方式 def print_hello ( sex = 1 , name ): .... # 调用时不传sex的值，则使用默认值1 # print_hello('tanggu') # 调用时传入sex的值，并指定为2 # print_hello('tanggu', 2) 可变参数 定义函数时，有时候我们不确定调用的时候会传递多少个参数（不传参也可以）。此时，可用包裹（packing）位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。 包裹位置传递 def func ( * args ): .... ↓ # func() # func(a) # func(a, b, c) 我们传进的所有参数都会被 args 变量收集，它会根据传进参数的位置合并为一个元组(tuple)， args 是元组类型，这就是包裹位置传递。 包裹关键字传递 def func ( ** kargs ): .... ↓ # func(a=1) # func(a=1, b=2, c=3) kargs是一个字典(dict)，收集所有关键字参数 解包裹参数 * 和 ** ，也可以在函数调用的时候使用，称之为解包裹(unpacking) 在传递元组时，让元组的每一个元素对应一个位置参数 def print_hello ( name , sex ): print name , sex # args = ('tanggu', '男') # print_hello(*args) # tanggu 男 在传递字典时，让字典的每个键值对作为一个关键字参数传递给函数 def print_hello ( kargs ): print kargs # kargs = {'name': 'tanggu', 'sex', u'男'} # print_hello(**kargs) # {'name': 'tanggu', 'sex', u'男'} 位置参数、默认参数、可变参数的混合使用 顺序是：位置参数、默认参数、包裹位置、包裹关键字，定义和调用都应遵循这个顺序。 def func ( name , age , sex = 1 , * args , ** kargs ): print name , age , sex , args , kargs # func('tanggu', 25, 2, 'music', 'sport', class=2) # tanggu 25 1 ('music', 'sport') {'class'=2}","text_tokens":["用户","1","正确","抑制",">","时","tuple","拷贝","同时","函式体","对","疑惑","关键字","name","写","实例","函数","寻找","发现","确定","出现","释器","作用","pass","选","后面","全局变量","参","作为","在","前","—","a","指定","实在","unpacking","男","none","表达","可不","你","也","可以","其它","能","默认","事实上","每","合法","↓","序列","实际上","b","声明","给","函数调用","通过","传递","代码","、","用","包裹","它","程序","闭包","函式"," ","后","开始","对象","称之为","c","显得","更加","到底","体从","所有","直到","不传","25","#","使用","括号","细节","一个","fib","没有","此时","？","字典","从","形式","传值","一致",":","第一","且","元组","结束","让","混合","表达式","想","达式","这个","def","三种","_","get","传","注意","上面","缩进","....","给出","传进","前面","引入","sport","music","按","女士","可用","%","可","python","打印","概念","dict","刚学","但是","参数","内置","存储","文档","sex","才","3","具体","就是","很多","将","元素","操作","否则","来","被","需要","class","传参","解释","to","print","时不传","=","清晰",",","以下","转换","方便","return","所以","非常","类型","进行","执行","地","输出","先生","直接","第一个","部分","关键","多少","传该","返回","然后","我们","位置","args","引用","中","命名","之间","赋值","则","除非","事实","如果","跟上","字串","并且","影响","即使","字符串","时可传","并","{","先后顺序","参考","语言","会","永远都是","自动","welcome","最后","指出","先后","hello","人","语句","遵循","交互","强制","工具","一行","第一行","了","“","容易","默认值","*","func","world","答案","最好","age","个","传入","-","那么","名字","tanggu","解","kargs","时候",".","之为","存在","必须","错误","因为","称为","，","调用函数","参数传递",")","这","2","u","很","每个","用于","形参","jack","s","键","对应","方式","不","可传","调用","它会","根据","但","经验","定义","可能","!","}","行为","名","有时候","提供","'","是","看看","四种","都","数传","global","(","键值","还是","如","少","应","再","可变","局部","操作前","不可","首先","唯一","要","收集","永远","正当","省略","返回值","仅","packing","一定","解释器","实际","空间","和","包括","值","。","（","里","）","顺序","浏览","或","一样","有时","在线","而是","：","作用域","docstring","的","圆括号","有","合并","或者","先深","字符","这次","变量","为","”","全局","不是"],"title":"2.9.函数","title_tokens":[".","2.9","函数"]},{"location":"Python基础/2.9.函数.html#_1","text":"关键字 def 引入了一个函数定义。后面必须跟上函数名和在圆括号里的参数序列。函数体从第一行开始，并且一定要缩进。 def func (): pass 函式体的第一个语句可以是字串。这个字串就是函式的文档字符串，或称为 docstring。有很多能将文档字串自动转换为在线或可打印文档的工具，或让用户在代码中交互地浏览它的工具。 执行函数会引入局部命名空间。所有在函数中被赋值的变量和值都将存储在局部命名空间中。 变量引用会首先在函数的局部命名空间里寻找，然后才是闭包函数的局部命名空间，再然后是全局命名空间，最后是内置命名空间。在函数中可以引用全局变量，但是不可直接赋值 (除非用 global 语句进行声明)。 具体细节参考 命名空间和作用域。 根据其它语言的经验，你可能会指出 fib 不是一个函数，而是一个程序，因为它不返回值。事实上，即使没有写 return 语句的函数也会返回一个值—— None 。如果要唯一输出的值是 None，那么解释器会正当的抑制这次返回。如你实在想看看这个值，可以使用 print() 函数。 return 语句从函式中返回一个值。没有表达式参数的 return 语句返回 None。直到函式结束也没有 return 语句也返回 。","text_tokens":[":","第一个","用户","关键","抑制","第一","结束","让","函式体","然后","返回","表达式","想","引用","不","关键字","达式","中","命名","写","赋值","除非","这个","def","根据","函数","寻找","经验","事实","定义","可能","如果","释器","作用","pass","名","缩进","后面","跟上","全局变量","字串","并且","在","即使","—","字符串","是","看看","都","引入","实在","none","global","(","参考","如","语言","会","自动","再","最后","表达","可","不是","打印","指出","你","语句","也","局部","可以","交互","其它","工具","能","一行","但是","参数","第一行","不可","内置","首先","唯一","了","存储","事实上","序列","要","文档","声明","才","具体","就是","正当","很多","func","返回值","代码","一定","输出","解释器","将","用","它","空间","和","程序","闭包","值","。","被","函式"," ","里","那么","解释","开始","浏览","print","或","在线","而是","体从","所有","转换","作用域","docstring","的","return","直到","圆括号","必须","使用","因为","括号","细节","一个","fib","没有","有","称为","，","进行",")","执行","字符","地","变量","这次","从","为","全局","直接"],"title":"函数","title_tokens":["函数"]},{"location":"Python基础/2.9.函数.html#_2","text":"刚学Python的人可能会疑惑，Python函数传参，到底是传值，还是传引用？ 答案很直接，Python函数传参永远都是传引用。 实际上，Python函数传参就是赋值，所以传参的行为和赋值的行为是一样的。在对可变对象的参数进行操作前，最好先深拷贝参数的值，否则可能会影响全局变量。","text_tokens":["操作前","刚学","对象","参数","全局变量","一样","在","影响","实际上","很","拷贝","是","到底","对","疑惑","就是","引用","永远","答案","最好","赋值","的","人","所以","还是","实际","会","和","操作","永远都是","否则","函数","值","，","可能","python","进行","先深","？","。","可变","行为","变量","传"," ","传参","全局","直接","传值"],"title":"函数传参","title_tokens":["传参","函数"]},{"location":"Python基础/2.9.函数.html#_3","text":"函数有四种参数概念：位置参数、默认参数、关键字参数、可变参数。 函数有三种合法调用形式： 仅给出强制参数 给出所有强制参数和部分可选参数 给出所有参数","text_tokens":["强制","关键","部分","参数","给出","默认","合法","：","四种","所有","位置","关键字","调用","仅","、","和","三种","函数","有","可","可变","。","概念","形式"," ","选"],"title":"参数","title_tokens":["参数"]},{"location":"Python基础/2.9.函数.html#_4","text":"调用函数时可以省略形参名字，根据函数定义的参数位置来传递参数。传入的参数顺序必须和定义参数的顺序一致，且少一个参数都不可以。 def print_hello ( name , sex ): sex_dict = { 1 : u '先生' , 2 : u '女士' } print ( 'hello %s %s , welcome to python world!' % ( name , sex_dict . get ( sex , u '先生' ))) print_hello ( 'Jack' , 1 ) hello Jack 先生, welcome to python world!","text_tokens":["一致",":","可以","名字","1","顺序","to","print","参数","形参","时","且","=","jack","'",",","s","sex","位置","都","不","传递","name","{","hello","world","省略","调用","的","(",".","必须","少","def","女士","和","根据","函数","一个","来","%","，","调用函数","定义","_","welcome","python","。",")","}","!","get","dict","2","传入"," ","u","先生"],"title":"位置参数","title_tokens":["位置","参数"]},{"location":"Python基础/2.9.函数.html#_5","text":"函数调用时，可以通过“键=值”形式指定。这可以让函数更加清晰、容易使用，同时关键字参数不需要按顺序指定。 # 以下是用关键字参数正确调用函数的实例 print_hello ( 'tanggu' , sex = 1 ) print_hello ( name = 'tanggu' , sex = 1 ) print_hello ( sex = 1 , name = 'tanggu' ) hello tanggu 先生, welcome to python world! hello tanggu 先生, welcome to python world! hello tanggu 先生, welcome to python world! # 以下是错误的调用方式 print_hello ( 1 , name = 'tanggu' ) print_hello ( name = 'tanggu' , 1 ) print_hello ( sex = 1 , 'tanggu' ) 通过上面的代码可以发现： 有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序的 。","text_tokens":["可以","tanggu","1","顺序","正确","关键","to","print","参数","时","=","清晰","“","在","'",",","更加","容易","让","同时","sex","键","是","：","以下","指定","函数调用","位置","前面","方式","通过","不","关键字","name","world","hello","上面","之间","实例","调用","的","(","代码","#","先后顺序","、","存在","使用","按","用","错误","必须","函数","但","发现","有","值","welcome","，","调用函数","_","python","!","。",")","这","需要","先后","形式"," ","”","先生"],"title":"关键字参数","title_tokens":["关键","关键字","参数"]},{"location":"Python基础/2.9.函数.html#_6","text":"用于定义函数，为参数提供默认值，调用函数时可传可不传该默认参数的值。 注意：所有位置参数必须出现在默认参数前，包括函数定义和调用。 # 正确的默认参数定义方式--> 位置参数在前，默认参数在后 def print_hello ( name , sex = 1 ): .... # 错误的定义方式 def print_hello ( sex = 1 , name ): .... # 调用时不传sex的值，则使用默认值1 # print_hello('tanggu') # 调用时传入sex的值，并指定为2 # print_hello('tanggu', 2)","text_tokens":["后",":","1","tanggu","正确","....","print","参数","用于",">","时","默认","时不传","提供","=","在","'",",","前","传该","时可传","sex","：","默认值","所有","指定","位置","方式","并","name","可传","hello","调用","的","(","#","则","必须","错误","def","使用","和","为","函数","包括","值","，","定义","调用函数","_","出现","。",")","可不","2","传入","注意"," ","-"],"title":"默认参数","title_tokens":["默认","参数"]},{"location":"Python基础/2.9.函数.html#_7","text":"定义函数时，有时候我们不确定调用的时候会传递多少个参数（不传参也可以）。此时，可用包裹（packing）位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。","text_tokens":["也","可以","关键","参数","参","多少","时","有时候","显得","有时","我们","位置","不","传递","时候","关键字","数传","方便","packing","调用","的","不传","非常","包裹","会","函数","可用","来","，","定义","个","确定","此时","或者","。","进行","参数传递","（","）"],"title":"可变参数","title_tokens":["可变","参数"]},{"location":"Python基础/2.9.函数.html#_8","text":"def func ( * args ): .... ↓ # func() # func(a) # func(a, b, c) 我们传进的所有参数都会被 args 变量收集，它会根据传进参数的位置合并为一个元组(tuple)， args 是元组类型，这就是包裹位置传递。","text_tokens":[":","....","参数","c","↓","元组",",","b","收集","tuple","是","a","我们","传进","所有","args","都","位置","就是","传递","*","func","的","(","#","def","包裹","会","它会","为","类型","根据","一个","合并","，","。",")","被","这","变量"," "],"title":"包裹位置传递","title_tokens":["传递","包裹","位置"]},{"location":"Python基础/2.9.函数.html#_9","text":"def func ( ** kargs ): .... ↓ # func(a=1) # func(a=1, b=2, c=3) kargs是一个字典(dict)，收集所有关键字参数","text_tokens":[":","1","关键","....","参数","c","=","↓",",","b","收集","是","3","a","kargs","所有","关键字","*","func","(","#","def","一个","，",")","字典","2","dict"," "],"title":"包裹关键字传递","title_tokens":["关键","传递","关键字","包裹"]},{"location":"Python基础/2.9.函数.html#_10","text":"* 和 ** ，也可以在函数调用的时候使用，称之为解包裹(unpacking) 在传递元组时，让元组的每一个元素对应一个位置参数 def print_hello ( name , sex ): print name , sex # args = ('tanggu', '男') # print_hello(*args) # tanggu 男 在传递字典时，让字典的每个键值对作为一个关键字参数传递给函数 def print_hello ( kargs ): print kargs # kargs = {'name': 'tanggu', 'sex', u'男'} # print_hello(**kargs) # {'name': 'tanggu', 'sex', u'男'}","text_tokens":["也",":","可以","tanggu","解","关键","称之为","print","参数","每个","时","=","作为","每","元组","在","'",",","让","sex","对应","对","给","kargs","函数调用","位置","args","unpacking","男","时候","传递","*","name","关键字","hello","数传","{","调用","的","(","#","键值","之为","使用","def","元素","包裹","和","函数","一个","，","_","参数传递",")","字典","}"," ","u"],"title":"解包裹参数","title_tokens":["解","包裹","参数"]},{"location":"Python基础/2.9.函数.html#_11","text":"顺序是：位置参数、默认参数、包裹位置、包裹关键字，定义和调用都应遵循这个顺序。 def func ( name , age , sex = 1 , * args , ** kargs ): print name , age , sex , args , kargs # func('tanggu', 25, 2, 'music', 'sport', class=2) # tanggu 25 1 ('music', 'sport') {'class'=2}","text_tokens":[":","1","tanggu","顺序","关键","print","参数","默认","=","'",",","sex","：","是","kargs","位置","都","args","关键字","name","*","func","{","调用","25","sport","(","#","、","music","这个","def","包裹","应","和","age","，","定义","。",")","}","2","class"," ","遵循"],"title":"位置参数、默认参数、可变参数的混合使用","title_tokens":["的","混合","、","可变","参数","使用","默认","位置"]},{"location":"Python基础/3.1.异常.html","text":"异常处理机制 异常处理无外乎几件事: 断言（assert） 抛错（raise） 检查（try） 捕获（except） 处理（except, else, finally） 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。当Python脚本发生异常时，异常会从发生异常的位置向程序上层传播。例如异常从函数向外传播到调用函数的地方，如果在这里没有被捕获，则继续向上传播，如果一直都没有被捕获，则传播到程序的最顶层，即主程序（全局作用域）。如果在主程序中也没有处理异常的程序，python将调用默认的异常处理程序，自动匹配异常的类型，然后中止程序并显示栈跟踪信息。 # 在cause_error函数中抛出异常 def cause_error (): raise Exception ( \"Somrthing is wrong\" ) # 在call_cause_error函数中调用cause_error函数 def call_cause_error (): cause_error () def deal_error (): try : cause_error () except : print ( \"Exception handled\" ) call_cause_error () ---------------------------------------------------------------------------Exception Traceback (most recent call last)<ipython-input-1-eb81f11bf5d9> in <module> ----> 1 call_cause_error() <ipython-input-1-ec5e029839e0> in call_cause_error() 1 def call_cause_error(): ----> 2 cause_error() 3 <ipython-input-1-11326a099618> in cause_error() 1 def cause_error(): ----> 2 raise Exception(\"Somrthing is wrong\") 3 Exception: Somrthing is wrong deal_error () Exception handled 如你所见，cause_error中引发的异常依次从cause_error和call_cause_error向外传播，最终导致显示一条栈跟踪信息。调用deal_error时，异常在传播到deal_error时被捕获，并被这里的try/except语句处理。 异常是Python对象，表示一个错误。异常可以作为类被定义, 也可以人为引发异常。 异常处理语句 try : < statement > #' try语句中代码首先被运行 except ： < statement > #' 捕获任何在try中引发的异常 except < name > ： < statement > #' 捕获在try中引发的<name>异常 except < name > ， < data > : < statement > #' 如果引发了'name'异常，获得附加的数据 except ( < name1 > , < name2 >... ): < statement > #' 捕获列出的多个异常 else : < statement > #' 如果没有异常发生 finally : < statement > #' 退出try时总会执行 raise #' 人为引发错误 assert < judgement > #' 断言,判断一定要返回True否则会引发AssertionError raise语句 使用raise...from...语句来提供自己的异常上下文，也可以使用None来禁止上下文。 # 默认输出异常上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 1 try: ----> 2 1/0 3 except ZeroDivisionError: ZeroDivisionError: division by zero During handling of the above exception, another exception occurred: ValueError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError 5 ValueError: # 自定义上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from ZeroDivisionError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)ZeroDivisionError: The above exception was the direct cause of the following exception: ValueError Traceback (most recent call last)<ipython-input-1-00ed5b67ecd8> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from ZeroDivisionError 5 ValueError: # 禁止上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from None ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-d9388897f61c> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from None ValueError: 内置异常 异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告 参考 Python异常处理 python在异常捕获里抛出异常 异常处理","text_tokens":["用户","1","上下","最大",">","时","long","index","eof","importerror","futurewarning","对","人为","输入","name","属性","自定","5","零","函数","已经","继续","释器","迭代","通常","作用","keyerror","arithmeticerror","0","机制","zerodivisionerror","上下文","weak","tab","作为","最终","模块","索引","在","附加","above","ioerror","by","userwarning","name2","none","true","一般","栈","提升","即","当","exception","内建","你","is","也","可以","多","handled","默认","序列","限制","上层","试图","4","声明","这里","浮点","禁止","操作系统","valueerror","division","代码","input","the","<","用","初始","主程序","导致","就","indentationerror","程序","相关","本地","无法","生成","此"," ","判断","混用","对象","try","多个","语义","c","抛出","实现","windowserror","所有","过程","nameerror","notimplementederror","runtimeerror","#","使用","\"","方法","一个","异常","没有","unicodeerror","标记","00ed5b67ecd8","following","从","occurred",":","indexerror","direct","查询","another","被弃","somrthing","空格","解码","将会","这个","def","_","finally","总会","traceback","11326a099618","handling","of","缩进","一条","顶层","typeerror","assertionerror","抛错","捕获","警告","旧","/","访问","reference","到","python","基类","during","参数","无外乎","from","内置","systemexit","deal","任何","溢出","error","3","显示","module","地方","ec5e029839e0","中止","将","操作","否则","来","内","被","解释","发生","print","...","generatorexit","生成器",",","转换","代码生成","d9388897f61c","behavior","内存","语法","类型","runtime","正常","cause","eoferror","尚未","可疑","执行","计算错误","垃圾","类","in","输出","call","废弃","失败","oserror","generator","返回","然后","位置","引用","baseexception","unicode","中","则","除","lookuperror","referenceerror","else","系统","如果","几件","unicodetranslateerror","stopiteration","statement","name1","一直","影响","most","算错","传播","标准","并","未","常规","无效","参考","会","处理","自动","更","语句","该","except","取模","处理程序","eb81f11bf5d9","syntaxerror","程序执行","last","了","整型","获得","到达","自定义","关于","改变","脚本","floatingpointerror","standarderror","中断","syntaxwarning","systemerror","传入","-","attributeerror","引发","通知","几件事","向外","recent","情况","例如","检查","overflowerror","错误","对于","overflowwarning","unicodeencodeerror","assert","，","调用函数",")","2","下","向","断言","自己","未声明","退出","zero","信息","器","data","键","56b5a2b441f0","请求","特性","数据类型","调用","最","定义","名称","特征","成器","行为","raise","构造","语法错误","提供","将来","致命","'","事件","unboundlocalerror","是","都","(","如","pendingdeprecationwarning","taberror","environmenterror","建","导入","wrong","初始化","依次","向上","首先","超出","要","为长","runtimewarning","judgement","^","数值","列出","一定","解释器","和","表示","was","下文","warning","值","keyboardinterrupt","ipython","。","运算","回收","（","数据","映射","）","编码","里","memoryerror","或","弱","：","作用域","的","匹配","所见","运行","deprecationwarning","计算","有","跟踪","描述","变量","unicodedecodeerror","全局","不是"],"title":"3.1.异常","title_tokens":[".","3.1","异常"]},{"location":"Python基础/3.1.异常.html#_1","text":"异常处理无外乎几件事: 断言（assert） 抛错（raise） 检查（try） 捕获（except） 处理（except, else, finally） 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。当Python脚本发生异常时，异常会从发生异常的位置向程序上层传播。例如异常从函数向外传播到调用函数的地方，如果在这里没有被捕获，则继续向上传播，如果一直都没有被捕获，则传播到程序的最顶层，即主程序（全局作用域）。如果在主程序中也没有处理异常的程序，python将调用默认的异常处理程序，自动匹配异常的类型，然后中止程序并显示栈跟踪信息。 # 在cause_error函数中抛出异常 def cause_error (): raise Exception ( \"Somrthing is wrong\" ) # 在call_cause_error函数中调用cause_error函数 def call_cause_error (): cause_error () def deal_error (): try : cause_error () except : print ( \"Exception handled\" ) call_cause_error () ---------------------------------------------------------------------------Exception Traceback (most recent call last)<ipython-input-1-eb81f11bf5d9> in <module> ----> 1 call_cause_error() <ipython-input-1-ec5e029839e0> in call_cause_error() 1 def call_cause_error(): ----> 2 cause_error() 3 <ipython-input-1-11326a099618> in cause_error() 1 def cause_error(): ----> 2 raise Exception(\"Somrthing is wrong\") 3 Exception: Somrthing is wrong deal_error () Exception handled 如你所见，cause_error中引发的异常依次从cause_error和call_cause_error向外传播，最终导致显示一条栈跟踪信息。调用deal_error时，异常在传播到deal_error时被捕获，并被这里的try/except语句处理。 异常是Python对象，表示一个错误。异常可以作为类被定义, 也可以人为引发异常。","text_tokens":["call",":","1",">","时","信息","然后","人为","位置","somrthing","中","调用","则","最","def","函数","else","_","finally","定义","继续","如果","traceback","几件","作用","11326a099618","raise","一条","顶层","作为","最终","一直","在","影响","事件","most","传播","是","都","并","抛错","捕获","类","(","一般","如","栈","/","会","处理","即","自动","当","exception","到","python","你","is","wrong","语句","该","except","也","处理程序","eb81f11bf5d9","可以","依次","无外乎","向上","handled","默认","程序执行","last","了","上层","deal","这里","error","3","显示","module","地方","ec5e029839e0","脚本","input","中止","将","<","主程序","导致","就","和","表示","程序","无法","ipython","。","被"," ","-","（","）","引发","几件事","发生","try","对象","print","向外","recent","情况","抛出",",","例如","检查","过程","作用域","的","匹配","所见","#","错误","类型","\"","一个","异常","没有","assert","正常","，","调用函数","cause","跟踪","执行",")","2","下","向","从","断言","全局","in"],"title":"异常处理机制","title_tokens":["处理","异常","机制"]},{"location":"Python基础/3.1.异常.html#_2","text":"try : < statement > #' try语句中代码首先被运行 except ： < statement > #' 捕获任何在try中引发的异常 except < name > ： < statement > #' 捕获在try中引发的<name>异常 except < name > ， < data > : < statement > #' 如果引发了'name'异常，获得附加的数据 except ( < name1 > , < name2 >... ): < statement > #' 捕获列出的多个异常 else : < statement > #' 如果没有异常发生 finally : < statement > #' 退出try时总会执行 raise #' 人为引发错误 assert < judgement > #' 断言,判断一定要返回True否则会引发AssertionError","text_tokens":["引发",":","断言","statement","发生","try","多个","...",">","首先","退出","时","了","在","'",",","要","任何","返回","data","：","获得","附加","人为","judgement","assertionerror","name","name2","列出","中","捕获","的","代码","运行","#","(","一定","true","<","错误","name1","会","否则","异常","没有","else","assert","，","finally","如果","总会","被",")","执行","判断","raise"," ","语句","数据","except"],"title":"异常处理语句","title_tokens":["处理","语句","异常"]},{"location":"Python基础/3.1.异常.html#raise","text":"使用raise...from...语句来提供自己的异常上下文，也可以使用None来禁止上下文。 # 默认输出异常上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 1 try: ----> 2 1/0 3 except ZeroDivisionError: ZeroDivisionError: division by zero During handling of the above exception, another exception occurred: ValueError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError 5 ValueError: # 自定义上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from ZeroDivisionError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)ZeroDivisionError: The above exception was the direct cause of the following exception: ValueError Traceback (most recent call last)<ipython-input-1-00ed5b67ecd8> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from ZeroDivisionError 5 ValueError: # 禁止上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from None ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-d9388897f61c> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from None ValueError:","text_tokens":["也","call",":","可以","1","上下","0","try","zerodivisionerror","...","from","-","上下文","默认","recent","提供",">","last","of","zero","except","most",",","direct","another","4","3","above","自定义","by","module","56b5a2b441f0","禁止","d9388897f61c","valueerror","自定","的","none","division","(","#","input","the","5","使用","<","/","was","下文","异常","来","cause","，","exception","handling","occurred","ipython","定义","。","traceback",")","2","00ed5b67ecd8","following","raise"," ","语句","in","输出","自己","during"],"title":"raise语句","title_tokens":["语句","raise"]},{"location":"Python基础/3.1.异常.html#_3","text":"异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告","text_tokens":["用户","最大","未声明","退出","indexerror","时","long","废弃","失败","oserror","index","generator","查询","eof","器","importerror","futurewarning","键","被弃","对","引用","输入","请求","baseexception","unicode","属性","中","数据类型","空格","特性","调用","解码","将会","这个","零","除","已经","lookuperror","referenceerror","系统","名称","特征","释器","迭代","成器","unicodetranslateerror","行为","通常","stopiteration","keyerror","构造","arithmeticerror","缩进","语法错误","zerodivisionerror","weak","tab","将来","模块","索引","致命","算错","unboundlocalerror","typeerror","是","ioerror","标准","userwarning","未","常规","assertionerror","警告","旧","(","无效","一般","提升","/","访问","会","pendingdeprecationwarning","taberror","environmenterror","自动","reference","exception","建","python","导入","不是","内建","基类","更","语句","初始化","取模","多","参数","syntaxerror","systemexit","了","超出","整型","序列","限制","试图","为长","runtimewarning","溢出","声明","到达","浮点","关于","^","数值","操作系统","valueerror","改变","代码","解释器","用","floatingpointerror","操作","初始","indentationerror","和","相关","warning","来","值","standarderror","keyboardinterrupt","中断","本地","syntaxwarning","内","被","运算","生成","systemerror","回收","此","传入"," ","数据","映射","attributeerror","编码","解释","memoryerror","混用","通知","发生","对象","语义","或","c","generatorexit","实现","生成器",",","windowserror","弱","所有","转换","nameerror","代码生成","behavior","内存","notimplementederror","runtimeerror","的","语法","运行","overflowerror","错误","对于","类型","方法","runtime","deprecationwarning","overflowwarning","计算","异常","没有","unicodeencodeerror","有","eoferror","尚未","可疑","计算错误","执行",")","垃圾","unicodeerror","描述","标记","变量","unicodedecodeerror","断言","输出"],"title":"内置异常","title_tokens":["内置","异常"]},{"location":"Python基础/3.1.异常.html#_4","text":"Python异常处理 python在异常捕获里抛出异常 异常处理","text_tokens":["捕获","python","抛出"," ","在","异常","里","处理"],"title":"参考","title_tokens":["参考"]},{"location":"Python基础/3.2.命名空间和作用域.html","text":"命名空间 Namespace : namespace 是一个从 name 到 object 的映射。现在大部分的 namespace 通过Python字典 1 实现，将来可能会改变实现方式。 namespace：中文称为命名空间，或者名字空间。 命名空间的最重要的作用是避免名字冲突，各个命名空间是独立的，因此不同的命名空间可以重名。 Namespace 的种类 一般而言，name 产生地点决定其所处的 namespace。例如，在函数内定义的 name 会位于（函数的）局部命名空间。但使用了 global 、 nonlocal 语句会改变这种情况，这个在后面会说到。 built-in namespace ：builtins 模块定义的所有名字存在内置命名空间，这些名字包括内置函数、内置异常、内置常量、内置类型。如果是Python 2，则是 __builtin__ 模块。 global namespace ：每个模块都有全局命名空间，包括所有在模块最外层的作用域中定义的名字，例如类、函数、常量、被导入的模块。 local namespace ：相对于全局命名空间，每一个局部作用域都有一个局部命名空间。例如，函数或类所定义的命名空间，记录了函数参数、函数内的变量、类属性、类方法等。 enclosing namespace ：闭包命名空间不仅记录了当前嵌套函数内定义的变量，还记录了嵌套函数引用的外部变量。 Namespace生命周期 不同类型的命名空间有不同的生命周期： built-in：在 Python 解释器启动时创建，解释器退出时销毁 global：在模块定义被解释器读入时创建，通常也会一直保存到解释器退出，除非使用 del 语句。 local：这里要区分 function 以及 class 定义： 函数的局部命名空间：在函数调用时创建，函数返回或者产生未被捕获的异常时销毁 - 类定义的局部命名空间：在解释器读到类定义创建，离开类定义时创建class object。这个类对象实际上就是这个局部命名空间的包装（见官方对类定义的 说明 ）。 查看Namespace 局部命名空间可以通过 locals() 来访问 全局 （模块级别）命名空间可以通过 globals() 来访问 虽然都是返回命名空间，但 globals() 和 locals() 有一点不一样。 locals() 返回的是局部命名空间的副本，所以修改 locals() 对象并不会影响局部名字空间。 globals 返回是全局命名空间，而不是副本，所以修改 globals() 对象会影响全局命名空间。 # 修改局部命名空间无效 def change_local (): x = 123 print ( \"当前的局部命名空间\" , locals (), sep = \"：\" ) locals ()[ \"x\" ] = 6789 print ( \"修改locals()，并不影响x的值\" , f \"x= {x} \" , sep = \"：\" ) change_local () 当前的局部命名空间：{'x': 123} 修改locals()，并不影响x的值：x=123 # 修改全局命名空间生效 y = 123 globals ()[ \"y\" ] = 456 print ( \"修改全局命名空间生效：\" , f \"y= {y} \" ) 修改全局命名空间生效： y=456 作用域 scope : scope 是Python程序的一块文本区域（即一个代码区域），在这个区域可以直接访问namespace 。 直接访问意味着无须特性的指明引用。在Python中，直接访问是指直接使用name访问对象，如 name ，这会在命名空间搜索名字 name ；而间接访问是指使用形如 objname.attrname 的方式，即引用对象的属性，这不会在命名空间搜索名字 attrname ，而是搜索名字 objname ，再访问其属性。 换而言之，作用域其实就是一个命名空间可以发生作用的代码区域，发生作用是指命名空间可以被作用域直接访问。 作用域与命名空间的关系 命名空间保存着名字到对象的映射，映射关系在作用域中被定义，同时作用域可以通过引用命名空间的名字访问对象。代码区域可以直接引用哪个命名空间中的名字，它也就是哪个命名空间的作用域。有些代码区域可以访问多个命名空间的名字，那么它同时是多个命名空间的作用域。 作用域是静态的（它只是代码文本），而命名空间是动态的，命名空间随着解释器的执行而产生。 有些文章认为动态的作用域就是命名空间。其实并不是，命名空间是一种映射，作用域是一块代码区域。 Python对象通过命名空间被访问，而作用域则限制了Python对象的使用范围。 名字搜索顺序（LEGB） 当一行代码需要使用名字 X 所对应的值， Python会从当前层级的Namespace开始 ，并根据以下顺序，去查找名字 X ： local namespace ：包含局部名字的最内层（innermost）作用域，如函数、方法、类的内部局部作用域。 Enclosing ：根据嵌套层次从内到外搜索，包含非局部（nonlocal）非全局（nonglobal）名字的任意封闭函数的作用域。如两个嵌套的函数，内层函数的作用域是局部作用域，外层函数作用域就是内层函数的 Enclosing 作用域。 global built-in NameError ：如果 Python 在以上4个namespace找不到 X ，将放弃搜索并抛出 NameError 异常： NameError: name 'a' is not defined 程序在运行时，local、global、built-in三个namespace一定存在，但Enclosing namespace不一定存在。 Namespace和scope总结 不能在名字未定义前引用该名字（命名空间不存在该映射关系）。 built-in、global两个命名空间的引入是不能够通过代码操作的，Python 解释器会自动引入它们。注意，这里说的是引入，而不是修改。built-in命名空间是不能被修改的（已经预定义好），但global命名空间可以被Python代码修改。 类定义、函数定义、推导式会引入local命名空间 ，闭包函数定义会引入enclosing命名空间。 会导致命名空间被修改的情况： 类定义、函数定义 2. 赋值语句 3. import 语句、 if 语句、 for 语句、 while 语句5. if 、 for 、 while 语句并不会引入新的命名空间。 作用范围最大的命名空间是global namespace，但global namespace也只是模块级别的。 a 模块不能直接引用在 b 模块定义的name，即使 a 模块已经导入了整个 b 模块： import b 。除非直接导入name： from b import name 。 导入 b 模块中其中一个name： from b import name ，整个 b 模块都会被执行。因为 Python 并不知道 name 在 b.py 文档的何处，为了能够找到 name ，Python 需要执行整个 b.py。 import 语句不一定会改变global namespace，例如 import 语句写在函数内。 根据LEGB搜索规则，外层作用域不能引用内层作用域的变量。 def try_to_define_name (): '''函数中定义了名字i，并绑定了一个整数对象1''' i = 1 # 引用名字i之前，先调用函数定义i try_to_define_name () # 在引用名字i之前，明明调用了函数，定义了名字i，可是还是找不到这个名字。 print ( i ) NameError : name 'i' is not defined 虽然定义了名字 i ，但是定义在了函数的局部作用域对应的局部命名空间中，按照 LEGB 搜索规则，在全局作用域中自然访问不到局部作用域的命名空间；再者，函数调用结束后，这个命名空间被销毁了。 global 和 nonlocal 根据LEGB搜索规则，任何时候，Python程序都可以直接读取全局变量，但是却不可以在内层作用域直接改写上层变量。 可以读取全部变量，这容易理解，因为任何时候，global namespace都可以被访问。但为什么在内层作用域全局变量可以被访问，却不能被修改呢？这看起来像是Python的一个规定，但其实是很自然的事情。在Python中修改变量意味着将一个名字绑定到另一个对象，这需要使用assignment运算符 = 。 这意味着 = 左边的名字会被加入当前的命名空间，名字对应着 = 右边的对象。 例如下面的代码： a = 1 def change_a (): a = 10 change_a () a # 1 1 a = 10 语句在函数作用域中，当它被Python执行时，Python会将 a 加入函数的局部命名空间，而不会将 a 视作全局命名空间的 a 。当我们在最外层作用域引用 a 时，按照LEGB搜索规则，Python会从 a 所在的作用域对应的命名空间（即全局命名空间）开始搜索 a 对应的对象，而不会搜索局部命名空间。再者，此时函数 change_a() 执行完之后，局部命名空间已经被销毁，即使想搜索也搜索不到。 相信你从上面的叙述已经意识到，如果想让Python在内层作用域修改外层作用域的变量，那就需要让Python知道这个变量来自外层作用域。 global 语句和 nonlocal 语句正是可以起到这样的作用。 global 语句声明列在其后的所有标识符将被解析为全局变量。 使用global时有以下两条限制： 在同一代码块中，列在global语句中的所有标识符不能在该global语句前出现。 列在global 语句后的标识符不能被定义成形参，不能出现在for循环控制的目标、类定义和函数定义，或者import语句中。 CPython实现细节：当前实现并未强制履行上面两条限制 2 ，但程序不应该滥用这种自由，因为未来的版本可能会强制履行它们或者不留痕迹的改变程序含义。 nonlocal 语句声明列在其后的所有标识符 关联 到 最近的 enclosing 作用域里定义过的同名变量（不包括全局变量，只是最近的 enclosing 作用域的变量）。 def scope_test (): def do_local (): spam = \"local spam of do_local\" def do_nonlocal (): nonlocal spam spam = \"nonlocal spam of do_nonlocal\" def do_global (): global spam spam = \"global spam of do_global\" spam = \"test spam of scope_test\" # do_local函数内部的赋值不影响scope_test作用域的spam do_local () print ( \"After local assignment:\" , spam ) # do_nonlocal函数内部的赋值影响scope_test作用域的spam，但是不影响全局的spam do_nonlocal () print ( \"After nonlocal assignment:\" , spam ) # do_global 函数内声明的spam存在于全局作用域，而不影响scope_test作用域的 do_global () print ( \"After global assignment:\" , spam ) scope_test () print ( \"In global scope:\" , spam ) After local assignment: test spam of scope_test After nonlocal assignment: nonlocal spam of do_nonlocal After global assignment: nonlocal spam of do_nonlocal In global scope: global spam of do_global nonlocal 语句和 global 语句有两个不同点： 其一， global 语句只是声明标识符来存在于全局命名空间，并不会在当前作用域创建该标识符； nonlocal 语句则会在子函数命名空间中创建与父函数变量同名的标识符： gv = 'a global var' def func (): global gv lv = 'a local var' print ( locals ()) def inn_func (): nonlocal lv global gv print ( locals ()) return inn_func a = func () a () {'lv': 'a local var'} {'lv': 'a local var'} 之所以 nonlocal 语句与 global 语句的处理不同，是因为全局变量的作用域生存期很长，在模块内随时都可以访问，而父函数的局部作用域在父函数执行完毕后便会直接释放，因此 nonlocal 语句必须将父函数的标识符和引用写入enclosing namespace。 其二， global 语句可以声明全局作用域还没存在的名字，而 nonlocal 语句只能将它声明的名字关联到enclosing作用域中已经存在的绑定： # nonlocal 语句之前的eclosing作用域不存在spam 则报错 def scope_test (): def do_nonlocal (): # 父函数作用域要先定义spam，否则报错 nonlocal spam spam = \"nonlocal spam of do_nonlocal\" scope_test () File \"<ipython-input-1-e77162de9535>\", line 5 nonlocal spam ^ SyntaxError: no binding for nonlocal 'spam' found nonlocal 语句只能声明的名字会绑定到离 nonlocal 语句最近的enclosing 作用域（如果enclosing 作用域存在 nonlocal 语句声明的名字）： def scope_test (): spam = \"local spam of scope_test\" def do_local (): spam = \"local spam of do_local\" print ( \"After local assignment:\" , spam ) def do_nonlocal (): # 通过nonlocal声明将spam和最近的enclosing作用域的spam关联 # 所以关联的是do_local函数的spam nonlocal spam spam = \"nonlocal spam of do_nonlocal\" do_nonlocal () print ( \"After nonlocal assignment:\" , spam ) do_local () print ( \"After nonlocal assignment, scope_test's spam:\" , spam ) scope_test () After local assignment: local spam of do_local After nonlocal assignment: nonlocal spam of do_nonlocal After nonlocal assignment, scope_test's spam: local spam of scope_test 因此 nonlocal 语句重新绑定的name的真实作用域是不清楚的，这取决于已经存在的name本来位于那一层作用域。 nonlocal 语句和 global 语句有一个相同点： 当前作用域不能在 nonlocal 语句和 global 语句之前绑定两者声明的标识符： # global def scope_test (): spam = \"conflict\" global spam spam = \"nonlocal spam of do_nonlocal\" scope_test () # nonlocal def scope_test (): spam = \"local spam of scope_test\" def do_nonlocal (): spam = \"conflict\" nonlocal spam spam = \"nonlocal spam of do_nonlocal\" do_nonlocal () print ( \"After nonlocal assignment, scope_test's spam:\" , spam ) scope_test () File \"<ipython-input-1-d9548726e53c>\", line 5 global spam ^ SyntaxError: name 'spam' is assigned to before global declaration 类的作用域和命名空间 类定义的作用域和函数定义的作用域都可以产生局部命名空间，但它们执行机制不一样，有不小的区别。 其一，函数初始化时不会被执行，类初始化时会被执行。 Python读入函数定义时，函数不会被执行： def func (): print ( \"executed\" ) Python读入类定义时，类作用域的代码会被执行： class A : print ( \"executed_A\" ) def A_func ( self ): print ( \"executed_A_func\" ) class B : print ( \"executed_B\" ) class C : print ( \"executed_C\" ) executed_A executed_B executed_C 这看起来感觉有点不可思议，大家都是定义，为什么类定义会被执行，难道不应该是定义被引用时才执行吗？ 其实这也是很自然的事情。Python解释器读入函数定义时，只需要在当前命名空间绑定函数名，不需要创建函数的局部命名空间，自然不需要执行函数作用域的代码。 命名空间的动态性：命名空间在作用域被执行时才产生。 而类定义实际上是类局部命名空间的包装，因此Python解释器读入类定义时，不仅需要在当前命名空间绑定类名，还需要创建类局部命名空间。而命名空间在作用域被执行时才会产生，因此类定义需要在读入的时候就被执行。注意：类方法内的作用域和函数一样，是不会被执行的。 为什么读入类定义就需要创建类局部命名空间？ 因为类具有属性和方法，创建类属性就必须执行代码（进行赋值）。那为什么在读入类定义就创建类属性呢？因为类是创建实例、生成其他类（涉及继承、重载等）的对象，必须在实例之前被创建，在代码加载时就被创建有助于提高效率和降低逻辑复杂度。 另外，类还有一个特点：类可以直接被调用，不一定要先创建实例。这个特点就要求类初始化时就创建类命名空间。例如，创建一个类用于统一管理某一类常量： class Math_Constant : pi = 3.1415926 e = 2.7182818 sqrt_2 = 1.4142135 rho = 1.3247195 如果 Math_Constant 的类属性需要创建一个实例才能被调用，那就太麻烦了，而且类方法、静态方法也就没了意义。 而方法本质是函数，不会在读入定义时被执行。 为什么读入函数定义时不需要创建函数局部命名空间？ 一般来说，函数的局部命名空间主要与参数有关，而参数在函数被调用时才传入，创建了命名空间也意义不大。另外函数不像类那么复杂，也就没必要读入定义时就创建局部命名空间。 其二，类的局部命名空间不在名字搜索路径中。 例如： class A : pi = 3.1415926 def print_pi ( self ): print ( pi ) A () . print_pi () NameError : name 'pi' is not defined 类 A 是 print_pi 方法的外层作用域，按照设想， print_pi 方法中找不到变量 pi ，应该会到上一层作用域中查找，但是 print_pi 方法并没有在类 A 的作用域中查找，而是直接抛出异常。 又例如： class A (): a = 1 b = [ a + i for i in range ( 3 )] #NameError: name 'a' is not defined 执行上段代码，我们可以发现在类 A 内列表推导式无法调取 a 的值。 列表推导式也会产生局部命名空间。 但在函数中，完全没问题： def func (): a = 1 b = [ a + i for i in range ( 3 )] print ( b ) func () # [ 1 , 2 , 3 ] 因此，类 A 中的 a 不同于函数 func 中的 a 在局部命名空间中可以被任意引用。之所以强调”不可以被任意读取”，原因在于在类 A 的局部空间内， a 在当前层级的作用域是可以被直接引用的： class A (): a = 1 c = a + 2 A . c # 3 3 因此，类内可以产生局部命名空间的代码（方法、推导式等）严格上不是作用域。 脚注 参考 python的嵌套函数中局部作用域问题? Python进阶 - 对象，名字以及绑定 即 {name:object} 。 ↩ 当前的CPython已经实现第一条限制，至少在0.29.14版本的CPython中已经实现。 ↩","text_tokens":["太","1","完毕","不到","最大","123","var","时",">","查看","globals","强调","同时","有关","1.4142135","取决","相同","统一","是因为","助于","主要","name","属性","写","新","实例","大家","5","封闭","这种","规则","已经","函数","一层","发现","出现","包含","释器","通常","作用","之后","见","搜索","还","至少","后面","全局变量","参","机制","大","模块","未来","在","非","很长","前","no","生命周期","a","一种","其中","先","思议","一般","严格","提高效率","即","换","当","有些","读到","你","is","也","可以","销毁","其后","f","标识符","每","test","不同点","提高","实际上","限制","b","上层","4","声明","这里","父","函数调用","通过","必要","各个","完","代码","sqrt","input","、","形","lv","<","初始","这会","它","导致","就","有助于","程序","闭包","过","line","无法","逻辑","层次","生成","调取","函数参数","认为","；"," ","外","子函数","中文","一般来说","后","哪个","开始","对象","多个","try","c","抛出","实现","内层","涉及","列表","↩","以及","具有","文章","其一","因此","所有","麻烦","另","nameerror","gv","第一条","nonglobal","式","#","while","使用","import","方法","\"","细节","一个","异常","没有","i","效率","此时","列","？","字典","知道","独立","从","大部","清楚",":","标识","并不知道","locals","随着","规定","found","第一","assigned","before","写入","inn","0.29","理解","结束","让","种类","想","自然","scope","放弃","在于","地点","这个","def","现在","生存期","类名","读入","避免","不仅","目标","enclosing","位于","将父","_","define","说明","重载","这样","注意","两个","着","外层","上面","算符","of","一条","右边","循环","legb","解析","2.7182818","却","object","层级","引入","修改","相对","捕获","其二","绑定","eclosing","最近","executed","访问","只是","整个","那","到","python","加入","虽然","释放","吗","一块","if","do","declaration","相信","但是","参数","from","内置","动态","不同","文档","任何","456","读取","3","文本","就是","6789","同于","控制","相同点","记录","继承","不知","另外","又","将","built","操作","namespace","否则","关联","之前","来","内","被","运算符","class","需要","设想","降低","看起来","解释","其所处","发生","to","视作","print","义好","=","不同于","重名","生效","左边",",","以下","任意","改写","关系","return","所以","file","e","__","类型","after","官方","生命","全部","时会","其实","进行","执行","不能","完全","类","nonlocal","直接","in","类内","要求","部分","周期","明明","什么","静态方法","下面","不留","预定","意识","滥用","区别","+","builtins","返回","便","或类","我们","not","引用","中","命名","assignment","赋值","本质","整数","则","除非","innermost","d9548726e53c","而类","冲突","如果","并未","等","离开","像是","改变程序","来自","区域","其他","含义","有助","指","一直","影响","?","叙述","conflict","即使","x","真实","块","未定","路径","常量","并","未","查找","{","y","取决于","副本","无效","上","参考","静态","会","处理","自动","一类","复杂","之","语句","能够","该","脚注","这些","时有","强制","正是","一行","为了","syntaxerror","所在","成形","了","之所以","不能引用","还有","而言","当前","容易","会到","加载","constant","原因","三个","1.3247195","func","改变","感觉","一般而言","defined","决定","未定义","本来","binding","去","个","存期","指明","再者","总结","传入","内部","-","意味","以上","那么","生存","名字","它们","self","range","同点","何处","情况","随时","痕迹","外部","]","例如","对类","找","时候","来说","事情","其","看起",".","14","存在","必须","与","因为","间接","没","高效","称为","，","调用函数","del","local",")","这","2","履行","同名","很","math","进阶","每个","用于","退出","意义","为什么","创建","change","s","objname","某","于","产生","对应","方式","不","应该","而","说","特性","调用","不像","意味着","一点","不小","最","问题","可是","根据","但","难道","两者","可能","定义","}","有点","名","找到","spam","只","才能","将来","'","自由","版本","是","级别","重新","都","管理","启动","同一","时才","global","(","还是","如","而父","再","包装","范围","pi","导入","按照","起来","builtin","初始化","局部","保存","10","不可","要","所","大部分","复杂度","无须","不会","推导","^","只能","function","起到","一定","解释器","[","实际","空间","和","不可思议","包括","值","e77162de9535","所处","ipython","。","运算","报错","段","（","映射","里","）","而且","顺序","sep","3.1415926","attrname","一样","而是","动态性","：","离","作用域","嵌套","的","运行","重要","区分","rho","呢","for","py","高效率","有","cpython","或者","特点","变量","为","”","全局","不是","两条"],"title":"3.2.命名空间和作用域","title_tokens":["命名",".","作用","空间","和","作用域","3.2"]},{"location":"Python基础/3.2.命名空间和作用域.html#_1","text":"Namespace : namespace 是一个从 name 到 object 的映射。现在大部分的 namespace 通过Python字典 1 实现，将来可能会改变实现方式。 namespace：中文称为命名空间，或者名字空间。 命名空间的最重要的作用是避免名字冲突，各个命名空间是独立的，因此不同的命名空间可以重名。","text_tokens":["中文",":","可以","1","名字","部分","将来","重名","实现","不同","是","大部分","：","因此","object","方式","通过","name","各个","改变","命名","的","重要","最","现在","会","空间","namespace","避免","一个","冲突"," ","，","到","可能","python","称为","或者","。","字典","作用","独立","从","大部","映射"],"title":"命名空间","title_tokens":["命名","空间"]},{"location":"Python基础/3.2.命名空间和作用域.html#namespace","text":"一般而言，name 产生地点决定其所处的 namespace。例如，在函数内定义的 name 会位于（函数的）局部命名空间。但使用了 global 、 nonlocal 语句会改变这种情况，这个在后面会说到。 built-in namespace ：builtins 模块定义的所有名字存在内置命名空间，这些名字包括内置函数、内置异常、内置常量、内置类型。如果是Python 2，则是 __builtin__ 模块。 global namespace ：每个模块都有全局命名空间，包括所有在模块最外层的作用域中定义的名字，例如类、函数、常量、被导入的模块。 local namespace ：相对于全局命名空间，每一个局部作用域都有一个局部命名空间。例如，函数或类所定义的命名空间，记录了函数参数、函数内的变量、类属性、类方法等。 enclosing namespace ：闭包命名空间不仅记录了当前嵌套函数内定义的变量，还记录了嵌套函数引用的外部变量。","text_tokens":["每个","builtins","于","产生","或类","引用","name","说","属性","中","命名","地点","则","这种","最","这个","函数","但","不仅","enclosing","位于","定义","如果","等","作用","外层","还","后面","模块","在","是","都","常量","相对","global","一般","会","全局","到","python","导入","语句","builtin","局部","这些","参数","内置","了","每","而言","当前","所","改变","记录","一般而言","、","决定","built","空间","namespace","闭包","包括","所处","内","。","被","函数参数"," ","-","（","）","nonlocal","名字","其所处","情况","外部","例如","：","所有","作用域","嵌套","的","__","存在","使用","类型","方法","一个","异常","有","，","local","2","变量","类","in"],"title":"Namespace 的种类","title_tokens":[" ","namespace","的","种类"]},{"location":"Python基础/3.2.命名空间和作用域.html#namespace_1","text":"不同类型的命名空间有不同的生命周期： built-in：在 Python 解释器启动时创建，解释器退出时销毁 global：在模块定义被解释器读入时创建，通常也会一直保存到解释器退出，除非使用 del 语句。 local：这里要区分 function 以及 class 定义： 函数的局部命名空间：在函数调用时创建，函数返回或者产生未被捕获的异常时销毁 - 类定义的局部命名空间：在解释器读到类定义创建，离开类定义时创建class object。这个类对象实际上就是这个局部命名空间的包装（见官方对类定义的 说明 ）。","text_tokens":["也","局部","保存","解释","销毁","对象","语句","周期","退出","时","模块","一直","在","创建","不同","要","实际上","以及","返回","产生","生命周期","：","这里","object","包装","对类","函数调用","就是","未","离开","命名","启动","function","捕获","的","global","调用","类","除非","解释器","区分","使用","built","这个","实际","空间","类型","读入","会","函数","异常","官方","有","生命","，","定义","python","到","del","。","被","释器","local","或者","读到","说明","通常","class","）"," ","-","in","（","见"],"title":"Namespace生命周期","title_tokens":["namespace","生命周期","周期","生命"]},{"location":"Python基础/3.2.命名空间和作用域.html#namespace_2","text":"局部命名空间可以通过 locals() 来访问 全局 （模块级别）命名空间可以通过 globals() 来访问 虽然都是返回命名空间，但 globals() 和 locals() 有一点不一样。 locals() 返回的是局部命名空间的副本，所以修改 locals() 对象并不会影响局部名字空间。 globals 返回是全局命名空间，而不是副本，所以修改 globals() 对象会影响全局命名空间。 # 修改局部命名空间无效 def change_local (): x = 123 print ( \"当前的局部命名空间\" , locals (), sep = \"：\" ) locals ()[ \"x\" ] = 6789 print ( \"修改locals()，并不影响x的值\" , f \"x= {x} \" , sep = \"：\" ) change_local () 当前的局部命名空间：{'x': 123} 修改locals()，并不影响x的值：x=123 # 修改全局命名空间生效 y = 123 globals ()[ \"y\" ] = 456 print ( \"修改全局命名空间生效：\" , f \"y= {y} \" ) 修改全局命名空间生效： y=456","text_tokens":["局部",":","可以","名字","对象","locals","sep","123","print","=","模块","f","一样","生效","影响","'",",","change","globals","当前","x","]","返回","456","是","：","级别","都","修改","并","通过","不","不会","6789","而","{","命名","的","所以","副本","(","无效","一点","#","y","[","def","访问","空间","和","会","\"","但","来","有","值","，","_","local","。",")","不是","}","虽然"," ","全局","（","）"],"title":"查看Namespace","title_tokens":["namespace","查看"]},{"location":"Python基础/3.2.命名空间和作用域.html#_2","text":"scope : scope 是Python程序的一块文本区域（即一个代码区域），在这个区域可以直接访问namespace 。 直接访问意味着无须特性的指明引用。在Python中，直接访问是指直接使用name访问对象，如 name ，这会在命名空间搜索名字 name ；而间接访问是指使用形如 objname.attrname 的方式，即引用对象的属性，这不会在命名空间搜索名字 attrname ，而是搜索名字 objname ，再访问其属性。 换而言之，作用域其实就是一个命名空间可以发生作用的代码区域，发生作用是指命名空间可以被作用域直接访问。","text_tokens":["搜索",":","可以","名字","区域","对象","发生","attrname","意味","指","在","而言","而是","objname","是","文本","就是","无须","引用","scope","方式","不会","作用域","name","而","特性","中","命名","属性","的","其","代码","意味着",".","直接","如","形","使用","这个","访问","这会","空间","间接","namespace","即","一个","程序","换","再","，","python","其实","指明","。","被","这","作用","一块","之","；"," ","（","）"],"title":"作用域","title_tokens":["作用","作用域"]},{"location":"Python基础/3.2.命名空间和作用域.html#_3","text":"命名空间保存着名字到对象的映射，映射关系在作用域中被定义，同时作用域可以通过引用命名空间的名字访问对象。代码区域可以直接引用哪个命名空间中的名字，它也就是哪个命名空间的作用域。有些代码区域可以访问多个命名空间的名字，那么它同时是多个命名空间的作用域。 作用域是静态的（它只是代码文本），而命名空间是动态的，命名空间随着解释器的执行而产生。 有些文章认为动态的作用域就是命名空间。其实并不是，命名空间是一种映射，作用域是一块代码区域。 Python对象通过命名空间被访问，而作用域则限制了Python对象的使用范围。","text_tokens":["也","保存","那么","可以","名字","哪个","区域","对象","多个","随着","解释","了","在","动态","限制","同时","文章","产生","是","文本","一种","就是","作用域","引用","通过","并","范围","而","中","命名","关系","的","代码","则","解释器","使用","静态","访问","空间","它","只是","，","到","定义","（","其实","有些","。","被","释器","执行","不是","python","作用","一块","认为"," ","着","直接","映射","）"],"title":"作用域与命名空间的关系","title_tokens":["命名","关系","的","作用","与","空间","作用域"]},{"location":"Python基础/3.2.命名空间和作用域.html#legb","text":"当一行代码需要使用名字 X 所对应的值， Python会从当前层级的Namespace开始 ，并根据以下顺序，去查找名字 X ： local namespace ：包含局部名字的最内层（innermost）作用域，如函数、方法、类的内部局部作用域。 Enclosing ：根据嵌套层次从内到外搜索，包含非局部（nonlocal）非全局（nonglobal）名字的任意封闭函数的作用域。如两个嵌套的函数，内层函数的作用域是局部作用域，外层函数作用域就是内层函数的 Enclosing 作用域。 global built-in NameError ：如果 Python 在以上4个namespace找不到 X ，将放弃搜索并抛出 NameError 异常： NameError: name 'a' is not defined 程序在运行时，local、global、built-in三个namespace一定存在，但Enclosing namespace不一定存在。","text_tokens":[":","不到","时","对应","not","不","name","放弃","innermost","封闭","最","根据","函数","但","enclosing","如果","包含","作用","两个","外层","搜索","在","'","非","x","是","a","层级","并","查找","类","global","如","会","当","全局","到","python","is","局部","一行","当前","4","所","就是","三个","代码","一定","、","defined","将","built","namespace","程序","去","值","个","内","。","层次","需要","内部"," ","-","外","（","）","以上","名字","开始","顺序","抛出","内层","：","以下","找","任意","作用域","nameerror","嵌套","nonglobal","的","运行","存在","使用","方法","异常","，","local","从","nonlocal","in"],"title":"名字搜索顺序（LEGB）","title_tokens":["搜索","名字","顺序","legb","（","）"]},{"location":"Python基础/3.2.命名空间和作用域.html#namespacescope","text":"不能在名字未定义前引用该名字（命名空间不存在该映射关系）。 built-in、global两个命名空间的引入是不能够通过代码操作的，Python 解释器会自动引入它们。注意，这里说的是引入，而不是修改。built-in命名空间是不能被修改的（已经预定义好），但global命名空间可以被Python代码修改。 类定义、函数定义、推导式会引入local命名空间 ，闭包函数定义会引入enclosing命名空间。 会导致命名空间被修改的情况： 类定义、函数定义 2. 赋值语句 3. import 语句、 if 语句、 for 语句、 while 语句5. if 、 for 、 while 语句并不会引入新的命名空间。 作用范围最大的命名空间是global namespace，但global namespace也只是模块级别的。 a 模块不能直接引用在 b 模块定义的name，即使 a 模块已经导入了整个 b 模块： import b 。除非直接导入name： from b import name 。 导入 b 模块中其中一个name： from b import name ，整个 b 模块都会被执行。因为 Python 并不知道 name 在 b.py 文档的何处，为了能够找到 name ，Python 需要执行整个 b.py。 import 语句不一定会改变global namespace，例如 import 语句写在函数内。 根据LEGB搜索规则，外层作用域不能引用内层作用域的变量。 def try_to_define_name (): '''函数中定义了名字i，并绑定了一个整数对象1''' i = 1 # 引用名字i之前，先调用函数定义i try_to_define_name () # 在引用名字i之前，明明调用了函数，定义了名字i，可是还是找不到这个名字。 print ( i ) NameError : name 'i' is not defined 虽然定义了名字 i ，但是定义在了函数的局部作用域对应的局部命名空间中，按照 LEGB 搜索规则，在全局作用域中自然访问不到局部作用域的命名空间；再者，函数调用结束后，这个命名空间被销毁了。","text_tokens":[":","1","并不知道","最大","不到","明明","预定","结束","对应","not","自然","引用","不","而","说","name","中","命名","写","赋值","新","调用","整数","5","除非","直接","这个","def","规则","可是","已经","但","函数","根据","enclosing","_","定义","define","释器","作用","注意","两个","外层","搜索","找到","模块","在","legb","'","前","即使","是","a","级别","未定","都","引入","修改","并","其中","先","global","(","绑定","还是","只是","会","访问","自动","整个","全局","范围","python","导入","按照","虽然","if","is","语句","能够","该","也","局部","可以","销毁","但是","为了","from","了","不能引用","b","文档","这里","3","函数调用","推导","不会","通过","改变","不知","代码","一定","、","解释器","defined","built","操作","未定义","空间","导致","namespace","闭包","之前","内","。","被","再者","需要","；"," ","-","（","映射","）","解释","后","名字","它们","to","try","对象","print","义好","何处","情况","=","内层","例如","：","找","作用域","nameerror","关系","式","的","#",".","while","存在","因为","import","for","py","一个","i","，","调用函数","local","执行",")","2","知道","变量","不能","类","in","不是"],"title":"Namespace和scope总结","title_tokens":["scope","namespace","总结","和"]},{"location":"Python基础/3.2.命名空间和作用域.html#global-nonlocal","text":"根据LEGB搜索规则，任何时候，Python程序都可以直接读取全局变量，但是却不可以在内层作用域直接改写上层变量。 可以读取全部变量，这容易理解，因为任何时候，global namespace都可以被访问。但为什么在内层作用域全局变量可以被访问，却不能被修改呢？这看起来像是Python的一个规定，但其实是很自然的事情。在Python中修改变量意味着将一个名字绑定到另一个对象，这需要使用assignment运算符 = 。 这意味着 = 左边的名字会被加入当前的命名空间，名字对应着 = 右边的对象。 例如下面的代码： a = 1 def change_a (): a = 10 change_a () a # 1 1 a = 10 语句在函数作用域中，当它被Python执行时，Python会将 a 加入函数的局部命名空间，而不会将 a 视作全局命名空间的 a 。当我们在最外层作用域引用 a 时，按照LEGB搜索规则，Python会从 a 所在的作用域对应的命名空间（即全局命名空间）开始搜索 a 对应的对象，而不会搜索局部命名空间。再者，此时函数 change_a() 执行完之后，局部命名空间已经被销毁，即使想搜索也搜索不到。 相信你从上面的叙述已经意识到，如果想让Python在内层作用域修改外层作用域的变量，那就需要让Python知道这个变量来自外层作用域。 global 语句和 nonlocal 语句正是可以起到这样的作用。 global 语句声明列在其后的所有标识符将被解析为全局变量。 使用global时有以下两条限制： 在同一代码块中，列在global语句中的所有标识符不能在该global语句前出现。 列在global 语句后的标识符不能被定义成形参，不能出现在for循环控制的目标、类定义和函数定义，或者import语句中。 CPython实现细节：当前实现并未强制履行上面两条限制 2 ，但程序不应该滥用这种自由，因为未来的版本可能会强制履行它们或者不留痕迹的改变程序含义。 nonlocal 语句声明列在其后的所有标识符 关联 到 最近的 enclosing 作用域里定义过的同名变量（不包括全局变量，只是最近的 enclosing 作用域的变量）。 def scope_test (): def do_local (): spam = \"local spam of do_local\" def do_nonlocal (): nonlocal spam spam = \"nonlocal spam of do_nonlocal\" def do_global (): global spam spam = \"global spam of do_global\" spam = \"test spam of scope_test\" # do_local函数内部的赋值不影响scope_test作用域的spam do_local () print ( \"After local assignment:\" , spam ) # do_nonlocal函数内部的赋值影响scope_test作用域的spam，但是不影响全局的spam do_nonlocal () print ( \"After nonlocal assignment:\" , spam ) # do_global 函数内声明的spam存在于全局作用域，而不影响scope_test作用域的 do_global () print ( \"After global assignment:\" , spam ) scope_test () print ( \"In global scope:\" , spam ) After local assignment: test spam of scope_test After nonlocal assignment: nonlocal spam of do_nonlocal After global assignment: nonlocal spam of do_nonlocal In global scope: global spam of do_global nonlocal 语句和 global 语句有两个不同点： 其一， global 语句只是声明标识符来存在于全局命名空间，并不会在当前作用域创建该标识符； nonlocal 语句则会在子函数命名空间中创建与父函数变量同名的标识符： gv = 'a global var' def func (): global gv lv = 'a local var' print ( locals ()) def inn_func (): nonlocal lv global gv print ( locals ()) return inn_func a = func () a () {'lv': 'a local var'} {'lv': 'a local var'} 之所以 nonlocal 语句与 global 语句的处理不同，是因为全局变量的作用域生存期很长，在模块内随时都可以访问，而父函数的局部作用域在父函数执行完毕后便会直接释放，因此 nonlocal 语句必须将父函数的标识符和引用写入enclosing namespace。 其二， global 语句可以声明全局作用域还没存在的名字，而 nonlocal 语句只能将它声明的名字关联到enclosing作用域中已经存在的绑定： # nonlocal 语句之前的eclosing作用域不存在spam 则报错 def scope_test (): def do_nonlocal (): # 父函数作用域要先定义spam，否则报错 nonlocal spam spam = \"nonlocal spam of do_nonlocal\" scope_test () File \"<ipython-input-1-e77162de9535>\", line 5 nonlocal spam ^ SyntaxError: no binding for nonlocal 'spam' found nonlocal 语句只能声明的名字会绑定到离 nonlocal 语句最近的enclosing 作用域（如果enclosing 作用域存在 nonlocal 语句声明的名字）： def scope_test (): spam = \"local spam of scope_test\" def do_local (): spam = \"local spam of do_local\" print ( \"After local assignment:\" , spam ) def do_nonlocal (): # 通过nonlocal声明将spam和最近的enclosing作用域的spam关联 # 所以关联的是do_local函数的spam nonlocal spam spam = \"nonlocal spam of do_nonlocal\" do_nonlocal () print ( \"After nonlocal assignment:\" , spam ) do_local () print ( \"After nonlocal assignment, scope_test's spam:\" , spam ) scope_test () After local assignment: local spam of do_local After nonlocal assignment: nonlocal spam of do_nonlocal After nonlocal assignment, scope_test's spam: local spam of scope_test 因此 nonlocal 语句重新绑定的name的真实作用域是不清楚的，这取决于已经存在的name本来位于那一层作用域。 nonlocal 语句和 global 语句有一个相同点： 当前作用域不能在 nonlocal 语句和 global 语句之前绑定两者声明的标识符： # global def scope_test (): spam = \"conflict\" global spam spam = \"nonlocal spam of do_nonlocal\" scope_test () # nonlocal def scope_test (): spam = \"local spam of scope_test\" def do_nonlocal (): spam = \"conflict\" nonlocal spam spam = \"nonlocal spam of do_nonlocal\" do_nonlocal () print ( \"After nonlocal assignment, scope_test's spam:\" , spam ) scope_test () File \"<ipython-input-1-d9548726e53c>\", line 5 global spam ^ SyntaxError: name 'spam' is assigned to before global declaration","text_tokens":[":","1","标识","不到","in","locals","完毕","什么","规定","var","时",">","下面","found","为什么","滥用","意识","不留","创建","写入","inn","assigned","before","change","理解","s","让","于","对应","想","便","取决","相同","我们","自然","引用","是因为","不","应该","scope","而","name","中","assignment","命名","赋值","意味着","5","则","这种","最","这个","def","规则","生存期","d9548726e53c","根据","但","函数","已经","目标","一层","两者","enclosing","位于","将父","_","定义","可能","如果","出现","}","并未","这样","作用","两个","像是","着","外层","之后","上面","来自","算符","改变程序","of","搜索","还","含义","全局变量","参","spam","右边","模块","未来","循环","legb","在","自由","影响","'","叙述","前","版本","解析","即使","很长","conflict","no","却","是","真实","a","块","重新","都","修改","并","{","同一","类","其二","global","先","(","取决于","绑定","eclosing","最近","访问","会","只是","处理","而父","即","当","那","到","python","按照","加入","起来","释放","你","is","do","语句","该","也","局部","declaration","可以","相信","销毁","10","但是","正是","时有","强制","其后","syntaxerror","所在","标识符","成形","之所以","test","不同","不同点","限制","上层","要","任何","容易","当前","声明","读取","父","不会","通过","^","只能","func","改变","控制","相同点","起到","完","代码","input","、","lv","将","<","它","空间","就","和","namespace","否则","程序","关联","本来","binding","过","包括","来","之前","e77162de9535","line","内","存期","。","被","再者","运算","ipython","运算符","需要","报错","；"," ","内部","-","意味","（","看起来","）","里","子函数","nonlocal","后","生存","名字","开始","它们","对象","to","视作","print","同点","=","实现","内层","左边",",","随时","痕迹","例如","：","其一","因此","以下","所有","离","作用域","另","改写","时候","gv","事情","的","return","看起","所以","file","#","清楚","存在","使用","必须","因为","import","呢","for","细节","\"","一个","after","与","没","有","cpython","，","全部","此时","其实","列","或者","？",")","这","执行","local","2","变量","知道","履行","不能","从","为","全局","同名","直接","很","两条"],"title":"global和 nonlocal","title_tokens":[" ","nonlocal","global","和"]},{"location":"Python基础/3.2.命名空间和作用域.html#_4","text":"类定义的作用域和函数定义的作用域都可以产生局部命名空间，但它们执行机制不一样，有不小的区别。 其一，函数初始化时不会被执行，类初始化时会被执行。 Python读入函数定义时，函数不会被执行： def func (): print ( \"executed\" ) Python读入类定义时，类作用域的代码会被执行： class A : print ( \"executed_A\" ) def A_func ( self ): print ( \"executed_A_func\" ) class B : print ( \"executed_B\" ) class C : print ( \"executed_C\" ) executed_A executed_B executed_C 这看起来感觉有点不可思议，大家都是定义，为什么类定义会被执行，难道不应该是定义被引用时才执行吗？ 其实这也是很自然的事情。Python解释器读入函数定义时，只需要在当前命名空间绑定函数名，不需要创建函数的局部命名空间，自然不需要执行函数作用域的代码。 命名空间的动态性：命名空间在作用域被执行时才产生。 而类定义实际上是类局部命名空间的包装，因此Python解释器读入类定义时，不仅需要在当前命名空间绑定类名，还需要创建类局部命名空间。而命名空间在作用域被执行时才会产生，因此类定义需要在读入的时候就被执行。注意：类方法内的作用域和函数一样，是不会被执行的。 为什么读入类定义就需要创建类局部命名空间？ 因为类具有属性和方法，创建类属性就必须执行代码（进行赋值）。那为什么在读入类定义就创建类属性呢？因为类是创建实例、生成其他类（涉及继承、重载等）的对象，必须在实例之前被创建，在代码加载时就被创建有助于提高效率和降低逻辑复杂度。 另外，类还有一个特点：类可以直接被调用，不一定要先创建实例。这个特点就要求类初始化时就创建类命名空间。例如，创建一个类用于统一管理某一类常量： class Math_Constant : pi = 3.1415926 e = 2.7182818 sqrt_2 = 1.4142135 rho = 1.3247195 如果 Math_Constant 的类属性需要创建一个实例才能被调用，那就太麻烦了，而且类方法、静态方法也就没了意义。 而方法本质是函数，不会在读入定义时被执行。 为什么读入函数定义时不需要创建函数局部命名空间？ 一般来说，函数的局部命名空间主要与参数有关，而参数在函数被调用时才传入，创建了命名空间也意义不大。另外函数不像类那么复杂，也就没必要读入定义时就创建局部命名空间。 其二，类的局部命名空间不在名字搜索路径中。 例如： class A : pi = 3.1415926 def print_pi ( self ): print ( pi ) A () . print_pi () NameError : name 'pi' is not defined 类 A 是 print_pi 方法的外层作用域，按照设想， print_pi 方法中找不到变量 pi ，应该会到上一层作用域中查找，但是 print_pi 方法并没有在类 A 的作用域中查找，而是直接抛出异常。 又例如： class A (): a = 1 b = [ a + i for i in range ( 3 )] #NameError: name 'a' is not defined 执行上段代码，我们可以发现在类 A 内列表推导式无法调取 a 的值。 列表推导式也会产生局部命名空间。 但在函数中，完全没问题： def func (): a = 1 b = [ a + i for i in range ( 3 )] print ( b ) func () # [ 1 , 2 , 3 ] 因此，类 A 中的 a 不同于函数 func 中的 a 在局部命名空间中可以被任意引用。之所以强调”不可以被任意读取”，原因在于在类 A 的局部空间内， a 在当前层级的作用域是可以被直接引用的： class A (): a = 1 c = a + 2 A . c # 3 3 因此，类内可以产生局部命名空间的代码（方法、推导式等）严格上不是作用域。","text_tokens":["类内","要求",":","太","1","math","不到","什么","用于","静态方法","时","意义","为什么","创建","区别","+","强调","某","有关","产生","1.4142135","统一","我们","自然","not","引用","不","应该","助于","主要","而","name","属性","中","命名","赋值","实例","调用","本质","不像","不小","大家","在于","这个","def","问题","类名","读入","难道","函数","但","而类","不仅","一层","发现","_","定义","如果","释器","重载","等","作用","注意","有点","外层","名","搜索","还","其他","大","机制","有助","只","才能","在","'","2.7182818","是","a","层级","路径","都","常量","并","查找","管理","其二","思议","时才","先","(","上","绑定","一般","静态","executed","严格","会","提高效率","一类","那","包装","python","pi","不是","复杂","按照","起来","吗","is","初始化","也","局部","可以","但是","参数","不可","还有","了","之所以","动态","提高","要","b","实际上","不同","当前","读取","3","会到","复杂度","加载","不会","constant","推导","必要","原因","1.3247195","同于","func","继承","另外","感觉","代码","sqrt","一定","、","解释器","defined","又","[","初始","实际","空间","和","就","有助于","不可思议","之前","值","内","无法","。","被","逻辑","生成","传入","class","需要","调取","段"," ","设想","（","降低","看起来","）","而且","一般来说","解释","那么","名字","它们","对象","3.1415926","print","self","c","range","=","抛出","不同于","一样","涉及","列表",",","而是","动态性","具有","]","例如","其一","：","因此","麻烦","找","作用域","任意","nameerror","时候","来说","事情","式","的","所以","看起","e","#",".","必须","因为","rho","\"","方法","呢","没","高效率","一个","与","异常","for","没有","高效","有","效率","i","，","时会","其实","进行","特点","？","执行",")","这","2","变量","完全","”","类","in","直接","很"],"title":"类的作用域和命名空间","title_tokens":["命名","的","作用","作用域","和","空间","类"]},{"location":"Python基础/3.2.命名空间和作用域.html#_5","text":"","text_tokens":[],"title":"脚注","title_tokens":["脚注"]},{"location":"Python基础/3.2.命名空间和作用域.html#_6","text":"python的嵌套函数中局部作用域问题? Python进阶 - 对象，名字以及绑定 即 {name:object} 。 ↩ 当前的CPython已经实现第一条限制，至少在0.29.14版本的CPython中已经实现。 ↩","text_tokens":["局部",":","名字","进阶","对象","一条","至少","第一","实现","在","?","0.29","限制","↩","版本","当前","以及","object","作用域","name","中","{","第一条","嵌套","的","绑定",".","14","问题","即","函数","已经","cpython","，","python","。","}","作用"," ","-"],"title":"参考","title_tokens":["参考"]},{"location":"Python基础/3.3.闭包.html","text":"闭包 以下引用自维基百科中关于闭包的介绍： 在 计算机科学 中， 闭包 （英语：Closure），又称 词法闭包 （Lexical Closure）或 函数闭包 （function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 闭包的概念出现于60年代，最早实现闭包的程序语言是 Scheme 。之后，闭包被广泛使用于 函数式编程 语言如 ML语言 和 LISP 。很多命令式程序语言也开始支持闭包。 在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。运行时，一旦外部的函数被执行，一个闭包就形成了，闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。其中所引用的变量称作 上值 (upvalue)。 维基百科中对于闭包的介绍，应该还是比较直观的。简而言之：内嵌函数引用了外部函数的变量，这个内嵌函数被执行时，就形成一个闭包。例如： def outside ( a , b ): a = a b = b def inner (): y = a + b print ( locals ()) inner () # 调用outside函数 inner被执行 形成闭包 outside ( 1 , 2 ) {'y': 3, 'a': 1, 'b': 2} inner() 被执行时，创建的局部命名空间会包括其引用的外层函数的变量，这样的局部命名空间被称为闭包命名空间（enclosing namespace）。 注意，在Python中，内嵌函数可以被外层函数返回，也就是Python函数可以返回闭包。 理解什么是闭包不难，但问题在于闭包有什么作用呢？ 闭包的作用 闭包的独特之处在于它可以绑定外部函数的变量，即使生成闭包的环境（外层函数）已经释放，闭包仍然存在。 这个过程很像类生成实例，不同的是外部函数只在调用时生成命名空间，执行完毕后其命名空间就会释放，而类的命名空间在读入定义时创建，一般Python解释器退出才释放命名空间。因此对一些需要重用的功能且不足以定义为类的行为，使用闭包会比使用类占用更少的资源，且更轻巧灵活。 例如：假设我们仅仅想打印出各类动物的叫声，分别以类和闭包来实现： # 类实现 class Animal ( object ): def __init__ ( self , animal ): self . animal = animal def sound ( self , voice ): print ( self . animal , ':' , voice , \"...\" ) dog = Animal ( \"dog\" ) dog . sound ( \"wangwang\" ) dog . sound ( \"wowo\" ) dog : wangwang ... dog : wowo ... # 闭包实现 def voice ( animal ): def sound ( voc ): print ( animal , ':' , voc , \"...\" ) return sound dog = voice ( \"dog\" ) dog ( \"wangwang\" ) dog ( \"wowo\" ) dog : wangwang ... dog : wowo ... 输出结果是完全一样的，但显然类的实现相对繁琐，且这里只是想输出一下动物的叫声，定义一个 Animal 类未免小题大做，而且 voice 函数在执行完毕后，其命名空间就已经释放，但 Animal 类及其实例 dog 的相应属性却一直贮存在内存中。而这种内存占用是没有必要的。 除此之外，闭包还有其他作用。闭包可以减少函数参数的数目，因此可以用于封装。这对并行计算也非常有用，比如可以让每台电脑负责一个函数的计算。另外，闭包在Python中有一种重要的应用——装饰器。这个会在装饰器的文章讲述。 闭包作用域与命名空间 来看一个典型的 闭包 结构： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv = [ 'gv' ] + gv # UnboundLocalError:local variable 'gv' referenced before assignment lv = [] def inn_func (): lv = lv + [ v ] # UnboundLocalError:local variable 'lv' referenced before assignment gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 这段代码似乎没有问题，赋值操作从右到左执行，先从右边的 gv 、 lv 开始执行代码，此时局部作用域还没有 gv 变量，局部作用域也没有 lv 变量，Python应该会访问外层作用域的 gv 、 lv 变量。但实际调用 func() 函数时，上面两处对 gv 和 lv 进行赋值操作的地方都会触发 UnboundLocalError 。 这是因为 Python 在执行函数前，会首先生成各层命名空间和作用域 ，因此 Python 在执行赋值前会将 func 内的 'gv' 'lv' 写入局部命名空间和闭包命名空间： dict_局部命名空间.update({“gv”:['gv'] + gv}) dict_闭包命名空间.update({“lv”:['lv'] + lv}) 当 Python 执行赋值时，按照LEGB搜索规则，会先在局部作用域、闭包作用域内发现 gv 和 lv 标识符，但 gv 和 lv 在局部命名空间和闭包命名空间内都没有绑定对象，从而引发错误。 这段代码本意只是想让具有对象的全局变量 gv 和局部变量 lv 参与运算，而不是局部命名空间中的 gv 和闭包命名空间中的 lv 。为了避免类似的情况发生， Python 引入了 global 、 nonlocal 语句来说明所修饰的 gv 、 lv 分别来自全局命名空间和局部命名空间 ，声明之后，就可以在 func 和 inn_func 内直接改写上层命名空间内 gv 和 lv 的值： gv = [ 'a' , 'global' , 'var' ] print ( \"gv的内存地址\" , id ( gv )) def func ( v ): global gv print ( \"gv的内存地址\" , id ( gv )) gv = [ 'gv' ] + gv lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): nonlocal lv print ( \"lv的内存地址\" , id ( lv )) lv = lv + [ v ] gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () gv的内存地址 1441702558856 gv的内存地址 1441702558856 lv的内存地址 1441702558856 lv的内存地址 1441702558856 ['gv', 'is', 'a', 'global', 'var'] 如上，全局变量 gv 值被函数改写了， inn_func 修改的也确实是父函数 lv 的值 （依据内存地址判断）。 借壳 那么是不是不使用 global 和 nonlocal 就不能达到上面的目的呢？来看看下面这段代码： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv . insert ( 0 , 'gv' ) lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): lv . append ( v ) print ( \"lv的内存地址\" , id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () print ( gv ) lv的内存地址 1441701536776 lv的内存地址 1441701536776 ['gv', 'is', 'a', 'global', 'var'] 可以发现，执行结果同上面完全一致，问题自然来了：“为什么不用 global nonlocal 也可以改写全局变量 gv 和父函数变量 lv 的值？ 为了看清楚这个过程，我们将上面的 gv.insert(0, 'gv') 和 lv.append(v) 改写为 gv[0:0] = ['gv'] 和 lv[:] = [v] ： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv [ 0 : 0 ] = [ 'gv' ] lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): lv [:] = [ v ] print ( \"lv的内存地址\" , id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () print ( gv ) lv的内存地址 1441702387208 lv的内存地址 1441702387208 ['gv', 'is', 'a', 'global', 'var'] 执行结果完全一致，事实上两者之间的本质也是完全一样的。 .insert() 、 .append() 方法并没有修改 gv 和 lv ，而是修改 gv 和 lv 的元素 gv[0:0] 和 lv[:] ，因此 gv 和 lv 并没有被加入局部命名空间。因此，不需要 global 和 nonlocal 修饰就可以直接改写， 这就是“借壳”。 另外，也是借助了list对象的mutable性质。 在 nonlocal 尚未引入 Python 中，比如 Python 2.x 若要在子函数中改写父函数变量的值就得通过这种方法。","text_tokens":["1","完毕","由","var","时","闭","对","closure","相同","从而","是因为","不足","属性","显然","实例","说法","这种","各类","规则","已经","函数","发现","出现","包含","释器","作用","之后","搜索","还","0","重用","全局变量","在","触发","前","—","不用","a","一种","其中","借壳","先","一般","装饰","当","自","voc","is","完全一致","也","可以","应用","标识符","事实上","b","上层","独特","声明","这里","mutable","父","介绍","通过","必要","似乎","代码","、","lv","它","就","程序","看清楚","闭包","相关","生成","v","函数参数","认为"," ","判断","子函数","后","开始","对象","多个","两处","中有","计算机科学","借助","除此","实现","百科","占用","以及","具有","文章","因此","过程","讲述","closures","另","gv","式","#","使用","id","dog","\"","方法","一个","没有","此时","假设","有用","？","减少","从","init","清楚","一致",":","标识","及其","locals","且","before","写入","inn","理解","让","想","灵活","内存地址","自然","一下","在于","这个","比较","def","读入","避免","enclosing","_","说明","足以","小题","这样","注意","例外","外层","上面","每台","右边","legb","若要","1441701536776","lexical","并行计算","并行","却","object","引入","修改","相对","绑定","看清","为类","只是","访问","python","打印","加入","概念","释放","dict","性质","地址","参数","本意","不同","维基百","3","才","依据","就是","很多","另外","地方","资源","将","元素","操作","达到","namespace","程序语言","来","仍然","内","被","scheme","需要","class","解释","发生","出","print","...","=","一些",",","负责","ml","以下","创造","改写","内存","return","所以","修饰","非常","__","科学","广泛","尚未","英语","进行","执行","不能","完全","lisp","类","nonlocal","输出","闭包会","直接","什么","insert","下面","+","年代","返回","我们","引用","中","命名","assignment","之间","赋值","本质","则","append","一旦","而类","事实","如果","内嵌","离开","来自","其他","会先","outside","一直","典型","形成","sound","算机","即使","x","并","{","y","上","命令式","语言","会","环境","以类","之","更","语句","未免","支持","为了","wowo","还有","了","“","而言","关于","update","func","比","电脑","编程","轻巧","结构","直观","内部","繁琐","引发","那么","参与","self","贮存","情况","variable","外部","]","例如","wangwang","目的","其","与其",".","从右到左","包来","存在","错误","对于","与","因为","称为","，","像","local",")","这","2","list","计算机","各层","很","叫声","inner","退出","用于","同","为什么","创建","器","于","维基百科","产生","比如","不","应该","referenced","而","调用","称作","upvalue","问题","但","两者","定义","可能","维基","}","除此之外","行为","功能","只","animal","词法","自由","命令","'","之外","unboundlocalerror","是","voice","看看","都","组合","global","(","还是","如","结果","相应","仅仅","最早","类似","按照","需","封装","局部","又称","首先","局部变量","所","两者之间","60","来看","function","小题大做","解释器","[","是不是","实际","空间","和","一同","包括","值","。","运算","不足以","分别","实体","段","（","）","而且","前会","1441702387208","确实","或","一样","组合而成","更少","而是","简而言之","：","动物","作用域","处","嵌套","1441702558856","的","运行","上值","重要","呢","计算","包被","得","有","数目","变量","为","”","全局","不难","不是"],"title":"3.3.闭包","title_tokens":[".","闭包","3.3"]},{"location":"Python基础/3.3.闭包.html#_1","text":"以下引用自维基百科中关于闭包的介绍： 在 计算机科学 中， 闭包 （英语：Closure），又称 词法闭包 （Lexical Closure）或 函数闭包 （function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 闭包的概念出现于60年代，最早实现闭包的程序语言是 Scheme 。之后，闭包被广泛使用于 函数式编程 语言如 ML语言 和 LISP 。很多命令式程序语言也开始支持闭包。 在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。运行时，一旦外部的函数被执行，一个闭包就形成了，闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。其中所引用的变量称作 上值 (upvalue)。 维基百科中对于闭包的介绍，应该还是比较直观的。简而言之：内嵌函数引用了外部函数的变量，这个内嵌函数被执行时，就形成一个闭包。例如： def outside ( a , b ): a = a b = b def inner (): y = a + b print ( locals ()) inner () # 调用outside函数 inner被执行 形成闭包 outside ( 1 , 2 ) {'y': 3, 'a': 1, 'b': 2} inner() 被执行时，创建的局部命名空间会包括其引用的外层函数的变量，这样的局部命名空间被称为闭包命名空间（enclosing namespace）。 注意，在Python中，内嵌函数可以被外层函数返回，也就是Python函数可以返回闭包。 理解什么是闭包不难，但问题在于闭包有什么作用呢？","text_tokens":[":","1","locals","由","什么","inner","时","创建","+","闭","年代","理解","于","维基百科","产生","返回","closure","相同","引用","不","应该","中","命名","实例","调用","在于","称作","说法","则","upvalue","这个","比较","def","问题","一旦","已经","函数","但","enclosing","定义","可能","维基","如果","出现","包含","内嵌","}","这样","作用","注意","例外","离开","外层","之后","词法","outside","在","自由","命令","'","形成","lexical","算机","即使","是","a","一种","其中","组合","{","y","(","命令式","如","语言","还是","会","自","环境","python","最早","需","概念","也","局部","又称","可以","支持","了","而言","不同","b","维基百","所","3","60","关于","介绍","就是","很多","function","代码","将","它","空间","和","就","一同","namespace","程序","程序语言","闭包","相关","包括","编程","。","被","scheme","直观","认为","实体"," ","内部","（","）","开始","多个","print","或","计算机科学","=","实现","一些","百科",",","组合而成","简而言之","外部","以及","例如","：","ml","以下","创造","closures","另","嵌套","式","的","所以","其","运行","与其","#","上值","存在","使用","科学","广泛","对于","呢","一个","计算","包被","有","称为","，","英语","？","执行",")","2","变量","计算机","lisp","不难"],"title":"闭包","title_tokens":["闭包"]},{"location":"Python基础/3.3.闭包.html#_2","text":"闭包的独特之处在于它可以绑定外部函数的变量，即使生成闭包的环境（外层函数）已经释放，闭包仍然存在。 这个过程很像类生成实例，不同的是外部函数只在调用时生成命名空间，执行完毕后其命名空间就会释放，而类的命名空间在读入定义时创建，一般Python解释器退出才释放命名空间。因此对一些需要重用的功能且不足以定义为类的行为，使用闭包会比使用类占用更少的资源，且更轻巧灵活。 例如：假设我们仅仅想打印出各类动物的叫声，分别以类和闭包来实现： # 类实现 class Animal ( object ): def __init__ ( self , animal ): self . animal = animal def sound ( self , voice ): print ( self . animal , ':' , voice , \"...\" ) dog = Animal ( \"dog\" ) dog . sound ( \"wangwang\" ) dog . sound ( \"wowo\" ) dog : wangwang ... dog : wowo ... # 闭包实现 def voice ( animal ): def sound ( voc ): print ( animal , ':' , voc , \"...\" ) return sound dog = voice ( \"dog\" ) dog ( \"wangwang\" ) dog ( \"wowo\" ) dog : wangwang ... dog : wowo ... 输出结果是完全一样的，但显然类的实现相对繁琐，且这里只是想输出一下动物的叫声，定义一个 Animal 类未免小题大做，而且 voice 函数在执行完毕后，其命名空间就已经释放，但 Animal 类及其实例 dog 的相应属性却一直贮存在内存中。而这种内存占用是没有必要的。 除此之外，闭包还有其他作用。闭包可以减少函数参数的数目，因此可以用于封装。这对并行计算也非常有用，比如可以让每台电脑负责一个函数的计算。另外，闭包在Python中有一种重要的应用——装饰器。这个会在装饰器的文章讲述。","text_tokens":[":","完毕","及其","叫声","用于","退出","时","且","创建","闭","器","让","想","对","灵活","比如","我们","不足","而","一下","属性","中","命名","显然","实例","在于","调用","这种","这个","各类","def","读入","已经","函数","而类","但","定义","释器","足以","小题","除此之外","行为","作用","外层","其他","每台","重用","功能","只","animal","一直","在","'","sound","之外","并行计算","即使","并行","—","却","是","voice","一种","object","相对","(","绑定","一般","为类","结果","只是","会","相应","装饰","仅仅","环境","python","voc","以类","打印","释放","封装","之","更","未免","也","可以","应用","参数","wowo","还有","不同","独特","才","这里","必要","比","小题大做","电脑","另外","资源","解释器","输出","它","空间","就","和","闭包","仍然","。","轻巧","不足以","生成","分别","需要","class","函数参数"," ","繁琐","（","）","而且","后","解释","出","print","self","...","中有","贮存","=","一样","一些","实现","除此","占用","更少",",","负责","外部","文章","例如","：","wangwang","因此","动物","过程","讲述","处","内存","的","其","return","#",".","__","非常","重要","包来","存在","使用","dog","\"","一个","计算","没有","，","假设","像","有用","数目","执行",")","这","变量","减少","完全","类","闭包会","很","init"],"title":"闭包的作用","title_tokens":["作用","的","闭包"]},{"location":"Python基础/3.3.闭包.html#_3","text":"来看一个典型的 闭包 结构： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv = [ 'gv' ] + gv # UnboundLocalError:local variable 'gv' referenced before assignment lv = [] def inn_func (): lv = lv + [ v ] # UnboundLocalError:local variable 'lv' referenced before assignment gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 这段代码似乎没有问题，赋值操作从右到左执行，先从右边的 gv 、 lv 开始执行代码，此时局部作用域还没有 gv 变量，局部作用域也没有 lv 变量，Python应该会访问外层作用域的 gv 、 lv 变量。但实际调用 func() 函数时，上面两处对 gv 和 lv 进行赋值操作的地方都会触发 UnboundLocalError 。 这是因为 Python 在执行函数前，会首先生成各层命名空间和作用域 ，因此 Python 在执行赋值前会将 func 内的 'gv' 'lv' 写入局部命名空间和闭包命名空间： dict_局部命名空间.update({“gv”:['gv'] + gv}) dict_闭包命名空间.update({“lv”:['lv'] + lv}) 当 Python 执行赋值时，按照LEGB搜索规则，会先在局部作用域、闭包作用域内发现 gv 和 lv 标识符，但 gv 和 lv 在局部命名空间和闭包命名空间内都没有绑定对象，从而引发错误。 这段代码本意只是想让具有对象的全局变量 gv 和局部变量 lv 参与运算，而不是局部命名空间中的 gv 和闭包命名空间中的 lv 。为了避免类似的情况发生， Python 引入了 global 、 nonlocal 语句来说明所修饰的 gv 、 lv 分别来自全局命名空间和局部命名空间 ，声明之后，就可以在 func 和 inn_func 内直接改写上层命名空间内 gv 和 lv 的值： gv = [ 'a' , 'global' , 'var' ] print ( \"gv的内存地址\" , id ( gv )) def func ( v ): global gv print ( \"gv的内存地址\" , id ( gv )) gv = [ 'gv' ] + gv lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): nonlocal lv print ( \"lv的内存地址\" , id ( lv )) lv = lv + [ v ] gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () gv的内存地址 1441702558856 gv的内存地址 1441702558856 lv的内存地址 1441702558856 lv的内存地址 1441702558856 ['gv', 'is', 'a', 'global', 'var'] 如上，全局变量 gv 值被函数改写了， inn_func 修改的也确实是父函数 lv 的值 （依据内存地址判断）。","text_tokens":[":","1","标识","var","insert","时","before","写入","inn","+","让","想","对","从而","内存地址","是因为","referenced","应该","而","assignment","命名","中","赋值","调用","直接","def","问题","规则","避免","但","函数","发现","_","说明","}","作用","外层","上面","来自","之后","搜索","还","0","会先","全局变量","右边","在","'","典型","legb","unboundlocalerror","触发","前","是","a","都","引入","修改","{","先","global","上","(","绑定","如","访问","会","只是","当","全局","python","类似","按照","dict","is","语句","也","局部","可以","地址","为了","本意","首先","标识符","了","“","局部变量","上层","声明","所","依据","父","update","来看","func","似乎","地方","代码","、","lv","将","[","操作","实际","和","空间","就","闭包","来","值","内","。","被","运算","结构","生成","分别","v","段"," ","判断","（","）","前会","引发","nonlocal","参与","开始","确实","对象","两处","发生","print","=","情况","variable",",","]","具有","：","因此","作用域","改写","gv","内存","1441702558856","的","return","修饰","#",".","从右到左","错误","id","因为","\"","一个","没有","，","此时","进行","local",")","这","执行","变量","从","”","各层","不是"],"title":"闭包作用域与命名空间","title_tokens":["命名","作用","与","作用域","空间","闭包"]},{"location":"Python基础/3.3.闭包.html#_4","text":"那么是不是不使用 global 和 nonlocal 就不能达到上面的目的呢？来看看下面这段代码： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv . insert ( 0 , 'gv' ) lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): lv . append ( v ) print ( \"lv的内存地址\" , id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () print ( gv ) lv的内存地址 1441701536776 lv的内存地址 1441701536776 ['gv', 'is', 'a', 'global', 'var'] 可以发现，执行结果同上面完全一致，问题自然来了：“为什么不用 global nonlocal 也可以改写全局变量 gv 和父函数变量 lv 的值？ 为了看清楚这个过程，我们将上面的 gv.insert(0, 'gv') 和 lv.append(v) 改写为 gv[0:0] = ['gv'] 和 lv[:] = [v] ： gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv [ 0 : 0 ] = [ 'gv' ] lv = [] print ( \"lv的内存地址\" , id ( lv )) def inn_func (): lv [:] = [ v ] print ( \"lv的内存地址\" , id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) a () print ( gv ) lv的内存地址 1441702387208 lv的内存地址 1441702387208 ['gv', 'is', 'a', 'global', 'var'] 执行结果完全一致，事实上两者之间的本质也是完全一样的。 .insert() 、 .append() 方法并没有修改 gv 和 lv ，而是修改 gv 和 lv 的元素 gv[0:0] 和 lv[:] ，因此 gv 和 lv 并没有被加入局部命名空间。因此，不需要 global 和 nonlocal 修饰就可以直接改写， 这就是“借壳”。 另外，也是借助了list对象的mutable性质。 在 nonlocal 尚未引入 Python 中，比如 Python 2.x 若要在子函数中改写父函数变量的值就得通过这种方法。","text_tokens":["一致",":","1","什么","var","insert","下面","同","为什么","inn","比如","我们","内存地址","自然","不","中","命名","之间","本质","直接","这种","这个","问题","def","append","函数","两者","发现","_","事实","上面","0","全局变量","在","'","若要","1441701536776","x","不用","是","看看","a","引入","修改","并","借壳","global","(","看清","结果","python","加入","is","完全一致","性质","也","局部","可以","地址","为了","了","“","事实上","mutable","父","两者之间","就是","通过","func","另外","代码","、","lv","将","[","元素","是不是","达到","和","就","空间","看清楚","来","值","。","被","v","需要","段"," ","子函数","nonlocal","那么","1441702387208","对象","print","=","借助","一样",",","而是","]","：","因此","目的","过程","改写","gv","内存","的","return","修饰",".","使用","id","呢","\"","方法","没有","得","，","尚未","？",")","这","执行","list","2","变量","不能","完全","为","”","全局","不是","清楚"],"title":"借壳","title_tokens":["借壳"]},{"location":"Python基础/3.4.装饰器.html","text":"装饰器简述 有时候，我们需要给一个函数添加新功能。那么有一种做法就是修改原函数的代码，直接添加新功能。但这总做法有时未免太繁琐。在python中，直接给原函数套上装饰就可以实现这个需求。 假设有一个这样的函数： def hello (): return 'hello world' # hello函数的名字 print ( \"hello函数的名字：\" , hello . __name__ ) hello函数的名字： hello 现在我们想增强 hello() 函数的功能，希望给返回加上 HTML 标签，比如 <i>hello world</i> ，但有一个要求，不改变原来 hello() 函数的定义。 那么可以这样做： def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped 要注意的是，makeitalic函数的参数是一个函数，返回的结果是wrapped函数。 # 给hello函数套上makeitalic函数 # makeitalic函数返回wrapped函数 # 实际上此时hello变成了wrapped函数 hello = makeitalic ( hello ) 将 hello 函数作为参数传入 makeitalic 函数， makeitalic 函数返回wrapped函数，名字 hello 与 wrapped 函数绑定。此时名字 hello 代表了一个函数，也就是 wrapped 函数有了新的名字—— hello 。 # 可以看出hello函数的名字变了 print ( \"hello函数的名字：\" , hello . __name__ ) hello函数的名字： wrapped 总结一下：为了增强原函数 hello 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数。 事实上， makeitalic 就是一个装饰器（decorator），它『装饰』了函数 hello ，并返回一个函数，将其赋给 hello 。 像上面的情况，可以动态修改函数（或类）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 hello ）为参数，并返回一个包装后的函数（比如上面的 wrapped ）给被装饰函数（ hello ）。 装饰器的一般使用形式 在python中，装饰器一般这样用： @decorator def func (): pass 等价于下面的形式 ： def func (): pass func = decorator ( func ) 装饰器可以定义多个，离函数定义最近的装饰器先被调用，比如 @decorator_one @decorator_two def func (): pass 等价于： def func (): pass func = decorator_one ( decorator_two ( func )) 装饰器还可以带参数，比如： @decorator ( arg1 , arg2 ) def func (): pass 等价于： def func (): pass func = decorator ( arg1 , arg2 )( func ) 例子： def makeitalic2 ( func ): return \"<i>\" + func () + \"</i>\" @makeitalic def hello_2 (): return 'hello world' def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped hello_2 () ' <i> hello world </i> ' 如果返回的不是函数就会这样： @makeitalic def hello_3 (): return 'hello world' def makeitalic ( func ): return \"<i>\" + func () + \"</i>\" hello_3 <function __main__.makeitalic.<locals>.wrapped()> 对带参数的函数进行装饰 前面的例子中，被装饰的函数 hello() 是没有带参数的，我们看看被装饰函数带参数的情况。对前面例子中的 hello() 函数进行改写，使其带参数，如下： def makeitalic ( func ): def wrapped ( * args , ** kwargs ): ret = func ( * args , ** kwargs ) return '<i>' + ret + '</i>' return wrapped @makeitalic def hello ( name ): return 'hello %s ' % name @makeitalic def hello2 ( name1 , name2 ): return 'hello %s , %s ' % ( name1 , name2 ) hello ( 'Jack' ) hello2 ( 'Jack' , \"Lusis\" ) 由于函数 hello 带参数，因此内嵌包装函数 wrapped 需要改变。 带参数的装饰器 上面的例子，我们增强了函数 hello 的功能，给它的返回加上了标签 <i>...</i> ，现在，我们想改用标签 <b>...</b> 或 <p>...</p> 。是不是要像前面一样，再定义一个类似 makeitalic 的装饰器呢？其实，我们可以定义一个函数，将标签作为参数，返回一个装饰器，比如： def wrap_in_tag ( tag ): def decorator ( func ): def wrapped ( * args , ** kwargs ): ret = func ( * args , ** kwargs ) return '<' + tag + '>' + ret + '</' + tag + '>' return wrapped return decorator 生成想要的装饰器了： makebold = wrap_in_tag ( 'b' ) # 根据 'b' 返回 makebold 生成器 @makebold def hello ( name ): return 'hello %s ' % name hello ( 'world' ) ' <b> hello world </b> ' 上面的形式也可以写得更加简洁： @wrap_in_tag ( 'b' ) def hello ( name ): return 'hello %s ' % name 多个装饰器 现在，让我们来看看多个装饰器的例子，为了简单起见，下面的例子就不使用带参数的装饰器。 def makebold ( func ): def wrapped (): return '<b>' + func () + '</b>' return wrapped def makeitalic ( func ): def wrapped (): return '<i>' + func () + '</i>' return wrapped @makebold @makeitalic def hello (): return 'hello world' 上面定义了两个装饰器，对 hello 进行装饰，上面的最后几行代码相当于： def hello (): return 'hello world' hello = makebold ( makeitalic ( hello )) 调用函数 hello： hello () ' <b><i> hello world </i></b> ' 基于类的装饰器 前面的装饰器都是一个函数，其实也可以基于类定义装饰器，看下面的例子： class Bold ( object ): def __init__ ( self , func ): self . func = func def __call__ ( self , * args , ** kwargs ): return '<b>' + self . func ( * args , ** kwargs ) + '</b>' @Bold def hello ( name ): return 'hello %s ' % name hello ( 'world' ) 可以看到，类 Bold 有两个方法： __init__() ：它接收一个函数作为参数，也就是被装饰的函数 __call__() ：让类对象可调用，就像函数调用一样，在调用被装饰函数时被调用 还可以让类装饰器带参数： class Tag ( object ): def __init__ ( self , tag ): self . tag = tag def __call__ ( self , func ): def wrapped ( * args , ** kwargs ): return \"< {tag} > {res} </ {tag} >\" . format ( res = func ( * args , ** kwargs ), tag = self . tag ) return wrapped @Tag ( 'b' ) def hello ( name ): return 'hello %s ' % name 需要注意的是，如果类装饰器有参数， 则 __init__ 接收参数，而 __call__ 接收 func。 装饰器的副作用 前面提到，使用装饰器有一个瑕疵，就是被装饰的函数，它的函数名称已经不是原来的名称了，回到最开始的例子： def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped @makeitalic def hello (): return 'hello world' 函数 hello 被 makeitalic 装饰后，它的函数名称已经改变了： hello . __name__ 'wrapped' 为了消除这样的副作用，Python 中的 functools 包提供了一个 wraps 的装饰器： from functools import wraps def makeitalic ( func ): @wraps ( func ) # 加上 wraps 装饰器 def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped @makeitalic def hello (): return 'hello world' hello . __name__ 'hello' 事实上，装饰器就是闭包的一种应用，但它比较特别，接收被装饰函数为参数，并返回一个函数，赋给被装饰函数，闭包则没这种限制。","text_tokens":["call","要求",":","locals","以",">","时","标签","下面","jack","+","带","s","器","让","返回","于","代表","想","one","two","比如","或类","对","我们","看出","起","args","副作用","不","简单","name","一下","decorator","中","tag","而","新","调用","本质","其带","则","其赋","这种","最","这个","def","现在","比较","根据","函数","但","已经","事实","定义","_","名称","如果","内嵌","}","成器","这样","lusis","作用","注意","由于","pass","两个","上面","name1","format","见","还","功能","变","有时候","提供","作为","对带","在","'","bold","使","—","例子","wraps","器带","是","看看","一种","调用函数","object","加上","前面","都","修改","并","name2","{","增强","wrapped","上","添加","(","makeitalic","绑定","kwargs","一般","p","__.","结果","最近","/","装饰","会","arg1","再","提到","%","包装","改用","需求","python","未免太","最后","类似","不是","基于","原来","可","瑕疵","赋给","hello","器先","『","未免","也","消除","可以","看到","应用","参数","希望","为了","wrap","from","想要","做","了","事实上","看","动态","』","要","实际上","b","限制","3","给","就是","函数调用","functools","*","func","改变","world","function","做法","套上","代码","当于","回到","@","相当于","将","<","用","是不是","简述","实际","就","它","总","闭包","hello2","来","接收","原函数","。","被","总结","生成","传入","需要","写得","class","简洁"," ","繁琐","（","包","）","相当","那么","后","名字","res","开始","对象","多个","print","几行","...","或","self","=","情况","一样","实现","有时","生成器","makebold",",","更加","main","：","因此","等价","离","器有","改写","时候","如下","ret","的","return","#",".","__","高阶","arg2","使用","与","import","\"","呢","方法","没","一个","没有","i","有","，","此时","变成","假设","像","makeitalic2","进行",")","这","？","其实","2","特别","html","形式","为","类","in","直接","init"],"title":"3.4.装饰器","title_tokens":[".","器","装饰","3.4"]},{"location":"Python基础/3.4.装饰器.html#_1","text":"有时候，我们需要给一个函数添加新功能。那么有一种做法就是修改原函数的代码，直接添加新功能。但这总做法有时未免太繁琐。在python中，直接给原函数套上装饰就可以实现这个需求。 假设有一个这样的函数： def hello (): return 'hello world' # hello函数的名字 print ( \"hello函数的名字：\" , hello . __name__ ) hello函数的名字： hello 现在我们想增强 hello() 函数的功能，希望给返回加上 HTML 标签，比如 <i>hello world</i> ，但有一个要求，不改变原来 hello() 函数的定义。 那么可以这样做： def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped 要注意的是，makeitalic函数的参数是一个函数，返回的结果是wrapped函数。 # 给hello函数套上makeitalic函数 # makeitalic函数返回wrapped函数 # 实际上此时hello变成了wrapped函数 hello = makeitalic ( hello ) 将 hello 函数作为参数传入 makeitalic 函数， makeitalic 函数返回wrapped函数，名字 hello 与 wrapped 函数绑定。此时名字 hello 代表了一个函数，也就是 wrapped 函数有了新的名字—— hello 。 # 可以看出hello函数的名字变了 print ( \"hello函数的名字：\" , hello . __name__ ) hello函数的名字： wrapped 总结一下：为了增强原函数 hello 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数。 事实上， makeitalic 就是一个装饰器（decorator），它『装饰』了函数 hello ，并返回一个函数，将其赋给 hello 。 像上面的情况，可以动态修改函数（或类）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 hello ）为参数，并返回一个包装后的函数（比如上面的 wrapped ）给被装饰函数（ hello ）。","text_tokens":["要求",":","以",">","标签","+","器","返回","代表","想","比如","或类","我们","看出","不","name","一下","decorator","中","新","本质","其赋","这个","def","现在","函数","但","事实","定义","这样","注意","上面","功能","变","有时候","作为","在","'","—","是","一种","加上","修改","并","增强","wrapped","上","添加","(","makeitalic","绑定","结果","/","装饰","包装","需求","python","未免太","原来","hello","『","未免","也","可以","参数","希望","为了","做","了","事实上","动态","』","要","实际上","给","就是","func","改变","world","做法","套上","代码","将","<","实际","它","就","总","接收","原函数","。","被","总结","传入","需要"," ","繁琐","（","）","那么","后","名字","print","=","情况","实现","有时",",","：","时候","的","return","#",".","__","高阶","与","\"","一个","i","有","，","此时","变成","假设","像",")","这","html","为","直接"],"title":"装饰器简述","title_tokens":["简述","器","装饰"]},{"location":"Python基础/3.4.装饰器.html#_2","text":"在python中，装饰器一般这样用： @decorator def func (): pass 等价于下面的形式 ： def func (): pass func = decorator ( func ) 装饰器可以定义多个，离函数定义最近的装饰器先被调用，比如 @decorator_one @decorator_two def func (): pass 等价于： def func (): pass func = decorator_one ( decorator_two ( func )) 装饰器还可以带参数，比如： @decorator ( arg1 , arg2 ) def func (): pass 等价于： def func (): pass func = decorator ( arg1 , arg2 )( func ) 例子： def makeitalic2 ( func ): return \"<i>\" + func () + \"</i>\" @makeitalic def hello_2 (): return 'hello world' def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped hello_2 () ' <i> hello world </i> ' 如果返回的不是函数就会这样： @makeitalic def hello_3 (): return 'hello world' def makeitalic ( func ): return \"<i>\" + func () + \"</i>\" hello_3 <function __main__.makeitalic.<locals>.wrapped()>","text_tokens":[":","可以","还","多个","locals","参数",">","下面","=","在","'",",","带","+","器","例子","于","返回","main","：","3","one","two","比如","等价","离","func","decorator","中","hello","world","wrapped","的","调用","return","(","makeitalic","function",".","__","一般","@","arg2","<","用","def","最近","/","__.","装饰","\"","就","会","函数","arg1","i","，","定义","_","python","如果","makeitalic2",")","被","2","这样","形式","pass"," ","器先","不是"],"title":"装饰器的一般使用形式","title_tokens":["的","器","一般","使用","装饰","形式"]},{"location":"Python基础/3.4.装饰器.html#_3","text":"前面的例子中，被装饰的函数 hello() 是没有带参数的，我们看看被装饰函数带参数的情况。对前面例子中的 hello() 函数进行改写，使其带参数，如下： def makeitalic ( func ): def wrapped ( * args , ** kwargs ): ret = func ( * args , ** kwargs ) return '<i>' + ret + '</i>' return wrapped @makeitalic def hello ( name ): return 'hello %s ' % name @makeitalic def hello2 ( name1 , name2 ): return 'hello %s , %s ' % ( name1 , name2 ) hello ( 'Jack' ) hello2 ( 'Jack' , \"Lusis\" ) 由于函数 hello 带参数，因此内嵌包装函数 wrapped 需要改变。","text_tokens":[":","参数",">","=","情况","jack","'",",","带","+","使","s","例子","是","：","看看","对","因此","我们","前面","args","改写","如下","ret","*","func","中","name","name2","wrapped","改变","的","return","(","makeitalic","kwargs","其带","@","<","def","/","装饰","\"","函数","没有","i","hello2"," ","，","%","包装","进行","。","被",")","内嵌","lusis","需要","由于","hello","name1"],"title":"对带参数的函数进行装饰","title_tokens":["的","进行","参数","对带","装饰","函数"]},{"location":"Python基础/3.4.装饰器.html#_4","text":"上面的例子，我们增强了函数 hello 的功能，给它的返回加上了标签 <i>...</i> ，现在，我们想改用标签 <b>...</b> 或 <p>...</p> 。是不是要像前面一样，再定义一个类似 makeitalic 的装饰器呢？其实，我们可以定义一个函数，将标签作为参数，返回一个装饰器，比如： def wrap_in_tag ( tag ): def decorator ( func ): def wrapped ( * args , ** kwargs ): ret = func ( * args , ** kwargs ) return '<' + tag + '>' + ret + '</' + tag + '>' return wrapped return decorator 生成想要的装饰器了： makebold = wrap_in_tag ( 'b' ) # 根据 'b' 返回 makebold 生成器 @makebold def hello ( name ): return 'hello %s ' % name hello ( 'world' ) ' <b> hello world </b> ' 上面的形式也可以写得更加简洁： @wrap_in_tag ( 'b' ) def hello ( name ): return 'hello %s ' % name","text_tokens":[":",">","标签","+","s","器","返回","想","比如","我们","args","tag","name","decorator","def","现在","根据","函数","_","定义","成器","上面","功能","作为","'","例子","加上","前面","增强","wrapped","makeitalic","(","kwargs","p","/","装饰","再","%","改用","类似","hello","也","可以","参数","wrap","想要","了","要","b","给","*","func","world","@","将","<","是不是","它","。","生成","写得","简洁"," ","...","或","=","一样","生成器","makebold",",","更加","：","ret","的","return","#","呢","一个","i","，","其实","像","？",")","形式","in","不是"],"title":"带参数的装饰器","title_tokens":["的","器","参数","装饰","带"]},{"location":"Python基础/3.4.装饰器.html#_5","text":"现在，让我们来看看多个装饰器的例子，为了简单起见，下面的例子就不使用带参数的装饰器。 def makebold ( func ): def wrapped (): return '<b>' + func () + '</b>' return wrapped def makeitalic ( func ): def wrapped (): return '<i>' + func () + '</i>' return wrapped @makebold @makeitalic def hello (): return 'hello world' 上面定义了两个装饰器，对 hello 进行装饰，上面的最后几行代码相当于： def hello (): return 'hello world' hello = makebold ( makeitalic ( hello )) 调用函数 hello： hello () ' <b><i> hello world </i></b> '","text_tokens":["相当",":","多个","几行","参数","为了",">","下面","=","了","makebold","'","带","b","+","器","让","例子","：","看看","对","我们","起","不","简单","func","world","hello","wrapped","的","return","调用","(","makeitalic","代码","当于","@","相当于","使用","<","def","现在","/","装饰","就","函数","i","来","，","定义","最后","进行","调用函数","。",")","两个"," ","上面","见"],"title":"多个装饰器","title_tokens":["多个","器","装饰"]},{"location":"Python基础/3.4.装饰器.html#_6","text":"前面的装饰器都是一个函数，其实也可以基于类定义装饰器，看下面的例子： class Bold ( object ): def __init__ ( self , func ): self . func = func def __call__ ( self , * args , ** kwargs ): return '<b>' + self . func ( * args , ** kwargs ) + '</b>' @Bold def hello ( name ): return 'hello %s ' % name hello ( 'world' ) 可以看到，类 Bold 有两个方法： __init__() ：它接收一个函数作为参数，也就是被装饰的函数 __call__() ：让类对象可调用，就像函数调用一样，在调用被装饰函数时被调用 还可以让类装饰器带参数： class Tag ( object ): def __init__ ( self , tag ): self . tag = tag def __call__ ( self , func ): def wrapped ( * args , ** kwargs ): return \"< {tag} > {res} </ {tag} >\" . format ( res = func ( * args , ** kwargs ), tag = self . tag ) return wrapped @Tag ( 'b' ) def hello ( name ): return 'hello %s ' % name 需要注意的是，如果类装饰器有参数， 则 __init__ 接收参数，而 __call__ 接收 func。","text_tokens":["call",":",">","时","下面","+","s","器","让","args","name","tag","而","调用","则","def","函数","定义","如果","}","注意","两个","format","还","作为","bold","'","在","例子","器带","是","object","前面","都","{","wrapped","(","kwargs","/","装饰","%","可","基于","hello","也","可以","看到","参数","看","b","就是","函数调用","*","func","world","@","<","它","就","接收","。","被","class","需要"," ","res","对象","self","=","一样",",","：","器有","的","return",".","__","方法","\"","一个","有","，","其实","像",")","类","init"],"title":"基于类的装饰器","title_tokens":["的","器","基于","装饰","类"]},{"location":"Python基础/3.4.装饰器.html#_7","text":"前面提到，使用装饰器有一个瑕疵，就是被装饰的函数，它的函数名称已经不是原来的名称了，回到最开始的例子： def makeitalic ( func ): def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped @makeitalic def hello (): return 'hello world' 函数 hello 被 makeitalic 装饰后，它的函数名称已经改变了： hello . __name__ 'wrapped' 为了消除这样的副作用，Python 中的 functools 包提供了一个 wraps 的装饰器： from functools import wraps def makeitalic ( func ): @wraps ( func ) # 加上 wraps 装饰器 def wrapped (): return \"<i>\" + func () + \"</i>\" return wrapped @makeitalic def hello (): return 'hello world' hello . __name__ 'hello' 事实上，装饰器就是闭包的一种应用，但它比较特别，接收被装饰函数为参数，并返回一个函数，赋给被装饰函数，闭包则没这种限制。","text_tokens":[":",">","+","器","返回","副作用","name","中","则","这种","最","比较","def","已经","函数","但","事实","名称","这样","作用","提供","'","例子","wraps","一种","加上","前面","并","wrapped","makeitalic","(","/","装饰","提到","瑕疵","python","赋给","原来","hello","消除","应用","参数","为了","from","了","事实上","限制","就是","functools","func","world","改变","回到","@","<","它","闭包","接收","。","被"," ","包","后","开始","：","器有","的","return","#",".","__","使用","import","\"","没","一个","i","，","特别",")","为","不是"],"title":"装饰器的副作用","title_tokens":["的","器","副作用","作用","装饰"]},{"location":"Python基础/4.1.类.html","text":"类提供了一种组合数据和功能的方法。类通常是由函数（称为方法，method）、变量（称为类变量，class variable）和计算出的属性（称为特性，property）组成的集合。创建一个新类意味着创建一个新类型的对象，从而允许创建一个该类型的新实例。每个类的实例可以拥有保存自己状态的属性。 Python 的类提供了面向对象编程的所有标准特性：类继承机制允许多个基类，派生类可以覆盖它基类的任何方法，一个方法可以调用基类中相同名称的的方法。对象可以包含任意数量和类型的数据。和模块一样，类也拥有 Python 天然的动态特性：它们在运行时创建，可以在创建后修改。 在Python中，约定使用单数并将首字母大写。 类中定义的函数称为 实例方法 。实例方法是一种在类的实例上进行操作的函数，类实例作为第一个参数传递。根据约定，这个参数称为self，尽管所有合法的标识符都可以使用。 self 参数指向对象本身。 self 很有用，甚至必不可少。如果没有它，所有的方法都无法访问对象本身（要操作的属性所属的对象）。 类变量 是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。 类实例 类的实例是以函数形式调用类对象来创建的。这种方法将创建一个新实例，然后将该实例传递给类的 __init__() 方法。 __init__() 方法的参数包括新创建的实例 self 和在调用类对象时提供的参数。 在 __init__() 内，通过将属性分配给 self 来将其保存到实例中。例如， self.name = name 表示将 name 属性保存在实例中。其中，点 . 运算符用于属性绑定。在新创建的实例返回到用户之后，使用点 . 运算符即可访问这些属性以及类的属性。 访问属性时，结果值可能来自多个不同的地方。可能来自实例独有的属性，也可能来自类的属性。访问属性时，Python 首先会检查实例，如果不知道该属性的任何信息，则会对实例的类进行搜索。这是类与其所有实例共享其属性的底层机制。 继承 继承是一种创建新类的机制，目的是使用或修改现有类的行为。原始类称为 基类 或 超类 。新类称为 派生类 或 子类 。 通过继承创建类时，所创建的类将“继承”其基类定义的属性。==但是，==派生类可以重新定义任何这些属性并添加自己的新属性。 在class语句中用以逗号分隔的基类名称列表来指定继承。如果没有有效的基类，类将继承object。object是所有Python对象的根类，提供了一些常见方法（如 __str__() ，它可创建供打印函数使用的字符串）的默认实现。 继承通常用于重新定义现有方法的行为。 继承是用功能稍微增强的点 . 运算符实现的。具体来讲，如果搜索一个属性时未在实例或实例的类中找到匹配项，将会继续搜索基类。这个过程会一直继续下去，直到没有更多的基类可供搜索为止。 派生类重定义 __init__() 时，不会自动调用基类的 __init__() 方法。因此，如果派生类想重定义 __init__() ，还想调用基类的 __init__() 方法，那么要由派生类调用基类的 __init__() 方法来对它们进行恰当的初始化。如果基类未定义 __init__() ，就可以忽略这一步。如果不知道基类是否定义了 __init__() ，可在不提供任何参数的情况下调用它，因为始终存在一个不执行任何操作的默认 __init__() 实现。 # 定义一个人类 class Person : def __init__ ( self , name , age ): self . name = name self . age = age def get_name ( self ): return self . name def get_age ( self ): return self . age # 定义一个美国人类 ## 现在想给美国人在初始化的时候加上 性别 的属性 class American ( Person ): # 重新定义__init__()会覆盖Person的__init__()方法 def __init__ ( self , name , age , gender ): Person . __init__ ( self , name , age ) self . gender = gender def get_gender ( self ): return self . gender jackson = American ( name = \"Cesar T. Mauck\" , age = 14 , gender = \"male\" ) jackson . get_age () 14 jackson . get_gender () 'male' # 有时，派生类将重新实现方法，但是还想调用原始的实现。 为此，有一种方法可以显式地调用基类中的原始方法，将实例 self 作为第一个参数传递即可，如下所示： # 定义一个华盛顿人类 class Washington ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 age = American . get_age () age += 1 self . age = age print ( \"Washington people grow up one year old\" ) 这个例子的微妙之处在于，American这个类其实没有实现 get_age() 方法。该方法是在Person类中实现的。尽管这段代码能够运行，但它可能会引起一些混淆（例如，American是否应该实现 get_age() ? ）。因此，替代解决方案是用 super() 函数，如下所示： # 定义一个加利福尼亚人类 class California ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 ## 实际上，因为get_age()方法在Person中定义 ## 这里可以传入Person的任何一个派生类 age = super ( California , self ) . get_age () age += 1 self . age = age print ( \"Californians grow up one year old\" ) Terri = California ( \"Terri H. Booth\" , 25 , \"female\" ) Terri . growing_up () Californians grow up one year old super(cls, instance) 会返回一个特殊对象，该对象支持在基类上执行属性查找。如果使用该函数，Python将使用本来应该在基类上使用的正常搜索规则来搜索属性。有了这种方式，就无需写死方法位置，并且能更清晰地陈述你的意图（即你希望调用以前的实现，无论它是哪个基类定义的）。然而， super() 的语法尚有不足之处。如果使用Python 3，可以使用简化的语句 super().get_age() 来执行上面示例中的计算。 多重继承 Python支持多重继承。通过让一个类列出多个基类即可指定多重继承。例如，下面给出了一个类集合： # 定义一个圣拉蒙人类 class San_Ramon ( American , California , Washington ): def growing_up ( self ): pass Edwin = San_Ramon ( \"Edwin A. Marcotte\" , 37 , \"male\" ) Edwin . get_age () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-6c60ffbe4e5a> in <module> 1 # 定义一个圣拉蒙人类 ----> 2 class San_Ramon(American, California, Washington): 3 def growing_up(self): 4 pass 5 TypeError: Cannot create a consistent method resolution order (MRO) for bases American, California, Washington 使用多重继承时，属性的解析会变得非常复杂，因为可以使用很多搜索路径来绑定属性。 在查找使用了多重继承的属性时，会将所有基类按从“最特殊”的类到“最不特殊”的类这种顺序进行排列。然后在搜索属性时，就会按这个顺序搜索，直至找到该属性的第一个定义。对于任何给定的类，通过打印它的 mro 属性即可查看基类的顺序，例如： 在大多数情况下，这个列表基于“有意义”的规则排列得出。也就是说，始终先检查派生类，然后再检查其基类，如果一个类具有多个父类，那么始终按类定义中列出的父类顺序检查这些父类。但是，基类的准确顺序实际上非常复杂，不是基于任何“简单的”算法，如深度优先或广度优先搜索。实际上，基类的顺序由 C3 线性化算法确定，可以在论文“A Monotonic Superclass Linearization for Dylan”（K. Barrett 等，发表于 OOPSLA’96）中找到该算法的介绍。该算法的一个需要注意的地方是，某些类层次结构将被 Python 拒绝并会抛出 TypeError 错误，例如： 一般来说，在大多数程序中最好避免使用多重继承。但是，多重继承有时可用于定义所谓的混合（mixin）类。混合类通常定义了要“混合到”其他类中的一组方法，目的是添加更多的功能（这与宏很类似）。通常，混合类中的方法将假定其他方法存在，并将以这些方法为基础构建。 多态动态绑定和鸭子类型 动态绑定（在继承背景下使用时，有时也称为多态性）是指在不考虑实例类型的情况下使用实例只要以 obj.attr 的形式访问属性，就会按照一定的顺序搜索并定位 attr ： 首先是实例本身，接着是实例的类定义，然后是基类。 查找过程会返回第一个匹配项。 这种绑定过程的关键在于，它不受对象 obj 的类型影响。因此，如果执行像 obj.name 这样的查找，对所有拥有 name 属性的 obj 都是适用的。这种行为有时被称为“鸭子类型”（duck typing），这个名称来源于一句谚语：“如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子。” Python 程序员经常编写利用这种行为的程序。例如，如果想编写现有对象的自定义版本，可以继承该对象，也可以创建一个外观和行为像它但与它无任何关系的全新对象。后一种方法通常用于保持程序组件的松散耦合。例如，可以编写代码来处理任何种类的对象，只要该对象拥有特定的方法集。最常见的例子就是利用标准库中定义的各种“类似文件”的对象。尽管这些对象的工作方式像文件，但它们并不是继承自内置文件对象的。 实例方法 类中最常用的方法是实例方法，即 将实例作为第一个参数传递给该方法。 例如，基本的实例方法如下： class Kls ( object ): def __init__ ( self , data ): self . data = data def printd ( self ): print ( self . data ) ik1 = Kls ( 'arun' ) ik2 = Kls ( 'seema' ) ik1 . printd () ik2 . printd () arun seema 然后看一下代码和示例图片: 在1、2中，参数传递给方法。 在3中， self参数指向当前实例。 在4中，我们不需要给方法提供实例， Python解释器自己会做这些操作 。 静态方法 Note 以下两个代码示例介绍了静态方法的两个应用场景： 不需要访问实例对象或类对象的方法和属性，但与类有关的功能 创建构造函数 经常有一些跟类有关系的功能，但在运行时又不需要实例和类参与（比如更改环境变量或者修改其他类的属性），当然可以在类定义之外写一个函数实现这些功能，但这样会扩散类内部的代码，不利于代码的维护。比如这样： IND = 'ON' def checkind (): return ( IND == 'ON' ) class Kls ( object ): def __init__ ( self , data ): self . data = data def do_reset ( self ): if checkind (): print ( 'Reset done for:' , self . data ) def set_db ( self ): if checkind (): self . db = 'new db connection' print ( 'DB connection made for:' , self . data ) ik1 = Kls ( 12 ) do_reset ( ik1 ) # Reset done for: 12 set_db ( ik1 ) # DB connection made for: 12 如果使用 @staticmethod 就能把相关的代码放到对应的位置了。 IND = 'ON' class Kls ( object ): def __init__ ( self , data ): self . data = data @staticmethod def checkind (): return ( IND == 'ON' ) def do_reset ( self ): if self . checkind (): print ( 'Reset done for:' , self . data ) def set_db ( self ): if self . checkind (): self . db = 'New db connection' print ( 'DB connection made for: ' , self . data ) ik1 = Kls ( 12 ) ik1 . do_reset () ik1 . set_db () Reset done for: 12 DB connection made for: 12 实际上，静态方法是一种普通函数，只不过它们正好位于类定义的命名空间中， 因为它不会对任何实例类型进行操作 。 如果在编写类时需要采用很多不同的方式来创建新实例，则常常使用静态方法。因为类中只能有一个 __init__() 函数，所以替代的创建函数通常按如下方式定义： import time class Date ( object ): def __init__ ( self , year , month , day ): self . year = year self . month = month self . day = day @staticmethod def now (): t = time . localtime () return Date ( t . tm_year , t . tm_mon , t . tm_mday ) @staticmethod def tomorrow (): t = time . localtime ( time . time () + 86400 ) return Date ( t . tm_year , t . tm_mon , t . tm_mday ) # 创建日期的示例 a = Date ( 1967 , 4 , 9 ) b = Date . now () # 调用静态方法now() c = Date . tomorrow () # 调用静态方法tomorrow() 类方法 Note 以下两个代码示例介绍了类方法的两个应用场景： 创建构造函数 动态更新类 类方法是将类本身作为对象进行操作的方法。类方法使用 @classmethod 装饰器定义，与实例方法不同，Python解释器会将类本身传递给类方法的第一个参数（一般将该参数命名为 cls ）。例如： class Times ( object ): factor = 1 @classmethod def mul ( cls , x ): return cls . factor * x class TwoTimes ( Times ): factor = 2 x = TwoTimes . mul ( 4 ) # 调用Times.mul(TwoTimes, 4) -> 8 在这个例子中，请注意类 TwoTimes 是如何作为对象传递给 mul() 的。尽管这个例子有些深奥，但类方法还有一些实用且巧妙的用法。例如，你定义了一个类，它继承自前面给出的 Date 类并对其略加定制： class EuroDate ( Date ): # 修改字符串转换，以使用欧洲日期格式 def __str__ ( self ): return \" %02d / %02d / %4d \" % ( self . day , self . month , self . year ) 由于该类继承自 Date，所以它拥有 Date 的所有特性。但是 now() 和 tomorrow() 方法稍微有点不同。例如，如果调用 EuroDate.now()，则会返回 Date 对象，而不是 EuroDate 对象。类方法可以解决该问题： class Date ( object ): def __init__ ( self , year , month , day ): self . year = year self . month = month self . day = day @classmethod def now ( cls ): t = time . localtime () return cls ( t . tm_year , t . tm_mon , t . tm_mday ) @classmethod def tomorrow ( cls ): t = time . localtime ( time . time () + 86400 ) return cls ( t . tm_year , t . tm_mon , t . tm_mday ) class EuroDate ( Date ): # 修改字符串转换，以使用欧洲日期格式 def __str__ ( self ): return \" %02d / %02d / %4d \" % ( self . day , self . month , self . year ) a = Date . now () # 调用Date.now(Date)并返回Date b = EuroDate . now () # 调用Date.now(EuroDate)并返回EuroDate print ( type ( a )) print ( type ( b )) <class '__main__.Date'> <class '__main__.EuroDate'> 类方法除了用于创建构造函数，另一个例子是动态更新类。例如我们想动态更新一个类属性： class Kls ( object ): models = {} def __init__ ( self , model_name ): # 加载模型 pass @classmethod def load_model ( cls , model_name ): cls . models [ model_name ] = cls ( model_name ) @classmethod def get_model ( cls , model_name ): return cls . models . get ( model_name , None ) def predict ( self ): return \"预测结果为1\" model_name = \"svm\" Kls . load_model ( model_name ) model = Kls . get_model ( model_name ) model . predict () '预测结果为1' Kls . models {'svm': <__main__.Kls at 0x215c1ba3d30>} 当然，除了使用类方法，也可以在实例方法中显式调用类属性，达到动态更新类的效果，例如我们要获取实例数： class Kls ( object ): no_inst = 0 def __init__ ( self ): Kls . no_inst = Kls . no_inst + 1 @classmethod def get_no_of_instance ( cls_obj ): return cls_obj . no_inst ik1 = Kls () ik2 = Kls () print ( ik1 . get_no_of_instance ()) print ( Kls . get_no_of_instance ()) 2 2 但是如果要用实例方法实现的话，就得创建一个实例对象，这意味着我们必须要给这个实例对象命名。在编程中，给过多的变量命名，有时是一个头疼的问题。 在类外面写一个函数也可以实现这样的效果，但不利于代码的维护。 def get_no_of_instances ( cls_obj ): return cls_obj . no_inst class Kls ( object ): no_inst = 0 def __init__ ( self ): Kls . no_inst = Kls . no_inst + 1 ik1 = Kls () ik2 = Kls () print ( get_no_of_instances ( Kls )) 2 实例方法、静态方法、类方法对比 在实例方法和类方法中，Python默认将当前实例或者类对象传给方法的第一个参数（非指定默认值的参数），如果方法不设置参数，便会报错： class Kls ( object ): def __init__ ( self , data ): self . data = data def imethod1 (): print ( \"不接收实例\" ) def imethod2 ( * arg ): print ( 'Instance:' , arg ) @staticmethod def smethod ( * arg ): print ( 'Static:' , arg ) @classmethod def cmethod1 (): print ( \"不接收类对象\" ) @classmethod def cmethod2 ( * arg ): print ( 'Class:' , arg ) ik3 = Kls ( 'arun' ) ik3 . imethod1 () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-82fbcd62768a> in <module> 1 ik3 = Kls('arun') ----> 2 ik3.imethod1() TypeError: imethod1() takes 0 positional arguments but 1 was given ik3 . cmethod1 () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-6055e1d64eee> in <module> ----> 1 ik3.cmethod1() TypeError: cmethod1() takes 0 positional arguments but 1 was given 实例方法、类方法必须设置参数接收类对象： ik3 . imethod2 () ik3 . cmethod2 () Instance: (<__main__.Kls object at 0x00000215C1B91F28>,) Class: (<class '__main__.Kls'>,) 静态方法则不会传入实例或类对象： ik3 . smethod () Static: () 如果方法不设置参数，只能通过类去调用，应该避免这种用法，没参数的方法应该加上 @staticmethod 装饰器： Kls . imethod1 () 不接收实例 关于静态方法和类方法需要注意的一点是，Python 不会在与实例方法独立的命名空间中管理它们。因此，可以通过实例或类调用它们。例如： Kls . cmethod2 () Kls ( 'arun' ) . cmethod2 () Kls . smethod () Kls ( 'arun' ) . smethod () Class: (<class '__main__.Kls'>,) Class: (<class '__main__.Kls'>,) Static: () Static: () 这可能很容易引起混淆，因为对 Kls('arun').cmethod2() 的调用与实例 Kls('arun') 没有任何关系。 这种行为是 Python 对象系统与其他面向对象语言（如 Smalltalk 和 Ruby）对象系统的区别之一。在这些语言中，类方法与实例方法是严格分开的。 而实例方法必须通过实例调用，因为需要传入实例。 特性 @property ——把方法变为属性 通常，访问实例或类的属性时，返回的会是所存储的相关值。特性（property）是一种特殊的属性，访问它时会计算它的值。下面是一个简单的例子： import math class Circle ( object ): def __init__ ( self , radius ): self . radius = radius # Circle的一些附加特性 @property def area ( self ): return math . pi * self . radius ** 2 @property def preimeter ( self ): return 2 * math . pi * self . radius 得到的Circle对象的行为如下： c = Circle ( 4.0 ) c . radius 4.0 c . area 50.26548245743669 c . preimeter 25.132741228718345 c . area = 2 ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-0dac39a0c579> in <module> ----> 1 c.area = 2 AttributeError: can't set attribute 在这个例子中，Circle 实例存储了一个实例变量 c.radius 。 c.area 和 c.perimeter 是根据该值计算得来的。 @property 装饰器支持以简单属性的形式访问后面的方法，无需像平常一样添加额外的 () 来调用该方法。对象的使用者很难发现正在计算一个属性，除非在试图重新定义该属性时生成了错误消息（如上面的 AttributeError 异常所示）。 这种特性使用方式遵循所谓的统一访问原则。 实际上，如果定义一个类，尽可能保持编程接口的统一总是不错的。如果没有特性，将会以简单属性（如 c.radius ）的形式访问对象的某些属性，而其他属性将以方法（如 c.area() ）的形式访问。费力去了解何时添加额外的 () 会带来不必要的混淆。特性可以解决该问题。 Python 程序员很少认识到， 方法本身是被隐式地作为一类特性处理的。 考虑下面这个类： class Foo ( object ): def __init__ ( self , name ): self . name = name def spam ( self , x ): print ( \" %s , %s \" % ( self . name , x )) Foo ( \"d\" ) . spam <bound method Foo.spam of <__main__.Foo object at 0x00000215C1BB43C8>> 用户创建 f = Foo(\"Guido\") 这样的实例然后访问 f.spam 时，不会返回原始函数对象 spam ，而是会得到所谓的绑定方法（bound method），绑定方法是一个对象，代表将在对象上调用 () 运算符时执行的方法调用。绑定方法有点类似于已部分计算的函数，其中的self参数已经填入，但其他参数仍然需要在使用 () 调用该函数时提供。这种绑定方法对象是由在后台执行的特性函数静默地创建的。 使用 @staticmethod 和 @classmethod 定义静态方法和类方法时，实际上就指定了使用不同的特性函数，以不同的方式处理对这些方法的访问。 例如， @staticmethod 仅“按原样”返回方法函数，不会进行任何特殊的包装或处理。 特性还可以截获操作权，以设置和删除属性。这是通过向特性附加其他 setter 和 deleter 方法来实现的，如下所示： class Foo ( object ): def __init__ ( self , name ): self . __name = name @property def name ( self ): return self . __name @name . setter def name ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value @name . deleter def name ( self ): raise TypeError ( \"Can't delete name\" ) 在这个例子中，首先使用 @property 装饰器和相关方法将属性 name 定义为只读特性。后面的 @name.setter 和 @name.deleter 装饰器将其他方法与 name 属性上的设置和删除操作相关联。这些方法的名称必须与原始特性的名称完全匹配。在这些方法中，请注意实际的名称值存储在属性 __name 中。所存储属性的名称无需遵循任何约定，但它必须与特性名称不同，以便将它与特性的名称区分开。 在以前的代码中，通常会看到用 property(getf=None, setf=None, delf=None, doc=None) 函数来定义特性，往其中传入一组名称不同的方法，用于执行相关操作。例如： class Foo ( object ): def getname ( self ): return self . __name def setname ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value def delname ( self ): raise TypeError ( \"Can't delete name\" ) name = property ( getname , setname , delname ) 这种老方法仍然可以使用，但装饰器版本会让类看起来更整洁。 例如，如果使用装饰器，get、 set 和 delete 函数将不会显示为方法。 数据封装和私有属性 默认情况下，类的所有属性和方法都是“公共的”。这意味着对它们的访问没有任何限制。这还暗示着，在基类中定义的所有内容都会被派生类继承，并可从派生类内进行访问。在面向对象的应用程序中，通常我们不希望发生这种行为，因为它会暴露对象的内部实现，可能导致在派生类中定义的对象与在基类中定义的对象之间发生命名空间冲突。 Note 这意味着派生类可以覆盖基类的定义。 为了解决该问题， 类中所有以双下划线开头的名称（如 __Foo ）都会自动变形，形成具有 _Classname__Foo 形式的新名称。 这提供了一种在类中添加私有属性和方法的有效方式，因为派生类中使用的私有名称不会与基类中使用的相同私有名称发生冲突，如下所示： class A ( object ): def __init__ ( self ): self . __X = 3 # 变形为self._A__X def __spam ( self ): # 变形为_A__spam() print ( \"A\" ) def bar ( self ): self . __spam () # 只调用A.__spam() class B ( A ): def __init__ ( self ): A . __init__ ( self ) self . __X = 37 # 变形为self._B__X def __spam ( self ): # 变形为_B__spam() print ( \"B\" ) b = B () # 派生类的定义没有覆盖基类的定义 b . bar () A 尽管这种方案似乎隐藏了数据，但并没有严格的机制来实际阻止对类的“私有”属性进行访问。特别是如果已知类名称和相应私有属性的名称，则可以使用变形后的名称来访问它们。通过重定义 dir() 方法，类可以降低这些属性的可见性， dir() 方法提供了检查对象的 dir() 函数所返回的名称列表。 尽管这种名称变形似乎是一个额外的处理步骤，但变形过程实际上只在定义类时发生一次。它不会在方法执行期间发生，也不会为程序的执行添加额外的开销。而且要知道，名称变形不会在 getattr() 、 hasattr() 、 setattr() 或 delattr() 等函数中发生，在这些函数中，属性名被指定为字符串。对于这些函数，需要显式使用变形名称（如 __Classname__name ）来访问属性。 建议在定义可变属性时，通过特性来使用私有属性。这样，就可鼓励用户使用特性名称，而无需直接访问底层实例数据（如果你在实例开头添加了一个特性，可能不想采用这种访问方式）。 通过为方法提供私有名称，超类可以阻止派生类重新定义和更改方法的实现。 例如，示例中的 A.bar() 方法只调用 A.__spam() ，无论 self 具有何种类型，或者派生类中是否存在不同的 __spam() 方法都是如此。 最后，不要混淆私有类属性的命名和模块中“私有”定义的命名。一个常见的错误是，在定义类时，在属性名上使用单个前导下划线来隐藏属性值（如 _name ）。 在模块中，这种命名约定可以阻止通过 from module import * 语句导出名称。 这意味着单下划线开头的定义只能被类本身和其派生类访问。但是在类中，这种命名约定既不能隐藏属性，在某个类继承该类并使用相同名称定义一个新属性或方法时，也不能阻止出现名称冲突。 对象表示和属性绑定 从内部实现上看，实例是使用字典来实现的，可以通过实例的 __dict__ 属性访问该字典。这个字典包含的数据对每个实例而言都是唯一的，如下所示： class Account ( object ): def __init__ ( self , name , balance ): self . name = name self . balance = balance a = Account ( \"Guido\" , 1100.0 ) a . __dict__ {'name': 'Guido', 'balance': 1100.0} 可以在任何时候向实例添加新属性，例如： a . number = 123456 # 将属性'number'添加到 a.__dict__ 对实例的修改始终会反映到局部 __dict__ 属性中。同样，如果直接对 __dict__ 进行修改，所做的修改也会反映在实例的属性中。 实例通过特殊属性 __class__ 链接回它们的类。类本身也只是对字典的浅层包装，你可以在实例的 __dict__ 属性中找到这个字典。可以在类字典中找到各种方法。例如： a . __class__ __main__.Account Account . __dict__ . keys () dict_keys(['__module__', '__init__', '__dict__', '__weakref__', '__doc__']) 最后，通过特殊属性 __bases__ 中将类链接到它们的基类，该属性是一个基类元组。这种底层结构是获取、设置和删除对象属性的所有操作的基础。 只要使用 obj.name = value 设置了属性，特殊方法 obj.__setattr__(\"name\", value) 就会被调用。如果使用 del obj.name 删除了一个属性，就会调用特殊方法 obj.__delattr__(\"name\") 。 这些方法的默认行为是修改或删除 obj 的局部 __dict__ 的值，除非请求的属性正好是一个特性或描述符。在这种情况下，设置和删除操作将由与该特性相关联的设置和删除函数执行。 在查找属性（如 obj.name ）时，将调用特殊方法 obj.__getattrribute__(\"name\") 。该方法执行搜索来查找该属性，这通常涉及检查特性、查找局部 __dict__ 属性、检查类字典以及搜索基类。如果搜索过程失败，最终会尝试调用类的 __getattr__() 方法（如果已定义）来查找该属性。如果这也失败，就会抛出 AttributeError 异常。 如果有必要，用户定义的类可以实现其自己的属性访问函数。例如： import math class Circle ( object ): def __init__ ( self , radius ): self . radius = radius def __getattr__ ( self , name ): if name == 'area' : return math . pi * self . radius ** 2 elif name == 'perimeter' : return 2 * math . pi * self . radius else : return object . __getattr__ ( self , name ) def __setattr__ ( self , name , value ): if name in [ 'area' , 'perimeter' ]: raise TypeError ( \" %s is readonly\" % name ) from None object . __setattr__ ( self , name , value ) c = Circle ( 2 ) c . area 12.566370614359172 c . area = 10 ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-52599b4ddcfc> in <module> ----> 1 c.area = 10 <ipython-input-1-a1a0cdcb1eb3> in __setattr__(self, name, value) 13 def __setattr__(self,name,value): 14 if name in ['area','perimeter']: ---> 15 raise TypeError(\"%s is readonly\" % name) from None 16 object.__setattr__(self,name,value) TypeError: area is readonly 重新实现这些方法的类应该可以依靠 object 中的默认实现来执行实际的工作。这是因为默认实现能够处理类的更高级特性，如描述符和特性。 一般来讲，类很少重新定义属性访问运算符。但是，在编写通用的包装器和现有对象的代理时，通常会使用属性访问运算符。通过重新定义 __getattr__() 、 __setattr__() 和 __delattr__() ，代理可以捕获属性访问操作，并透明地将这些操作转发给另一个对象。 __slots__ 通过定义特殊变量 slots ，类可以限制对合法实例属性名称的设置，如下所示： class Account ( object ): def __init__ ( self , name , balance ): self . name = name self . balance = balance __slots__ = ( 'name' , 'balance' ) a = Account ( \"Guido\" , 1100.0 ) a . date = \"12-12\" ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-b978ca4ed4ad> in <module> 7 8 a = Account(\"Guido\", 1100.0) ----> 9 a.date = \"12-12\" AttributeError: 'Account' object has no attribute 'date' 定义 __slots__ 时，可以将实例上分配的属性名称限制为指定的名称，否则将引发 AttributeError 异常。这种限制可以阻止其他人向现有实例添加新属性，即便用户将属性名称写错，也不会创建出新的属性来。 在实际使用中， __slots__ 从未被当作一种安全的特性来实现。它实际上是对内存和执行速度的一种性能优化。 使用 __slots__ 的类的实例不再使用字典来存储实例数据，转而采用一种基于数组的更加紧凑的数据结构。在会创建大量对象的程序中，使用 __slots__ 可以显著减少减少内存占用和执行时间。 注意， __slots__ 与继承的配合使用需要一定的技巧。如果类继承自使用 __slots__ 的基类，那么它也需要定义 __slots__ 来存储自己的属性（即使它不会添加任何属性也是如此），这样才能利用 __slots__ 提供的优势。如果忘记了这一点，派生类的运行速度将更慢，占用的内存也更多，比完全不使用 __slots__ 时情况更糟。 __slots__ 的使用还会破坏期望实例具有底层 __dict__ 属性的代码。尽管这一点通常不适用于用户代码，但对于支持对象的实用库和其他工具，其代码可能要依靠 __dict__ 来调试、序列化对象以及执行其他操作。 最后，如果类中重新定义了 __getattribute__() 、 __getattr__() 和 __setattr__() 等方法， __slots__ 的存在不会对它们的调用产生任何影响。但是，这些方法的默认行为将考虑到 __slots__ 。此外应该强调一点，没有必要向 __slots__ 添加方法或特性名称，因为它们存储在类中，而不是存储在每个实例中。 参考 difference between staticmethod and classmethod in python","text_tokens":["用户","1","tm","暗示着","意图","由","k","导出","其他人",">","时","扩散","不过","classmethod","利用","开销","查看","强调","有关","组成","想重","对","jackson","相同","多重","san","普通","从而","times","type","imethod1","统一","不足","是因为","简单","name","该值","属性","写","新","实例","自定","5","15","这种","规则","resolution","前导","已经","函数","多态","instances","发现","继续","确定","外面","包含","出现","释器","arg","通常","getattribute","由于","pass","环境变","ruby","之后","性别","传给","建议","优势","搜索","供","还","性","0","后面","机制","arguments","模块","作为","mro","当然","最终","在","安全","以便","非","string","全新","—","很难","no","time","a","一种","附加","分开","指定","不足之处","组件","linearization","其中","尼亚","factor","变得","先","none","相关联","阻止","一般","__.","额外","getname","cesar","month","装饰","严格","area","代理","即","获取","eurodate","死","自","略加","原始","便会","下去","基于","经常","有些","96","delf","老","不利","面向对象","你","classname","如何","is","巧妙","也","years","obj","7","可以","多","and","能","应用","把","无需","默认","标识符","f","面向","做","合法","序列","实际上","简化","b","请","试图","限制","出新","4","是否","done","此外","这里","给","25.132741228718345","既","线性化","直至","介绍","通过","必要","传递","似乎","后台","程序员","还会","名上","person","为此","代码","input","、","@","新创建","<","用","对比","如此","初始","它","所示","就","之处","之一","尽可能","程序","图片","导致","相关","过","私有","接收","无法","层次","生成","为止","getf","只读"," ","不适","实用","一般来说","后","方案","哪个","对象","多个","单数","c","必不可少","edwin","抛出","转而","实现","何种","列表","微妙","涉及","更加","占用","时间","以及","具有","用以","positional","因此","所有","过程","有效","的话","另","填入","无论","load","inst","直到","25","#","female","’","变形","使用","import","方法","\"","twotimes","一个","异常","一步","认识","没有","数据结构","有用","特别","字典","知道","独立","平常","del","形式","从","减少","cmethod1","init",":","circle","标识","基础","以","陈述","note","第一","且","9","isinstance","元组","论文","must","无法访问","reset","描述符","让","混合","种类","即可","整洁","想","one","也就是说","consistent","can","一下","people","set","加利福尼亚","在于","适用","6055e1d64eee","将会","暴露","new","这个","def","现在","新类","tomorrow","balance","技巧","避免","允许","monotonic","位于","_","已知","速度","项","get","traceback","37","but","这样","注意","两个","库","上面","given","算符","of","up","使用者","权","更糟","解决方案","给出","忘记","svm","调试","解析","优先","16","typeerror","加利福","0dac39a0c579","object","现有","前面","非常复杂","修改","c3","getattr","oopsla","状态","利于","捕获","绑定","拒绝","按","/","访问","只是","接着","._","%","然而","到","mauck","python","可","某些","year","天然","正好","指向","打印","at","单个","基类","dict","隐式","类去","链接","if","californians","do","cmethod2","between","超类","但是","dylan","keys","参数","from","内置","给定","准确","grow","删除","拉蒙","存储","即便","华盛","动态","不同","marcotte","任何","3","稍微","该类","具体","显示","就是","来讲","module","mday","old","很多","继承","地方","gender","基本","又","delete","将","1100.0","0x00000215c1bb43c8","操作","达到","smethod","california","否则","关联","来","隐藏","来源","转发给","仍然","内","被","instance","运算符","class","需要","定制","总是","一句","看起来","barrett","日期","降低","单","解释","应用程序","混淆","发生","出","写错","print","新创","=","清晰","bar","一些",",","不利于","bound","福尼亚","示例","得出","集合","一般来讲","male","以下","任意","转换","下划线","如下","内存","具体来讲","关系","return","所以","语法","date","所谓","非常","__","be","头疼","欧洲","底层","定位","model","类型","数","并会","a1a0cdcb1eb3","perimeter","slots","正常","原则","时会","进行","其实","大多数","执行","保持","库中","8","不要","地","hasattr","account","不能","完全","类","in","order","直接","super","call","第一个","部分","关键","静态方法","下面","b978ca4ed4ad","失败","公共","大量","区别","+","类时","尽管","返回","然后","或类","我们","往","13","位置","d","6c60ffbe4e5a","not","difference","中","构造函数","之间","命名","takes","华盛顿","h","则","除非","跟类","用者","期间","static","4d","predict","冲突","系统","else","某个","下划","如果","紧凑","重","等","费力","用法","可见","superclass","来自","无","其他","foo","bases","算法","模型","更慢","走起","不想","耦合","并且","一直","指","?","most","影响","形成","环境变量","x","字符串","即使","123456","通用","未定","路径","标准","并","查找","一组","{","增强","圣","上","回","ik3","参考","不再","语言","正在","尚有","静态","会","编写","处理","以双","自动","str","一类","环境","最后","复杂","day","之","更","语句","人","该","独有","能够","分隔","ik1","中显式","变为","遵循","不必要","这些","鸭子","逗号","支持","看到","工具","为了","last","还有","了","“","看","维护","带来","设置","静默","而言","当前","容易","从未","放到","层次结构","默认值","printd","恰当","自定义","关于","加载","排列","子类","美国","staticmethod","*","多态性","不受","最好","比","booth","只要","期望","未定义","解决","age","本来","透明","去","关键在于","编程","更新","结构","集","传入","deleter","这是","序列化","发表","内部","-","意味","attributeerror","引发","那么","参与","它们","radius","采用","self","单独","很少","谚语","recent","情况","他人","variable","假定","has","特殊","main","]","例如","替代","目的","检查","忽略","dir","对类","鼓励","内容","ramon","时候","来说","格式","made","只不过","growing","mul","其","大多","看起","与其","依靠",".","浅层","14","存在","错误","必须","对于","因为","与","本身","工作","没","原样","常见","字母","称为","，","就是说","preimeter","大写","像","参数传递","得来",")","这","了解",".__","2","下","duck","50.26548245743669","向","weakref","数组","很","自己","常用","math","常常","localtime","性能","number","每个","用于","叫声","52599b4ddcfc","ind","高级","意义","转发","kls","已","创建","深奥","信息","s","显式","器","于","now","data","对应","代表","产生","比如","1967","方式","不","应该","加利","开","广度","而","特性","不错","请求","效果","调用","根类","意味着","分配","一点","delname","typing","最","问题","多数","它会","宏","根据","甚至","但","消息","源于","12.566370614359172","名称","定义","可能","人类","!","}","尽可","行为","外观","截获","raise","何时","构造","有点","名","readonly","cls","找到","顺序搜索","功能","首字","除了","松散","spam","只","提供","显著","才能","'","之外","约定","版本","例子","同样","是","派生","打印函数","重新","mixin","加上","都","但类","4.0","管理","组合","数传","深度","86400","开头","checkind","添加","(","mon","如","on","elif","结果","相应","再","value","所属","0x215c1ba3d30","不必","包装","中将","pi","类似","ik2","暗示","按照","可变","起来","考虑","connection","更改","封装","getattrribute","0x00000215c1b91f28","尝试","初始化","优化","局部","保存","setname","10","attribute","拥有","不可","希望","派生类","首先","唯一","发给","场景","按类","要","02d","走起路来","terri","所","models","反映","划线","不会","smalltalk","列出","只能","首字母","仅","继续下去","一定","覆盖","特定","解释器","create","[","配合","破坏","实际","空间","和","表示","共享","was","来源于","包括","点","值","12","步骤","ipython","。","运算","背景","类中","报错","setter","段","数据","（","始终","）","而且","各种","imethod2","顺序","method","时未","t","或","delattr","attr","预测","一样","seema","有时","构建","而是","property","接口","数量","文件","：","面向对象编程","处","得到","doc","的","匹配","运行","american","父类","线性","db","cannot","区分","##","for","82fbcd62768a","计算","得","有","当作","arun","一次","引起","setf","washington","或者","setattr","字符","以前","描述","变量","发生冲突","为","”","不是","guido"],"title":"4.1.类","title_tokens":["类",".","4.1"]},{"location":"Python基础/4.1.类.html#_1","text":"类的实例是以函数形式调用类对象来创建的。这种方法将创建一个新实例，然后将该实例传递给类的 __init__() 方法。 __init__() 方法的参数包括新创建的实例 self 和在调用类对象时提供的参数。 在 __init__() 内，通过将属性分配给 self 来将其保存到实例中。例如， self.name = name 表示将 name 属性保存在实例中。其中，点 . 运算符用于属性绑定。在新创建的实例返回到用户之后，使用点 . 运算符即可访问这些属性以及类的属性。 访问属性时，结果值可能来自多个不同的地方。可能来自实例独有的属性，也可能来自类的属性。访问属性时，Python 首先会检查实例，如果不知道该属性的任何信息，则会对实例的类进行搜索。这是类与其所有实例共享其属性的底层机制。","text_tokens":["用户","以","用于","时","创建","信息","返回","然后","即可","对","不","name","属性","中","实例","调用","新","分配","则","这种","函数","可能","如果","之后","来自","算符","搜索","机制","提供","在","是","其中","(","绑定","结果","访问","会","到","python","该","独有","也","保存","这些","参数","首先","不同","任何","给","通过","传递","地方","将","新创建","和","表示","共享","包括","点","来","值","内","。","运算","运算符"," ","对象","多个","self","新创","=","以及","例如","检查","所有","的","其","与其",".","__","使用","底层","方法","一个","，","进行",")","这","知道","形式","类","init"],"title":"类实例","title_tokens":["类","实例"]},{"location":"Python基础/4.1.类.html#_2","text":"继承是一种创建新类的机制，目的是使用或修改现有类的行为。原始类称为 基类 或 超类 。新类称为 派生类 或 子类 。 通过继承创建类时，所创建的类将“继承”其基类定义的属性。==但是，==派生类可以重新定义任何这些属性并添加自己的新属性。 在class语句中用以逗号分隔的基类名称列表来指定继承。如果没有有效的基类，类将继承object。object是所有Python对象的根类，提供了一些常见方法（如 __str__() ，它可创建供打印函数使用的字符串）的默认实现。 继承通常用于重新定义现有方法的行为。 继承是用功能稍微增强的点 . 运算符实现的。具体来讲，如果搜索一个属性时未在实例或实例的类中找到匹配项，将会继续搜索基类。这个过程会一直继续下去，直到没有更多的基类可供搜索为止。 派生类重定义 __init__() 时，不会自动调用基类的 __init__() 方法。因此，如果派生类想重定义 __init__() ，还想调用基类的 __init__() 方法，那么要由派生类调用基类的 __init__() 方法来对它们进行恰当的初始化。如果基类未定义 __init__() ，就可以忽略这一步。如果不知道基类是否定义了 __init__() ，可在不提供任何参数的情况下调用它，因为始终存在一个不执行任何操作的默认 __init__() 实现。 # 定义一个人类 class Person : def __init__ ( self , name , age ): self . name = name self . age = age def get_name ( self ): return self . name def get_age ( self ): return self . age # 定义一个美国人类 ## 现在想给美国人在初始化的时候加上 性别 的属性 class American ( Person ): # 重新定义__init__()会覆盖Person的__init__()方法 def __init__ ( self , name , age , gender ): Person . __init__ ( self , name , age ) self . gender = gender def get_gender ( self ): return self . gender jackson = American ( name = \"Cesar T. Mauck\" , age = 14 , gender = \"male\" ) jackson . get_age () 14 jackson . get_gender () 'male' # 有时，派生类将重新实现方法，但是还想调用原始的实现。 为此，有一种方法可以显式地调用基类中的原始方法，将实例 self 作为第一个参数传递即可，如下所示： # 定义一个华盛顿人类 class Washington ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 age = American . get_age () age += 1 self . age = age print ( \"Washington people grow up one year old\" ) 这个例子的微妙之处在于，American这个类其实没有实现 get_age() 方法。该方法是在Person类中实现的。尽管这段代码能够运行，但它可能会引起一些混淆（例如，American是否应该实现 get_age() ? ）。因此，替代解决方案是用 super() 函数，如下所示： # 定义一个加利福尼亚人类 class California ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 ## 实际上，因为get_age()方法在Person中定义 ## 这里可以传入Person的任何一个派生类 age = super ( California , self ) . get_age () age += 1 self . age = age print ( \"Californians grow up one year old\" ) Terri = California ( \"Terri H. Booth\" , 25 , \"female\" ) Terri . growing_up () Californians grow up one year old super(cls, instance) 会返回一个特殊对象，该对象支持在基类上执行属性查找。如果使用该函数，Python将使用本来应该在基类上使用的正常搜索规则来搜索属性。有了这种方式，就无需写死方法位置，并且能更清晰地陈述你的意图（即你希望调用以前的实现，无论它是哪个基类定义的）。然而， super() 的语法尚有不足之处。如果使用Python 3，可以使用简化的语句 super().get_age() 来执行上面示例中的计算。","text_tokens":["super",":","第一个","1","意图","由","用于","陈述","时","第一","创建","+","类时","尽管","显式","返回","即可","想重","想","对","jackson","one","位置","方式","不","应该","加利","不足","name","语法","属性","中","people","写","新","实例","调用","根类","华盛顿","在于","加利福尼亚","h","将会","这种","这个","def","现在","新类","规则","函数","但","_","定义","名称","继续","如果","项","人类","get","}","可能","重","行为","通常","上面","性别","算符","搜索","up","供","还","cls","找到","机制","功能","解决方案","提供","作为","并且","一直","在","'","?","例子","字符串","加利福","是","派生","打印函数","一种","object","未定","重新","指定","现有","加上","不足之处","修改","并","查找","尼亚","数传","{","增强","上","添加","(","如","尚有","cesar","会","即","自动","str","死","原始","然而","mauck","python","可","下去","year","打印","基类","你","之","californians","更","语句","人","该","初始化","能够","分隔","years","可以","超类","这些","多","但是","逗号","支持","能","参数","希望","无需","派生类","默认","grow","f","了","“","华盛","要","实际上","简化","25","任何","terri","是否","所","这里","稍微","给","3","具体","恰当","来讲","不会","通过","子类","传递","old","美国","继承","gender","booth","person","为此","继续下去","代码","覆盖","将","用","初始","它","未定义","就","操作","所示","解决","california","实际","age","本来","之处","点","来","。","instance","运算","类中","运算符","class","为止","传入","段"," ","（","始终","）","那么","方案","哪个","它们","混淆","对象","时未","self","或","t","print","=","情况","清晰","一些","实现","有时","列表",",","微妙","特殊","福尼亚","示例","用以","例如","：","因此","目的","替代","忽略","所有","male","过程","有效","时候","如下","处","无论","具体来讲","growing","的","其","匹配","直到","return","#",".","__","american","14","运行","存在","使用","female","##","因为","方法","\"","一个","计算","常见","一步","没有","有","称为","，","引起","正常","进行","washington","参数传递","其实",")","这","执行","字符","以前","下","知道","地","”","类","自己","init"],"title":"继承","title_tokens":["继承"]},{"location":"Python基础/4.1.类.html#_3","text":"Python支持多重继承。通过让一个类列出多个基类即可指定多重继承。例如，下面给出了一个类集合： # 定义一个圣拉蒙人类 class San_Ramon ( American , California , Washington ): def growing_up ( self ): pass Edwin = San_Ramon ( \"Edwin A. Marcotte\" , 37 , \"male\" ) Edwin . get_age () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-6c60ffbe4e5a> in <module> 1 # 定义一个圣拉蒙人类 ----> 2 class San_Ramon(American, California, Washington): 3 def growing_up(self): 4 pass 5 TypeError: Cannot create a consistent method resolution order (MRO) for bases American, California, Washington 使用多重继承时，属性的解析会变得非常复杂，因为可以使用很多搜索路径来绑定属性。 在查找使用了多重继承的属性时，会将所有基类按从“最特殊”的类到“最不特殊”的类这种顺序进行排列。然后在搜索属性时，就会按这个顺序搜索，直至找到该属性的第一个定义。对于任何给定的类，通过打印它的 mro 属性即可查看基类的顺序，例如： 在大多数情况下，这个列表基于“有意义”的规则排列得出。也就是说，始终先检查派生类，然后再检查其基类，如果一个类具有多个父类，那么始终按类定义中列出的父类顺序检查这些父类。但是，基类的准确顺序实际上非常复杂，不是基于任何“简单的”算法，如深度优先或广度优先搜索。实际上，基类的顺序由 C3 线性化算法确定，可以在论文“A Monotonic Superclass Linearization for Dylan”（K. Barrett 等，发表于 OOPSLA’96）中找到该算法的介绍。该算法的一个需要注意的地方是，某些类层次结构将被 Python 拒绝并会抛出 TypeError 错误，例如： 一般来说，在大多数程序中最好避免使用多重继承。但是，多重继承有时可用于定义所谓的混合（mixin）类。混合类通常定义了要“混合到”其他类中的一组方法，目的是添加更多的功能（这与宏很类似）。通常，混合类中的方法将假定其他方法存在，并将以这些方法为基础构建。","text_tokens":["call",":","第一个","1","基础","以","由","k","用于",">","时","第一","下面","意义","论文","查看","让","于","然后","即可","混合","多重","也就是说","san","6c60ffbe4e5a","不","consistent","简单","广度","属性","中","5","这种","最","这个","def","规则","resolution","多数","避免","宏","monotonic","_","定义","确定","如果","人类","get","traceback","37","等","通常","注意","pass","superclass","搜索","up","其他","找到","顺序搜索","bases","算法","给出","功能","mro","在","most","解析","优先","typeerror","是","派生","a","路径","指定","mixin","非常复杂","linearization","并","查找","c3","oopsla","变得","深度","一组","圣","先","添加","(","order","绑定","拒绝","如","一般","按","会","再","到","python","可","基于","某些","类似","96","复杂","打印","基类","更","该","可以","这些","多","支持","但是","dylan","派生类","给定","准确","last","拉蒙","了","“","按类","marcotte","要","实际上","任何","4","3","层次结构","线性化","直至","就是","介绍","module","排列","通过","列出","很多","继承","最好","地方","input","create","将","<","它","实际","就","california","程序","age","来","ipython","。","被","层次","结构","类中","class","需要","发表"," ","-","（","始终","barrett","）","一般来说","那么","顺序","多个","method","self","或","edwin","recent","=","情况","抛出","有时","构建","假定","列表",",","特殊","得出","具有","例如","集合","：","目的","检查","male","所有","ramon","来说","growing","的","大多","其","所谓","#","american",".","非常","父类","cannot","线性","使用","’","错误","对于","存在","因为","与","\"","for","方法","并会","一个","有","，","就是说","进行","washington","大多数",")","这","2","下","从","为","”","类","in","不是","很"],"title":"多重继承","title_tokens":["继承","多重"]},{"location":"Python基础/4.1.类.html#_4","text":"动态绑定（在继承背景下使用时，有时也称为多态性）是指在不考虑实例类型的情况下使用实例只要以 obj.attr 的形式访问属性，就会按照一定的顺序搜索并定位 attr ： 首先是实例本身，接着是实例的类定义，然后是基类。 查找过程会返回第一个匹配项。 这种绑定过程的关键在于，它不受对象 obj 的类型影响。因此，如果执行像 obj.name 这样的查找，对所有拥有 name 属性的 obj 都是适用的。这种行为有时被称为“鸭子类型”（duck typing），这个名称来源于一句谚语：“如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子。” Python 程序员经常编写利用这种行为的程序。例如，如果想编写现有对象的自定义版本，可以继承该对象，也可以创建一个外观和行为像它但与它无任何关系的全新对象。后一种方法通常用于保持程序组件的松散耦合。例如，可以编写代码来处理任何种类的对象，只要该对象拥有特定的方法集。最常见的例子就是利用标准库中定义的各种“类似文件”的对象。尽管这些对象的工作方式像文件，但它们并不是继承自内置文件对象的。","text_tokens":["第一个","关键","以","叫声","用于","时","第一","利用","创建","尽管","返回","然后","种类","想","对","方式","不","name","属性","自定","实例","在于","适用","这种","typing","最","这个","但","多态","源于","定义","名称","项","如果","这样","行为","通常","外观","搜索","无","顺序搜索","松散","走起","耦合","指","在","影响","版本","全新","例子","是","一种","现有","组件","都","标准","并","查找","绑定","访问","会","编写","接着","处理","自","python","经常","类似","按照","起来","基类","考虑","该","也","obj","可以","这些","鸭子","拥有","内置","首先","“","动态","走起路来","任何","自定义","就是","多态性","继承","不受","程序员","代码","一定","、","只要","特定","它","就","和","程序","来源于","关键在于","来","来源","。","被","背景","集"," ","（","一句","看起来","）","而且","那么","后","各种","它们","顺序","对象","attr","谚语","情况","有时","例如","文件","：","因此","所有","过程","关系","的","匹配","看起",".","使用","定位","与","类型","本身","方法","工作","一个","常见","称为","，","像","执行","保持","库中","duck","下","形式","”","类","不是"],"title":"多态动态绑定和鸭子类型","title_tokens":["鸭子","绑定","类型","和","多态","动态"]},{"location":"Python基础/4.1.类.html#_5","text":"类中最常用的方法是实例方法，即 将实例作为第一个参数传递给该方法。 例如，基本的实例方法如下： class Kls ( object ): def __init__ ( self , data ): self . data = data def printd ( self ): print ( self . data ) ik1 = Kls ( 'arun' ) ik2 = Kls ( 'seema' ) ik1 . printd () ik2 . printd () arun seema 然后看一下代码和示例图片: 在1、2中，参数传递给方法。 在3中， self参数指向当前实例。 在4中，我们不需要给方法提供实例， Python解释器自己会做这些操作 。","text_tokens":["常用",":","第一个","1","解释","这些","print","参数","self","第一","=","作为","提供","做","kls","seema","看","'","在",",","当前","示例","4","例如","data","是","：","给","然后","object","printd","3","我们","不","传递","数传","如下","一下","中","实例","的","基本","(","代码",".","__","、","解释器","将","最","def","操作","会","方法","和","即","一个","图片","ik1","arun","，","python","参数传递","。",")","ik2","指向","释器","2","类中","class","需要"," ","该","自己","init"],"title":"实例方法","title_tokens":["实例","方法"]},{"location":"Python基础/4.1.类.html#_6","text":"Note 以下两个代码示例介绍了静态方法的两个应用场景： 不需要访问实例对象或类对象的方法和属性，但与类有关的功能 创建构造函数 经常有一些跟类有关系的功能，但在运行时又不需要实例和类参与（比如更改环境变量或者修改其他类的属性），当然可以在类定义之外写一个函数实现这些功能，但这样会扩散类内部的代码，不利于代码的维护。比如这样： IND = 'ON' def checkind (): return ( IND == 'ON' ) class Kls ( object ): def __init__ ( self , data ): self . data = data def do_reset ( self ): if checkind (): print ( 'Reset done for:' , self . data ) def set_db ( self ): if checkind (): self . db = 'new db connection' print ( 'DB connection made for:' , self . data ) ik1 = Kls ( 12 ) do_reset ( ik1 ) # Reset done for: 12 set_db ( ik1 ) # DB connection made for: 12 如果使用 @staticmethod 就能把相关的代码放到对应的位置了。 IND = 'ON' class Kls ( object ): def __init__ ( self , data ): self . data = data @staticmethod def checkind (): return ( IND == 'ON' ) def do_reset ( self ): if self . checkind (): print ( 'Reset done for:' , self . data ) def set_db ( self ): if self . checkind (): self . db = 'New db connection' print ( 'DB connection made for: ' , self . data ) ik1 = Kls ( 12 ) ik1 . do_reset () ik1 . set_db () Reset done for: 12 DB connection made for: 12 实际上，静态方法是一种普通函数，只不过它们正好位于类定义的命名空间中， 因为它不会对任何实例类型进行操作 。 如果在编写类时需要采用很多不同的方式来创建新实例，则常常使用静态方法。因为类中只能有一个 __init__() 函数，所以替代的创建函数通常按如下方式定义： import time class Date ( object ): def __init__ ( self , year , month , day ): self . year = year self . month = month self . day = day @staticmethod def now (): t = time . localtime () return Date ( t . tm_year , t . tm_mon , t . tm_mday ) @staticmethod def tomorrow (): t = time . localtime ( time . time () + 86400 ) return Date ( t . tm_year , t . tm_mon , t . tm_mday ) # 创建日期的示例 a = Date ( 1967 , 4 , 9 ) b = Date . now () # 调用静态方法now() c = Date . tomorrow () # 调用静态方法tomorrow()","text_tokens":[":","常常","localtime","tm","note","静态方法","时","ind","扩散","不过","9","kls","创建","reset","类时","+","有关","now","data","对应","普通","对","比如","或类","位置","1967","方式","不","属性","构造函数","命名","中","写","实例","set","新","调用","则","跟类","new","def","tomorrow","但","函数","位于","_","定义","如果","这样","通常","两个","环境变","构造","其他","功能","当然","在","'","之外","环境变量","time","是","a","一种","object","修改","86400","利于","checkind","(","mon","on","静态","按","month","访问","会","编写","环境","经常","正好","year","不利","day","connection","更改","if","do","ik1","可以","这些","能","应用","把","了","场景","维护","不同","实际上","b","任何","4","done","放到","介绍","不会","mday","staticmethod","很多","只能","代码","又","@","实际","空间","和","就","它","操作","相关","来","12","。","类中","需要","class","内部"," ","（","）","日期","参与","它们","对象","采用","print","self","t","c","=","一些","实现","不利于",",","示例","：","替代","以下","如下","made","关系","只不过","的","return","所以","运行","date","#",".","__","db","使用","与","因为","方法","for","类型","import","一个","有","，","进行","或者",")","变量","类","init"],"title":"静态方法","title_tokens":["静态","静态方法","方法"]},{"location":"Python基础/4.1.类.html#_7","text":"Note 以下两个代码示例介绍了类方法的两个应用场景： 创建构造函数 动态更新类 类方法是将类本身作为对象进行操作的方法。类方法使用 @classmethod 装饰器定义，与实例方法不同，Python解释器会将类本身传递给类方法的第一个参数（一般将该参数命名为 cls ）。例如： class Times ( object ): factor = 1 @classmethod def mul ( cls , x ): return cls . factor * x class TwoTimes ( Times ): factor = 2 x = TwoTimes . mul ( 4 ) # 调用Times.mul(TwoTimes, 4) -> 8 在这个例子中，请注意类 TwoTimes 是如何作为对象传递给 mul() 的。尽管这个例子有些深奥，但类方法还有一些实用且巧妙的用法。例如，你定义了一个类，它继承自前面给出的 Date 类并对其略加定制： class EuroDate ( Date ): # 修改字符串转换，以使用欧洲日期格式 def __str__ ( self ): return \" %02d / %02d / %4d \" % ( self . day , self . month , self . year ) 由于该类继承自 Date，所以它拥有 Date 的所有特性。但是 now() 和 tomorrow() 方法稍微有点不同。例如，如果调用 EuroDate.now()，则会返回 Date 对象，而不是 EuroDate 对象。类方法可以解决该问题： class Date ( object ): def __init__ ( self , year , month , day ): self . year = year self . month = month self . day = day @classmethod def now ( cls ): t = time . localtime () return cls ( t . tm_year , t . tm_mon , t . tm_mday ) @classmethod def tomorrow ( cls ): t = time . localtime ( time . time () + 86400 ) return cls ( t . tm_year , t . tm_mon , t . tm_mday ) class EuroDate ( Date ): # 修改字符串转换，以使用欧洲日期格式 def __str__ ( self ): return \" %02d / %02d / %4d \" % ( self . day , self . month , self . year ) a = Date . now () # 调用Date.now(Date)并返回Date b = EuroDate . now () # 调用Date.now(EuroDate)并返回EuroDate print ( type ( a )) print ( type ( b )) <class '__main__.Date'> <class '__main__.EuroDate'> 类方法除了用于创建构造函数，另一个例子是动态更新类。例如我们想动态更新一个类属性： class Kls ( object ): models = {} def __init__ ( self , model_name ): # 加载模型 pass @classmethod def load_model ( cls , model_name ): cls . models [ model_name ] = cls ( model_name ) @classmethod def get_model ( cls , model_name ): return cls . models . get ( model_name , None ) def predict ( self ): return \"预测结果为1\" model_name = \"svm\" Kls . load_model ( model_name ) model = Kls . get_model ( model_name ) model . predict () '预测结果为1' Kls . models {'svm': <__main__.Kls at 0x215c1ba3d30>} 当然，除了使用类方法，也可以在实例方法中显式调用类属性，达到动态更新类的效果，例如我们要获取实例数： class Kls ( object ): no_inst = 0 def __init__ ( self ): Kls . no_inst = Kls . no_inst + 1 @classmethod def get_no_of_instance ( cls_obj ): return cls_obj . no_inst ik1 = Kls () ik2 = Kls () print ( ik1 . get_no_of_instance ()) print ( Kls . get_no_of_instance ()) 2 2 但是如果要用实例方法实现的话，就得创建一个实例对象，这意味着我们必须要给这个实例对象命名。在编程中，给过多的变量命名，有时是一个头疼的问题。 在类外面写一个函数也可以实现这样的效果，但不利于代码的维护。 def get_no_of_instances ( cls_obj ): return cls_obj . no_inst class Kls ( object ): no_inst = 0 def __init__ ( self ): Kls . no_inst = Kls . no_inst + 1 ik1 = Kls () ik2 = Kls () print ( get_no_of_instances ( Kls )) 2","text_tokens":[":","第一个","1","localtime","tm","以","note","用于",">","第一","且","classmethod","kls","创建","深奥","+","尽管","器","now","返回","想","对","type","我们","times","而","name","特性","构造函数","命名","中","属性","实例","调用","效果","写","意味着","则","这个","def","tomorrow","问题","4d","predict","函数","但","instances","_","定义","如果","外面","get","}","释器","这样","用法","注意","由于","两个","pass","构造","有点","of","cls","0","给出","除了","模型","作为","当然","在","'","svm","x","例子","字符串","no","time","是","a","object","前面","但类","并","修改","factor","86400","{","利于","none","(","mon","一般","__.","结果","/","month","装饰","会","获取","eurodate","str","自","略加","%","0x215c1ba3d30","python","有些","year","at","ik2","不利","day","你","如何","该","ik1","巧妙","也","中显式","obj","可以","多","但是","应用","参数","拥有","还有","了","场景","维护","动态","不同","要","请","02d","b","4","给","该类","稍微","models","介绍","加载","mday","传递","*","继承","代码","@","解释器","将","<","[","用","操作","它","和","达到","解决","就","过","编程","更新","。","instance","class","定制"," ","-","（","意味","实用","）","日期","解释","对象","t","self","print","预测","=","一些","实现","有时",",","不利于","示例","main","]","例如","：","以下","所有","转换","的话","另","格式","load","inst","mul","的","return","date","其","所以","#",".","__","头疼","欧洲","使用","必须","与","model","方法","本身","\"","twotimes","一个","数","得","，","进行",")","这","8","字符","2","变量","为","类","不是","init"],"title":"类方法","title_tokens":["类","方法"]},{"location":"Python基础/4.1.类.html#_8","text":"在实例方法和类方法中，Python默认将当前实例或者类对象传给方法的第一个参数（非指定默认值的参数），如果方法不设置参数，便会报错： class Kls ( object ): def __init__ ( self , data ): self . data = data def imethod1 (): print ( \"不接收实例\" ) def imethod2 ( * arg ): print ( 'Instance:' , arg ) @staticmethod def smethod ( * arg ): print ( 'Static:' , arg ) @classmethod def cmethod1 (): print ( \"不接收类对象\" ) @classmethod def cmethod2 ( * arg ): print ( 'Class:' , arg ) ik3 = Kls ( 'arun' ) ik3 . imethod1 () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-82fbcd62768a> in <module> 1 ik3 = Kls('arun') ----> 2 ik3.imethod1() TypeError: imethod1() takes 0 positional arguments but 1 was given ik3 . cmethod1 () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-6055e1d64eee> in <module> ----> 1 ik3.cmethod1() TypeError: cmethod1() takes 0 positional arguments but 1 was given 实例方法、类方法必须设置参数接收类对象： ik3 . imethod2 () ik3 . cmethod2 () Instance: (<__main__.Kls object at 0x00000215C1B91F28>,) Class: (<class '__main__.Kls'>,) 静态方法则不会传入实例或类对象： ik3 . smethod () Static: () 如果方法不设置参数，只能通过类去调用，应该避免这种用法，没参数的方法应该加上 @staticmethod 装饰器： Kls . imethod1 () 不接收实例 关于静态方法和类方法需要注意的一点是，Python 不会在与实例方法独立的命名空间中管理它们。因此，可以通过实例或类调用它们。例如： Kls . cmethod2 () Kls ( 'arun' ) . cmethod2 () Kls . smethod () Kls ( 'arun' ) . smethod () Class: (<class '__main__.Kls'>,) Class: (<class '__main__.Kls'>,) Static: () Static: () 这可能很容易引起混淆，因为对 Kls('arun').cmethod2() 的调用与实例 Kls('arun') 没有任何关系。 这种行为是 Python 对象系统与其他面向对象语言（如 Smalltalk 和 Ruby）对象系统的区别之一。在这些语言中，类方法与实例方法是严格分开的。 而实例方法必须通过实例调用，因为需要传入实例。","text_tokens":["call",":","第一个","1","静态方法",">","第一","classmethod","kls","区别","器","data","对","或类","imethod1","不","应该","而","中","命名","实例","调用","takes","一点","则","6055e1d64eee","这种","def","static","避免","系统","可能","如果","traceback","but","arg","行为","用法","注意","ruby","given","传给","0","其他","arguments","在","'","most","非","typeerror","是","object","分开","指定","加上","管理","(","ik3","如","语言","__.","静态","严格","装饰","便会","python","at","面向对象","类去","0x00000215c1b91f28","cmethod2","可以","这些","参数","默认","last","面向","设置","很","当前","容易","任何","默认值","关于","module","不会","通过","smalltalk","*","staticmethod","只能","input","、","@","将","<","空间","和","smethod","was","之一","接收","ipython","。","instance","传入","class","报错","需要"," ","-","（","）","imethod2","它们","混淆","对象","print","self","recent","=",",","main","例如","：","positional","因此","关系","的",".","__","必须","与","因为","方法","\"","82fbcd62768a","没","一个","没有","arun","，","引起","或者",")","这","2","独立","类","in","cmethod1","init"],"title":"实例方法、静态方法、类方法对比","title_tokens":["实例","、","静态方法","静态","对比","方法","类"]},{"location":"Python基础/4.1.类.html#_9","text":"@property ——把方法变为属性 通常，访问实例或类的属性时，返回的会是所存储的相关值。特性（property）是一种特殊的属性，访问它时会计算它的值。下面是一个简单的例子： import math class Circle ( object ): def __init__ ( self , radius ): self . radius = radius # Circle的一些附加特性 @property def area ( self ): return math . pi * self . radius ** 2 @property def preimeter ( self ): return 2 * math . pi * self . radius 得到的Circle对象的行为如下： c = Circle ( 4.0 ) c . radius 4.0 c . area 50.26548245743669 c . preimeter 25.132741228718345 c . area = 2 ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-0dac39a0c579> in <module> ----> 1 c.area = 2 AttributeError: can't set attribute 在这个例子中，Circle 实例存储了一个实例变量 c.radius 。 c.area 和 c.perimeter 是根据该值计算得来的。 @property 装饰器支持以简单属性的形式访问后面的方法，无需像平常一样添加额外的 () 来调用该方法。对象的使用者很难发现正在计算一个属性，除非在试图重新定义该属性时生成了错误消息（如上面的 AttributeError 异常所示）。 这种特性使用方式遵循所谓的统一访问原则。 实际上，如果定义一个类，尽可能保持编程接口的统一总是不错的。如果没有特性，将会以简单属性（如 c.radius ）的形式访问对象的某些属性，而其他属性将以方法（如 c.area() ）的形式访问。费力去了解何时添加额外的 () 会带来不必要的混淆。特性可以解决该问题。 Python 程序员很少认识到， 方法本身是被隐式地作为一类特性处理的。 考虑下面这个类： class Foo ( object ): def __init__ ( self , name ): self . name = name def spam ( self , x ): print ( \" %s , %s \" % ( self . name , x )) Foo ( \"d\" ) . spam <bound method Foo.spam of <__main__.Foo object at 0x00000215C1BB43C8>> 用户创建 f = Foo(\"Guido\") 这样的实例然后访问 f.spam 时，不会返回原始函数对象 spam ，而是会得到所谓的绑定方法（bound method），绑定方法是一个对象，代表将在对象上调用 () 运算符时执行的方法调用。绑定方法有点类似于已部分计算的函数，其中的self参数已经填入，但其他参数仍然需要在使用 () 调用该函数时提供。这种绑定方法对象是由在后台执行的特性函数静默地创建的。 使用 @staticmethod 和 @classmethod 定义静态方法和类方法时，实际上就指定了使用不同的特性函数，以不同的方式处理对这些方法的访问。 例如， @staticmethod 仅“按原样”返回方法函数，不会进行任何特殊的包装或处理。 特性还可以截获操作权，以设置和删除属性。这是通过向特性附加其他 setter 和 deleter 方法来实现的，如下所示： class Foo ( object ): def __init__ ( self , name ): self . __name = name @property def name ( self ): return self . __name @name . setter def name ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value @name . deleter def name ( self ): raise TypeError ( \"Can't delete name\" ) 在这个例子中，首先使用 @property 装饰器和相关方法将属性 name 定义为只读特性。后面的 @name.setter 和 @name.deleter 装饰器将其他方法与 name 属性上的设置和删除操作相关联。这些方法的名称必须与原始特性的名称完全匹配。在这些方法中，请注意实际的名称值存储在属性 __name 中。所存储属性的名称无需遵循任何约定，但它必须与特性名称不同，以便将它与特性的名称区分开。 在以前的代码中，通常会看到用 property(getf=None, setf=None, delf=None, doc=None) 函数来定义特性，往其中传入一组名称不同的方法，用于执行相关操作。例如： class Foo ( object ): def getname ( self ): return self . __name def setname ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value def delname ( self ): raise TypeError ( \"Can't delete name\" ) name = property ( getname , setname , delname ) 这种老方法仍然可以使用，但装饰器版本会让类看起来更整洁。 例如，如果使用装饰器，get、 set 和 delete 函数将不会显示为方法。","text_tokens":["用户","1","由",">","时","classmethod","对","统一","简单","name","该值","属性","实例","这种","已经","函数","发现","通常","还","后面","作为","在","以便","string","—","很难","a","一种","附加","指定","其中","none","相关联","__.","额外","getname","装饰","area","原始","老","delf","可以","把","无需","f","实际上","试图","请","25.132741228718345","通过","必要","后台","程序员","代码","input","、","@","<","用","所示","它","尽可能","就","程序","相关","生成","getf","只读"," ","对象","c","实现","填入","#","使用","import","方法","\"","一个","异常","认识","没有","平常","形式","init","circle",":","以","isinstance","must","让","整洁","can","set","将会","这个","def","traceback","get","这样","注意","上面","of","算符","使用者","权","typeerror","0dac39a0c579","object","绑定","按","访问","%","到","python","某些","at","隐式","if","参数","删除","存储","不同","任何","显示","module","delete","将","0x00000215c1bb43c8","操作","关联","来","仍然","被","运算符","class","需要","总是","看起来","混淆","print","=","一些",",","bound","如下","return","所谓","__","be","perimeter","原则","时会","进行","执行","保持","地","完全","类","in","call","部分","静态方法","下面","返回","然后","或类","往","not","d","中","除非","用者","如果","费力","其他","foo","most","x","一组","上","正在","静态","会","处理","str","一类","更","该","变为","遵循","不必要","这些","支持","看到","last","了","“","带来","静默","设置","*","staticmethod","解决","去","编程","传入","deleter","这是","-","attributeerror","radius","self","很少","recent","特殊","main","例如","看起",".","错误","必须","与","本身","原样","preimeter","，","得来","了解","像",")","2","50.26548245743669","向","math","用于","已","创建","s","器","于","代表","方式","开","而","不错","特性","调用","delname","问题","消息","根据","但","定义","可能","名称","!","尽可","行为","截获","raise","何时","有点","spam","提供","'","约定","版本","例子","是","重新","4.0","添加","(","如","value","不必","包装","pi","类似","起来","考虑","setname","attribute","首先","所","不会","仅","实际","和","值","ipython","。","运算","setter","（","）","method","t","或","一样","而是","property","接口","：","得到","doc","的","匹配","区分","计算","setf","以前","变量","为","”","guido"],"title":"特性","title_tokens":["特性"]},{"location":"Python基础/4.1.类.html#_10","text":"默认情况下，类的所有属性和方法都是“公共的”。这意味着对它们的访问没有任何限制。这还暗示着，在基类中定义的所有内容都会被派生类继承，并可从派生类内进行访问。在面向对象的应用程序中，通常我们不希望发生这种行为，因为它会暴露对象的内部实现，可能导致在派生类中定义的对象与在基类中定义的对象之间发生命名空间冲突。 Note 这意味着派生类可以覆盖基类的定义。 为了解决该问题， 类中所有以双下划线开头的名称（如 __Foo ）都会自动变形，形成具有 _Classname__Foo 形式的新名称。 这提供了一种在类中添加私有属性和方法的有效方式，因为派生类中使用的私有名称不会与基类中使用的相同私有名称发生冲突，如下所示： class A ( object ): def __init__ ( self ): self . __X = 3 # 变形为self._A__X def __spam ( self ): # 变形为_A__spam() print ( \"A\" ) def bar ( self ): self . __spam () # 只调用A.__spam() class B ( A ): def __init__ ( self ): A . __init__ ( self ) self . __X = 37 # 变形为self._B__X def __spam ( self ): # 变形为_B__spam() print ( \"B\" ) b = B () # 派生类的定义没有覆盖基类的定义 b . bar () A 尽管这种方案似乎隐藏了数据，但并没有严格的机制来实际阻止对类的“私有”属性进行访问。特别是如果已知类名称和相应私有属性的名称，则可以使用变形后的名称来访问它们。通过重定义 dir() 方法，类可以降低这些属性的可见性， dir() 方法提供了检查对象的 dir() 函数所返回的名称列表。 尽管这种名称变形似乎是一个额外的处理步骤，但变形过程实际上只在定义类时发生一次。它不会在方法执行期间发生，也不会为程序的执行添加额外的开销。而且要知道，名称变形不会在 getattr() 、 hasattr() 、 setattr() 或 delattr() 等函数中发生，在这些函数中，属性名被指定为字符串。对于这些函数，需要显式使用变形名称（如 __Classname__name ）来访问属性。 建议在定义可变属性时，通过特性来使用私有属性。这样，就可鼓励用户使用特性名称，而无需直接访问底层实例数据（如果你在实例开头添加了一个特性，可能不想采用这种访问方式）。 通过为方法提供私有名称，超类可以阻止派生类重新定义和更改方法的实现。 例如，示例中的 A.bar() 方法只调用 A.__spam() ，无论 self 具有何种类型，或者派生类中是否存在不同的 __spam() 方法都是如此。 最后，不要混淆私有类属性的命名和模块中“私有”定义的命名。一个常见的错误是，在定义类时，在属性名上使用单个前导下划线来隐藏属性值（如 _name ）。 在模块中，这种命名约定可以阻止通过 from module import * 语句导出名称。 这意味着单下划线开头的定义只能被类本身和其派生类访问。但是在类中，这种命名约定既不能隐藏属性，在某个类继承该类并使用相同名称定义一个新属性或方法时，也不能阻止出现名称冲突。","text_tokens":[":","用户","暗示着","note","导出","时","开销","公共","类时","尽管","显式","返回","对","私有","相同","隐藏","我们","方式","不","name","而","属性","中","命名","之间","特性","新","调用","实例","意味着","则","这种","暴露","期间","问题","def","前导","它会","但","函数","冲突","某个","下划","定义","可能","名称","_","如果","已知","出现","37","重","行为","通常","可见","等","这样","名","建议","还","性","foo","机制","spam","只","提供","模块","不想","在","形成","约定","x","字符串","是","派生","a","一种","object","重新","指定","都","并","getattr","开头","添加","(","阻止","如","额外","访问","会","严格","相应","处理","以双","自动","._","最后","可","暗示","可变","单个","基类","面向对象","你","更改","classname","语句","该","也","可以","这些","超类","但是","应用","希望","为了","无需","派生类","默认","from","面向","“","了","不同","要","限制","b","实际上","任何","是否","所","3","既","该类","划线","不会","通过","module","似乎","*","只能","继承","名上","覆盖","、","如此","所示","实际","导致","和","空间","解决","dir","程序","它","就","来","值","步骤","内","。","被","类中","class","需要"," ","内部","意味","（","数据","）","降低","而且","单","方案","后","它们","应用程序","对象","发生","混淆","采用","print","self","或","delattr","=","情况","bar","实现","何种","列表","示例","具有","例如","：","鼓励","检查","所有","对类","过程","有效","内容","下划线","如下","无论","的","其","#",".","__","变形","存在","使用","底层","错误","发生冲突","对于","因为","与","方法","\"","类型","import","一个","本身","常见","没有","一次","，","进行","特别","或者","setattr",")","这","执行",".__","字符","下","知道","hasattr","不要","从","形式","为","”","类","不能","直接","init"],"title":"数据封装和私有属性","title_tokens":["私有","封装","和","数据","属性"]},{"location":"Python基础/4.1.类.html#_11","text":"从内部实现上看，实例是使用字典来实现的，可以通过实例的 __dict__ 属性访问该字典。这个字典包含的数据对每个实例而言都是唯一的，如下所示： class Account ( object ): def __init__ ( self , name , balance ): self . name = name self . balance = balance a = Account ( \"Guido\" , 1100.0 ) a . __dict__ {'name': 'Guido', 'balance': 1100.0} 可以在任何时候向实例添加新属性，例如： a . number = 123456 # 将属性'number'添加到 a.__dict__ 对实例的修改始终会反映到局部 __dict__ 属性中。同样，如果直接对 __dict__ 进行修改，所做的修改也会反映在实例的属性中。 实例通过特殊属性 __class__ 链接回它们的类。类本身也只是对字典的浅层包装，你可以在实例的 __dict__ 属性中找到这个字典。可以在类字典中找到各种方法。例如： a . __class__ __main__.Account Account . __dict__ . keys () dict_keys(['__module__', '__init__', '__dict__', '__weakref__', '__doc__']) 最后，通过特殊属性 __bases__ 中将类链接到它们的基类，该属性是一个基类元组。这种底层结构是获取、设置和删除对象属性的所有操作的基础。 只要使用 obj.name = value 设置了属性，特殊方法 obj.__setattr__(\"name\", value) 就会被调用。如果使用 del obj.name 删除了一个属性，就会调用特殊方法 obj.__delattr__(\"name\") 。 这些方法的默认行为是修改或删除 obj 的局部 __dict__ 的值，除非请求的属性正好是一个特性或描述符。在这种情况下，设置和删除操作将由与该特性相关联的设置和删除函数执行。 在查找属性（如 obj.name ）时，将调用特殊方法 obj.__getattrribute__(\"name\") 。该方法执行搜索来查找该属性，这通常涉及检查特性、查找局部 __dict__ 属性、检查类字典以及搜索基类。如果搜索过程失败，最终会尝试调用类的 __getattr__() 方法（如果已定义）来查找该属性。如果这也失败，就会抛出 AttributeError 异常。 如果有必要，用户定义的类可以实现其自己的属性访问函数。例如： import math class Circle ( object ): def __init__ ( self , radius ): self . radius = radius def __getattr__ ( self , name ): if name == 'area' : return math . pi * self . radius ** 2 elif name == 'perimeter' : return 2 * math . pi * self . radius else : return object . __getattr__ ( self , name ) def __setattr__ ( self , name , value ): if name in [ 'area' , 'perimeter' ]: raise TypeError ( \" %s is readonly\" % name ) from None object . __setattr__ ( self , name , value ) c = Circle ( 2 ) c . area 12.566370614359172 c . area = 10 ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-52599b4ddcfc> in <module> ----> 1 c.area = 10 <ipython-input-1-a1a0cdcb1eb3> in __setattr__(self, name, value) 13 def __setattr__(self,name,value): 14 if name in ['area','perimeter']: ---> 15 raise TypeError(\"%s is readonly\" % name) from None 16 object.__setattr__(self,name,value) TypeError: area is readonly 重新实现这些方法的类应该可以依靠 object 中的默认实现来执行实际的工作。这是因为默认实现能够处理类的更高级特性，如描述符和特性。 一般来讲，类很少重新定义属性访问运算符。但是，在编写通用的包装器和现有对象的代理时，通常会使用属性访问运算符。通过重新定义 __getattr__() 、 __setattr__() 和 __delattr__() ，代理可以捕获属性访问操作，并透明地将这些操作转发给另一个对象。","text_tokens":["call",":","用户","circle","基础","math","1","number","每个","由","52599b4ddcfc",">","时","高级","失败","转发","元组","已","描述符","s","器","对","13","是因为","应该","请求","name","属性","中","特性","实例","新","调用","除非","15","balance","这种","这个","def","函数","else","12.566370614359172","_","定义","如果","包含","}","traceback","行为","通常","raise","算符","搜索","readonly","找到","bases","最终","因为","在","'","most","16","typeerror","同样","是","123456","a","通用","object","重新","现有","都","修改","并","查找","getattr","{","捕获","上","添加","回","(","相关联","none","如","一般","__.","elif","代理","访问","会","只是","area","处理","编写","获取","value","%","包装","到","最后","中将","pi","正好","链接","dict","基类","你","if","is","getattrribute","能够","更","该","尝试","也","局部","obj","可以","这些","10","但是","keys","from","唯一","默认","删除","发给","做","last","了","看","而言","设置","任何","所","来讲","反映","module","通过","必要","*","input","、","只要","将","[","1100.0","<","所示","操作","实际","和","就","关联","相关","透明","来","值","转发给","ipython","。","被","运算","结构","运算符","class","内部"," ","-","数据","（","始终","）","attributeerror","各种","init","它们","对象","radius","self","delattr","或","c","很少","recent","=","情况","抛出","实现","涉及",",","特殊","main","]","以及","例如","：","一般来讲","检查","所有","过程","另","如下","时候","doc","的","其","return","依靠","#",".","__","浅层","14","使用","底层","与","import","\"","本身","方法","工作","一个","perimeter","异常","a1a0cdcb1eb3","有","，","del","进行","setattr",")","字典","执行",".__","这","描述","下","2","向","account","从","weakref","地","类","in","直接","自己","guido"],"title":"对象表示和属性绑定","title_tokens":["对象","绑定","和","表示","属性"]},{"location":"Python基础/4.1.类.html#__slots__","text":"通过定义特殊变量 slots ，类可以限制对合法实例属性名称的设置，如下所示： class Account ( object ): def __init__ ( self , name , balance ): self . name = name self . balance = balance __slots__ = ( 'name' , 'balance' ) a = Account ( \"Guido\" , 1100.0 ) a . date = \"12-12\" ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-b978ca4ed4ad> in <module> 7 8 a = Account(\"Guido\", 1100.0) ----> 9 a.date = \"12-12\" AttributeError: 'Account' object has no attribute 'date' 定义 __slots__ 时，可以将实例上分配的属性名称限制为指定的名称，否则将引发 AttributeError 异常。这种限制可以阻止其他人向现有实例添加新属性，即便用户将属性名称写错，也不会创建出新的属性来。 在实际使用中， __slots__ 从未被当作一种安全的特性来实现。它实际上是对内存和执行速度的一种性能优化。 使用 __slots__ 的类的实例不再使用字典来存储实例数据，转而采用一种基于数组的更加紧凑的数据结构。在会创建大量对象的程序中，使用 __slots__ 可以显著减少减少内存占用和执行时间。 注意， __slots__ 与继承的配合使用需要一定的技巧。如果类继承自使用 __slots__ 的基类，那么它也需要定义 __slots__ 来存储自己的属性（即使它不会添加任何属性也是如此），这样才能利用 __slots__ 提供的优势。如果忘记了这一点，派生类的运行速度将更慢，占用的内存也更多，比完全不使用 __slots__ 时情况更糟。 __slots__ 的使用还会破坏期望实例具有底层 __dict__ 属性的代码。尽管这一点通常不适用于用户代码，但对于支持对象的实用库和其他工具，其代码可能要依靠 __dict__ 来调试、序列化对象以及执行其他操作。 最后，如果类中重新定义了 __getattribute__() 、 __getattr__() 和 __setattr__() 等方法， __slots__ 的存在不会对它们的调用产生任何影响。但是，这些方法的默认行为将考虑到 __slots__ 。此外应该强调一点，没有必要向 __slots__ 添加方法或特性名称，因为它们存储在类中，而不是存储在每个实例中。","text_tokens":["call",":","用户","1","性能","其他人","每个","用于",">","时","9","b978ca4ed4ad","利用","创建","大量","尽管","强调","产生","对","不","应该","name","而","属性","中","特性","实例","新","调用","分配","一点","balance","这种","def","技巧","但","定义","名称","速度","如果","紧凑","traceback","可能","这样","通常","getattribute","等","注意","行为","库","优势","其他","更糟","才能","显著","提供","忘记","更慢","在","'","most","安全","影响","调试","即使","no","是","派生","a","一种","object","重新","指定","现有","getattr","上","添加","(","阻止","不再","会","自","最后","到","基于","dict","基类","考虑","更","优化","7","也","可以","这些","多","支持","工具","attribute","但是","派生类","默认","last","数组","存储","了","合法","即便","设置","要","限制","实际上","序列","任何","出新","此外","从未","module","不会","通过","必要","继承","比","还会","代码","input","一定","、","将","期望","<","1100.0","如此","配合","所示","实际","它","和","破坏","操作","否则","程序","来","12","ipython","。","被","结构","类中","class","需要","序列化"," ","-","数据","（","attributeerror","）","不适","实用","引发","那么","init","写错","对象","它们","采用","self","或","recent","=","他人","情况","转而","实现","has",",","更加","特殊","占用","时间","以及","具有","：","如下","内存","的","date","其","运行","依靠",".","__","存在","使用","底层","对于","与","因为","\"","方法","异常","没有","slots","当作","，","数据结构","setattr",")","执行","8","字典","这","变量","向","account","减少","完全","为","类","in","不是","自己","guido"],"title":"__slots__","title_tokens":["slots","__"]},{"location":"Python基础/4.1.类.html#_12","text":"difference between staticmethod and classmethod in python","text_tokens":["and","python","classmethod"," ","difference","in","staticmethod","between"],"title":"参考","title_tokens":["参考"]},{"location":"Python基础/4.2.模块.html","text":"为什么需要模块 如果你想要编写一些更大的程序，肯定不想定义重复的函数、类，想让代码可以重复使用。随着程序变得越来越大，你可能想要将它分割成几个更易于维护的文件。为了满足这些需要，Python 提供了一个方法可以从文件中获取定义，在脚本或者解释器的一个交互式实例中使用。这样的文件被称为模块。 模块搜索路径 Python 怎样知道从何处找到模块文件？ 如果你熟悉命令行，那么这个问题对你来说就不难理解。在命令行中执行的任何命令，实际上背后都对应了一个可执行文件。命令行解释器（比如 cmd, bash）会从一个全局的环境变量 PATH 中读取一个有序的列表。这个列表包含了一系列的路径，而命令行解释器，会依次在这些路径里，搜索需要的可执行文件。 Python 搜寻模块文件，也遵循了类似的思路。比如，用户在 Python 中尝试导入 import foobar，那么 首先，Python 会在内建模块中搜寻 foobar； 若未找到，则 Python 会在当前工作路径（当前脚本所在路径，或者执行 Python 解释器的路径）中搜寻 foobar； 若仍未找到，则 Python 会在环境变量 PYTHONPATH 中指示的路径中搜寻 foobar； 若依旧未能找到，则 Python 会在安装时指定的路径中搜寻 foobar； 若仍旧失败，则 Python 会报错，提示找不到 foobar 这个模块。 添加搜索路径 当我们使用import加载自己编写的py代码时，必须放在python的默认路径下才可以import。 添加临时路径—— sys.path.append 在python中引入 sys ， sys 中的 path 是一个列表类型的对象，内容就是路径的列表，我们将sys引入后查看就可以清楚的知道了： import sys print ( type ( sys . path )) [ path for path in sys . path if \"Wiki\" not in path ] <class 'list'> ['C:\\\\Users\\\\Android\\\\Desktop', 'G:\\\\Installed\\\\Anaconda3\\\\python37.zip', 'G:\\\\Installed\\\\Anaconda3\\\\DLLs', 'G:\\\\Installed\\\\Anaconda3\\\\lib', 'G:\\\\Installed\\\\Anaconda3', 'C:\\\\Users\\\\Android\\\\AppData\\\\Roaming\\\\Python\\\\Python37\\\\site- packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site- packages\\\\xgboost-1.0.0_snapshot-py3.7.egg', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32\\\\lib', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\Pythonwin', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\IPython\\\\extensions', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop'] 既然是list对象，那么使用append可以向列表添加新的元素，假设我们要添加的路径是 \"C:\\Users\\Android\\Desktop\" ： import sys sys . path . append ( r \"C:\\Users\\Android\\Desktop\" ) 但这只是临时添加路径，如果重启编译器，添加的路径就会消失。 修改环境变量 在Windows10中，选择 ->控制面板\\系统和安全\\系统->高级系统设置->环境变量 ， # 找到path后选择编辑，添加新的路径。 但这种方法不能适用所有python的功能，因为这种方法并未将要查找的路径添加到python的Path系统环境中，在sys.path的列表中找不到相关路径的元素。也就是说这样做并没有将路径添加到python的搜索路径中。 添加永久搜索路径——增加.pth文件 在site-packages文件夹添加path文件，可以实现搜索路径的永久添加。方法如下： 先编辑一个扩展名为 .pth 的文本文件，在这个文本文件里面写上要添加的path就可以了，例如： 文本文件的文件名是：test.pth test.pth 文件的内容是： C:\\Users\\Android\\Desktop 接着获取python的site-packages文件夹的路径： import site site . getsitepackages () ['G:\\\\Installed\\\\Anaconda3', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site- packages'] 然后将 test.pth 文件放进 G:\\Installed\\Anaconda3\\lib\\site-packages 里面即可。 模块的导入 在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块(module)导入: 例如，我们要使用使用 sys 模块，那么首先要导入该模块： import sys 导入 sys 模块后，我们就有了 变量 sys 指向该模块，利用 sys 这个变量，就可以访问 sys 模块的所有功能。 也就是说导入整个模块的做法会导致命名空间的修改。 也可以一次性导入多个module： import os , sys , time 通过 as 关键字，可以在导入module的时候，给module定义别名： import sys as system 从某个模块中导入函数： 从某个模块中导入某个函数 from somemodule import somefunction 从某个模块中导入多个函数 from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入 from somemodule import * 一般而言，除了实验、排查，不推荐导入模块内的所有公开符号（没有前缀 _ 的那些）。因为导入模块会修改namespace，而通常你不知道模块定义了哪些符号、是否与当前的namespace有重名的符号。一旦有重名，那么，就会覆盖掉当前namespace的值。从而造成难以排查的错误 模块重载 出于性能考虑， 每个模块在每个解释器会话中只导入一遍。 因此，如果修改了的模块，需要重启解释器；如果想交互式地测试一个模块，则需要使用以下方法重新导入模块： 注意 只能重载模块，不能单独重载模块中的某个函数、类、变量。 Python 2.x： reload ( modulename ) Python 2.x 至 Python3.3： import imp imp . reload ( modulename ) Python3.4+： import importlib importlib . reload ( modulename ) 另外，spyder 的UMR(user module reloader)提供了自动重载模块的功能。 模块的识别 和 Python 中的其它对象一样，Python 也为模块定义了一些形如 __foo__ 的变量。对于模块来说，最重要的就是它的名字 __name__ 了。每当 Python 执行脚本，它就会为该脚本赋予一个名字： 对于「主程序」来说，这一脚本的 __name__ 被定义为 \"__main__\" 对于被 import 进主程序的模块来说，这一脚本的 __name__ 被定义为脚本的文件名（base filename） 因此，我们可以用如下的形式，在模块代码中定义一些测试代码： if __name__ == \"__main__\" : ··· 当脚本被直接运行时，测试代码就会被运行；当脚本作为模块被导入，测试代码不会被运行。 以下是一个完整的代码示例： 参考：(Python 中的黑暗角落（三）：模块与包)[https://liam0205.me/2017/07/23/modules-and-packages-of-python/] #!/usr/bin/env python3 # -*- coding: utf-8 -*- ' a test module ' __author__ = 'Michael Liao' import sys def test (): args = sys . argv if len ( args ) == 1 : print ( 'Hello, world!' ) elif len ( args ) == 2 : print ( 'Hello, %s !' % args [ 1 ]) else : print ( 'Too many arguments!' ) if __name__ == '__main__' : test () Hello, world! 作用域 在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用，在Python中，是通过 _ 前缀来实现的。 正常的函数和变量名是公开的（public），可以被直接引用，比如： abc ， x123 ， PI 等； 类似 __xxx__ 这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的 __author__ ， __name__ 就是特殊变量， hello 模块定义的文档注释也可以用特殊变量 __doc__ 访问，我们自己的变量一般不要用这种变量名； 类似 _xxx 和 __xxx 这样的函数或变量就是非公开的（private），不应该被直接引用，比如 _abc ， __abc 等； 之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。 private函数或变量不应该被别人引用，那它们有什么用呢？请看例子 def _private_1 ( name ): return 'Hello, %s ' % name def _private_2 ( name ): return 'Hi, %s ' % name def greeting ( name ): if len ( name ) > 3 : return _private_1 ( name ) else : return _private_2 ( name ) 我们在模块里公开 greeting() 函数，而把内部逻辑用private函数隐藏起来了，这样，调用 greeting() 函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即： 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。 作为脚本来执行模块 当你使用以下方式运行 Python 模块时，模块中的代码便会被执行: python fibo.py <arguments> 模块中的代码会被执行，就像导入它一样，不过 此时 __name__ 被设置为 \"__main__\" 。 这相当于，如果你在模块后加入如下代码: if __name__ == \"__main__\" : import sys fib ( int ( sys . argv [ 1 ])) 就可以让此文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为 “main” 文件执行时才被调用: $ python fibo . py 50 1 1 2 3 5 8 13 21 34 如果模块被导入，不会执行这段代码: >>> import fibo >>> 这通常用来为模块提供一个便于测试的用户接口（将模块作为脚本执行测试需求）。 “编译的” Python 文件—— pyc 文件 和 LaTeX 中遇到的问题一样：装载大量文本文件（ .py 文件）是很慢的。因此 Python 也采用了类似 LaTeX 的解决方案：将模块编译成容易装载的文件，并在 __pycache__ 目录下以 module.*version*.pyc 名字缓存这些文件。（相当于 LaTeX 中的 dump 格式文件 .fmt ）。 这里的版本编制了编译后文件的格式。它通常会包含 Python 的版本号。例如，在 CPython 3.3 版中，spam.py 编译后的版本将缓存为 __pycache__/spam.cpython-33.pyc 。这种命名约定允许由不同发布和不同版本的 Python 编译的模块同时存在。 当 Python 编译好模块之后，下次载入时，Python 就会读取相应的 .pyc 文件，而不是 .py 文件。而装载 .pyc 文件会比装载 .py 文件更快。 Python 会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。 这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。 Python 不检查在两个不同环境中的缓存。首先，它会永远重新编译而且不会存储直接从命令行加载的模块。其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源文件的模块。 部分高级技巧: 为了减少一个编译模块的大小，你可以在 Python 命令行中使用 -O 或者 -OO 。 -O 参数删除了断言语句， -OO 参数删除了断言语句和 doc 字符串。 因为某些程序依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。“优化的” 模块有一个 .pyo 后缀而不是 .pyc 后缀。未来的版本可能会改变优化的效果。 来自 .pyc 文件或 .pyo 文件中的程序不会比来自 .py 文件的运行更快； .pyc 或 .pyo 文件只是在它们加载的时候更快一些。 compileall 模块可以为指定目录中的所有模块创建 .pyc 文件（或者使用 -O 参数创建 .pyo 文件）。 在 PEP 3147 中有很多关这一部分内容的细节，并且包含了一个决策流程。","text_tokens":["公开","用户","1","不到","重启","env","由",">","时","version","每当","不过","len","利用","greeting","选项","查看","同时","system","对","隐藏","type","从而","是因为","关键字","name","21","写","实例","新","foobar","python37","5","这种","dlls","50","egg","函数","遇到","确定","包含","释器","通常","作用","一遍","环境变","之后","搜索","赖于","0","造成","大","安装","arguments","模块","更大","」","作为","未来","在","安全","后缀","—","path","出于","time","不用","a","一种","指定","1.0","变得","roaming","版本号","先","一般","这一","dump","wiki","即","获取","当","secondfunc","便会","需求","zip","肯定","流程","你","也","场合","可以","其它","and","把","默认","想要","做","oo","test","实际上","限制","请","文本文件","是否","x123","给","这里","编译成","通过","·","代码","、","形","好","<","用","一部","它","导致","就","主程序","程序","相关","别名","满足","somefunction","逻辑","此","；"," ","名为","三","包","33","相当","后","方案","pyc","对象","多个","pythonwin","c","中有","pythonpath","制面","实现","compileall","列表","习惯","abc","因此","编译器","所有","过程","filename","#","使用","一次性","import","方法","\"","细节","一个","fib","用来","没有","此时","假设","有用","？","若","知道","减少","从","形式","清楚",":","windows10","me","随着","以","行文","角落","理解","让","即可","想","也就是说","文件夹","注释","适用","installed","这个","当前工作","def","技巧","r","搜寻","允许","sys","_","越来","放在","重载","这样","注意","两个","库","上面","of","thirdfunc","解决方案","下次","依旧","可执行文件","base","依赖于","引入","修改","coding","装载","somemodule","/","只是","访问","其次","接着","整个","慢","可用","那","%","源文件","到","python","某些","指向","加入","if","文件名","提示","下才","user","但是","参数","from","latex","删除","关心","存储","reloader","不同","文档","任何","读取","hi","3","文本","才","目录","就是","module","自动化","packages","很多","控制","另外","做法","未能","当于","将","元素","缓存","namespace","既然","来","内","黑暗","被","需要","class","日期","几个","解释","无误","「","print","...","=","重名","一些",",","只有","android","仍旧","示例","$","以下","格式文件","如下","return","所以","3.3","非常","__","未找到","类型","变量名","版中","正常","全部","执行","8","不要","地","重复使用","不能","完全","过期","类","in","直接","xxx","部分","关键","什么","modules","失败","大量","+","里面","指示","然后","仍","我们","extensions","not","args","引用","13","难以","中","命名","之间","一系列","则","将要","命令行","append","熟悉","g","一旦","spyder","系统","else","某个","如果","author","并未","等","win32","来自","liao","越来越","public","foo","modulename","不想","并且","2017","环境变量","哪些","x","字符串","思路","getsitepackages","路径","并","查找","决策","上","背后","参考","同一个","实验","编写","会","测试","自动","快","环境","hello","更","语句","一系","该","23","遵循","3147","分割","这些","交互","是非","那些","支持","为了","推荐","所在","之所以","了","“","看","维护","设置","而言","发布","当前","怎样","容易","消失","加载","pep","*","world","改变","比","一般而言","脚本","架构","解决","跨平台","编程","本文","这是","内部","-","临时","那么","名字","它们","many","采用","单独","放进","何处","编制","特殊","main","]","外部","例如","检查","易于","找","pycache","内容","来说","site","时候","格式",".","bash","必须","排查","错误","对于","存在","因为","与","工作","在内","称为","，","就是说","像",")","这","list","2","下","向","appdata","断言","自己","很","pyo","性能","每个","cmd","成","高级","符号","为什么","创建","别人","s","34","\\","对应","比如","方式","不","应该","而","说","识别","可用性","效果","调用","源","件夹","最","问题","python3.3","它会","python3.4","但","定义","可能","usr","!","关","赋予","michael","找到","argv","功能","spam","除了","只","liam0205","提供","命令","'","版本","抽象","永久","约定","例子","o","是","选择","pth","重新","都","下以","源目录","同一","系列","添加","增加","(","时才","如","不难理解","too","elif","相应","一部分","umr","仅仅","py3.7","建","imp","lib","pi","类似","导入","fmt","起来","as","firstfunc","考虑","封装","大小","至","尝试","优化","版","os","掉","依次","https","用途","希望","首先","重复","要","private","不会","永远","users","只能","utf","从文件","解释器","覆盖","相当于","[","实际","空间","和","共享","xgboost","值","ipython","。","importlib","报错","有序","段","便于","（","里","）","而且","或","平台","一样","完整","接口","文件","：","前缀","int","译成","作用域","扩展","会话","面板","python3","doc","编辑","的","编译","运行","reload","snapshot","控制面板","重要","anaconda3","载入","呢","for","py","交互式","有","进","一次","cpython","或者","bin","测试代码","desktop","字符","变量","07","依赖","为","”","全局","不难","不是","fibo"],"title":"4.2.模块","title_tokens":[".","4.2","模块"]},{"location":"Python基础/4.2.模块.html#_1","text":"如果你想要编写一些更大的程序，肯定不想定义重复的函数、类，想让代码可以重复使用。随着程序变得越来越大，你可能想要将它分割成几个更易于维护的文件。为了满足这些需要，Python 提供了一个方法可以从文件中获取定义，在脚本或者解释器的一个交互式实例中使用。这样的文件被称为模块。","text_tokens":["越来越","分割","几个","可以","这些","解释","交互","随着","大","为了","想要","成","更大","提供","不想","一些","重复","了","维护","在","模块","让","文件","想","易于","变得","中","实例","的","代码","脚本","、","从文件","解释器","将","使用","它","编写","方法","函数","程序","一个","获取","交互式","称为","，","定义","越来","可能","如果","满足","。","python","或者","释器","被","肯定","这样","需要","你","重复使用"," ","更","类"],"title":"为什么需要模块","title_tokens":["需要","模块","什么","为什么"]},{"location":"Python基础/4.2.模块.html#_2","text":"Python 怎样知道从何处找到模块文件？ 如果你熟悉命令行，那么这个问题对你来说就不难理解。在命令行中执行的任何命令，实际上背后都对应了一个可执行文件。命令行解释器（比如 cmd, bash）会从一个全局的环境变量 PATH 中读取一个有序的列表。这个列表包含了一系列的路径，而命令行解释器，会依次在这些路径里，搜索需要的可执行文件。 Python 搜寻模块文件，也遵循了类似的思路。比如，用户在 Python 中尝试导入 import foobar，那么 首先，Python 会在内建模块中搜寻 foobar； 若未找到，则 Python 会在当前工作路径（当前脚本所在路径，或者执行 Python 解释器的路径）中搜寻 foobar； 若仍未找到，则 Python 会在环境变量 PYTHONPATH 中指示的路径中搜寻 foobar； 若依旧未能找到，则 Python 会在安装时指定的路径中搜寻 foobar； 若仍旧失败，则 Python 会报错，提示找不到 foobar 这个模块。","text_tokens":["用户","不到","cmd","时","失败","行文","理解","指示","对应","对","仍","比如","而","中","foobar","一系列","则","这个","问题","命令行","当前工作","熟悉","搜寻","如果","包含","释器","环境变","搜索","找到","安装","模块","在","命令","依旧","可执行文件","环境变量","path","思路","路径","指定","都","系列","背后","不难理解","会","环境","建","python","类似","导入","你","一系","尝试","遵循","也","这些","提示","依次","首先","所在","了","实际上","任何","怎样","当前","读取","未能","脚本","解释器","实际","就","。","需要","报错","有序"," ","；","（","里","）","那么","解释","pythonpath","何处","列表",",","仍旧","文件","找","来说","的","bash","未找到","import","工作","一个","在内","，","或者","？","执行","若","知道","变量","从","全局","不难"],"title":"模块搜索路径","title_tokens":["路径","搜索","模块"]},{"location":"Python基础/4.2.模块.html#_3","text":"当我们使用import加载自己编写的py代码时，必须放在python的默认路径下才可以import。","text_tokens":["可以","下才","时","默认","路径","我们","加载","的","代码","使用","必须","import","编写","py","当","，","放在","python","。","自己"],"title":"添加搜索路径","title_tokens":["路径","搜索","添加"]},{"location":"Python基础/4.2.模块.html#syspathappend","text":"在python中引入 sys ， sys 中的 path 是一个列表类型的对象，内容就是路径的列表，我们将sys引入后查看就可以清楚的知道了： import sys print ( type ( sys . path )) [ path for path in sys . path if \"Wiki\" not in path ] <class 'list'> ['C:\\\\Users\\\\Android\\\\Desktop', 'G:\\\\Installed\\\\Anaconda3\\\\python37.zip', 'G:\\\\Installed\\\\Anaconda3\\\\DLLs', 'G:\\\\Installed\\\\Anaconda3\\\\lib', 'G:\\\\Installed\\\\Anaconda3', 'C:\\\\Users\\\\Android\\\\AppData\\\\Roaming\\\\Python\\\\Python37\\\\site- packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site- packages\\\\xgboost-1.0.0_snapshot-py3.7.egg', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32\\\\lib', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\Pythonwin', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\IPython\\\\extensions', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop', 'C:\\\\Users\\\\Android\\\\Desktop'] 既然是list对象，那么使用append可以向列表添加新的元素，假设我们要添加的路径是 \"C:\\Users\\Android\\Desktop\" ： import sys sys . path . append ( r \"C:\\Users\\Android\\Desktop\" ) 但这只是临时添加路径，如果重启编译器，添加的路径就会消失。","text_tokens":[":","重启",">","查看","\\","type","我们","extensions","not","中","新","python37","installed","dlls","append","r","g","egg","但","sys","_","如果","win32","0","在","'","path","是","路径","1.0","引入","roaming","添加","(","只是","会","wiki","py3.7","python","lib","zip","if","可以","了","要","消失","就是","users","packages","将","[","<","元素","就","既然","xgboost","ipython","。","class"," ","-","临时","后","那么","对象","print","pythonwin","c","列表",",","android","]","：","编译器","内容","site","的","编译",".","snapshot","使用","anaconda3","import","类型","for","\"","一个","，","假设",")","这","desktop","list","知道","向","appdata","in","清楚"],"title":"添加临时路径——sys.path.append","title_tokens":["临时","sys","—","添加","path",".","路径","append"]},{"location":"Python基础/4.2.模块.html#_4","text":"在Windows10中，选择 ->控制面板\\系统和安全\\系统->高级系统设置->环境变量 ， # 找到path后选择编辑，添加新的路径。 但这种方法不能适用所有python的功能，因为这种方法并未将要查找的路径添加到python的Path系统环境中，在sys.path的列表中找不到相关路径的元素。也就是说这样做并没有将路径添加到python的搜索路径中。","text_tokens":["搜索","后","windows10","不到","找到","功能",">","制面","高级","做","在","安全","设置","环境变","列表","环境变量","path","\\","选择","也就是说","路径","所有","就是","找","并","查找","面板","控制","中","编辑","新","添加","的","适用","#",".","控制面板","这种","将要","将","元素","因为","和","方法","但","相关","没有","系统","sys","环境","，","到","就是说","python","。","并未","这样","变量","不能"," ","-"],"title":"修改环境变量","title_tokens":["环境变量","环境","变量","修改","环境变"]},{"location":"Python基础/4.2.模块.html#pth","text":"在site-packages文件夹添加path文件，可以实现搜索路径的永久添加。方法如下： 先编辑一个扩展名为 .pth 的文本文件，在这个文本文件里面写上要添加的path就可以了，例如： 文本文件的文件名是：test.pth test.pth 文件的内容是： C:\\Users\\Android\\Desktop 接着获取python的site-packages文件夹的路径： import site site . getsitepackages () ['G:\\\\Installed\\\\Anaconda3', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site- packages'] 然后将 test.pth 文件放进 G:\\Installed\\Anaconda3\\lib\\site-packages 里面即可。","text_tokens":["搜索",":","可以","c","放进","实现","了","在","'","test",",","要","android","永久","文本文件","path","里面","\\","例如","文件","：","是","]","pth","文本","getsitepackages","路径","然后","即可","内容","扩展","如下","site","文件夹","packages","文件名","users","写","编辑","的","添加","先","上","(",".","将","件夹","[","这个","installed","anaconda3","import","方法","就","接着","g","一个","获取","，","python","lib","。",")","desktop","本文"," ","-","名为"],"title":"添加永久搜索路径——增加.pth文件","title_tokens":["搜索","永久","—","添加","增加","文件",".","pth","路径"]},{"location":"Python基础/4.2.模块.html#_5","text":"在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块(module)导入: 例如，我们要使用使用 sys 模块，那么首先要导入该模块： import sys 导入 sys 模块后，我们就有了 变量 sys 指向该模块，利用 sys 这个变量，就可以访问 sys 模块的所有功能。 也就是说导入整个模块的做法会导致命名空间的修改。 也可以一次性导入多个module： import os , sys , time 通过 as 关键字，可以在导入module的时候，给module定义别名： import sys as system 从某个模块中导入函数： 从某个模块中导入某个函数 from somemodule import somefunction 从某个模块中导入多个函数 from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入 from somemodule import * 一般而言，除了实验、排查，不推荐导入模块内的所有公开符号（没有前缀 _ 的那些）。因为导入模块会修改namespace，而通常你不知道模块定义了哪些符号、是否与当前的namespace有重名的符号。一旦有重名，那么，就会覆盖掉当前namespace的值。从而造成难以排查的错误","text_tokens":["公开",":","关键","符号","利用","system","也就是说","我们","从而","不","关键字","而","难以","中","命名","这个","一旦","函数","sys","某个","_","定义","通常","造成","thirdfunc","功能","除了","模块","在","哪些","time","修改","somemodule","(","一般","实验","访问","相应","会","整个","secondfunc","python","导入","指向","as","firstfunc","你","该","也","os","可以","掉","那些","from","首先","推荐","了","而言","要","当前","是否","给","就是","module","通过","*","做法","一般而言","、","覆盖","将","用","导致","就","空间","namespace","来","别名","值","somefunction","内","。"," ","（","）","那么","后","多个","...","重名",",","例如","：","前缀","所有","时候","的","排查","使用","错误","一次性","import","因为","与","没有","有","一次","全部","，","就是说","或者",")","变量","知道","从"],"title":"模块的导入","title_tokens":["导入","的","模块"]},{"location":"Python基础/4.2.模块.html#_6","text":"出于性能考虑， 每个模块在每个解释器会话中只导入一遍。 因此，如果修改了的模块，需要重启解释器；如果想交互式地测试一个模块，则需要使用以下方法重新导入模块： 注意 只能重载模块，不能单独重载模块中的某个函数、类、变量。 Python 2.x： reload ( modulename ) Python 2.x 至 Python3.3： import imp imp . reload ( modulename ) Python3.4+： import importlib importlib . reload ( modulename ) 另外，spyder 的UMR(user module reloader)提供了自动重载模块的功能。","text_tokens":["解释","性能","交互","user","重启","每个","单独","功能","只","modulename","提供","模块","了","在","reloader","+","出于","x","：","想","因此","以下","重新","修改","module","会话","只能","中","另外","的","(","则","、","解释器",".","reload","使用","python3.3","import","方法","spyder","python3.4","测试","一个","函数","importlib","交互式","umr","自动","某个","，","imp","python","如果","导入","。","释器","重载",")","2","地","变量","考虑","需要","注意","一遍","；"," ","不能","类","至"],"title":"模块重载","title_tokens":["模块","重载"]},{"location":"Python基础/4.2.模块.html#_7","text":"和 Python 中的其它对象一样，Python 也为模块定义了一些形如 __foo__ 的变量。对于模块来说，最重要的就是它的名字 __name__ 了。每当 Python 执行脚本，它就会为该脚本赋予一个名字： 对于「主程序」来说，这一脚本的 __name__ 被定义为 \"__main__\" 对于被 import 进主程序的模块来说，这一脚本的 __name__ 被定义为脚本的文件名（base filename） 因此，我们可以用如下的形式，在模块代码中定义一些测试代码： if __name__ == \"__main__\" : ··· 当脚本被直接运行时，测试代码就会被运行；当脚本作为模块被导入，测试代码不会被运行。 以下是一个完整的代码示例： 参考：(Python 中的黑暗角落（三）：模块与包)[https://liam0205.me/2017/07/23/modules-and-packages-of-python/] #!/usr/bin/env python3 # -*- coding: utf-8 -*- ' a test module ' __author__ = 'Michael Liao' import sys def test (): args = sys . argv if len ( args ) == 1 : print ( 'Hello, world!' ) elif len ( args ) == 2 : print ( 'Hello, %s !' % args [ 1 ]) else : print ( 'Too many arguments!' ) if __name__ == '__main__' : test () Hello, world!","text_tokens":[":","1","me","env","时","modules","每当","len","角落","s","我们","args","name","中","最","def","else","sys","定义","usr","author","!","赋予","michael","of","liao","argv","foo","liam0205","arguments","模块","」","作为","在","2017","'","base","是","a","coding","(","参考","如","too","elif","这一","/","会","测试","当","%","python","导入","if","hello","文件名","23","该","也","可以","其它","and","https","了","test","就是","module","不会","packages","*","world","·","代码","脚本","utf","形","[","用","它","主程序","和","就","程序","黑暗","。","被","；"," ","-","（","三","包","）","名字","对象","「","many","print","=","一样","一些","完整",",","main","示例","]","文件","：","因此","以下","来说","如下","python3","的","filename","运行","#",".","__","重要","对于","与","import","\"","一个","进","，","执行",")","测试代码","bin","8","2","变量","07","形式","为","直接"],"title":"模块的识别","title_tokens":["的","模块","识别"]},{"location":"Python基础/4.2.模块.html#_8","text":"在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用，在Python中，是通过 _ 前缀来实现的。 正常的函数和变量名是公开的（public），可以被直接引用，比如： abc ， x123 ， PI 等； 类似 __xxx__ 这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的 __author__ ， __name__ 就是特殊变量， hello 模块定义的文档注释也可以用特殊变量 __doc__ 访问，我们自己的变量一般不要用这种变量名； 类似 _xxx 和 __xxx 这样的函数或变量就是非公开的（private），不应该被直接引用，比如 _abc ， __abc 等； 之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。 private函数或变量不应该被别人引用，那它们有什么用呢？请看例子 def _private_1 ( name ): return 'Hello, %s ' % name def _private_2 ( name ): return 'Hi, %s ' % name def greeting ( name ): if len ( name ) > 3 : return _private_1 ( name ) else : return _private_2 ( name ) 我们在模块里公开 greeting() 函数，而把内部逻辑用private函数隐藏起来了，这样，调用 greeting() 函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即： 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。","text_tokens":["公开",":","1","什么",">","成","greeting","len","别人","s","隐藏","比如","我们","引用","是因为","不","应该","注释","name","说","而","中","调用","这种","def","函数","但","else","_","可能","定义","author","等","这样","上面","public","模块","在","'","抽象","例子","是","不用","一种","并","上","(","一般","访问","会","为","即","仅仅","那","%","python","pi","类似","不是","起来","封装","if","hello","也","可以","但是","是非","用途","把","希望","关心","之所以","了","“","看","限制","private","请","文档","x123","给","hi","3","才","就是","通过","很多","代码","用","和","就","来","编程","。","被","逻辑","需要","；"," ","内部","（","里","）","它们","或","实现",",","只有","特殊","习惯","外部","abc","：","前缀","doc","的","所以","return","非常","__","使用","因为","方法","呢","细节","一个","变量名","没有","有","正常","，","全部","有用","？",")","这","不要","2","变量","不能","完全","从","”","直接","自己","xxx"],"title":"作用域","title_tokens":["作用","作用域"]},{"location":"Python基础/4.2.模块.html#_9","text":"当你使用以下方式运行 Python 模块时，模块中的代码便会被执行: python fibo.py <arguments> 模块中的代码会被执行，就像导入它一样，不过 此时 __name__ 被设置为 \"__main__\" 。 这相当于，如果你在模块后加入如下代码: if __name__ == \"__main__\" : import sys fib ( int ( sys . argv [ 1 ])) 就可以让此文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为 “main” 文件执行时才被调用: $ python fibo . py 50 1 1 2 3 5 8 13 21 34 如果模块被导入，不会执行这段代码: >>> import fibo >>> 这通常用来为模块提供一个便于测试的用户接口（将模块作为脚本执行测试需求）。","text_tokens":[":","用户","1",">","时","不过","让","34","13","方式","name","21","中","调用","5","50","sys","如果","通常","argv","arguments","提供","模块","作为","在","时才","(","会","测试","当","便会","需求","python","导入","加入","你","if","可以","“","设置","3","不会","代码","当于","脚本","相当于","将","<","[","它","就","。","被","此","段"," ","便于","（","）","相当","后","=","一样","只有","接口","main","]","文件","$","以下","int","如下","的","运行",".","__","使用","import","\"","py","fib","一个","用来","，","此时","像","执行","这",")","8","2","为","”","fibo"],"title":"作为脚本来执行模块","title_tokens":["来","脚本","执行","作为","模块"]},{"location":"Python基础/4.2.模块.html#python-pyc","text":"和 LaTeX 中遇到的问题一样：装载大量文本文件（ .py 文件）是很慢的。因此 Python 也采用了类似 LaTeX 的解决方案：将模块编译成容易装载的文件，并在 __pycache__ 目录下以 module.*version*.pyc 名字缓存这些文件。（相当于 LaTeX 中的 dump 格式文件 .fmt ）。 这里的版本编制了编译后文件的格式。它通常会包含 Python 的版本号。例如，在 CPython 3.3 版中，spam.py 编译后的版本将缓存为 __pycache__/spam.cpython-33.pyc 。这种命名约定允许由不同发布和不同版本的 Python 编译的模块同时存在。 当 Python 编译好模块之后，下次载入时，Python 就会读取相应的 .pyc 文件，而不是 .py 文件。而装载 .pyc 文件会比装载 .py 文件更快。 Python 会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。 这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。 Python 不检查在两个不同环境中的缓存。首先，它会永远重新编译而且不会存储直接从命令行加载的模块。其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源文件的模块。 部分高级技巧: 为了减少一个编译模块的大小，你可以在 Python 命令行中使用 -O 或者 -OO 。 -O 参数删除了断言语句， -OO 参数删除了断言语句和 doc 字符串。 因为某些程序依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。“优化的” 模块有一个 .pyo 后缀而不是 .pyc 后缀。未来的版本可能会改变优化的效果。 来自 .pyc 文件或 .pyo 文件中的程序不会比来自 .py 文件的运行更快； .pyc 或 .pyo 文件只是在它们加载的时候更快一些。 compileall 模块可以为指定目录中的所有模块创建 .pyc 文件（或者使用 -O 参数创建 .pyo 文件）。 在 PEP 3147 中有很多关这一部分内容的细节，并且包含了一个决策流程。","text_tokens":[":","pyo","部分","以","由","version","时","高级","选项","创建","大量","同时","不","应该","而","可用性","中","命名","之间","效果","源","直接","这种","问题","命令行","技巧","它会","允许","系统","遇到","可能","确定","如果","包含","关","通常","两个","库","之后","来自","赖于","解决方案","spam","只","模块","下次","未来","并且","在","命令","版本","约定","后缀","o","字符串","依赖于","是","重新","指定","修改","并","下以","决策","源目录","装载","版本号","同一","同一个","这一","/","dump","会","相应","其次","只是","自动","一部分","慢","当","快","可用","源文件","环境","python","某些","类似","fmt","流程","大小","你","更","语句","优化","版","3147","也","场合","可以","这些","支持","参数","为了","首先","latex","删除","依赖","了","存储","“","oo","不同","要","发布","文本文件","容易","读取","是否","这里","文本","目录","编译成","module","永远","不会","自动化","加载","pep","*","很多","改变","比","当于","好","相当于","将","一部","它","缓存","和","就","解决","架构","共享","程序","跨平台","。","本文","需要","这是","；"," ","-","（","）","日期","33","相当","方案","后","pyc","名字","而且","断言","无误","它们","采用","或","中有","平台","一样","编制","一些","compileall","只有","例如","文件","：","因此","检查","所有","过程","译成","pycache","内容","过期","格式文件","时候","格式","doc","的","所以","编译","3.3","运行",".","__","存在","必须","使用","与","载入","因为","细节","py","一个","版中","没有","有","cpython","，","或者","若","这","字符","下","变量","减少","从","完全","为","”","不是","很"],"title":"“编译的” Python 文件——pyc 文件","title_tokens":["的","—","编译","pyc","python","文件"," ","“","”"]},{"location":"numpy笔记/6.1.创建数组.html","text":"import numpy as np 共同的参数 这里有几个共同的参数： a ：一个 array-like 类型的实例，它不一定是数组，可以为 list 、 tuple 、 list of tuple 、 list of list 、 tuple of list 、 tuple of tuple 等等。 dtype ：数组的值类型，默认为 float 。你可以指定Python的标准数值类型，也可以使用 numpy 的数值类型如： numpy.int32 或者 numpy.float64 等等。 order ：指定存储多维数据的方式。 - 'C' ，表示按行优先存储（C风格）； - 'F' ，表示按列优先存储（Fortran风格）。 - 对于 **_like() 函数， order 可以为： 'C' ， 'F' ， 'A' （表示结果的order与a相同）， 'K' （表示结果的 order 与 a 尽可能相似） subok ： bool 值。如果为 True 则：如果 a 为 ndarray 的子类（如 matrix 类），则结果类型与 a 类型相同。如果为 False 则：结果类型始终为 ndarray 。默认为True。 从现有的数据创建 1 np.array(object[, dtype, copy, order, subok, ndmin]) :从 object 创建。 - object 可以是一个 ndarray ，也可以是一个 array_like 的对象，也可以是一个含有返回一个序列或者 ndarray 的 __array__ 方法的对象，或者一个序列。 - `copy` ：默认为 `True` ，表示拷贝对象 - `order` 可以为 `'C'、'F'、'A'` 。默认为 `'K'` 。 - `subok` 默认为 `False` - `ndmin` ：指定结果 `ndarray` 最少有多少个维度。 2 np.asarray(a[, dtype, order]) ：将 a 转换成一个 ndarray 。其中 a 是 array_like 的对象， 可以是 list 、 list of tuple 、 tuple 、 tuple of list 、 ndarray 类型。 order 默认为 C 。 3 np.asanyarray(a[, dtype, order]) ：将 a 转换成 ndarray 。 4 np.ascontiguousarray(a[, dtype]) ：返回C风格的连续 ndarray 。 5 np.copy(a[, order]) ：返回 ndarray 的一份深拷贝。 以上5个方法实际上都是调用了 array() 的接口。 np . asarray () # array(a, dtype, copy=False, order=order) np . asanyarray () # array(a, dtype, copy=False, order=order, subok=True) np . ascontiguousarray () # array(a, dtype, copy=False, order='C', ndmin=1) np . copy () # array(a, order=order, copy=True) 6 np.asmatrix(data[, dtype]) ：返回 matrix 。 7 np.frombuffer(buffer[, dtype, count, offset]) ：从输入数据中返回一维 ndarray 。 count 指定读取的数量， -1 表示全部读取； offset 指定从哪里开始读取，默认为0。 创建的数组与 buffer 共享内存。 buffer 是一个提供了 buffer 接口的对象（ 内置的 bytes/bytearray/array.array 类型提供了该接口 ）。 from array import array # array.array 提供了类似list对象的内存机制 a = array ( \"d\" , [ 1 , 2 , 3 , 4 ]) # 创建一个array数组 na = np . frombuffer ( a , dtype = np . float ) # 通过np.frombuffer()创建一个和a共享内存的NumPy数组 print ( \"a:\" , a ) print ( \"na:\" , na ) na [ 1 ] = 20 # 修改NumPy数组中的第一个元素 a # array数组中的第一个元素也同时改变 a : array ( 'd' , [ 1.0 , 2.0 , 3.0 , 4.0 ]) na : [ 1 . 2 . 3 . 4 .] array('d', [1.0, 20.0, 3.0, 4.0]) 8 np.fromfile(file[, dtype, count, sep]) ：从二进制文件或者文本文件中读取数据返回 ndarray 。 sep ：当从文本文件中读取时，数值之间的分隔字符串，如果 sep 是空字符串则表示文件应该作为二进制文件读取；如果 sep 为 \" \" 表示可以匹配0个或者多个空白字符。 9 np.fromfunction(function, shape, \\**kwargs) ：返回一个 ndarray 。function会获取每一个坐标点的数据，作为输入参数。假设 shape 的维度为N，那么 function 带有 N 个参数， fn(x1,x2,...x_N) ，其返回值就是该坐标点的值。 def fun ( x , y ): return x + y np . fromfunction ( fun , shape = ( 3 , 3 )) array([[0., 1., 2.], [1., 2., 3.], [2., 3., 4.]]) 10 np.fromiter(iterable, dtype[, count]) ：从可迭代对象中迭代获取数据创建一维 ndarray 。 np . fromiter ( \"123\" , dtype = \"int64\" ) array([1, 2, 3], dtype=int64) 11 np.fromstring(string[, dtype, count, sep]) ：从字符串或者 raw binary 中创建一维 ndarray 。如果 sep 为空字符串则 string 将按照二进制数据解释（即每个字符作为 ASCII 码值对待）。创建的数组有自己的数据存储区。 a = \"abcdefg\" a = np . fromstring ( a , dtype = np . int8 ) # 将每个字符的ASCII编码解释为整数 print ( a ) a = \"1;2;3;4;5\" a = np . fromstring ( a , dtype = np . int8 , sep = \";\" ) print ( a ) [ 97 98 99 100 101 102 103] [1 2 3 4 5] .\\setup_m.py:2: DeprecationWarning: The binary mode of fromstring is deprecated, as it behaves surprisingly on unicode inputs. Use frombuffer instead from datetime import datetime 12 np.loadtxt(fname[, dtype, comments, delimiter, ...]) :从文本文件中加载数据创建 ndarray ，要求文本文件每一行都有相同数量的数值。 comments ：指示注释行的起始字符，可以为单个字符或者字符列表（默认为 # ）。 delimiter :指定数值之间的分隔字符串，默认为空白符。 converters ：将指定列号(0,1,2...)的列数据执行转换，是一个 map ，如 {0:func1} 表示对第一列数据执行 func1(val_0) 。 skiprows ：指定跳过开头的多少行。 usecols ：指定读取那些列（0表示第一列）。 从数值区间创建 1 np.arange([start,] stop[, step,][, dtype]) :返回均匀间隔的值组成的一维 ndarray 。区间是半闭半开的 [start,stop) ，其采样行为类似Python的 range 函数。 start 为开始点， stop 为终止点， step 为步长，默认为1。这几个数可以为整数可以为浮点数。 注意如果 step 为浮点数，则结果可能有误差，因为浮点数相等比较不准确（计算机精度有限）。 2 np.linspace(start, stop[, num, endpoint, ...]) ：返回 num 个均匀采样的数值组成的一维 ndarray （默认为50）。区间是闭区间 [start,stop] 。 endpoint 为布尔值，如果为真则表示 stop 是最后采样的值（默认为 True ），否则结果不包含 stop 。 retstep 如果为 True 则返回结果包含采样步长 step ，默认为 True 。 3 np.logspace(start, stop[, num, endpoint, base, ...]) ：返回对数级别上均匀采样的数值组成的一维 ndarray 。采样点开始于 base^start ，结束于 base^stop 。 base 为对数的基，默认为 10。 它逻辑上相当于先执行 arange 获取数组 array ，然后再执行 base^array[i] 获取采样点 - 它没有 retstep 关键字参数 以填充的方式创建 1 np.empty(shape[,dtype,order]) ：返回一个新的 ndarray ，指定了 shape 和 dtype ，但是没有初始化元素。因此其内容是随机的。 2 np.empty_like(a[,dtype,order,subok]) ：返回一个新的 ndarray ， shape 与 a 相同，但是没有初始化元素。因此其内容是随机的。 # 内存未初始化 a = np . empty (( 3 , 2 ), order = \"C\" ) # 内存未初始化 np . empty_like ( a ) array([[0., 0.], [0., 0.], [0., 0.]]) 3 np.eye(N[, M, k, dtype]) ：返回一个==二维数组==，对角线元素为1，其余元素为0。 M 默认等于 N 。 k 默认为0表示对角线元素为1，如为正数则表示对角线上方一格的元素为1，如为负数表示对角线下方一格的元素为1。 4 np.identity(n[, dtype]) ：返回一个单位矩阵。 np . eye ( N = 2 , M = 3 ) np . eye ( N = 2 , M = 3 , k = 0 ) # 参数k是可以超出范围的 np . eye ( N = 2 , M = 3 , k = 1 ) # 返回n阶单位矩阵 np . identity ( n = 4 ) array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) 5 np.ones(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为1. 6 np.ones_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为1。 7 np.zeros(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为0. 8 np.zeros_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a （另一个数组）相同，每个元素初始化为0。 9 np.full(shape, fill_value[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为 fill_value 。 10 np.full_like(a, fill_value[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为 fill_value 。 np . full (( 2 , 3 ), fill_value = 2 ) array([[2, 2, 2], [2, 2, 2]])","text_tokens":["1","布尔值","123","k","转换成","相等","时","tuple","闭","拷贝","同时","103","组成","对","相同","type","fill","输入","获取数据","关键字","实例","新","val","5","50","fn","精度","20","函数","包含","迭代","ascontiguousarray","真则","0","机制","作为","string","a","指定","1.0","其中","先","true","ndmin","即","获取","当","copy","你","is","converters","7","也","可以","默认","f","每","码值","序列","实际上","均匀","文本文件","frombuffer","4","这里","浮点","通过","the","、","mode","一维","6","它","尽可能","初始","正数","逻辑","；"," ","100","fortran","fromstring","ones","相当","开始","fromfile","对象","多个","半开","c","列表","按行","哪里","因此","超出范围","另","it","fname","#","使用","import","方法","\"","一个","没有","i","列","假设","fromiter","从",":","以","第一","9","结束","负数","注释","offset","full","eye","比较","def","2.0","一格","点数","_","raw","坐标","注意","of","对角","surprisingly","跳过","优先","基","base","一份","object","stop","现有","修改","empty","zeros","delimiter","/","ndarray","带有","python","可","behaves","ascii","单个","其余","loadtxt","但是","参数","from","内置","浮点数","准确","存储","99","相似","共享内存","读取","3","文本","x1","下方","就是","identity","numpy","当于","维度","将","inputs","元素","bytearray","否则","int64","matrix",";","fun","二维","几个","解释","print","...","=",",","单位矩阵","20.0","buffer","转换","fromfunction","内存","97","iterable","return","file","列号","__","步长","类型","数","阶","全部","执行","8","usecols","类","order","要求","第一个","关键","多少","采样","一列","+","返回","指示","共同","subok","然后","d","unicode","中","之间","整数","dtype","则","like","含有","如果","endpoint","区","3.0","abcdefg","算机","x","字符串","func1","对待","use","等等","标准","未","{","asmatrix","y","上","二进制","kwargs","会","空白符","最后","进制","等于","该","retstep","分隔","那些","一行","了","加载","子类","comments","*","改变","101","n","对角线","个","随机","本文","asarray","-","以上","那么","换成","shape","range","]","空","内容","半闭","间隔","其",".","bytes","对于","与","因为","行","int32","，",")","这","为空","list","2","计算机","数组","自己","np","每个","创建","深","\\","于","data","na","deprecated","空白","方式","不","应该","风格","调用","false","datetime","布尔","可能","}","读取数据","尽可","行为","有限","binary","提供","'","start","`","m","x2","是","int8","级别","都","4.0","instead","最少","开头","(","如","on","结果","如为","连续","再","value","11","终止","范围","单位","skiprows","类似","区间","按照","count","as","初始化","对数","10","填充","asanyarray","起始","超出","按列","多维","arange","^","数值","function","返回值","一定","相当于","[","实际","array","表示","共享","和","num","点","值","12","。","（","数据","始终","）","编码","98","sep","float64","setup","map","step","接口","数量","文件","：","误差","102","第一列","的","匹配","上方","py","deprecationwarning","logspace","计算","linspace","有","或者","bool","字符","float","矩阵","为"],"title":"6.1.创建数组","title_tokens":[".","创建","6.1","数组"]},{"location":"numpy笔记/6.1.创建数组.html#_1","text":"这里有几个共同的参数： a ：一个 array-like 类型的实例，它不一定是数组，可以为 list 、 tuple 、 list of tuple 、 list of list 、 tuple of list 、 tuple of tuple 等等。 dtype ：数组的值类型，默认为 float 。你可以指定Python的标准数值类型，也可以使用 numpy 的数值类型如： numpy.int32 或者 numpy.float64 等等。 order ：指定存储多维数据的方式。 - 'C' ，表示按行优先存储（C风格）； - 'F' ，表示按列优先存储（Fortran风格）。 - 对于 **_like() 函数， order 可以为： 'C' ， 'F' ， 'A' （表示结果的order与a相同）， 'K' （表示结果的 order 与 a 尽可能相似） subok ： bool 值。如果为 True 则：如果 a 为 ndarray 的子类（如 matrix 类），则结果类型与 a 类型相同。如果为 False 则：结果类型始终为 ndarray 。默认为True。","text_tokens":["k","tuple","共同","subok","相同","方式","不","实例","风格","dtype","则","like","false","函数","_","可能","如果","尽可","of","'","优先","是","a","等等","指定","标准","(","true","如","结果","ndarray","python","你","也","可以","参数","默认","f","数组","存储","相似","按列","这里","多维","数值","子类","*","numpy","一定","、","它","尽可能","array","表示","值","。","matrix","；"," ","fortran","-","（","数据","始终","）","几个","float64","c","按行","：","的",".","使用","对于","与","类型","一个","int32","有","，","或者","bool",")","list","float","为","类","order"],"title":"共同的参数","title_tokens":["共同","的","参数"]},{"location":"numpy笔记/6.1.创建数组.html#_2","text":"1 np.array(object[, dtype, copy, order, subok, ndmin]) :从 object 创建。 - object 可以是一个 ndarray ，也可以是一个 array_like 的对象，也可以是一个含有返回一个序列或者 ndarray 的 __array__ 方法的对象，或者一个序列。 - `copy` ：默认为 `True` ，表示拷贝对象 - `order` 可以为 `'C'、'F'、'A'` 。默认为 `'K'` 。 - `subok` 默认为 `False` - `ndmin` ：指定结果 `ndarray` 最少有多少个维度。 2 np.asarray(a[, dtype, order]) ：将 a 转换成一个 ndarray 。其中 a 是 array_like 的对象， 可以是 list 、 list of tuple 、 tuple 、 tuple of list 、 ndarray 类型。 order 默认为 C 。 3 np.asanyarray(a[, dtype, order]) ：将 a 转换成 ndarray 。 4 np.ascontiguousarray(a[, dtype]) ：返回C风格的连续 ndarray 。 5 np.copy(a[, order]) ：返回 ndarray 的一份深拷贝。 以上5个方法实际上都是调用了 array() 的接口。 np . asarray () # array(a, dtype, copy=False, order=order) np . asanyarray () # array(a, dtype, copy=False, order=order, subok=True) np . ascontiguousarray () # array(a, dtype, copy=False, order='C', ndmin=1) np . copy () # array(a, order=order, copy=True) 6 np.asmatrix(data[, dtype]) ：返回 matrix 。 7 np.frombuffer(buffer[, dtype, count, offset]) ：从输入数据中返回一维 ndarray 。 count 指定读取的数量， -1 表示全部读取； offset 指定从哪里开始读取，默认为0。 创建的数组与 buffer 共享内存。 buffer 是一个提供了 buffer 接口的对象（ 内置的 bytes/bytearray/array.array 类型提供了该接口 ）。 from array import array # array.array 提供了类似list对象的内存机制 a = array ( \"d\" , [ 1 , 2 , 3 , 4 ]) # 创建一个array数组 na = np . frombuffer ( a , dtype = np . float ) # 通过np.frombuffer()创建一个和a共享内存的NumPy数组 print ( \"a:\" , a ) print ( \"na:\" , na ) na [ 1 ] = 20 # 修改NumPy数组中的第一个元素 a # array数组中的第一个元素也同时改变 a : array ( 'd' , [ 1.0 , 2.0 , 3.0 , 4.0 ]) na : [ 1 . 2 . 3 . 4 .] array('d', [1.0, 20.0, 3.0, 4.0]) 8 np.fromfile(file[, dtype, count, sep]) ：从二进制文件或者文本文件中读取数据返回 ndarray 。 sep ：当从文本文件中读取时，数值之间的分隔字符串，如果 sep 是空字符串则表示文件应该作为二进制文件读取；如果 sep 为 \" \" 表示可以匹配0个或者多个空白字符。 9 np.fromfunction(function, shape, \\**kwargs) ：返回一个 ndarray 。function会获取每一个坐标点的数据，作为输入参数。假设 shape 的维度为N，那么 function 带有 N 个参数， fn(x1,x2,...x_N) ，其返回值就是该坐标点的值。 def fun ( x , y ): return x + y np . fromfunction ( fun , shape = ( 3 , 3 )) array([[0., 1., 2.], [1., 2., 3.], [2., 3., 4.]]) 10 np.fromiter(iterable, dtype[, count]) ：从可迭代对象中迭代获取数据创建一维 ndarray 。 np . fromiter ( \"123\" , dtype = \"int64\" ) array([1, 2, 3], dtype=int64) 11 np.fromstring(string[, dtype, count, sep]) ：从字符串或者 raw binary 中创建一维 ndarray 。如果 sep 为空字符串则 string 将按照二进制数据解释（即每个字符作为 ASCII 码值对待）。创建的数组有自己的数据存储区。 a = \"abcdefg\" a = np . fromstring ( a , dtype = np . int8 ) # 将每个字符的ASCII编码解释为整数 print ( a ) a = \"1;2;3;4;5\" a = np . fromstring ( a , dtype = np . int8 , sep = \";\" ) print ( a ) [ 97 98 99 100 101 102 103] [1 2 3 4 5] .\\setup_m.py:2: DeprecationWarning: The binary mode of fromstring is deprecated, as it behaves surprisingly on unicode inputs. Use frombuffer instead from datetime import datetime 12 np.loadtxt(fname[, dtype, comments, delimiter, ...]) :从文本文件中加载数据创建 ndarray ，要求文本文件每一行都有相同数量的数值。 comments ：指示注释行的起始字符，可以为单个字符或者字符列表（默认为 # ）。 delimiter :指定数值之间的分隔字符串，默认为空白符。 converters ：将指定列号(0,1,2...)的列数据执行转换，是一个 map ，如 {0:func1} 表示对第一列数据执行 func1(val_0) 。 skiprows ：指定跳过开头的多少行。 usecols ：指定读取那些列（0表示第一列）。","text_tokens":["要求",":","第一个","1","np","123","k","转换成","多少","每个","时","第一","9","一列","创建","深","+","tuple","拷贝","同时","返回","\\","data","subok","na","103","deprecated","相同","指示","对","d","空白","输入","获取数据","应该","注释","unicode","offset","中","之间","风格","调用","整数","val","dtype","5","则","def","like","含有","fn","false","datetime","20","2.0","_","如果","}","读取数据","迭代","raw","ascontiguousarray","坐标","区","of","surprisingly","0","binary","机制","提供","3.0","作为","abcdefg","跳过","'","`","string","m","x2","字符串","x","func1","对待","是","use","a","一份","object","int8","指定","1.0","都","修改","其中","4.0","instead","最少","{","开头","asmatrix","y","delimiter","(","true","二进制","kwargs","on","如","结果","/","ndmin","会","ndarray","带有","即","空白符","获取","当","连续","11","可","behaves","类似","skiprows","按照","copy","count","ascii","as","单个","进制","is","converters","该","loadtxt","7","也","分隔","可以","10","那些","一行","参数","from","内置","默认","asanyarray","f","数组","了","每","存储","起始","99","码值","序列","实际上","共享内存","文本文件","frombuffer","4","读取","3","文本","x1","就是","加载","通过","数值","comments","*","改变","numpy","function","返回值","101","the","、","维度","mode","将","inputs","[","一维","元素","6","实际","array","表示","共享","bytearray","和","n","点","值","12","个","int64","。","matrix","fun",";","本文","asarray","；"," ","fromstring","-","100","数据","（","）","以上","编码","98","那么","解释","换成","开始","对象","fromfile","sep","多个","print","shape","...","setup","c","=","map","列表",",","接口","]","数量","文件","：","哪里","20.0","buffer","空","转换","fromfunction","102","第一列","内存","97","it","iterable","fname","的","匹配","其","file","return","#",".","__","bytes","列号","与","import","方法","类型","\"","py","一个","deprecationwarning","行","有","，","全部","列","假设","或者",")","fromiter","8","字符","2","list","为空","执行","usecols","float","从","为","order","自己"],"title":"从现有的数据创建","title_tokens":["的","现有","从","创建","数据"]},{"location":"numpy笔记/6.1.创建数组.html#_3","text":"1 np.arange([start,] stop[, step,][, dtype]) :返回均匀间隔的值组成的一维 ndarray 。区间是半闭半开的 [start,stop) ，其采样行为类似Python的 range 函数。 start 为开始点， stop 为终止点， step 为步长，默认为1。这几个数可以为整数可以为浮点数。 注意如果 step 为浮点数，则结果可能有误差，因为浮点数相等比较不准确（计算机精度有限）。 2 np.linspace(start, stop[, num, endpoint, ...]) ：返回 num 个均匀采样的数值组成的一维 ndarray （默认为50）。区间是闭区间 [start,stop] 。 endpoint 为布尔值，如果为真则表示 stop 是最后采样的值（默认为 True ），否则结果不包含 stop 。 retstep 如果为 True 则返回结果包含采样步长 step ，默认为 True 。 3 np.logspace(start, stop[, num, endpoint, base, ...]) ：返回对数级别上均匀采样的数值组成的一维 ndarray 。采样点开始于 base^start ，结束于 base^stop 。 base 为对数的基，默认为 10。 它逻辑上相当于先执行 arange 获取数组 array ，然后再执行 base^array[i] 获取采样点 - 它没有 retstep 关键字参数","text_tokens":[":","1","np","布尔值","关键","相等","采样","闭","结束","返回","于","组成","然后","不","关键字","整数","dtype","则","比较","50","精度","布尔","函数","点数","可能","如果","包含","endpoint","行为","注意","真则","有限","start","算机","基","base","是","级别","stop","上","先","(","true","结果","ndarray","为","获取","再","终止","最后","python","类似","区间","retstep","可以","对数","10","参数","默认","浮点数","准确","均匀","3","浮点","arange","^","数值","当于","相当于","[","一维","它","array","表示","否则","num","点","值","个","。","逻辑"," ","-","（","）","相当","几个","开始","半开","...","range","step",",","]","：","误差","半闭","间隔","的","其",".","步长","因为","数","logspace","计算","linspace","没有","i","有","，",")","这","执行","2","计算机","数组"],"title":"从数值区间创建","title_tokens":["数值","创建","区间","从"]},{"location":"numpy笔记/6.1.创建数组.html#_4","text":"1 np.empty(shape[,dtype,order]) ：返回一个新的 ndarray ，指定了 shape 和 dtype ，但是没有初始化元素。因此其内容是随机的。 2 np.empty_like(a[,dtype,order,subok]) ：返回一个新的 ndarray ， shape 与 a 相同，但是没有初始化元素。因此其内容是随机的。 # 内存未初始化 a = np . empty (( 3 , 2 ), order = \"C\" ) # 内存未初始化 np . empty_like ( a ) array([[0., 0.], [0., 0.], [0., 0.]]) 3 np.eye(N[, M, k, dtype]) ：返回一个==二维数组==，对角线元素为1，其余元素为0。 M 默认等于 N 。 k 默认为0表示对角线元素为1，如为正数则表示对角线上方一格的元素为1，如为负数表示对角线下方一格的元素为1。 4 np.identity(n[, dtype]) ：返回一个单位矩阵。 np . eye ( N = 2 , M = 3 ) np . eye ( N = 2 , M = 3 , k = 0 ) # 参数k是可以超出范围的 np . eye ( N = 2 , M = 3 , k = 1 ) # 返回n阶单位矩阵 np . identity ( n = 4 ) array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) 5 np.ones(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为1. 6 np.ones_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为1。 7 np.zeros(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为0. 8 np.zeros_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a （另一个数组）相同，每个元素初始化为0。 9 np.full(shape, fill_value[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为 fill_value 。 10 np.full_like(a, fill_value[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为 fill_value 。 np . full (( 2 , 3 ), fill_value = 2 ) array([[2, 2, 2], [2, 2, 2]])","text_tokens":["1","np","每个","k","9","返回","subok","相同","负数","type","fill","新","full","dtype","则","5","eye","like","一格","_","对角","0","m","是","a","指定","未","empty","zeros","(","order","ndarray","如为","value","范围","单位","其余","等于","初始化","7","可以","10","但是","参数","默认","了","超出","4","3","下方","identity","[","元素","初始","6","和","array","表示","n","对角线","。","随机","正数","二维"," ","ones","（","）","shape","c","=",",","单位矩阵","]","：","因此","超出范围","内容","另","内存","的","其","#",".","上方","与","\"","一个","阶","没有","，",")","8","2","矩阵","为","数组"],"title":"以填充的方式创建","title_tokens":["的","填充","以","方式","创建"]},{"location":"numpy笔记/6.10.函数库.html","text":"import numpy as np 随机数库","text_tokens":["numpy","随机数","np","随机","机数","as","import"," ","库"],"title":"6.10.函数库","title_tokens":[".","函数","6.10","函数库"]},{"location":"numpy笔记/6.10.函数库.html#_1","text":"","text_tokens":[],"title":"随机数库","title_tokens":["随机数","随机","机数","库"]},{"location":"numpy笔记/6.12.结构化数组.html","text":"结构化数组常用操作 import numpy as np import pprint x = np . array ([( 'Rex' , 9 , 81.0 ), ( 'Fido' , 3 , 27.0 )], dtype = [( 'name' , 'U10' ), ( 'age' , 'i4' ), ( 'weight' , 'f4' )]) pprint . pprint ( x ) array([('Rex', 9, 81.), ('Fido', 3, 27.)], dtype=[('name', '<U10'), ('age', '<i4'), ('weight', '<f4')]) 通过索引，可以获得一个结构 pprint . pprint ( x [ 0 ]) # 可以通过使用 字段名称 建立索引来访问和修改结构化数组的各个 字段： pprint . pprint ( x [ \"name\" ]) pprint . pprint ( x [[ \"age\" , \"name\" ]]) # 根据 字段名称 做过滤 pprint . pprint ( x [ x [ \"age\" ] > 5 ][ \"name\" ]) # 修改全部数组的age字段 x [ \"age\" ] = 20 pprint . pprint ( x ) ('Rex', 9, 81.) array(['Rex', 'Fido'], dtype='<U10') array([(9, 'Rex'), (3, 'Fido')], dtype={'names':['age','name'], 'formats':['<i4','<U10'], 'offsets':[40,0], 'itemsize':48}) array(['Rex'], dtype='<U10') array([('Rex', 20, 81.), ('Fido', 20, 27.)], dtype=[('name', '<U10'), ('age', '<i4'), ('weight', '<f4')]) 创建结构化数组 可以通过 a list of tuple 的形式创建结构化数组。 \"\"\" # the tupe is (fieldname, datatype, Shape) # fieldname、Shape可以省略 # fieldname 是字符串，如果使用 title，则为元组 # 如果fieldname省略，则用 f# 的默认名称代替 # shape 如果省略，则默认为(1,) \"\"\" np . dtype ([( 'x' , 'f4' ), ( 'y' , np . float32 ), ( 'z' , 'f4' , ( 2 , 2 ))]) \"\"\" 如果 fieldname 是空字符串 '' ，则将为字段指定格式为 f# 的默认名称， 其中 # 是字段的整数索引，从左侧开始从0开始计数： \"\"\" np . dtype ([( 'x' , 'f4' ), ( '' , 'i4' ), ( 'z' , 'i8' )]) dtype([('x', '<f4'), ('f1', '<i4'), ('z', '<i8')]) 可以通过“逗号分割的字符串”创建结构化数组。字符串要符合规范。 np . dtype ( 'i8, f4, S3' ) np . dtype ( '3int8, float32, (2, 3)float64' ) dtype([('f0', 'i1', (3,)), ('f1', '<f4'), ('f2', '<f8', (2, 3))]) 通过“字段参数组字典”创建结构化数组。 这是最灵活的规范形式，因为它允许控制字段的字节偏移和结构的项目大小。 dict有两个必需键 names 和 format ，以及四个可选键 offsets 、 itemsize 、 Aligned 和 title ： names 和 format 的值应该分别是相同长度的字段名列表和dtype规范列表。 可选的 offsets 值应该是整数字节偏移量的列表，结构中的每个字段都有一个偏移量。如果未给出 offsets ，则自动确定偏移量。 可选的 itemsize 值应该是一个整数， 描述 dtype 的总大小（以字节为单位），它必须足够大以包含所有字段。 可选的 Aligned 值可以设置为True，以使自动偏移计算使用对齐的偏移量（ 请参阅自动字节偏移量和对齐 ）。 可选的 titles 值应该是长度与 names 相同的标题列表。 np . dtype ({ 'names' : [ 'col1' , 'col2' ], 'formats' : [ 'i4' , 'f4' ]}) np . dtype ({ 'names' : [ 'col1' , 'col2' ], 'formats' : [ 'i4' , 'f4' ], 'offsets' : [ 0 , 4 ], 'itemsize' : 12 }) dtype({'names':['col1','col2'], 'formats':['<i4','<f4'], 'offsets':[0,4], 'itemsize':12}) 通过 dict of fieldname 创建结构化数组。不鼓励使用这种形式，因为Python字典在Python 3.6之前的Python版本中不保留顺序，但结构化dtype中字段的顺序有意义。 字典的关键字是字段名称，值是指定类型和偏移量的元组： np . dtype ({ 'col1' : ( 'i1' , 0 ), 'col2' : ( 'f4' , 1 )}) dtype([('col1', 'i1'), ('col2', '<f4')]) 操作和显示结构化数据类型 d = np . dtype ([( 'x' , 'i8' ), ( 'y' , 'f4' )]) d . names d . fields mappingproxy({'x': (dtype('int64'), 0), 'y': (dtype('float32'), 8)}) 为什么需要结构化数组 numpy结构化数组中的用法好像类似于Python的dict of list，那为什么还要用numpy结构化数组呢？ 因为numpy的结构化数组底层是类似C语言的结构，占用一块连续的内存区域，并且numpy底层是C实现，numpy数组中的类型都是静态类型的，性能好于Python的的字典列表。 可以来做一下性能比较。 import time ### 定义计时器 def timer ( func ): def wrapper ( self , * args , ** kwargs ): start = time . process_time () something = func ( self , * args , ** kwargs ) end = time . process_time () type_str = func . __repr__ () print ( \"当前函数：\" , type_str , \" \\n \" , \"用时：\" , end - start , \"秒\" , sep = \"\" ) return something return wrapper # numpy版本长一岁 @timer def addage_numpy ( data , loop ): for i in range ( loop ): data [ 'age' ] += 1 # python循环长一岁 @timer def addage_python ( data , loop ): for j in range ( loop ): for i in range ( 4 ): data [ i ][ \"age\" ] += 1 # 创建结构化数组 names = [ 'Lin' , 'Pan' , 'Shen' , 'Zhou' ] ages = [ 28 , 33 , 34 , 29 ] grades = [ 25 , 26 , 27 , 24 ] data_np = np . zeros ( 4 , dtype = { 'names' :( 'name' , 'age' , 'grade' ), 'formats' :( 'U10' , 'i4' , 'i4' ) }) data_np [ 'name' ] = names data_np [ 'age' ] = ages data_np [ 'grade' ] = grades data_py = [] for i in range ( 4 ): person = { \"name\" : names [ i ], \"age\" : ages [ i ], \"grade\" : grades [ i ]} data_py . append ( person ) addage_numpy ( data_np , loop = 1000000 ) addage_python ( data_py , loop = 1000000 ) 当前函数：<function addage_numpy at 0x000001198F1ECC80> 用时：5.53125秒 当前函数：<function addage_python at 0x000001198F1ECD90> 用时：1.796875秒 记录数组 记录数组和结构数组没有太大区别，它们所使用的场景也是类似的，只不过记录数组可以通过属性的方式访问数据。 创建记录数组的最简单方法是 numpy.rec.array 。 recordarr = np . rec . array ([( 1 , 2. , 'Hello' ), ( 2 , 3. , \"World\" )], dtype = [( 'foo' , 'i4' ),( 'bar' , 'f4' ), ( 'baz' , 'S10' )]) print ( type ( recordarr )) # 通过属性访问数据 recordarr . foo <class 'numpy.recarray'> array([1, 2]) numpy.rec.array 可以将各种参数转换为记录数组，包括结构化数组： arr = np . array ([( 1 , 2. , 'Hello' ), ( 2 , 3. , \"World\" )], dtype = [( 'foo' , 'i4' ), ( 'bar' , 'f4' ), ( 'baz' , 'S10' )]) recordarr = np . rec . array ( arr ) pprint . pprint ( recordarr ) rec.array([(1, 2., b'Hello'), (2, 3., b'World')], dtype=[('foo', '<i4'), ('bar', '<f4'), ('baz', 'S10')]) numpy.rec 模块提供了多个便利的函数来创建记录数组，请参阅 记录数组创建方法列表 。 注意： numpy.rec 是 numpy.core.records 的首选别名。 core.records.array(obj[, dtype, shape, …]) ：从各种各样的对象构造一个记录数组。 core.records.fromarrays(arrayList[, dtype, …]) ：从一维的list或array创建记录数组。 core.records.fromrecords(recList[, dtype, …]) ：从文本格式的list创建一个记录数组。 core.records.fromstring(datastring[, dtype, …]) ：从二进制字符串数据创建（只读）记录数组。 core.records.fromfile(fd[, dtype, shape, …]) ：从二进制文件数据创建记录数组。 参考 一文彻底搞懂numpy的结构化数组——structured array Numpy的结构化数组 结构化数组","text_tokens":["太","1",">","不过","tuple","相同","type","简单","关键字","name","属性","grades","5","这种","文本格式","20","函数","确定","包含","参阅","称","0","大","模块","索引","在","—","彻底","time","a","指定","结构化","48","其中","1.796875","offsets","字","true","addage","shen","fd","is","3int8","也","obj","可以","26","默认","f4","zhou","做","f","还要","formats","b","4","records","必需","各样","s3","通过","各个","person","the","、","@","<","用","一维","它","1000000","别名","只读"," ","col2","字节","fromstring","33","开始","fromfile","对象","多个","c","grade","实现","列表","占用","以及","所有","一文","25","请参阅","f1","#","itemsize","使用","首选","import","\"","方法","一个","没有","i","names","process","项目","？","字典","形式","从",":","计时器","以","9","loop","###","fromarrays","元组","大以","灵活","一下","0x000001198f1ecc80","字段","比较","def","end","允许","_","注意","两个","format","of","col1","给出","循环","修改","ages","f8","zeros","mappingproxy","访问","那","python","at","dict","可选","一块","recordarr","lin","参数","timer","可选键","aligned","3","过滤","文本","显示","用时","numpy","控制","记录","字段名","structured","将","操作","总","之前","来","int64","需要","class","datastring","print","符合","=","bar","baz",",","i1","转换","长","好像","内存","rec","return","偏移","__","底层","保留","类型","标题","f0","全部","8","计数","in","tupe","关键","什么","区别","+","weight","titles","0x000001198f1ecd90","args","d","中","整数","dtype","则","append","偏移量","代替","40","如果","用法","区域","foo","并且","使","合规","x","字符串","未","{","fromrecords","y","二进制","kwargs","参考","语言","静态","27.0","自动","str","计时","进制","hello","分割","逗号","了","“","设置","当前","获得","j","长度","repr","*","func","28","world","fields","age","n","s10","结构","-","对齐","fido","它们","shape","something","self","range","]","秒","鼓励","空","格式","i4","只不过",".","必须","因为","与","，",")","这","pan","list","2","数组","…","常用","np","性能","每个","i8","f2","81.0","意义","z","为什么","创建","title","34","于","u10","\\","键","data","方式","不","应该","数据类型","27","各种各样","arr","最","c语言","pprint","根据","但","名称","定义","中字","5.53125","}","recarray","四个","构造","float32","core","提供","29","81","'","start","版本","fieldname","左侧","是","组","都","一岁","(","wrapper","datatype","连续","单位","类似","as","大小","搞懂","arraylist","rex","3.6","场景","要","reclist","所","function","省略","24","[","便利","array","和","包括","值","12","。","分别","段","（","足够","数据","）","各种","建立","顺序","sep","float64","或","符合规范","文件","：","规范","好于","的","呢","for","py","计算","有","字符","描述","为","”"],"title":"6.12.结构化数组","title_tokens":[".","结构","6.12","结构化","数组"]},{"location":"numpy笔记/6.12.结构化数组.html#_1","text":"import numpy as np import pprint x = np . array ([( 'Rex' , 9 , 81.0 ), ( 'Fido' , 3 , 27.0 )], dtype = [( 'name' , 'U10' ), ( 'age' , 'i4' ), ( 'weight' , 'f4' )]) pprint . pprint ( x ) array([('Rex', 9, 81.), ('Fido', 3, 27.)], dtype=[('name', '<U10'), ('age', '<i4'), ('weight', '<f4')]) 通过索引，可以获得一个结构 pprint . pprint ( x [ 0 ]) # 可以通过使用 字段名称 建立索引来访问和修改结构化数组的各个 字段： pprint . pprint ( x [ \"name\" ]) pprint . pprint ( x [[ \"age\" , \"name\" ]]) # 根据 字段名称 做过滤 pprint . pprint ( x [ x [ \"age\" ] > 5 ][ \"name\" ]) # 修改全部数组的age字段 x [ \"age\" ] = 20 pprint . pprint ( x ) ('Rex', 9, 81.) array(['Rex', 'Fido'], dtype='<U10') array([(9, 'Rex'), (3, 'Fido')], dtype={'names':['age','name'], 'formats':['<i4','<U10'], 'offsets':[40,0], 'itemsize':48}) array(['Rex'], dtype='<U10') array([('Rex', 20, 81.), ('Fido', 20, 27.)], dtype=[('name', '<U10'), ('age', '<i4'), ('weight', '<f4')])","text_tokens":[":","可以","建立","np","0","rex",">","f4","=","9","81.0","索引","81","做","'","formats",",","weight","x","]","u10","：","3","获得","过滤","结构化","修改","48","通过","offsets","name","各个","字","{","numpy","i4","27","的","(","dtype",".","#","字段","字段名","5","itemsize","[","<","使用","访问","import","array","pprint","27.0","和","一个","\"","age","根据","20","来","names","，","全部","40",")","}","结构","as","称","段"," ","数组","fido"],"title":"结构化数组常用操作","title_tokens":["常用","结构","操作","结构化","数组"]},{"location":"numpy笔记/6.12.结构化数组.html#_2","text":"可以通过 a list of tuple 的形式创建结构化数组。 \"\"\" # the tupe is (fieldname, datatype, Shape) # fieldname、Shape可以省略 # fieldname 是字符串，如果使用 title，则为元组 # 如果fieldname省略，则用 f# 的默认名称代替 # shape 如果省略，则默认为(1,) \"\"\" np . dtype ([( 'x' , 'f4' ), ( 'y' , np . float32 ), ( 'z' , 'f4' , ( 2 , 2 ))]) \"\"\" 如果 fieldname 是空字符串 '' ，则将为字段指定格式为 f# 的默认名称， 其中 # 是字段的整数索引，从左侧开始从0开始计数： \"\"\" np . dtype ([( 'x' , 'f4' ), ( '' , 'i4' ), ( 'z' , 'i8' )]) dtype([('x', '<f4'), ('f1', '<i4'), ('z', '<i8')]) 可以通过“逗号分割的字符串”创建结构化数组。字符串要符合规范。 np . dtype ( 'i8, f4, S3' ) np . dtype ( '3int8, float32, (2, 3)float64' ) dtype([('f0', 'i1', (3,)), ('f1', '<f4'), ('f2', '<f8', (2, 3))]) 通过“字段参数组字典”创建结构化数组。 这是最灵活的规范形式，因为它允许控制字段的字节偏移和结构的项目大小。 dict有两个必需键 names 和 format ，以及四个可选键 offsets 、 itemsize 、 Aligned 和 title ： names 和 format 的值应该分别是相同长度的字段名列表和dtype规范列表。 可选的 offsets 值应该是整数字节偏移量的列表，结构中的每个字段都有一个偏移量。如果未给出 offsets ，则自动确定偏移量。 可选的 itemsize 值应该是一个整数， 描述 dtype 的总大小（以字节为单位），它必须足够大以包含所有字段。 可选的 Aligned 值可以设置为True，以使自动偏移计算使用对齐的偏移量（ 请参阅自动字节偏移量和对齐 ）。 可选的 titles 值应该是长度与 names 相同的标题列表。 np . dtype ({ 'names' : [ 'col1' , 'col2' ], 'formats' : [ 'i4' , 'f4' ]}) np . dtype ({ 'names' : [ 'col1' , 'col2' ], 'formats' : [ 'i4' , 'f4' ], 'offsets' : [ 0 , 4 ], 'itemsize' : 12 }) dtype({'names':['col1','col2'], 'formats':['<i4','<f4'], 'offsets':[0,4], 'itemsize':12}) 通过 dict of fieldname 创建结构化数组。不鼓励使用这种形式，因为Python字典在Python 3.6之前的Python版本中不保留顺序，但结构化dtype中字段的顺序有意义。 字典的关键字是字段名称，值是指定类型和偏移量的元组： np . dtype ({ 'col1' : ( 'i1' , 0 ), 'col2' : ( 'f4' , 1 )}) dtype([('col1', 'i1'), ('col2', '<f4')])","text_tokens":["tupe",":","1","np","关键","以","每个","i8","f2","意义","z","元组","创建","tuple","title","大以","键","titles","灵活","相同","不","应该","关键字","中","整数","dtype","则","字段","这种","最","但","允许","偏移量","代替","名称","确定","如果","中字","包含","}","参阅","称","两个","四个","format","of","0","col1","float32","给出","索引","在","'","使","版本","合规","x","fieldname","字符串","左侧","是","a","指定","组","都","结构化","其中","未","f8","offsets","字","{","y","(","true","datatype","自动","单位","python","dict","大小","可选","is","3int8","分割","可以","逗号","参数","默认","f4","f","3.6","“","formats","设置","要","可选键","aligned","4","3","必需","s3","通过","长度","控制","省略","the","、","字段名","将","[","用","<","它","和","总","之前","值","12","。","结构","分别","段"," ","col2","字节","（","足够","对齐","）","开始","shape","顺序","float64","符合","列表",",","以及","]","符合规范","：","i1","鼓励","所有","空","规范","格式","i4","的","请参阅","偏移","f1","#",".","itemsize","使用","必须","因为","与","\"","保留","标题","类型","一个","计算","”","有","names","f0","，","项目",")","字典","这","字符","list","2","描述","形式","计数","为","从","数组"],"title":"创建结构化数组","title_tokens":["创建","结构化","数组","结构"]},{"location":"numpy笔记/6.12.结构化数组.html#_3","text":"d = np . dtype ([( 'x' , 'i8' ), ( 'y' , 'f4' )]) d . names d . fields mappingproxy({'x': (dtype('int64'), 0), 'y': (dtype('float32'), 8)})","text_tokens":[":","np","0","float32","i8","=","f4","'",",","x","]","d","{","y","fields","(","dtype",".","mappingproxy","[","names","int64",")","}","8"," "],"title":"操作和显示结构化数据类型","title_tokens":["数据类型","结构","显示","类型","结构化","操作","和","数据"]},{"location":"numpy笔记/6.12.结构化数组.html#_4","text":"numpy结构化数组中的用法好像类似于Python的dict of list，那为什么还要用numpy结构化数组呢？ 因为numpy的结构化数组底层是类似C语言的结构，占用一块连续的内存区域，并且numpy底层是C实现，numpy数组中的类型都是静态类型的，性能好于Python的的字典列表。 可以来做一下性能比较。 import time ### 定义计时器 def timer ( func ): def wrapper ( self , * args , ** kwargs ): start = time . process_time () something = func ( self , * args , ** kwargs ) end = time . process_time () type_str = func . __repr__ () print ( \"当前函数：\" , type_str , \" \\n \" , \"用时：\" , end - start , \"秒\" , sep = \"\" ) return something return wrapper # numpy版本长一岁 @timer def addage_numpy ( data , loop ): for i in range ( loop ): data [ 'age' ] += 1 # python循环长一岁 @timer def addage_python ( data , loop ): for j in range ( loop ): for i in range ( 4 ): data [ i ][ \"age\" ] += 1 # 创建结构化数组 names = [ 'Lin' , 'Pan' , 'Shen' , 'Zhou' ] ages = [ 28 , 33 , 34 , 29 ] grades = [ 25 , 26 , 27 , 24 ] data_np = np . zeros ( 4 , dtype = { 'names' :( 'name' , 'age' , 'grade' ), 'formats' :( 'U10' , 'i4' , 'i4' ) }) data_np [ 'name' ] = names data_np [ 'age' ] = ages data_np [ 'grade' ] = grades data_py = [] for i in range ( 4 ): person = { \"name\" : names [ i ], \"age\" : ages [ i ], \"grade\" : grades [ i ]} data_py . append ( person ) addage_numpy ( data_np , loop = 1000000 ) addage_python ( data_py , loop = 1000000 ) 当前函数：<function addage_numpy at 0x000001198F1ECC80> 用时：5.53125秒 当前函数：<function addage_python at 0x000001198F1ECD90> 用时：1.796875秒","text_tokens":[":","1","性能","in","np","计时器","什么",">","loop","为什么","###","创建","+","34","于","\\","data","u10","0x000001198f1ecd90","type","args","name","一下","中","grades","27","0x000001198f1ecc80","dtype","c语言","比较","def","append","end","函数","_","定义","5.53125","}","用法","of","区域","29","并且","循环","'","start","版本","time","是","都","结构化","ages","1.796875","{","一岁","zeros","(","kwargs","addage","wrapper","语言","静态","shen","str","连续","那","python","at","类似","dict","计时","一块","可以","26","lin","zhou","做","还要","formats","timer","当前","4","j","repr","用时","*","func","28","numpy","function","person","@","24","[","用","<","1000000","age","n","来","。","结构"," ","-","33","sep","something","print","self","c","range","=","grade","实现","列表","占用",",","]","秒","：","长","好像","内存","i4","好于","的","return","25","#",".","__","底层","因为","import","呢","类型","\"","for","py","i","names","，","process","？",")","字典","pan","list","数组"],"title":"为什么需要结构化数组","title_tokens":["什么","结构","需要","结构化","为什么","数组"]},{"location":"numpy笔记/6.12.结构化数组.html#_5","text":"记录数组和结构数组没有太大区别，它们所使用的场景也是类似的，只不过记录数组可以通过属性的方式访问数据。 创建记录数组的最简单方法是 numpy.rec.array 。 recordarr = np . rec . array ([( 1 , 2. , 'Hello' ), ( 2 , 3. , \"World\" )], dtype = [( 'foo' , 'i4' ),( 'bar' , 'f4' ), ( 'baz' , 'S10' )]) print ( type ( recordarr )) # 通过属性访问数据 recordarr . foo <class 'numpy.recarray'> array([1, 2]) numpy.rec.array 可以将各种参数转换为记录数组，包括结构化数组： arr = np . array ([( 1 , 2. , 'Hello' ), ( 2 , 3. , \"World\" )], dtype = [( 'foo' , 'i4' ), ( 'bar' , 'f4' ), ( 'baz' , 'S10' )]) recordarr = np . rec . array ( arr ) pprint . pprint ( recordarr ) rec.array([(1, 2., b'Hello'), (2, 3., b'World')], dtype=[('foo', '<i4'), ('bar', '<f4'), ('baz', 'S10')]) numpy.rec 模块提供了多个便利的函数来创建记录数组，请参阅 记录数组创建方法列表 。 注意： numpy.rec 是 numpy.core.records 的首选别名。 core.records.array(obj[, dtype, shape, …]) ：从各种各样的对象构造一个记录数组。 core.records.fromarrays(arrayList[, dtype, …]) ：从一维的list或array创建记录数组。 core.records.fromrecords(recList[, dtype, …]) ：从文本格式的list创建一个记录数组。 core.records.fromstring(datastring[, dtype, …]) ：从二进制字符串数据创建（只读）记录数组。 core.records.fromfile(fd[, dtype, shape, …]) ：从二进制文件数据创建记录数组。","text_tokens":["…","太","1","np",">","不过","fromarrays","创建","区别","type","方式","简单","属性","各种各样","arr","dtype","最","文本格式","pprint","函数","参阅","注意","recarray","构造","大","foo","core","提供","模块","'","字符串","是","结构化","fromrecords","(","二进制","访问","类似","fd","进制","hello","recordarr","也","obj","arraylist","可以","参数","f4","了","场景","b","reclist","所","3","文本","records","各样","通过","world","numpy","记录","将","[","<","便利","一维","和","array","包括","来","别名","s10","。","结构","class","datastring","只读"," ","fromstring","数据","（","）","各种","它们","shape","对象","多个","fromfile","print","或","=","bar","baz","列表",",","]","文件","：","转换","格式","rec","只不过","i4","的","请参阅","#",".","使用","首选","方法","\"","一个","没有","，",")","字符","2","list","从","为","数组"],"title":"记录数组","title_tokens":["记录","数组"]},{"location":"numpy笔记/6.12.结构化数组.html#_6","text":"一文彻底搞懂numpy的结构化数组——structured array Numpy的结构化数组 结构化数组","text_tokens":["numpy","的","—","彻底","structured","array","结构","结构化","一文"," ","数组","搞懂"],"title":"参考","title_tokens":["参考"]},{"location":"numpy笔记/6.2.索引.html","text":"import numpy as np import copy ndarrays 可以使用标准 Python x[obj] 语法对其进行索引 ，其中 x 是数组， obj 是索引。有三种可用的索引：字段访问，基本切片，高级索引。哪一个发生取决于 obj 。 在 Python 中， x[(exp1，exp2，.，EXPN)] 等同于 x[exp1，exp2，.，EXPN] 。后者只是前者的语法糖。 # 创建一个一维数组 a = np . arange ( 100 ) # 创建一个二维数组 b = copy . deepcopy ( np . reshape ( a , ( 20 , 5 ))) # 创建一个三维数组 c = copy . deepcopy ( np . arange ( 90 ) . reshape (( 10 , 3 , 3 ))) 一维数组的索引 一维数组的索引和列表相同。假设 a1 是一维数组，那么有以下5种使用索引的情况： 可以指定一个 整数 i 作为索引下标，如 a1[i] 。 可以指定一个 切片 作为索引下标，如 a1[i:j] ，等价于 a1[slice(j,j)] 。 可以指定一个 整数list 对数组进行存取，如 a1[[i1,i2,i3]] 。此时会将列表中的每个整数作为下标 (i1/i2/i3) ，使用列表作为下标得到的数组为 np.array([a1[i1],a1[i2],a1[i3]]) ，它不和原始数组共享内存。 可以指定一个 整数数组 作为数组下标，如 a1[a2] 此时会得到一个形状和下标数组 a2 相同的新数组。新数组的每个元素都是下标数组中对应位置的值作为下标从原始数组中获得的值。新数组不和原始数组共享数据。 可以指定一个 布尔数组 作为数组下标，如a1[b]。此时将获得数组a1中与数组b中的True对应的元素。新数组不和原始数组共享数据。 # 指定一个整数 a [ 1 ] # OWNDATA : True ## 等价于 a [( 1 )] # OWNDATA : True # 指定切片 a [ 0 : 20 : 2 ] # 返回视图 a [ slice ( 0 , 20 , 2 )] # 返回视图 # 指定一个整数列表 a [[ 1 , 2 , 3 , 4 ]] # OWNDATA : True # 指定一个整数数组 ## index是一维数组 index = np . array ([ 0 , 1 , 2 , 3 , 4 ]) a [ index ] # OWNDATA : True ## index是二维数组 index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) a [ index ] # OWNDATA : True # 指定一个布尔数组 ## 布尔数组的ndim需要和原数组相同 bool_a = a > 50 bool_a = list ( bool_a ) 多维数组的索引 多维数组使用 元组 作为数组的下标，如 a[1,2] ，当然你也可以添加圆括号为 a[(1,2)] 。实际上，一维数组也是如此，只是一维数组只有第 0 轴。 下标元组 中每个元素和数组的每个轴对应。下标元组的第 0 个元素对应数组第 0 轴，第 1 个元素对应数组第 1 轴，第 2 个元素对应数组第 2 轴··· 多维数组的下标必须是一个长度和数组的维度ndim相等的元组。 如果下标元组的长度大于数组的维度ndim，则IndexError 如果下标元组的长度小于数组的维度ndim，则自动在元组的后面补 : ，使得下标元组的长度等于数组维度ndim。 如果下标对象不是元组，则Numpy会首先将其转换为元组。 有以下7种使用索引的情况： 整数元组 切片 整数元组搭配切片 整数list 整数数组 布尔数组 整数数组、切片、整数元组混搭 # 指定一个整数元组 b [( 1 , 2 )] # OWNDATA : Trues ## 等价于 b [ 1 , 2 ] # OWNDATA : Trues ## 元组的维度超过多维数组的维度:IndexError ''' b[(1,2,3)] ''' ## 元组的维度超少于维数组的维度 b [ 1 ] # 返回视图 等价于 b[1,:] # 切片 b [ 0 , 0 : 5 : 2 ] # 返回视图 b [ 0 , 0 :: 2 ] # 返回视图 b [ 0 , slice ( 0 , None , 2 )] # 返回视图 ## SyntaxError b[0,slice(0,,2)] b [ 0 : 10 : 2 , 0 : 5 : 2 ] # 返回视图 ## 第二列 b [:, 1 ] # 返回视图 b [ ... , 1 ] # 返回视图 ## IndexError: an index can only have a single ellipsis ('...') ''' b[...,...] IndexError ''' b [ ... ,:] # 返回视图 b [:,:] # 返回视图 # 整数数组 ## arrays used as indices must be of integer (or boolean) type index = np . array ([ 0 , 1 , 2 , 3 ]) b [ index ] # OWNDATA : True index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) b [ index ] # OWNDATA : True ## 如果下标整数数组的维度不一致，会进行广播 rows = np . array ([[ 0 , 1 , 2 ]]) columns = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 4 ]]) index = ( rows , columns ) b [ index ] array([[ 0, 6, 12], [ 3, 9, 14]]) 多维数组的下标是布尔数组或者下标元组中包含了布尔数组，则相当于将布尔数组通过 np.nonzero() 将布尔数组转换成一个整数数组的元组，然后使用整数数组进行下标运行。 np.nonzero(a) 返回数组 a 中，值非零的元素的 下标 。它返回值是一个长度为 a.ndim 的元组，元组的每个元素都是一个一维的整数数组，其值为非零元素的下标在对应轴上的值。如：第 0 个元素为a中的非零值元素在0轴的下标、第 1 个元素为a中的非零值元素在1轴的下标... np . nonzero ( bool_a ) (array([51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], dtype=int64),) 进阶说明 使用切片返回视图的原因： 当下标使用切片时，所取得的数据在数据存储区域中是等间隔分布的。因为只需要修改数组的ndim/shape/strides等属性以及指向数据存储区域的data指针就能够实现整数和切片下标的索引。所以新数组和原始数组能够共享数据存储区域。 当使用整数数组（整数元组，整数列表页转换成整数数组），布尔数组时，不能保证所取得的数据在数据存储区中是等间隔的，因此无法和原始数组共享数据，只能对数据进行复制。 通过整数元组获取的数组元素的类型为数组的dtype类型 。如果你想获取标准python类型，可以使用数组的item()方法。 索引的维度变换 索引的下标元组中： 如果下标元组都是切片，则索引结果的数组与原始数组的维度相同（轴的数量相等） 每多一个整数下标，则索引结果的数组就少一个维度（少一个轴） 如果所有的下标都是整数，则索引结果的维度为 0 如果下标元组中存在数组，则还需要考虑该下标数组广播后的维度 多维数组的下标必须是一个长度和数组的维度 ndim 相等的元组。但是如果下标中包含None，则可以突破这一限制。每多一个None，则索引结构维度升 1 。 当数组的下标元组的长度小于等于数组的维度ndim时，元组中出现的None等价于切片: 当数组的下标元组的长度大于数组的维度ndim时，元组中哪里出现None，索引结果就在哪里创建一个新轴，该轴长度为 1。 b [ 1 , 2 ] b [ 1 , 2 , None ] b [ 1 , 2 , np . newaxis ] array([7])","text_tokens":["1","相等","转换成",">","时","后者","index","54","对","取决","相同","type","74","属性","少于","新","5","69","85","50","20","零","87","中是","出现","包含","75","还","0","后面","83","种","作为","索引","原","当然","在","or","非","58","a","指定","其中","字","rows","none","true","这一","获取","当","原始","第二列","96","copy","你","ndim","标","7","也","obj","62","65","可以","视图","糖","新轴","b","实际上","限制","4","一个三维","超","columns","通过","形状","·","、","79","一维","如此","6","它","就","boolean","无法","a2"," ","100","72","相当","后","对象","77","c","ellipsis","实现","列表","以及","an","因此","哪里","所有","#","使用","67","import","括号","方法","一个","i","此时","假设","strides","搭","突破","从","一致",":","expn","等同","slice","indexerror","9","元组","must","想","can","前者","下标","三种","51","_","55","说明","哪","64","等同于","of","95","63","newaxis","修改","trues","/","访问","只是","可用","78","区中","python","指向","大于","但是","广播","存储","84","99","补","共享内存","90","3","68","页","同于","numpy","基本","当于","维度","将","每多","元素","变换","89","owndata","int64","二维","需要","item","发生","...","=",",","只有","取得","i1","以下","等价","转换","91","内存","97","所以","语法","92","be","indices","三维","only","类型","integer","arrays","进行","reshape","不能","非零值","切片","56","返回","然后","exp1","位置","其值","中","88","整数","dtype","则","single","52","如果","等","53","区域","x","标准","取决于","73","指针","会","为","自动","82","80","等于","第二","能够","该","exp2","syntaxerror","了","j","获得","长度","a1","原因","搭配","93","个","小于","标的","结构","一个二维","那么","换成","shape","情况","]","混","升","间隔","其",".","14","存在","必须","因为","与","59","当下","，",")","list","2","超过","下","数组","np","使得","进阶","每个","高级","创建","61","于","data","对应","复制","不","布尔","二列","轴上","have","分布","只","'","70","是","都","第","值非","添加","(","i2","如","少","结果","as","考虑","94","used","10","i3","首先","76","存取","所","多维","arange","60","只能","返回值","相当于","[","实际","和","array","共享","71","值","12","nonzero","。","段","66","数据","（","98","）","57","维","数量","：","保证","得到","的","运行","圆括号","deepcopy","##","86","轴","ndarrays","有","或者","bool","81","不是"],"title":"6.2.索引","title_tokens":["6.2",".","索引"]},{"location":"numpy笔记/6.2.索引.html#_1","text":"一维数组的索引和列表相同。假设 a1 是一维数组，那么有以下5种使用索引的情况： 可以指定一个 整数 i 作为索引下标，如 a1[i] 。 可以指定一个 切片 作为索引下标，如 a1[i:j] ，等价于 a1[slice(j,j)] 。 可以指定一个 整数list 对数组进行存取，如 a1[[i1,i2,i3]] 。此时会将列表中的每个整数作为下标 (i1/i2/i3) ，使用列表作为下标得到的数组为 np.array([a1[i1],a1[i2],a1[i3]]) ，它不和原始数组共享内存。 可以指定一个 整数数组 作为数组下标，如 a1[a2] 此时会得到一个形状和下标数组 a2 相同的新数组。新数组的每个元素都是下标数组中对应位置的值作为下标从原始数组中获得的值。新数组不和原始数组共享数据。 可以指定一个 布尔数组 作为数组下标，如a1[b]。此时将获得数组a1中与数组b中的True对应的元素。新数组不和原始数组共享数据。 # 指定一个整数 a [ 1 ] # OWNDATA : True ## 等价于 a [( 1 )] # OWNDATA : True # 指定切片 a [ 0 : 20 : 2 ] # 返回视图 a [ slice ( 0 , 20 , 2 )] # 返回视图 # 指定一个整数列表 a [[ 1 , 2 , 3 , 4 ]] # OWNDATA : True # 指定一个整数数组 ## index是一维数组 index = np . array ([ 0 , 1 , 2 , 3 , 4 ]) a [ index ] # OWNDATA : True ## index是二维数组 index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) a [ index ] # OWNDATA : True # 指定一个布尔数组 ## 布尔数组的ndim需要和原数组相同 bool_a = a > 50 bool_a = list ( bool_a )","text_tokens":[":","1","np","每个","切片","slice",">","index","于","返回","对应","对","相同","位置","不","中","新","整数","5","下标","50","布尔","20","_","0","种","作为","索引","原","是","a","指定","都","(","true","i2","如","/","会","原始","ndim","可以","视图","i3","存取","b","共享内存","4","3","j","获得","a1","形状","将","一维","[","元素","它","和","array","共享","值","owndata","。","二维","a2","需要"," ","数据","那么","=","情况","列表",",","]","：","i1","以下","等价","内存","得到","的","#",".","使用","##","与","一个","i","有","，","此时","假设","进行","bool",")","list","2","从","为","数组"],"title":"一维数组的索引","title_tokens":["一维","数组","的","索引"]},{"location":"numpy笔记/6.2.索引.html#_2","text":"多维数组使用 元组 作为数组的下标，如 a[1,2] ，当然你也可以添加圆括号为 a[(1,2)] 。实际上，一维数组也是如此，只是一维数组只有第 0 轴。 下标元组 中每个元素和数组的每个轴对应。下标元组的第 0 个元素对应数组第 0 轴，第 1 个元素对应数组第 1 轴，第 2 个元素对应数组第 2 轴··· 多维数组的下标必须是一个长度和数组的维度ndim相等的元组。 如果下标元组的长度大于数组的维度ndim，则IndexError 如果下标元组的长度小于数组的维度ndim，则自动在元组的后面补 : ，使得下标元组的长度等于数组维度ndim。 如果下标对象不是元组，则Numpy会首先将其转换为元组。 有以下7种使用索引的情况： 整数元组 切片 整数元组搭配切片 整数list 整数数组 布尔数组 整数数组、切片、整数元组混搭 # 指定一个整数元组 b [( 1 , 2 )] # OWNDATA : Trues ## 等价于 b [ 1 , 2 ] # OWNDATA : Trues ## 元组的维度超过多维数组的维度:IndexError ''' b[(1,2,3)] ''' ## 元组的维度超少于维数组的维度 b [ 1 ] # 返回视图 等价于 b[1,:] # 切片 b [ 0 , 0 : 5 : 2 ] # 返回视图 b [ 0 , 0 :: 2 ] # 返回视图 b [ 0 , slice ( 0 , None , 2 )] # 返回视图 ## SyntaxError b[0,slice(0,,2)] b [ 0 : 10 : 2 , 0 : 5 : 2 ] # 返回视图 ## 第二列 b [:, 1 ] # 返回视图 b [ ... , 1 ] # 返回视图 ## IndexError: an index can only have a single ellipsis ('...') ''' b[...,...] IndexError ''' b [ ... ,:] # 返回视图 b [:,:] # 返回视图 # 整数数组 ## arrays used as indices must be of integer (or boolean) type index = np . array ([ 0 , 1 , 2 , 3 ]) b [ index ] # OWNDATA : True index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) b [ index ] # OWNDATA : True ## 如果下标整数数组的维度不一致，会进行广播 rows = np . array ([[ 0 , 1 , 2 ]]) columns = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 4 ]]) index = ( rows , columns ) b [ index ] array([[ 0, 6, 12], [ 3, 9, 14]]) 多维数组的下标是布尔数组或者下标元组中包含了布尔数组，则相当于将布尔数组通过 np.nonzero() 将布尔数组转换成一个整数数组的元组，然后使用整数数组进行下标运行。 np.nonzero(a) 返回数组 a 中，值非零的元素的 下标 。它返回值是一个长度为 a.ndim 的元组，元组的每个元素都是一个一维的整数数组，其值为非零元素的下标在对应轴上的值。如：第 0 个元素为a中的非零值元素在0轴的下标、第 1 个元素为a中的非零值元素在1轴的下标... np . nonzero ( bool_a ) (array([51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], dtype=int64),)","text_tokens":["非零值","一致",":","1","使得","np","每个","相等","转换成","切片","slice","indexerror","9","元组","index","must","61","56","于","返回","然后","对应","54","type","其值","不","74","can","中","88","少于","整数","5","则","single","69","85","dtype","下标","布尔","零","52","87","二列","51","_","55","如果","包含","75","轴上","64","have","of","95","53","0","后面","83","种","作为","索引","当然","81","在","'","or","非","58","70","是","a","指定","63","都","第","值非","rows","none","添加","(","true","trues","如","73","只是","会","自动","82","78","80","第二列","96","as","你","大于","等于","第二","ndim","94","7","也","62","used","65","可以","10","视图","首先","syntaxerror","广播","了","76","84","99","补","实际上","b","90","4","多维","3","超","columns","60","68","长度","通过","搭配","numpy","返回值","·","93","当于","维度","、","相当于","将","79","[","一维","如此","元素","6","实际","它","和","array","89","boolean","71","owndata","值","12","个","小于","nonzero","int64","。","66"," ","72","98","相当","换成","对象","77","...","ellipsis","情况","=",",","只有","57","维","]","混","：","an","以下","等价","转换","91","97","的","其","运行","92","#","圆括号",".","be","14","必须","使用","indices","##","only","67","括号","86","59","一个","integer","轴","arrays","有","，","进行","或者","bool",")","2","list","超过","搭","为","数组","不是"],"title":"多维数组的索引","title_tokens":["多维","的","索引","数组"]},{"location":"numpy笔记/6.2.索引.html#_3","text":"使用切片返回视图的原因： 当下标使用切片时，所取得的数据在数据存储区域中是等间隔分布的。因为只需要修改数组的ndim/shape/strides等属性以及指向数据存储区域的data指针就能够实现整数和切片下标的索引。所以新数组和原始数组能够共享数据存储区域。 当使用整数数组（整数元组，整数列表页转换成整数数组），布尔数组时，不能保证所取得的数据在数据存储区中是等间隔的，因此无法和原始数组共享数据，只能对数据进行复制。 通过整数元组获取的数组元素的类型为数组的dtype类型 。如果你想获取标准python类型，可以使用数组的item()方法。","text_tokens":["转换成","切片","时","元组","返回","data","想","对","复制","属性","新","整数","dtype","布尔","中是","如果","等","分布","区域","只","索引","在","是","标准","修改","(","/","指针","获取","当","原始","区中","python","指向","你","能够","ndim","标","可以","视图","存储","所","通过","原因","页","只能","元素","就","和","共享","标的","无法","。","需要"," ","item","（","数据","）","换成","shape","实现","列表","取得","以及","：","因此","转换","保证","间隔","的","所以","使用","因为","类型","方法","当下","，","进行",")","strides","下","不能","为","数组"],"title":"进阶说明","title_tokens":["说明","进阶"]},{"location":"numpy笔记/6.2.索引.html#_4","text":"索引的下标元组中： 如果下标元组都是切片，则索引结果的数组与原始数组的维度相同（轴的数量相等） 每多一个整数下标，则索引结果的数组就少一个维度（少一个轴） 如果所有的下标都是整数，则索引结果的维度为 0 如果下标元组中存在数组，则还需要考虑该下标数组广播后的维度 多维数组的下标必须是一个长度和数组的维度 ndim 相等的元组。但是如果下标中包含None，则可以突破这一限制。每多一个None，则索引结构维度升 1 。 当数组的下标元组的长度小于等于数组的维度ndim时，元组中出现的None等价于切片: 当数组的下标元组的长度大于数组的维度ndim时，元组中哪里出现None，索引结果就在哪里创建一个新轴，该轴长度为 1。 b [ 1 , 2 ] b [ 1 , 2 , None ] b [ 1 , 2 , np . newaxis ] array([7])","text_tokens":[":","1","np","相等","切片","时","元组","创建","于","相同","中","整数","则","下标","如果","出现","包含","还","0","索引","在","是","都","newaxis","none","(","少","结果","这一","当","原始","考虑","大于","等于","ndim","该","7","可以","但是","广播","新轴","限制","b","多维","长度","维度","[","每多","就","和","array","小于","。","结构","需要"," ","（","）","后",",","]","数量","：","哪里","所有","等价","升","的",".","存在","必须","与","一个","轴","，",")","2","突破","为","数组"],"title":"索引的维度变换","title_tokens":["维度","的","索引","变换"]},{"location":"numpy笔记/6.3.内存布局.html","text":"import numpy as np import pprint import copy ndarray对象 NumPy提供了一个N维数组对象ndarray，它描述了同一类型的元素的集合。可以使用N个整数对元素进行索引。 ndarray中所有元素都是 同质的 ：每个元素占用相同大小的内存块，并且所有内存块的解释方式完全相同。数组中各元素的解释方式由一个的 data-type 对象（dtype）指定。 图中显示了用于描述数组中数据的三个基本对象之间的关系： ndarray本身 描述数组中单个固定大小元素的内存布局的data-type对象 访问数组的单个元素时返回的数组标量（Python对象） ndarray类的实例由一个 连续的 一维计算机内存块（由数组或其他对象拥有）和一个索引方案组合而成，该索引方案将N个整数分别映射到内存块中N个元素的位置。索引可以变化的范围被数组的shape限制。 ndarray看上去似乎可以是多维的，但在内存中，ndarray是一维储存的。有许多方案将N维数组以一维数组的形式储存在内存中。其中numpy有两种储存方式： 元素按行顺序储存（C语言风格） 或者按列顺序储存（Fortran语言风格） 因此，如果要对一个ndarray以行为单位进行操作，最好以C-type的方式创建ndarray；如果要对一个ndarray以列为单位进行操作，则用Fortran方式。 内存布局 A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) pprint . pprint ( A ) array([[0, 1, 2], [3, 4, 5], [6, 7, 8]], dtype=int16) 属性（与数组内存布局有关） A的属性值 描述 A.dtype dtype('int16') 元素数据类型。A的每个元素是16bit大小的int型数据。 A.ndim 2 轴（维度）的个数。A有两个轴：0轴、1轴。 A.shape (3, 3) 各个轴的大小。0轴有3个元素，1轴有3个元素。 A.size 9 数组的大小，有多少个元素。 A.data <memory at 0x000001B17A238A68> 指向数组的数据的存储区。 A.itemsize 2 一个元素的长度，以字节为单位。16bit等于2字节。 A.nbytes 18 数组元素占据的总字节数。 A.base None 如果内存来自其他对象，则以此为基础对象。 A.flags 有关数组内存布局的信息。 A.strides (6, 2) 一个整数元组，每个元素保存着每个轴上相邻两个元素的地址差。 即当某个轴的下标增加1 时，数据存储区中的指针增加的字节数。 可以从不同的角度(即布局)观察该array： shape [ 1 ] ( = 3 ) ┌───────────┐ ┌ ┌───┬───┬───┐ ┐ │ │ 0 │ 1 │ 2 │ │ │ ├───┼───┼───┤ │ shape [ 0 ] │ │ 3 │ 4 │ 5 │ │ len ( Z ) ( = 3 ) │ ├───┼───┼───┤ │ ( = 3 ) │ │ 6 │ 7 │ 8 │ │ └ └───┴───┴───┘ ┘ 展开的item layout ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ └───┴───┴───┴───┴───┴───┴───┴───┴───┘ └───────────────────────────────────┘ A . size ( = 9 ) 内存布局(C顺序) strides [ 1 ] ( = 2 ) ┌─────────────────────┐ ┌ ┌──────────┬──────────┐ ┐ │ p + 00 : │ 00000000 │ 00000000 │ │ │ ├──────────┼──────────┤ │ │ p + 02 : │ 00000000 │ 00000001 │ │ strides [ 0 ] │ ├──────────┼──────────┤ │ ( = 2 x3 ) │ p + 04 │ 00000000 │ 00000010 │ │ │ ├──────────┼──────────┤ ┘ │ p + 06 │ 00000000 │ 00000011 │ │ ├──────────┼──────────┤ A . nbytes │ p + 08 : │ 00000000 │ 00000100 │ ( = 3 x3x2 ) │ ├──────────┼──────────┤ │ p + 10 : │ 00000000 │ 00000101 │ │ ├──────────┼──────────┤ │ p + 12 : │ 00000000 │ 00000110 │ │ ├──────────┼──────────┤ │ p + 14 : │ 00000000 │ 00000111 │ │ ├──────────┼──────────┤ │ p + 16 : │ 00000000 │ 00001000 │ └ └──────────┴──────────┘ └─────────────────────┘ A . itemsize A . dtype . itemsize ( = 2 ) 如果我们现在取一A的切片，结果是A的基本数组的一个视图： V = A[::2,::2] 这样的视图是由shape，dtype 和 strides 指定的，因为仅凭dtype和shape不能推断出strides: 如果我们现在取一A的切片，结果是A的基本数组的一个视图： V = A[::2,::2] 这样的视图是由shape，dtype 和 strides 指定的，因为仅凭dtype和shape不能推断出strides: Item layout shape [ 1 ] ( = 2 ) ┌───────────┐ ┌ ┌───┬───┬───┐ ┐ │ │ 0 │ │ 2 │ │ ┌───┬───┐ │ ├───┼───┼───┤ │ | 0 │ 2 │ shape [ 0 ] │ │ │ │ │ │ len ( A ) → ├───┼───┤ ( = 2 ) │ ├───┼───┼───┤ │ ( = 2 ) | 6 │ 8 │ │ │ 6 │ │ 8 │ │ └───┴───┘ └ └───┴───┴───┘ ┘ 展开的item layout ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐ ┌───┬───┬───┬───┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ → │ 0 │ 2 │ 6 │ 8 │ └───┴───┴───┴───┴───┴───┴───┴───┴───┘ └───┴───┴───┴───┘ └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘ └───┬───┘ └───┬───┘ └───────────┬───────────┘ A.size (=4) 内存布局(C顺序，大端序) ┌ ┌──────────┬──────────┐ ┐ ┐ ┌─┤ p + 00 : │ 00000000 │ 00000000 │ │ │ │ └ ├──────────┼──────────┤ │ strides [ 1 ] │ ┌─┤ p + 02 : │ │ │ │ ( = 4 ) │ │ │ ┌ ├──────────┼──────────┤ ┘ │ │ └─┤ p + 04 │ 00000000 │ 00000010 │ │ │ └ ├──────────┼──────────┤ │ strides [ 0 ] │ p + 06 : │ │ │ │ ( = 12 ) │ ├──────────┼──────────┤ │ A . nbytes ─┤ p + 08 : │ │ │ │ ( = 8 ) │ ├──────────┼──────────┤ │ │ p + 10 : │ │ │ │ │ ┌ ├──────────┼──────────┤ ┘ │ ┌─┤ p + 12 : │ 00000000 │ 00000110 │ │ │ └ ├──────────┼──────────┤ └─┤ p + 14 : │ │ │ │ ┌ ├──────────┼──────────┤ └─┤ p + 16 : │ 00000000 │ 00001000 │ └ └──────────┴──────────┘ └─────────────────────┘ A . itemsize A . dtype . itemsize ( = 2 ) 可以直接修改 ndarray 对象的 strides 属性，改变 ndarray 的内存布局，但此时会修改原数组。 A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) A . strides = ( 2 , 4 ) pprint . pprint ( A ) array([[0, 2, 4], [1, 3, 5], [2, 4, 6]], dtype=int16) 视图和副本 视图和副本是优化数值计算的重要概念。 在numpy中，可以用切片和 花式索引 （整数数组索引）来索引数据。切片将始终返回视图，而整数数组索引将返回一个副本。这种差异很重要，因为在切片情况下，修改视图会修改原数组，而在整数数组索引情况下则不是这样： Z = np . zeros ( 9 ) Z_view = Z [: 3 ] Z_view [ ... ] = 1 print ( Z ) [1. 1. 1. 0. 0. 0. 0. 0. 0.] Z = np . zeros ( 9 ) Z_copy = Z [[ 0 , 1 , 2 ]] Z_copy [ ... ] = 1 print ( Z ) [0. 0. 0. 0. 0. 0. 0. 0. 0.] 因此，如果你需要反复用到某个花式索引，最好保留它的副本（特别是如果计算它很复杂）。如果您不确定索引的结果是视图还是副本，则可以检查base的结果。如果是None，那么结果就是副本： Z = np . random . uniform ( 0 , 1 ,( 5 , 5 )) Z1 = Z [: 3 ,:] Z2 = Z [[ 0 , 1 , 2 ], :] print ( np . allclose ( Z1 , Z2 )) True print ( Z1 . base is Z ) True print ( Z2 . base is Z ) False print ( Z2 . base is None ) True 请注意，一些numpy函数在可能的情况下返回视图(例如， ravel )，而另一些函数总是返回副本(例如， flatten ): Z = np . zeros (( 5 , 5 )) print ( Z . ravel () . base is Z ) True print ( Z [:: 2 ,:: 2 ] . ravel () . base is Z ) False print ( Z . flatten () . base is Z ) False 可以通过 ndarray.view() 方法，从同一块内存区（储存着numpy数组的内存区）创建不同的dtype数组。 即用不同的数值类型查看同一段内存中的二进制数据。 它们使用的是同一块内存。 实际上， ndarray.view() 方法是创建了一个视图。 A = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ],[ 6 , 7 , 8 ]]) A_view = A . view ( np . int32 ) # A_view 是视图 A_view . flags C_CONTIGUOUS : True F_CONTIGUOUS : False OWNDATA : False WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False 如果我们直接修改原始数组的 dtype ，会达到同样的效果， 但此时直接修改原始数组。 A . dtype = np . float32 Caution 通常应避免改变由切片、transposes、fortran排序等定义的数组的 dtype 的大小，如下： A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) A_view = A . view ( np . int32 ) ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-7b8b7375e3ff> in <module> 1 A = copy.deepcopy(np.arange(9, dtype=np.int16).reshape(3,3)) ----> 2 A_view = A.view(np.int32) ValueError: When changing to a larger dtype, its size must be a divisor of the total size in bytes of the last axis of the array.","text_tokens":["1","18","由",">","时","len","layout","changing","查看","06","有关","对","相同","type","00001000","┴","属性","排序","实例","5","这种","函数","观察","确定","即当","|","通常","标量","0","索引","原","在","16bit","a","指定","其中","none","true","即","原始","相邻","copy","你","is","ndim","展开","7","即用","可以","视图","f","布局","限制","请","实际上","4","flatten","储存","通过","似乎","各个","valueerror","图中","许多","input","、","00000010","the","一维","用","<","6","它","00000111","00000110","v","；"," ","fortran","字节","方案","对象","c","以此","7b8b7375e3ff","占用","按行","因此","所有","另","┌","#","个数","itemsize","使用","import","方法","一个","┬","此时","大端","特别","strides","形式","从",":","基础","差","以","9","元组","must","推断","大端序","下标","现在","避免","x3x2","固定","00000100","_","型","traceback","这样","注意","两个","着","看上去","of","updateifcopy","axis","16","base","修改","zeros","您","访问","when","ndarray","到","区中","python","at","指向","单个","概念","地址","推断出","存储","不同","aligned","3","显示","就是","module","numpy","基本","维度","┘","将","元素","操作","达到","总","来","owndata","random","被","0x000001b17a238a68","需要","item","总是","解释","flags","to","print","...","=","一些",",","看上","集合","nbytes","如下","内存","关系","└","be","保留","类型","larger","进行","reshape","8","不能","完全","类","in","直接","z1","call","块内存","节数","多少","切片","+","返回","08","我们","位置","z2","字节数","中","之间","─","整数","dtype","则","某个","如果","等","区","来自","其他","int16","并且","most","算机","┼","块","ravel","变化","副本","二进制","p","语言","仅凭","指针","会","├","复杂","进制","等于","该","last","了","一段","各","下则","长度","三个","改变","最好","caution","00000001","n","个","-","那么","它们","shape","recent","情况","]","例如","反复","检查","view",".","bytes","14","与","因为","本身","int32","，","同质",")","列为","2","下","transposes","计算机","数组","很","np","allclose","每个","its","用于","同","z","创建","02","信息","data","方式","不","│","而","数据类型","效果","风格","用到","c语言","size","false","pprint","但","00000101","可能","定义","x3","00","行为","轴上","┐","float32","取一","提供","'","同样","是","两种","都","writebackifcopy","组合","→","同一","增加","(","还是","┤","结果","应","占据","连续","范围","单位","as","00000000","大小","优化","total","保存","10","拥有","完全相同","要","contiguous","按列","多维","arange","数值","[","实际","divisor","和","array","差异","值","12","ipython","。","分别","轴有","数据","（","映射","）","始终","顺序","或","组合而成","维","：","04","int","uniform","花式","memory","的","deepcopy","重要","计算","00000011","上去","轴","角度","有","或者","描述","writeable","为","不是"],"title":"6.3.内存布局","title_tokens":[".","布局","6.3","内存"]},{"location":"numpy笔记/6.3.内存布局.html#ndarray","text":"NumPy提供了一个N维数组对象ndarray，它描述了同一类型的元素的集合。可以使用N个整数对元素进行索引。 ndarray中所有元素都是 同质的 ：每个元素占用相同大小的内存块，并且所有内存块的解释方式完全相同。数组中各元素的解释方式由一个的 data-type 对象（dtype）指定。 图中显示了用于描述数组中数据的三个基本对象之间的关系： ndarray本身 描述数组中单个固定大小元素的内存布局的data-type对象 访问数组的单个元素时返回的数组标量（Python对象） ndarray类的实例由一个 连续的 一维计算机内存块（由数组或其他对象拥有）和一个索引方案组合而成，该索引方案将N个整数分别映射到内存块中N个元素的位置。索引可以变化的范围被数组的shape限制。 ndarray看上去似乎可以是多维的，但在内存中，ndarray是一维储存的。有许多方案将N维数组以一维数组的形式储存在内存中。其中numpy有两种储存方式： 元素按行顺序储存（C语言风格） 或者按列顺序储存（Fortran语言风格） 因此，如果要对一个ndarray以行为单位进行操作，最好以C-type的方式创建ndarray；如果要对一个ndarray以列为单位进行操作，则用Fortran方式。","text_tokens":["以","每个","由","用于","时","创建","返回","data","对","相同","type","位置","方式","中","之间","实例","风格","整数","dtype","则","c语言","但","固定","如果","行为","标量","看上去","其他","提供","索引","并且","在","算机","是","块","指定","两种","都","其中","组合","变化","同一","语言","访问","ndarray","连续","到","范围","python","单位","单个","大小","该","可以","拥有","完全相同","了","布局","要","限制","按列","多维","各","显示","储存","三个","似乎","numpy","图中","最好","基本","许多","将","一维","用","元素","它","操作","和","n","个","。","被","分别","；"," ","fortran","-","数据","（","映射","）","解释","方案","shape","对象","顺序","或","c","占用","组合而成","看上","按行","维","集合","：","因此","所有","内存","关系","的","使用","类型","本身","一个","计算","上去","有","，","进行","同质","或者","列为","描述","形式","完全","计算机","类","数组"],"title":"ndarray对象","title_tokens":["ndarray","对象"]},{"location":"numpy笔记/6.3.内存布局.html#_1","text":"A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) pprint . pprint ( A ) array([[0, 1, 2], [3, 4, 5], [6, 7, 8]], dtype=int16) 属性（与数组内存布局有关） A的属性值 描述 A.dtype dtype('int16') 元素数据类型。A的每个元素是16bit大小的int型数据。 A.ndim 2 轴（维度）的个数。A有两个轴：0轴、1轴。 A.shape (3, 3) 各个轴的大小。0轴有3个元素，1轴有3个元素。 A.size 9 数组的大小，有多少个元素。 A.data <memory at 0x000001B17A238A68> 指向数组的数据的存储区。 A.itemsize 2 一个元素的长度，以字节为单位。16bit等于2字节。 A.nbytes 18 数组元素占据的总字节数。 A.base None 如果内存来自其他对象，则以此为基础对象。 A.flags 有关数组内存布局的信息。 A.strides (6, 2) 一个整数元组，每个元素保存着每个轴上相邻两个元素的地址差。 即当某个轴的下标增加1 时，数据存储区中的指针增加的字节数。 可以从不同的角度(即布局)观察该array： shape [ 1 ] ( = 3 ) ┌───────────┐ ┌ ┌───┬───┬───┐ ┐ │ │ 0 │ 1 │ 2 │ │ │ ├───┼───┼───┤ │ shape [ 0 ] │ │ 3 │ 4 │ 5 │ │ len ( Z ) ( = 3 ) │ ├───┼───┼───┤ │ ( = 3 ) │ │ 6 │ 7 │ 8 │ │ └ └───┴───┴───┘ ┘ 展开的item layout ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ └───┴───┴───┴───┴───┴───┴───┴───┴───┘ └───────────────────────────────────┘ A . size ( = 9 ) 内存布局(C顺序) strides [ 1 ] ( = 2 ) ┌─────────────────────┐ ┌ ┌──────────┬──────────┐ ┐ │ p + 00 : │ 00000000 │ 00000000 │ │ │ ├──────────┼──────────┤ │ │ p + 02 : │ 00000000 │ 00000001 │ │ strides [ 0 ] │ ├──────────┼──────────┤ │ ( = 2 x3 ) │ p + 04 │ 00000000 │ 00000010 │ │ │ ├──────────┼──────────┤ ┘ │ p + 06 │ 00000000 │ 00000011 │ │ ├──────────┼──────────┤ A . nbytes │ p + 08 : │ 00000000 │ 00000100 │ ( = 3 x3x2 ) │ ├──────────┼──────────┤ │ p + 10 : │ 00000000 │ 00000101 │ │ ├──────────┼──────────┤ │ p + 12 : │ 00000000 │ 00000110 │ │ ├──────────┼──────────┤ │ p + 14 : │ 00000000 │ 00000111 │ │ ├──────────┼──────────┤ │ p + 16 : │ 00000000 │ 00001000 │ └ └──────────┴──────────┘ └─────────────────────┘ A . itemsize A . dtype . itemsize ( = 2 ) 如果我们现在取一A的切片，结果是A的基本数组的一个视图： V = A[::2,::2] 这样的视图是由shape，dtype 和 strides 指定的，因为仅凭dtype和shape不能推断出strides: 如果我们现在取一A的切片，结果是A的基本数组的一个视图： V = A[::2,::2] 这样的视图是由shape，dtype 和 strides 指定的，因为仅凭dtype和shape不能推断出strides: Item layout shape [ 1 ] ( = 2 ) ┌───────────┐ ┌ ┌───┬───┬───┐ ┐ │ │ 0 │ │ 2 │ │ ┌───┬───┐ │ ├───┼───┼───┤ │ | 0 │ 2 │ shape [ 0 ] │ │ │ │ │ │ len ( A ) → ├───┼───┤ ( = 2 ) │ ├───┼───┼───┤ │ ( = 2 ) | 6 │ 8 │ │ │ 6 │ │ 8 │ │ └───┴───┘ └ └───┴───┴───┘ ┘ 展开的item layout ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐ ┌───┬───┬───┬───┐ │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ → │ 0 │ 2 │ 6 │ 8 │ └───┴───┴───┴───┴───┴───┴───┴───┴───┘ └───┴───┴───┴───┘ └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘ └───┬───┘ └───┬───┘ └───────────┬───────────┘ A.size (=4) 内存布局(C顺序，大端序) ┌ ┌──────────┬──────────┐ ┐ ┐ ┌─┤ p + 00 : │ 00000000 │ 00000000 │ │ │ │ └ ├──────────┼──────────┤ │ strides [ 1 ] │ ┌─┤ p + 02 : │ │ │ │ ( = 4 ) │ │ │ ┌ ├──────────┼──────────┤ ┘ │ │ └─┤ p + 04 │ 00000000 │ 00000010 │ │ │ └ ├──────────┼──────────┤ │ strides [ 0 ] │ p + 06 : │ │ │ │ ( = 12 ) │ ├──────────┼──────────┤ │ A . nbytes ─┤ p + 08 : │ │ │ │ ( = 8 ) │ ├──────────┼──────────┤ │ │ p + 10 : │ │ │ │ │ ┌ ├──────────┼──────────┤ ┘ │ ┌─┤ p + 12 : │ 00000000 │ 00000110 │ │ │ └ ├──────────┼──────────┤ └─┤ p + 14 : │ │ │ │ ┌ ├──────────┼──────────┤ └─┤ p + 16 : │ 00000000 │ 00001000 │ └ └──────────┴──────────┘ └─────────────────────┘ A . itemsize A . dtype . itemsize ( = 2 ) 可以直接修改 ndarray 对象的 strides 属性，改变 ndarray 的内存布局，但此时会修改原数组。 A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) A . strides = ( 2 , 4 ) pprint . pprint ( A ) array([[0, 2, 4], [1, 3, 5], [2, 4, 6]], dtype=int16)","text_tokens":[":","1","np","18","基础","差","以","每个","节数","由","多少",">","时","切片","9","len","z","元组","layout","02","+","信息","06","有关","08","data","00001000","我们","字节数","│","┴","属性","数据类型","─","整数","dtype","5","则","推断","大端序","下标","size","现在","pprint","x3x2","但","观察","某个","00000100","型","00000101","如果","即当","x3","|","00","这样","轴上","区","两个","着","来自","0","其他","int16","┐","取一","原","'","16bit","┼","16","base","是","a","指定","修改","→","none","增加","(","p","┤","仅凭","结果","指针","会","占据","ndarray","即","├","单位","区中","at","相邻","指向","copy","00000000","大小","等于","ndim","该","展开","7","保存","可以","10","地址","视图","推断出","存储","布局","不同","4","3","arange","长度","各个","改变","基本","维度","、","┘","00000010","[","<","元素","6","00000001","array","和","总","值","12","个","。","00000111","0x000001b17a238a68","00000110","v","轴有"," ","item","字节","数据","（","）","flags","shape","对象","顺序","c","=","以此",",","]","：","04","int","nbytes","内存","memory","┌","的","└",".","deepcopy","个数","itemsize","14","与","因为","类型","一个","00000011","轴","角度","┬","有","，","大端","此时","reshape",")","8","2","描述","strides","从","不能","为","数组","直接"],"title":"内存布局","title_tokens":["布局","内存"]},{"location":"numpy笔记/6.3.内存布局.html#_2","text":"视图和副本是优化数值计算的重要概念。 在numpy中，可以用切片和 花式索引 （整数数组索引）来索引数据。切片将始终返回视图，而整数数组索引将返回一个副本。这种差异很重要，因为在切片情况下，修改视图会修改原数组，而在整数数组索引情况下则不是这样： Z = np . zeros ( 9 ) Z_view = Z [: 3 ] Z_view [ ... ] = 1 print ( Z ) [1. 1. 1. 0. 0. 0. 0. 0. 0.] Z = np . zeros ( 9 ) Z_copy = Z [[ 0 , 1 , 2 ]] Z_copy [ ... ] = 1 print ( Z ) [0. 0. 0. 0. 0. 0. 0. 0. 0.] 因此，如果你需要反复用到某个花式索引，最好保留它的副本（特别是如果计算它很复杂）。如果您不确定索引的结果是视图还是副本，则可以检查base的结果。如果是None，那么结果就是副本： Z = np . random . uniform ( 0 , 1 ,( 5 , 5 )) Z1 = Z [: 3 ,:] Z2 = Z [[ 0 , 1 , 2 ], :] print ( np . allclose ( Z1 , Z2 )) True print ( Z1 . base is Z ) True print ( Z2 . base is Z ) False print ( Z2 . base is None ) True 请注意，一些numpy函数在可能的情况下返回视图(例如， ravel )，而另一些函数总是返回副本(例如， flatten ): Z = np . zeros (( 5 , 5 )) print ( Z . ravel () . base is Z ) True print ( Z [:: 2 ,:: 2 ] . ravel () . base is Z ) False print ( Z . flatten () . base is Z ) False 可以通过 ndarray.view() 方法，从同一块内存区（储存着numpy数组的内存区）创建不同的dtype数组。 即用不同的数值类型查看同一段内存中的二进制数据。 它们使用的是同一块内存。 实际上， ndarray.view() 方法是创建了一个视图。 A = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ],[ 6 , 7 , 8 ]]) A_view = A . view ( np . int32 ) # A_view 是视图 A_view . flags C_CONTIGUOUS : True F_CONTIGUOUS : False OWNDATA : False WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False 如果我们直接修改原始数组的 dtype ，会达到同样的效果， 但此时直接修改原始数组。 A . dtype = np . float32 Caution 通常应避免改变由切片、transposes、fortran排序等定义的数组的 dtype 的大小，如下： A = copy . deepcopy ( np . arange ( 9 , dtype = np . int16 ) . reshape ( 3 , 3 )) A_view = A . view ( np . int32 ) ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-7b8b7375e3ff> in <module> 1 A = copy.deepcopy(np.arange(9, dtype=np.int16).reshape(3,3)) ----> 2 A_view = A.view(np.int32) ValueError: When changing to a larger dtype, its size must be a divisor of the total size in bytes of the last axis of the array.","text_tokens":["call",":","1","np","in","allclose","块内存","由","its","切片",">","9","同","z","changing","创建","查看","must","返回","我们","z2","不","而","排序","中","效果","用到","整数","5","则","dtype","直接","这种","size","false","避免","函数","但","某个","_","可能","定义","确定","如果","traceback","这样","通常","等","注意","区","着","of","updateifcopy","0","int16","float32","索引","原","在","most","axis","base","同样","是","a","ravel","修改","writebackifcopy","zeros","同一","none","副本","(","true","二进制","还是","您","z1","结果","应","会","when","ndarray","原始","复杂","copy","概念","你","大小","进制","is","优化","即用","7","total","可以","视图","f","last","了","不同","请","一段","实际上","contiguous","aligned","4","3","arange","下则","flatten","就是","module","通过","储存","数值","valueerror","改变","numpy","最好","input","、","caution","the","将","[","用","<","6","它","实际","和","差异","array","达到","divisor","来","owndata","ipython","。","random","需要"," ","fortran","-","总是","数据","（","始终","）","那么","flags","它们","to","print","...","c","recent","=","情况","一些","7b8b7375e3ff",",","]","例如","：","反复","因此","检查","uniform","另","花式","如下","内存","view","的","#",".","bytes","be","重要","deepcopy","使用","因为","保留","方法","类型","一个","计算","int32","larger","，","此时","特别","reshape",")","8","2","下","transposes","writeable","从","数组","不是","很"],"title":"视图和副本","title_tokens":["视图","副本","和"]},{"location":"numpy笔记/6.4.广播.html","text":"广播 当使用ufunc函数对两个数组进行计算时，ufunc函数会对这两个数组的对应元素进行计算。这要求这两个数组的形状相同。如果这两个数组的形状不同，就通过广播broadcasting进行处理： 首先让所有输入数组都向其中维度最高的数组看齐。看齐方式为：在shape属性的左侧插入数字1 最后输出数组的shape属性是输入数组的shape属性的各轴上的最大值 如果输入数组的某个轴的长度为 1，或者与输出数组的各对应轴的长度相同，该数组能正确广播。否则计算出错 当输入数组的某个轴的长度为 1时，沿着此轴运算时都用此轴上的第一组值。 \"\"\" numpy.broadcast_arrays() 查看广播之后的数组 np.broadcast_to(array, shape, subok=False) 将array广播为指定的shape，如果指定的shape不满足广播要求，则报错 ndarray.repeat(repeats, axis=None) 重复某个轴上的值. repeats为重复次数 axis指定被重复的轴，即沿着哪一轴重复。如果未指定，则将数组展平然后重复。返回的也是一个展平的数组 \"\"\" a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = np . arange ( 5 ) c = b [:, None ] d = np . ones (( 5 , 3 )) np . broadcast_arrays ( d , c ) [array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]), array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]])] np . broadcast_to ( b [:, None ], ( 5 , 2 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) a . repeat ( 3 , axis = 1 ) array([[0, 0, 0, 1, 1, 1], [2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5], [6, 6, 6, 7, 7, 7], [8, 8, 8, 9, 9, 9]]) 广播示意图 The code to produce the figures is part of the AstroML book","text_tokens":["要求",":","1","np","最大","正确","意图","时","第一","9","查看","示意","让","未指定","然后","哪一轴","对应","subok","对","返回","相同","d","输入","方式","不","属性","broadcasting","5","则","示意图","false","函数","出错","某个","_","如果","轴上","两个","之后","of","produce","0","在","axis","左侧","是","a","指定","都","其中","一组","none","(","插入","展平","会","figures","处理","ndarray","即","当","最大值","最后","copy","is","数字","该","7","也","10","能","首先","各轴上","广播","重复","不同","b","此轴上","4","3","astroml","各","arange","长度","通过","part","numpy","形状","the","维度","将","[","用","broadcast","元素","6","就","array","大值","否则","ufunc","值","满足","。","被","运算","报错"," ","ones","code","shape","第一组","to","repeats","c","=",",","此轴","]","：","所有","次数","的","沿着",".","看齐","deepcopy","使用","与","\"","一个","计算","book","轴","arrays","repeat","，","最高","进行","或者","reshape",")","这","8","2","向","为","数组","输出"],"title":"6.4.广播","title_tokens":["6.4",".","广播"]},{"location":"numpy笔记/6.4.广播.html#_1","text":"当使用ufunc函数对两个数组进行计算时，ufunc函数会对这两个数组的对应元素进行计算。这要求这两个数组的形状相同。如果这两个数组的形状不同，就通过广播broadcasting进行处理： 首先让所有输入数组都向其中维度最高的数组看齐。看齐方式为：在shape属性的左侧插入数字1 最后输出数组的shape属性是输入数组的shape属性的各轴上的最大值 如果输入数组的某个轴的长度为 1，或者与输出数组的各对应轴的长度相同，该数组能正确广播。否则计算出错 当输入数组的某个轴的长度为 1时，沿着此轴运算时都用此轴上的第一组值。 \"\"\" numpy.broadcast_arrays() 查看广播之后的数组 np.broadcast_to(array, shape, subok=False) 将array广播为指定的shape，如果指定的shape不满足广播要求，则报错 ndarray.repeat(repeats, axis=None) 重复某个轴上的值. repeats为重复次数 axis指定被重复的轴，即沿着哪一轴重复。如果未指定，则将数组展平然后重复。返回的也是一个展平的数组 \"\"\" a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = np . arange ( 5 ) c = b [:, None ] d = np . ones (( 5 , 3 )) np . broadcast_arrays ( d , c ) [array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]), array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]])] np . broadcast_to ( b [:, None ], ( 5 , 2 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) a . repeat ( 3 , axis = 1 ) array([[0, 0, 0, 1, 1, 1], [2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5], [6, 6, 6, 7, 7, 7], [8, 8, 8, 9, 9, 9]])","text_tokens":["要求",":","1","np","最大","正确","时","第一","9","查看","让","未指定","然后","哪一轴","对应","subok","对","返回","相同","d","输入","方式","不","属性","broadcasting","5","则","false","函数","出错","某个","_","如果","轴上","两个","之后","0","在","axis","左侧","是","a","指定","都","其中","一组","none","(","插入","展平","会","处理","ndarray","即","当","最大值","最后","copy","数字","该","7","也","10","能","首先","各轴上","广播","重复","不同","b","此轴上","4","3","各","arange","长度","通过","numpy","形状","维度","将","[","用","broadcast","元素","6","就","array","大值","否则","ufunc","值","满足","。","被","运算","报错"," ","ones","shape","第一组","to","repeats","c","=",",","此轴","]","：","所有","次数","的","沿着",".","看齐","deepcopy","使用","与","\"","一个","计算","轴","arrays","repeat","，","最高","进行","或者","reshape",")","这","8","2","向","为","数组","输出"],"title":"广播","title_tokens":["广播"]},{"location":"numpy笔记/6.4.广播.html#_2","text":"The code to produce the figures is part of the AstroML book","text_tokens":["produce","to","the","part","astroml","figures"," ","code","is","book","of"],"title":"广播示意图","title_tokens":["示意图","意图","示意","广播"]},{"location":"numpy笔记/6.5.常量.html","text":"import numpy as np NumPy定义了几个常量（都是IEEE 754 浮点表示）： （正）无穷大 # 使用`inf`是因为`Inf`、`Infinity`、`PINF`和`infty`是`inf`的别名。 np . inf np . Infinity np . PINF np . Inf np . infty inf 负无穷大 np . NINF -inf 非数字 NaN # `NaN`和`NAN`是`nan`的等价定义。请使用`nan而不是`NAN`。 np . nan np . NAN np . NaN nan 负零 np . NZERO -0.0 正零 np . PZERO 0.0 自然对数的基础，纳皮尔的常数 np . e 2.718281828459045 欧拉常数 γ = 0.5772156649015328606065120900824024310421... 参考 np . euler_gamma 0.5772156649015329 None的便捷别名 对索引数组很有用 np . newaxis 圆周率 np . pi 3.141592653589793","text_tokens":["np","基础","nan","对","自然","是因为","infinity","而","自然对数","无穷大","_","定义","754","纳皮尔","常数","索引","非","`","便捷","是","都","newaxis","常量","负零","圆周","none","参考","nzero","2.718281828459045","inf","ieee","pi","as","数字","euler","欧拉","对数","了","请","负","0.5772156649015329","0.5772156649015328606065120900824024310421","浮点","圆周率","numpy","、","和","表示","别名","。","γ","3.141592653589793"," ","-","（","）","几个","gamma","...","=","正零","：","无穷","等价","ninf","正","0.0","的","e","#",".","使用","infty","因为","import","，","pinf","有用","pzero","数组","不是","很"],"title":"6.5.常量","title_tokens":[".","常量","6.5"]},{"location":"numpy笔记/6.6.打印数组.html","text":"import numpy import numpy as np 打印数组 当打印ndarray时，numpy按照Python的嵌套list的格式打印输出，但是按照以下顺序打印： 最底层的axis按照从左到右的顺序输出 次底层的axis按照从上到下的顺序输出 其他层的axis也是按照从上到下的顺序输出，但是每个slice中间间隔一条空行 如： 一维的ndarray按行打印；二维的ndarray按照矩阵打印；三维的ndarray按照矩阵的list打印 如果ndarray太大，那么numpy默认跳过中间部分的数据而只是输出四个角落的数据。 要想任何时候都打印全部数据，可以在print(array)之前设置选项 numpy . set_printoptions ( threshold = None ) 这样后续的打印ndarray就不会省略中间数据。 np . set_printoptions ( threshold = 5 ) np . arange ( 200 ) array([ 0, 1, 2, ..., 197, 198, 199])","text_tokens":["1","np","部分","每个","slice","时","选项","角落","printoptions","想","而","set","5","197","后续","200","_","如果","这样","上到","太大","四个","一条","其他","0","中间","跳过","在","axis","是","从左到右","都","none","次","(","如","只是","ndarray","当","198","python","打印","按照","as","也","可以","但是","默认","从上到下","打印输出","设置","要","任何","arange","threshold","不会","numpy","省略","一维","[","层","array","空行","就","199","之前","。","二维","；"," ","数据","最底层","那么","顺序","print","...","=",",","按行","]","：","以下","时候","格式","间隔","嵌套","的",".","底层","三维","import","，","全部",")","list","2","矩阵","数组","输出"],"title":"6.6.打印数组","title_tokens":[".","数组","打印","6.6"]},{"location":"numpy笔记/6.6.打印数组.html#_1","text":"当打印ndarray时，numpy按照Python的嵌套list的格式打印输出，但是按照以下顺序打印： 最底层的axis按照从左到右的顺序输出 次底层的axis按照从上到下的顺序输出 其他层的axis也是按照从上到下的顺序输出，但是每个slice中间间隔一条空行 如： 一维的ndarray按行打印；二维的ndarray按照矩阵打印；三维的ndarray按照矩阵的list打印 如果ndarray太大，那么numpy默认跳过中间部分的数据而只是输出四个角落的数据。 要想任何时候都打印全部数据，可以在print(array)之前设置选项 numpy . set_printoptions ( threshold = None ) 这样后续的打印ndarray就不会省略中间数据。 np . set_printoptions ( threshold = 5 ) np . arange ( 200 ) array([ 0, 1, 2, ..., 197, 198, 199])","text_tokens":["1","np","部分","每个","slice","时","选项","角落","printoptions","想","而","set","5","197","后续","200","_","如果","这样","上到","太大","四个","一条","其他","0","中间","跳过","在","axis","是","从左到右","都","none","次","(","如","只是","ndarray","当","198","python","打印","按照","也","可以","但是","默认","从上到下","打印输出","设置","要","任何","arange","threshold","不会","numpy","省略","一维","[","层","array","空行","就","199","之前","。","二维","；"," ","数据","最底层","那么","顺序","print","...","=",",","按行","]","：","以下","时候","格式","间隔","嵌套","的",".","底层","三维","，","全部",")","list","2","矩阵","输出"],"title":"打印数组","title_tokens":["数组","打印"]},{"location":"numpy笔记/6.7.添加和删除.html","text":"import numpy as np 添加和删除数组元素 方法 描述 delete (arr, obj[, axis]) 沿指定轴删除指定的元素，返回未删除的数组 insert (arr, obj, values[, axis]) 沿指定轴在指定索引之前插入值 append (arr, values[, axis]) 将值附加到数组的末尾 trim_zeros s(filt[, trim]) 修剪一维数组或序列中的前导、尾随的零 unique (ar[, return_index, return_inverse, …]) 返回没有重复元素的数组 # append a = np . arange ( 4 ) . reshape (( 2 , 2 )) np . append ( a , [[ 1 , 2 ],[ 3 , 4 ]], axis = 0 ) array([[0, 1], [2, 3], [1, 2], [3, 4]]) # insert a = np . arange ( 4 ) . reshape (( 2 , 2 )) # obj 是索引 np . insert ( a , obj = 1 , values = [ 10 , 11 ], axis = 0 ) array([[ 0, 1], [10, 11], [ 2, 3]]) # delete 删除指定数据，返回未删除的数据 a = np . arange ( 4 ) . reshape (( 2 , 2 )) np . delete ( a , 1 , axis = 0 ) array([[0, 1]]) # 默认返回一维数组 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = False , axis = None ) array([1, 2, 3]) # 设置axis参数 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = False , axis = 0 ) array([[1, 2], [2, 3]]) # 同时返回unique数组元素在原数组中的索引index a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = True , return_inverse = False , return_counts = False , axis = 0 ) (array([[1, 2], [2, 3]]), array([0, 2], dtype=int64)) # 同时返回原数组元素在unique数组中的索引index # 可用于重建原数组 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = True , return_counts = False , axis = 0 ) (array([[1, 2], [2, 3]]), array([0, 0, 1], dtype=int64)) # 同时返回 计数 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = True , axis = 0 ) (array([[1, 2], [2, 3]]), array([2, 1], dtype=int64)) a = np . array ([ 0 , 0 , 1 , 2 , 3 , 0 , 0 ]) # 删除一维数组开头和结尾的0元素 # trim='f' 从前面裁剪 # trim='b' 从后面裁剪 # 默认为 trim='fb' np . trim_zeros ( a , trim = 'fb' ) array([1, 2, 3])","text_tokens":["…","1","np","用于","insert","重建","index","fb","将值","s","同时","返回","ar","中","arr","dtype","append","前导","false","零","_","values","0","后面","索引","原","在","'","axis","是","a","附加","指定","前面","未","开头","末尾","trim","zeros","none","添加","(","true","插入","unique","11","到","可","inverse","as","filt","obj","10","参数","默认","删除","f","重复","结尾","设置","序列","b","4","3","arange","numpy","、","delete","[","一维","元素","裁剪","和","array","之前","值","int64"," ","counts","数据","或","=","修剪",",","尾随","]","沿","的","return","#",".","import","方法","轴","没有","，","reshape",")","2","描述","从","计数","为","数组"],"title":"6.7.添加和删除","title_tokens":["6.7","添加",".","删除","和"]},{"location":"numpy笔记/6.7.添加和删除.html#_1","text":"方法 描述 delete (arr, obj[, axis]) 沿指定轴删除指定的元素，返回未删除的数组 insert (arr, obj, values[, axis]) 沿指定轴在指定索引之前插入值 append (arr, values[, axis]) 将值附加到数组的末尾 trim_zeros s(filt[, trim]) 修剪一维数组或序列中的前导、尾随的零 unique (ar[, return_index, return_inverse, …]) 返回没有重复元素的数组 # append a = np . arange ( 4 ) . reshape (( 2 , 2 )) np . append ( a , [[ 1 , 2 ],[ 3 , 4 ]], axis = 0 ) array([[0, 1], [2, 3], [1, 2], [3, 4]]) # insert a = np . arange ( 4 ) . reshape (( 2 , 2 )) # obj 是索引 np . insert ( a , obj = 1 , values = [ 10 , 11 ], axis = 0 ) array([[ 0, 1], [10, 11], [ 2, 3]]) # delete 删除指定数据，返回未删除的数据 a = np . arange ( 4 ) . reshape (( 2 , 2 )) np . delete ( a , 1 , axis = 0 ) array([[0, 1]]) # 默认返回一维数组 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = False , axis = None ) array([1, 2, 3]) # 设置axis参数 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = False , axis = 0 ) array([[1, 2], [2, 3]]) # 同时返回unique数组元素在原数组中的索引index a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = True , return_inverse = False , return_counts = False , axis = 0 ) (array([[1, 2], [2, 3]]), array([0, 2], dtype=int64)) # 同时返回原数组元素在unique数组中的索引index # 可用于重建原数组 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = True , return_counts = False , axis = 0 ) (array([[1, 2], [2, 3]]), array([0, 0, 1], dtype=int64)) # 同时返回 计数 a = np . array ([[ 1 , 2 ],[ 1 , 2 ],[ 2 , 3 ]]) np . unique ( a , return_index = False , return_inverse = False , return_counts = True , axis = 0 ) (array([[1, 2], [2, 3]]), array([2, 1], dtype=int64)) a = np . array ([ 0 , 0 , 1 , 2 , 3 , 0 , 0 ]) # 删除一维数组开头和结尾的0元素 # trim='f' 从前面裁剪 # trim='b' 从后面裁剪 # 默认为 trim='fb' np . trim_zeros ( a , trim = 'fb' ) array([1, 2, 3])","text_tokens":["…","1","np","用于","insert","重建","index","fb","将值","s","同时","返回","ar","中","arr","dtype","append","前导","false","零","_","values","0","后面","索引","原","在","'","axis","是","a","附加","指定","前面","未","开头","末尾","trim","zeros","none","(","true","插入","unique","11","到","可","inverse","filt","obj","10","参数","默认","删除","f","重复","结尾","设置","序列","b","4","3","arange","、","delete","[","一维","元素","裁剪","array","和","之前","值","int64","counts"," ","数据","或","=","修剪",",","尾随","]","沿","的","return","#",".","方法","轴","没有","，","reshape",")","2","描述","从","计数","为","数组"],"title":"添加和删除数组元素","title_tokens":["添加","元素","删除","和","数组"]},{"location":"numpy笔记/6.8.形状操纵.html","text":"import numpy as np import copy 形状操作( shape ) .shape .reshape() .resize() reshape resize 区别： reshape不会修改原数据 resize会修改原数据 # 创建示例数据 a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) # 会直接修改原始数组 a . shape = ( 5 , 10 ) a . flags # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . shape = ( 25 , - 1 ) # 不会直接修改原始数组 a . reshape ( 5 , 10 ) # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . reshape ( 5 , - 1 ) # 会直接修改原始数组 a . resize (( 25 , 2 )) 形状操作( ndim ) .flatten() ：多维数组转为一维数组 .reval() ：多维数组转为一维数组 .squeeze() ：将大小等于1的轴删除 .swapaxes(a, axis1, axis2)) ：交换指定的两个轴axis1/axis2。它获得是原数组的视图。 .transpose(a, axes=None) ：重置轴序。如果 axes=None ，则默认重置为逆序的轴序，如原来的 shape=(1,2,3) ，逆序之后为 (3,2,1） 如果 axes!=None ，则要给出重置后的轴序。它获得的是原数组的视图。 .atleast_1d(*arys) ：将输入转换为至少一维的数组 .atleast_2d(*arys) ：将输入转换为至少二维的数组 .atleast_3d(*arys) ：将输入转换为至少三维的数组 .expand_dims() ：在指定位置插入大小为1的新轴 .moveaxis(a, source, destination) ：将a中的source轴移动到位置destination，source、destination可以是int of list，一次性移动多个轴 # 多维数组转为一维数组 a . flatten () # 返回副本 a . ravel () # 一般返回视图 ## flatten ravel 区别 ## ravel()：如果没有必要，不会产生源数据的副本 ## flatten()：返回源数据的副本 b = np . arange ( 10 ) # 创建示例数据 b . flatten () . flags [ \"OWNDATA\" ] True b . ravel () . flags [ \"OWNDATA\" ] False a . ravel ( order = \"F\" ) . flags [ \"OWNDATA\" ] True # 对维数为1的维度降维,返回副本 b = copy . deepcopy ( np . arange ( 20 ) . reshape ( 20 , 1 )) b [: 6 ] array([[0], [1], [2], [3], [4], [5]]) b . squeeze ( 1 ) array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) # 返回数组的视图，其中axis1和axis2互换。 ## ndarray.swapaxes(axis1, axis2) a = copy . deepcopy ( np . arange ( 20 ) . reshape ( 10 , 2 )) a . swapaxes ( 0 , 1 ) # 视图 array([[ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18], [ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]]) # 返回轴转置的数组视图。 b = copy . deepcopy ( np . arange ( 60 ) . reshape ( 3 , 2 , 10 )) b . transpose () array ([[[ 0 , 20 , 40 ], [ 10 , 30 , 50 ]], [[ 1 , 21 , 41 ], [ 11 , 31 , 51 ]], [[ 2 , 22 , 42 ], [ 12 , 32 , 52 ]], [[ 3 , 23 , 43 ], [ 13 , 33 , 53 ]], [[ 4 , 24 , 44 ], [ 14 , 34 , 54 ]], [[ 5 , 25 , 45 ], [ 15 , 35 , 55 ]], [[ 6 , 26 , 46 ], [ 16 , 36 , 56 ]], [[ 7 , 27 , 47 ], [ 17 , 37 , 57 ]], [[ 8 , 28 , 48 ], [ 18 , 38 , 58 ]], [[ 9 , 29 , 49 ], [ 19 , 39 , 59 ]]]) # atleast_nd np . atleast_1d ( 1 ) array([1]) np . atleast_2d ([ 1 , 2 , 3 , 4 ]) array([[1, 2, 3, 4]]) np . atleast_3d ([[ 1 , 2 ],[ 3 , 4 ]]) array ([[[ 1 ], [ 2 ]], [[ 3 ], [ 4 ]]]) a = np . arange ( 4 ) . reshape ( 2 , 2 ) np . expand_dims ( a , 1 ) . shape (2, 1, 2) x = np . zeros (( 3 , 4 , 5 )) print ( np . moveaxis ( x , 0 , - 1 ) . shape ) print ( np . moveaxis ( x , - 1 , 0 ) . shape ) (4, 5, 3) (5, 3, 4) \"以下代码的效果一样\" x = np . zeros (( 3 , 4 , 5 )) np . transpose ( x ) . shape np . swapaxes ( x , 0 , - 1 ) . shape np . moveaxis ( x , [ 0 , 2 ], [ - 1 , - 2 ]) . shape np . moveaxis ( x , [ 0 , 1 , 2 ], [ - 1 , - 2 , - 3 ]) . shape 数组拼接 .concatenate((a1, a2, ...), axis=0) ：连接多个数组。其中 (a1,a2,...) 为数组的序列，给出了待连接的数组，它们沿着 axis 指定的已存在的轴连接。所有的这些数组的形状，除了 axis 轴之外都相同。 .vstack(tup) ：沿0轴拼接（垂直拼接），增加行。 .hstack(tup) ：沿1轴拼接（水平拼接），增加列。 .dstack(tup) ： numpy.concatenate((a1, a2, ...), axis=3) 。沿着3轴堆叠数组。 .column_stack(tup) ：类似于 hstack ，但是如果被拼接的数组是一维的，则将其形状修改为二维的$(N,1)$。 .c_ ： .c_ 对象的 [] 方法也可以用于按列连接数组。但是如果被拼接的数组是一维的，则将其形状修改为二维的$(N,1)$。沿列方向拼接，增加列。 a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) # 横向拼接、拼接 1 轴（第二个轴，即列） np . concatenate (( a , b ), axis = 1 ) np . hstack (( a , b )) np . c_ [ a , b ] array([[0, 1, 0, 1], [2, 3, 2, 3], [4, 5, 4, 5], [6, 7, 6, 7], [8, 9, 8, 9]]) # column_stack hstack np.c_区别 a1 = np . arange ( 5 ) np . column_stack (( a1 , a1 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) np . hstack (( a1 , a1 )) array([0, 1, 2, 3, 4, 0, 1, 2, 3, 4]) np . c_ [ a1 , a1 ] array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) 数组拆分 1. .split(ary, indices_or_sections, axis=0) ：用于沿着指定的轴拆分数组ary。 indices_or_sections指定了拆分点： 如果为整数N，则表示平均拆分成N份。如果不能平均拆分，则报错 如果为序列，则该序列指定了划分区间（无需指定最开始的0起点和终点）。如 [1,3] 指定了区间： [0,1],[1,3],[3:] 2. .array_split(ary, indices_or_sections, axis=0) ：作用与 .split() 类似。唯一的区别在于：当indices_or_sections为整数，且无法平均拆分时，并不报错，而是尽可能的维持平均拆分。 3. .dsplit(ary, indices_or_sections) ：沿第3轴将数组拆分为多个子数组。 4. .hsplit(ary, indices_or_sections) ：水平（按列）将一个数组拆分为多个子数组。 5. .vsplit(ary, indices_or_sections) ：垂直（行）将数组拆分为多个子数组。 a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) np . split ( a , 2 , axis = 0 ) [array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]]), array([[25, 26, 27, 28, 29], [30, 31, 32, 33, 34], [35, 36, 37, 38, 39], [40, 41, 42, 43, 44], [45, 46, 47, 48, 49]])] # [0,1) [1,3) [3:] np . split ( a ,[ 1 , 3 ], axis = 1 ) [array([[ 0], [ 5], [10], [15], [20], [25], [30], [35], [40], [45]]), array([[ 1, 2], [ 6, 7], [11, 12], [16, 17], [21, 22], [26, 27], [31, 32], [36, 37], [41, 42], [46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], [18, 19], [23, 24], [28, 29], [33, 34], [38, 39], [43, 44], [48, 49]])] np . array_split ( a , 2 , axis = 1 ) [array([[ 0, 1, 2], [ 5, 6, 7], [10, 11, 12], [15, 16, 17], [20, 21, 22], [25, 26, 27], [30, 31, 32], [35, 36, 37], [40, 41, 42], [45, 46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], [18, 19], [23, 24], [28, 29], [33, 34], [38, 39], [43, 44], [48, 49]])]","text_tokens":["sections","1","18","时","沿列","54","相同","输入","21","新","5","15","50","20","作用","之后","vstack","0","至少","原","在","or","3d","水平","nd","58","a","指定","其中","48","none","true","一般","当","原始","原来","copy","ndim","7","也","可以","26","视图","无需","默认","expand","f","序列","b","42","4","flatten","分成","必要","形状","代码","1d","、","一维","6","它","尽可能","31","无法","a2","逆序"," ","dsplit","33","后","开始","41","多个","对象","c","axes","44","所有","25","#","一次性","import","\"","方法","22","一个","没有","此时","列","方向","即列",":","且","9","destination","在于","arys","dims","source","对维数","axis2","_","51","47","55","37","两个","of","给出","axis","16","修改","待","zeros","垂直","插入","/","ndarray","到","但是","tup","删除","沿第","3","numpy","column","维度","36","49","将","19","第二个","操作","拆分","owndata","被","二维","横向","堆叠","flags","print","...","交换","=",",","示例","2d","$","以下","转换","indices","三维","划分","reshape","8","axis1","不能","order","直接","reval","区别","56","返回","concatenate","13","位置","dstack","中","整数","则","17","起点","52","某个","40","如果","拆","降维","53","二个","x","ravel","并","副本","split","重置","会","自动","transpose","hsplit","等于","第二","23","该","这些","了","设置","hstack","获得","长度","a1","*","轴序","28","转置","n","45","-","连接","它们","shape","平均","moveaxis","]","沿","其","沿着",".","14","38","存在","与","59","行","32","，",")","2","list","stack","数组","np","用于","46","已","创建","squeeze","34","产生","于","不","27","效果","源","最","false","可能","!","尽可","35","除了","29","之外","是","都","增加","(","如","39","11","类似","区间","as","大小","10","唯一","要","按列","多维","arange","60","子","不会","resize","份","43","24","[","array","和","表示","点","12","30","。","互换","拼接","维持","报错","数据","（","）","ary","swapaxes","终点","一样","而是","57","：","移动","int","vsplit","的","deepcopy","atleast","##","计算","轴","一次","分为","为","转为"],"title":"6.8.形状操纵","title_tokens":["操纵","形状",".","6.8"]},{"location":"numpy笔记/6.8.形状操纵.html#shape","text":".shape .reshape() .resize() reshape resize 区别： reshape不会修改原数据 resize会修改原数据 # 创建示例数据 a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) # 会直接修改原始数组 a . shape = ( 5 , 10 ) a . flags # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . shape = ( 25 , - 1 ) # 不会直接修改原始数组 a . reshape ( 5 , 10 ) # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . reshape ( 5 , - 1 ) # 会直接修改原始数组 a . resize (( 25 , 2 ))","text_tokens":["flags","可以","1","np","shape","10","=","该","原","创建","在","设置","区别",",","示例","：","a","arange","修改","不会","resize","长度","其","的","25","(","#",".","5","直接","deepcopy","维度","50","会","为","自动","计算","原始","某个","，","此时","reshape",")","被","copy","2"," ","-","数组","数据"],"title":"形状操作(shape)","title_tokens":["形状","shape","(",")","操作"]},{"location":"numpy笔记/6.8.形状操纵.html#ndim","text":".flatten() ：多维数组转为一维数组 .reval() ：多维数组转为一维数组 .squeeze() ：将大小等于1的轴删除 .swapaxes(a, axis1, axis2)) ：交换指定的两个轴axis1/axis2。它获得是原数组的视图。 .transpose(a, axes=None) ：重置轴序。如果 axes=None ，则默认重置为逆序的轴序，如原来的 shape=(1,2,3) ，逆序之后为 (3,2,1） 如果 axes!=None ，则要给出重置后的轴序。它获得的是原数组的视图。 .atleast_1d(*arys) ：将输入转换为至少一维的数组 .atleast_2d(*arys) ：将输入转换为至少二维的数组 .atleast_3d(*arys) ：将输入转换为至少三维的数组 .expand_dims() ：在指定位置插入大小为1的新轴 .moveaxis(a, source, destination) ：将a中的source轴移动到位置destination，source、destination可以是int of list，一次性移动多个轴 # 多维数组转为一维数组 a . flatten () # 返回副本 a . ravel () # 一般返回视图 ## flatten ravel 区别 ## ravel()：如果没有必要，不会产生源数据的副本 ## flatten()：返回源数据的副本 b = np . arange ( 10 ) # 创建示例数据 b . flatten () . flags [ \"OWNDATA\" ] True b . ravel () . flags [ \"OWNDATA\" ] False a . ravel ( order = \"F\" ) . flags [ \"OWNDATA\" ] True # 对维数为1的维度降维,返回副本 b = copy . deepcopy ( np . arange ( 20 ) . reshape ( 20 , 1 )) b [: 6 ] array([[0], [1], [2], [3], [4], [5]]) b . squeeze ( 1 ) array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) # 返回数组的视图，其中axis1和axis2互换。 ## ndarray.swapaxes(axis1, axis2) a = copy . deepcopy ( np . arange ( 20 ) . reshape ( 10 , 2 )) a . swapaxes ( 0 , 1 ) # 视图 array([[ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18], [ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]]) # 返回轴转置的数组视图。 b = copy . deepcopy ( np . arange ( 60 ) . reshape ( 3 , 2 , 10 )) b . transpose () array ([[[ 0 , 20 , 40 ], [ 10 , 30 , 50 ]], [[ 1 , 21 , 41 ], [ 11 , 31 , 51 ]], [[ 2 , 22 , 42 ], [ 12 , 32 , 52 ]], [[ 3 , 23 , 43 ], [ 13 , 33 , 53 ]], [[ 4 , 24 , 44 ], [ 14 , 34 , 54 ]], [[ 5 , 25 , 45 ], [ 15 , 35 , 55 ]], [[ 6 , 26 , 46 ], [ 16 , 36 , 56 ]], [[ 7 , 27 , 47 ], [ 17 , 37 , 57 ]], [[ 8 , 28 , 48 ], [ 18 , 38 , 58 ]], [[ 9 , 29 , 49 ], [ 19 , 39 , 59 ]]]) # atleast_nd np . atleast_1d ( 1 ) array([1]) np . atleast_2d ([ 1 , 2 , 3 , 4 ]) array([[1, 2, 3, 4]]) np . atleast_3d ([[ 1 , 2 ],[ 3 , 4 ]]) array ([[[ 1 ], [ 2 ]], [[ 3 ], [ 4 ]]]) a = np . arange ( 4 ) . reshape ( 2 , 2 ) np . expand_dims ( a , 1 ) . shape (2, 1, 2) x = np . zeros (( 3 , 4 , 5 )) print ( np . moveaxis ( x , 0 , - 1 ) . shape ) print ( np . moveaxis ( x , - 1 , 0 ) . shape ) (4, 5, 3) (5, 3, 4) \"以下代码的效果一样\" x = np . zeros (( 3 , 4 , 5 )) np . transpose ( x ) . shape np . swapaxes ( x , 0 , - 1 ) . shape np . moveaxis ( x , [ 0 , 2 ], [ - 1 , - 2 ]) . shape np . moveaxis ( x , [ 0 , 1 , 2 ], [ - 1 , - 2 , - 3 ]) . shape","text_tokens":["reval",":","1","np","18","46","9","创建","区别","destination","squeeze","返回","产生","34","54","56","13","位置","输入","21","中","27","效果","新","arys","5","则","源","15","dims","50","17","false","20","52","source","对维数","axis2","_","51","40","55","如果","!","47","37","35","两个","降维","之后","of","53","0","至少","给出","原","29","在","3d","nd","16","x","58","是","a","ravel","指定","其中","48","zeros","none","副本","(","true","order","如","插入","一般","/","重置","ndarray","39","11","到","transpose","原来","copy","大小","等于","23","7","可以","26","10","视图","默认","删除","expand","f","要","b","42","4","多维","获得","3","arange","flatten","60","不会","必要","*","轴序","28","43","代码","1d","、","维度","24","将","19","一维","[","36","49","6","它","转置","array","和","31","owndata","12","30","。","互换","二维","逆序","45"," ","-","数据","）","33","后","flags","shape","swapaxes","多个","41","print","moveaxis","交换","=","一样","axes",",","57","示例","]","2d","：","移动","44","以下","int","转换","的","25","#",".","deepcopy","14","38","三维","atleast","一次性","##","\"","22","59","32","轴","没有","一次","，","reshape",")","8","axis1","2","list","为","数组","转为"],"title":"形状操作(ndim)","title_tokens":["形状","(",")","操作","ndim"]},{"location":"numpy笔记/6.8.形状操纵.html#_1","text":".concatenate((a1, a2, ...), axis=0) ：连接多个数组。其中 (a1,a2,...) 为数组的序列，给出了待连接的数组，它们沿着 axis 指定的已存在的轴连接。所有的这些数组的形状，除了 axis 轴之外都相同。 .vstack(tup) ：沿0轴拼接（垂直拼接），增加行。 .hstack(tup) ：沿1轴拼接（水平拼接），增加列。 .dstack(tup) ： numpy.concatenate((a1, a2, ...), axis=3) 。沿着3轴堆叠数组。 .column_stack(tup) ：类似于 hstack ，但是如果被拼接的数组是一维的，则将其形状修改为二维的$(N,1)$。 .c_ ： .c_ 对象的 [] 方法也可以用于按列连接数组。但是如果被拼接的数组是一维的，则将其形状修改为二维的$(N,1)$。沿列方向拼接，增加列。 a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) # 横向拼接、拼接 1 轴（第二个轴，即列） np . concatenate (( a , b ), axis = 1 ) np . hstack (( a , b )) np . c_ [ a , b ] array([[0, 1, 0, 1], [2, 3, 2, 3], [4, 5, 4, 5], [6, 7, 6, 7], [8, 9, 8, 9]]) # column_stack hstack np.c_区别 a1 = np . arange ( 5 ) np . column_stack (( a1 , a1 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) np . hstack (( a1 , a1 )) array([0, 1, 2, 3, 4, 0, 1, 2, 3, 4]) np . c_ [ a1 , a1 ] array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]])","text_tokens":["即列","1","np","用于","沿列","9","已","区别","concatenate","于","相同","dstack","5","则","_","如果","vstack","0","给出","除了","二个","之外","水平","axis","是","a","指定","都","修改","其中","待","增加","(","垂直","类似","copy","第二","7","也","可以","这些","10","但是","tup","了","序列","hstack","b","4","按列","3","arange","a1","numpy","形状","column","、","将","一维","[","第二个","6","array","n","。","被","二维","拼接","a2"," ","（","横向","）","堆叠","连接","它们","对象","多个","...","c","=",",","]","$","：","沿","所有","的","其","沿着","#",".","deepcopy","存在","方法","行","轴","，","列","方向","reshape",")","8","2","stack","为","数组"],"title":"数组拼接","title_tokens":["拼接","数组"]},{"location":"numpy笔记/6.8.形状操纵.html#_2","text":"1. .split(ary, indices_or_sections, axis=0) ：用于沿着指定的轴拆分数组ary。 indices_or_sections指定了拆分点： 如果为整数N，则表示平均拆分成N份。如果不能平均拆分，则报错 如果为序列，则该序列指定了划分区间（无需指定最开始的0起点和终点）。如 [1,3] 指定了区间： [0,1],[1,3],[3:] 2. .array_split(ary, indices_or_sections, axis=0) ：作用与 .split() 类似。唯一的区别在于：当indices_or_sections为整数，且无法平均拆分时，并不报错，而是尽可能的维持平均拆分。 3. .dsplit(ary, indices_or_sections) ：沿第3轴将数组拆分为多个子数组。 4. .hsplit(ary, indices_or_sections) ：水平（按列）将一个数组拆分为多个子数组。 5. .vsplit(ary, indices_or_sections) ：垂直（行）将数组拆分为多个子数组。 a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) np . split ( a , 2 , axis = 0 ) [array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]]), array([[25, 26, 27, 28, 29], [30, 31, 32, 33, 34], [35, 36, 37, 38, 39], [40, 41, 42, 43, 44], [45, 46, 47, 48, 49]])] # [0,1) [1,3) [3:] np . split ( a ,[ 1 , 3 ], axis = 1 ) [array([[ 0], [ 5], [10], [15], [20], [25], [30], [35], [40], [45]]), array([[ 1, 2], [ 6, 7], [11, 12], [16, 17], [21, 22], [26, 27], [31, 32], [36, 37], [41, 42], [46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], [18, 19], [23, 24], [28, 29], [33, 34], [38, 39], [43, 44], [48, 49]])] np . array_split ( a , 2 , axis = 1 ) [array([[ 0, 1, 2], [ 5, 6, 7], [10, 11, 12], [15, 16, 17], [20, 21, 22], [25, 26, 27], [30, 31, 32], [35, 36, 37], [40, 41, 42], [45, 46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], [18, 19], [23, 24], [28, 29], [33, 34], [38, 39], [43, 44], [48, 49]])]","text_tokens":["sections",":","1","np","18","用于","46","时","且","9","区别","34","13","不","21","27","在于","整数","5","则","15","最","50","17","起点","20","47","_","可能","40","如果","37","尽可","作用","拆","35","0","29","or","水平","axis","16","a","指定","并","48","(","垂直","如","split","当","39","11","类似","区间","copy","hsplit","23","该","7","26","10","无需","唯一","了","序列","42","沿第","4","按列","3","arange","分成","子","份","28","43","36","24","49","将","19","[","6","尽可能","拆分","表示","和","array","31","n","点","12","30","无法","。","维持","报错","45"," ","dsplit","（","）","33","ary","开始","41","多个","平均","终点","=",",","而是","]","：","44","vsplit","的","25","沿着","#",".","deepcopy","14","38","indices","与","22","一个","行","32","轴","划分","，","分为","reshape",")","8","2","不能","为","数组"],"title":"数组拆分","title_tokens":["数组","拆分"]},{"location":"numpy笔记/6.9.ufunc函数.html","text":"import numpy as np np . set_printoptions ( threshold = 40 ) 四则运算 a = np . arange ( 1 , 6 ) # 表达式形式 a + a a - a a * a a / a # ufunc函数形式 np . add ( a , a ) np . subtract ( a , a ) np . multiply ( a , a ) np . true_divide ( a , a ) array([1., 1., 1., 1., 1.]) 比较运算 a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 表达式形式 a == b a != b a < b a <= b a > b a >= b # ufunc函数形式 np . equal ( a , b ) np . not_equal ( a , b ) np . less ( a , b ) np . less_equal ( a , b ) np . greater ( a , b ) np . greater_equal ( a , b ) array([[False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False]]) 逻辑运算 a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 与 np . logical_and ( a , b ) # 或 np . logical_or ( a , b ) # 非 np . logical_not ( a , b ) # 异或 np . logical_xor ( a , b ) # 任意一个元素 np . any ( a ) # 全部元素 np . all ( a ) False 位运算 a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) a & b a | b ~ a a ^ b # 按位与 np . bitwise_and ( a , b ) # 按位或 np . bitwise_or ( a , b ) # 按位取反 np . bitwise_not ( a ) # 按位异或 np . bitwise_xor ( a , b ) array([[10, 10, 14, 14, 10, 10, 22, 22, 26, 26], [30, 30, 26, 26, 22, 22, 10, 10, 14, 14]], dtype=int32) 自定义 ufunc 函数 可以通过 frompyfunc() 将计算单个元素的函数转换成ufunc函数。调用格式为如下： numpy . frompyfunc ( func , nin , nout ) # func：计算单个元素的函数 # nin：func的输入参数的个数 The number of input # nout：func返回值的个数 The number of output def my_add ( x , y ): z = x + y + 1 return z myufunc = np . frompyfunc ( my_add , 2 , 1 ) a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) myufunc ( a , b ) array([6, 8, 10, 12, 14], dtype=object) 也可以通过 vectorize() 函数来实现 frompyfunc() 的功能。 np . vectorize ( func , otypes = '' , doc = None , excluded = None ) 。 # func：计算单个元素的函数 # otypes：可以是一个表示结果数组元素类型的字符串，也可以是一个类型列表。如果使用类型列表，可以描述多个返回数组的元素类型 # doc：函数的描述字符串。若未给定，则使用func.__doc__ # excluded：指定func中哪些参数未被向量化。你可以指定一个字符串和整数的集合，其中字符串代表关键字参数，整数代表位置参数。 a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) def my_add ( x , num ): z = x + num return z myufunc = np . vectorize ( my_add , doc = \"每一个元素加上一个指定的数\" ) print ( myufunc . __doc__ ) myufunc ( a , 1 ) 每一个元素加上一个指定的数 array([1, 2, 3, 4, 5]) def my_add ( x , y , list_num ): z = x + y for i in list_num : z = z + i return z myufunc = np . vectorize ( my_add , excluded = [ 2 ]) myufunc ( a , b , [ 1 , 2 , 3 ]) # list_num 作为一个list，而不是向量化成一个个元素 array([11, 13, 15, 17, 19]) def my_add ( x , num ): z = x + num return z , z myufunc = np . vectorize ( my_add , otypes = [ np . float , int ]) myufunc ( a , 1 ) (array([1., 2., 3., 4., 5.]), array([1, 2, 3, 4, 5])) ufunc 对象的方法 ufunc函数对象本身还有一些方法。 这些方法只对于两个输入、一个输出的ufunc函数函数有效。对于其他的ufunc函数对象调用这些方法时，会抛出 ValueError 异常。 ufunc.reduce() ufunc.reduce 方法：类似于Python的 reduce 函数，它==沿着== axis 参数指定的轴，对数组进行操作。经过一次reduce，结果数组的维度降低一维。 假设 <op> 是一个ufunc函数， ufunc.reduce 用法如下： < op >. reduce ( array , axis = 0 , dtype = None ) a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . reduce ( a , axis = 1 ) # 沿着 列方向 array([ 6, 22, 38, 54, 70]) np . add . reduce ( a , axis = 0 ) # 沿着 行方向 array([40, 45, 50, 55]) 相当于将 运算符插入到沿着axis轴的所有元素之间： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) def fun ( a , b ): z = a + b + 1 return z fun2 = np . frompyfunc ( fun , 2 , 1 ) fun2 . reduce ( a , axis = 1 ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] array([9, 25, 41, 57, 73], dtype=object) ufunc.accumulate() ufunc.accumulate 方法：它类似于reduce()的计算过程，但是它会保存所有的中间计算结果，从而使得返回数组的形状和输入数组的形状相同： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . accumulate ( a , axis = 1 ) array([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38], [12, 25, 39, 54], [16, 33, 51, 70]], dtype=int32) ufunc.outer() ufunc.outer 方法：相当于将 运算符对输入数组A和输入数组B的每一对元素对(a,b)起作用。设A的shape=(4,5)，B的shape为(4,)，则结果数组的shape=(4,5,4) 一维数组和一维数组的outer操作为二维数组 a = np . arange ( 1 , 6 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array([[2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7], [5, 6, 7, 8], [6, 7, 8, 9]]) 多维数组的outer拆分成各自的一维操作 a = np . arange ( 1 , 7 ) . reshape ( 2 , 3 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array ([[[ 2 , 3 , 4 , 5 ], [ 3 , 4 , 5 , 6 ], [ 4 , 5 , 6 , 7 ]], [[ 5 , 6 , 7 , 8 ], [ 6 , 7 , 8 , 9 ], [ 7 , 8 , 9 , 10 ]]]) 数学函数 下面是一元的数学函数： abs/fabs ：计算整数、浮点数或者复数的绝对值。对于非复数值，可以使用更快的fabs sqrt ：计算平方根，相当于$a^{0.5}$ square ：计算平方，相当于$a^2$ exp ：计算指数$e^x$ log/log10/log2/log1p ：分别为$log_{e}(a), log_{10}(a), log_2(a), log_e(1+x)$ sign ：计算$sign(a)$ ceil ：计算各元素的ceiling值：大于等于该值的最小整数 floor ：计算个元素的floor值：小于等于该值的最大整数 rint ：将各元素四舍五入到最接近的整数，保留 dtype modf ：将数组的小数和整数部分以两个独立数组的形式返回 cos/cosh/sin/sinh/tan/tanh ：普通和双曲型三角函数 arccos/arcsosh/arcsin/arcsinh/arctan/arctanh :反三角函数 isnan ：返回一个布尔数组，该数组指示那些是 NaN isfinite/isinf ：返回一个布尔数组，该数组指示哪些是有限的/无限数","text_tokens":["1","18","~","最大","转换成",">","时","54","普通","对","相同","一对","0.5","从而","输入","关键字","该值","更快","自定","5","15","双曲","xor","50","20","函数","|","作用","0","取反","作为","or","非","a","指定","其中","无限","none","true","各自","tanh","表达","abs","你","四则","7","也","可以","26","and","每","b","小数","4","浮点","经过","分成","output","通过","valueerror","形状","sqrt","the","input","、","一维","<","6","它","logical","逻辑"," ","greater","33","相当","对象","多个","41","抛出","实现","列表","所有","一个个","过程","有效","化成","frompyfunc","25","#","otypes","个数","使用","import","方法","\"","22","一个","异常","i","非复","列","假设","方向","若","数学","独立","形式",":","以","arctan","9","all","rint","表达式","平方根","起","isnan","myufunc","达式","bitwise","set","比较","def","点数","51","_","型","55","两个","of","算符","axis","异或","16","object","插入","/","outer","到","python","modf","单个","大于","arcsin","excluded","四舍五入","但是","参数","给定","向量","浮点数","3","&","vectorize","fun2","numpy","当于","维度","将","19","元素","操作","逻辑运算","ufunc","来","被","fun","二维","运算符","降低","print","=","一些",",","集合","$","subtract","accumulate","任意","转换","cos","如下","三角函数","return","方根","e","__","保留","类型","数","nin","全部","进行","reshape","8","op","in","输出","floor","部分","关键","下面","printoptions","nan","+","返回","指示","isfinite","13","not","位置","一元","中","绝对值","之间","整数","dtype","则","reduce","17","复数","isinf","any","exp","40","如果","用法","拆","log2","其他","my","ceil","哪些","x","equal","字符串","未","log","{","y","73","会","等于","最小","绝对","该","这些","那些","log1p","还有","less","multiply","各","ceiling","自定义","threshold","*","func","个","小于","45","-","换成","shape","]","tan","arcsosh","格式","arcsinh","沿着",".","14","38","对于","与","本身","行","int32","，",")",".__","2","list","向","数组","np","使得","number","z","于","代表","而","27","调用","arctanh","最","false","它会","布尔","定义","!","sin","add","}","有限","中间","功能","只","'","位","三角","个个","70","是","设","加上","平方","(","square","结果","log10","39","11","类似","as","按位","保存","fabs","10","divide","指数","cosh","多维","arange","^","数值","四则运算","sinh","返回值","相当于","[","array","表示","和","num","值","12","30","。","运算","分别","接近","或","量化","57","：","arccos","int","doc","的","sign","计算结果","for","计算","nout","轴","一次","反","或者","字符","描述","float","为","不是"],"title":"6.9.ufunc函数","title_tokens":["ufunc",".","函数","6.9"]},{"location":"numpy笔记/6.9.ufunc函数.html#_1","text":"a = np . arange ( 1 , 6 ) # 表达式形式 a + a a - a a * a a / a # ufunc函数形式 np . add ( a , a ) np . subtract ( a , a ) np . multiply ( a , a ) np . true_divide ( a , a ) array([1., 1., 1., 1., 1.])","text_tokens":["1","np","=","divide",",","+","]","表达式","a","multiply","arange","subtract","*","达式","(","true","#",".","[","6","/","array","函数","ufunc","表达","_",")","add","形式"," ","-"],"title":"四则运算","title_tokens":["四则运算","四则","运算"]},{"location":"numpy笔记/6.9.ufunc函数.html#_2","text":"a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 表达式形式 a == b a != b a < b a <= b a > b a >= b # ufunc函数形式 np . equal ( a , b ) np . not_equal ( a , b ) np . less ( a , b ) np . less_equal ( a , b ) np . greater ( a , b ) np . greater_equal ( a , b ) array([[False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False]])","text_tokens":["np","10",">","=",",","b","less","equal","]","表达式","a","arange","not","达式","(","#",".","<","[","false","array","20","函数","ufunc","表达","_","30","reshape","!",")","2","形式"," ","greater"],"title":"比较运算","title_tokens":["比较","运算"]},{"location":"numpy笔记/6.9.ufunc函数.html#_3","text":"a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 与 np . logical_and ( a , b ) # 或 np . logical_or ( a , b ) # 非 np . logical_not ( a , b ) # 异或 np . logical_xor ( a , b ) # 任意一个元素 np . any ( a ) # 全部元素 np . all ( a ) False","text_tokens":["np","10","and","或","=","all","or",",","非","b","异或","a","arange","not","任意","(","#",".","xor","元素","与","false","any","20","一个","logical","_","全部","30","reshape",")","2"," "],"title":"逻辑运算","title_tokens":["逻辑","运算","逻辑运算"]},{"location":"numpy笔记/6.9.ufunc函数.html#_4","text":"a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) a & b a | b ~ a a ^ b # 按位与 np . bitwise_and ( a , b ) # 按位或 np . bitwise_or ( a , b ) # 按位取反 np . bitwise_not ( a ) # 按位异或 np . bitwise_xor ( a , b ) array([[10, 10, 14, 14, 10, 10, 22, 22, 26, 26], [30, 30, 26, 26, 22, 22, 10, 10, 14, 14]], dtype=int32)","text_tokens":["26","np","~","10","and","或","=","取反","or",",","b","异或","]","a","arange","&","not","^","bitwise","(","#",".","dtype","14","[","xor","与","array","20","22","int32","_","30","reshape",")","|","2","按位"," "],"title":"位运算","title_tokens":["位","运算"]},{"location":"numpy笔记/6.9.ufunc函数.html#ufunc","text":"可以通过 frompyfunc() 将计算单个元素的函数转换成ufunc函数。调用格式为如下： numpy . frompyfunc ( func , nin , nout ) # func：计算单个元素的函数 # nin：func的输入参数的个数 The number of input # nout：func返回值的个数 The number of output def my_add ( x , y ): z = x + y + 1 return z myufunc = np . frompyfunc ( my_add , 2 , 1 ) a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) myufunc ( a , b ) array([6, 8, 10, 12, 14], dtype=object) 也可以通过 vectorize() 函数来实现 frompyfunc() 的功能。 np . vectorize ( func , otypes = '' , doc = None , excluded = None ) 。 # func：计算单个元素的函数 # otypes：可以是一个表示结果数组元素类型的字符串，也可以是一个类型列表。如果使用类型列表，可以描述多个返回数组的元素类型 # doc：函数的描述字符串。若未给定，则使用func.__doc__ # excluded：指定func中哪些参数未被向量化。你可以指定一个字符串和整数的集合，其中字符串代表关键字参数，整数代表位置参数。 a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) def my_add ( x , num ): z = x + num return z myufunc = np . vectorize ( my_add , doc = \"每一个元素加上一个指定的数\" ) print ( myufunc . __doc__ ) myufunc ( a , 1 ) 每一个元素加上一个指定的数 array([1, 2, 3, 4, 5]) def my_add ( x , y , list_num ): z = x + y for i in list_num : z = z + i return z myufunc = np . vectorize ( my_add , excluded = [ 2 ]) myufunc ( a , b , [ 1 , 2 , 3 ]) # list_num 作为一个list，而不是向量化成一个个元素 array([11, 13, 15, 17, 19]) def my_add ( x , num ): z = x + num return z , z myufunc = np . vectorize ( my_add , otypes = [ np . float , int ]) myufunc ( a , 1 ) (array([1., 2., 3., 4., 5.]), array([1, 2, 3, 4, 5]))","text_tokens":[":","1","np","in","关键","number","转换成","z","+","返回","代表","13","位置","输入","myufunc","关键字","而","中","调用","整数","dtype","5","则","15","def","17","函数","_","如果","add","of","功能","作为","my","'","哪些","x","字符串","个个","是","a","object","指定","加上","其中","未","y","none","(","结果","11","单个","你","excluded","也","可以","10","参数","给定","向量","每","b","4","3","arange","vectorize","output","通过","func","numpy","返回值","the","input","将","19","[","元素","6","array","表示","和","num","ufunc","来","12","。","被"," ","换成","多个","print","=","实现","列表",",","量化","]","集合","：","int","一个个","转换","化成","frompyfunc","如下","格式","doc","的","return","#",".","otypes","__","个数","14","使用","类型","\"","数","for","一个","计算","nin","nout","i","，","若",")","8","字符","2","描述",".__","list","向","float","为","数组","不是"],"title":"自定义 ufunc 函数","title_tokens":["ufunc","自定","定义","自定义"," ","函数"]},{"location":"numpy笔记/6.9.ufunc函数.html#ufunc_1","text":"ufunc函数对象本身还有一些方法。 这些方法只对于两个输入、一个输出的ufunc函数函数有效。对于其他的ufunc函数对象调用这些方法时，会抛出 ValueError 异常。","text_tokens":["这些","对象","其他","只","时","抛出","还有","一些","有效","输入","valueerror","的","调用","、","对于","会","方法","本身","一个","函数","异常","ufunc","，","。","两个"," ","输出"],"title":"ufunc 对象的方法","title_tokens":["ufunc","的","对象","方法"," "]},{"location":"numpy笔记/6.9.ufunc函数.html#ufuncreduce","text":"ufunc.reduce 方法：类似于Python的 reduce 函数，它==沿着== axis 参数指定的轴，对数组进行操作。经过一次reduce，结果数组的维度降低一维。 假设 <op> 是一个ufunc函数， ufunc.reduce 用法如下： < op >. reduce ( array , axis = 0 , dtype = None ) a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . reduce ( a , axis = 1 ) # 沿着 列方向 array([ 6, 22, 38, 54, 70]) np . add . reduce ( a , axis = 0 ) # 沿着 行方向 array([40, 45, 50, 55]) 相当于将 运算符插入到沿着axis轴的所有元素之间： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) def fun ( a , b ): z = a + b + 1 return z fun2 = np . frompyfunc ( fun , 2 , 1 ) fun2 . reduce ( a , axis = 1 ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] array([9, 25, 41, 57, 73], dtype=object)","text_tokens":[":","1","np","18",">","9","z","+","于","54","对","13","之间","dtype","5","15","reduce","50","def","17","20","函数","40","55","add","用法","算符","0","axis","16","70","是","a","object","指定","none","(","插入","73","结果","11","到","python","类似","7","10","参数","b","4","3","经过","arange","fun2","当于","维度","相当于","将","19","一维","<","[","元素","6","它","操作","array","ufunc","12","。","fun","运算","运算符","45"," ","降低","相当","41","print","=",",","57","]","：","所有","frompyfunc","如下","的","return","25","沿着","#",".","14","38","方法","22","一个","行","轴","一次","，","列","进行","方向","假设","reshape",")","8","2","op","数组"],"title":"ufunc.reduce()","title_tokens":["ufunc","(",".",")","reduce"]},{"location":"numpy笔记/6.9.ufunc函数.html#ufuncaccumulate","text":"ufunc.accumulate 方法：它类似于reduce()的计算过程，但是它会保存所有的中间计算结果，从而使得返回数组的形状和输入数组的形状相同： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . accumulate ( a , axis = 1 ) array([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38], [12, 25, 39, 54], [16, 33, 51, 70]], dtype=int32)","text_tokens":["33","保存","1","使得","np","0","但是","10","中间","print","18","dtype","=","9",",","axis","16","]","于","返回","4","：","3","a","54","相同","arange","70","accumulate","所有","过程","从而","13","输入","形状","27","的","25","(","5",".","15","计算结果","14","38","19","reduce","[","结果","17","6","它","它会","方法","和","array","20","22","计算","int32","ufunc","39","11","51","，","12","reshape","类似",")","add","8","2"," ","数组","7"],"title":"ufunc.accumulate()","title_tokens":["ufunc","(",".",")","accumulate"]},{"location":"numpy笔记/6.9.ufunc函数.html#ufuncouter","text":"ufunc.outer 方法：相当于将 运算符对输入数组A和输入数组B的每一对元素对(a,b)起作用。设A的shape=(4,5)，B的shape为(4,)，则结果数组的shape=(4,5,4) 一维数组和一维数组的outer操作为二维数组 a = np . arange ( 1 , 6 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array([[2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7], [5, 6, 7, 8], [6, 7, 8, 9]]) 多维数组的outer拆分成各自的一维操作 a = np . arange ( 1 , 7 ) . reshape ( 2 , 3 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array ([[[ 2 , 3 , 4 , 5 ], [ 3 , 4 , 5 , 6 ], [ 4 , 5 , 6 , 7 ]], [[ 5 , 6 , 7 , 8 ], [ 6 , 7 , 8 , 9 ], [ 7 , 8 , 9 , 10 ]]])","text_tokens":["相当","7","1","np","shape","10","=","9","每",",","b","]","4","设","：","3","对","a","多维","一对","arange","起","分成","输入","的","(","5",".","当于","则","相当于","将","一维","[","结果","元素","6","操作","outer","和","方法","为","array","各自","ufunc","，","reshape","。",")","add","运算","二维","2","8","运算符","作用","拆"," ","数组","算符"],"title":"ufunc.outer()","title_tokens":["ufunc","(",".",")","outer"]},{"location":"numpy笔记/6.9.ufunc函数.html#_5","text":"下面是一元的数学函数： abs/fabs ：计算整数、浮点数或者复数的绝对值。对于非复数值，可以使用更快的fabs sqrt ：计算平方根，相当于$a^{0.5}$ square ：计算平方，相当于$a^2$ exp ：计算指数$e^x$ log/log10/log2/log1p ：分别为$log_{e}(a), log_{10}(a), log_2(a), log_e(1+x)$ sign ：计算$sign(a)$ ceil ：计算各元素的ceiling值：大于等于该值的最小整数 floor ：计算个元素的floor值：小于等于该值的最大整数 rint ：将各元素四舍五入到最接近的整数，保留 dtype modf ：将数组的小数和整数部分以两个独立数组的形式返回 cos/cosh/sin/sinh/tan/tanh ：普通和双曲型三角函数 arccos/arcsosh/arcsin/arcsinh/arctan/arctanh :反三角函数 isnan ：返回一个布尔数组，该数组指示那些是 NaN isfinite/isinf ：返回一个布尔数组，该数组指示哪些是有限的/无限数","text_tokens":[":","1","floor","最大","部分","以","下面","arctan","rint","nan","+","返回","指示","平方根","普通","0.5","isfinite","isnan","一元","该值","更快","绝对值","整数","dtype","arctanh","双曲","最","复数","isinf","布尔","函数","exp","点数","_","型","sin","}","两个","log2","有限","ceil","哪些","x","三角","是","a","log","平方","{","无限","(","square","log10","/","tanh","到","modf","abs","大于","等于","最小","绝对","arcsin","该","四舍五入","可以","fabs","10","那些","log1p","浮点数","指数","小数","cosh","浮点","各","ceiling","^","数值","sinh","sqrt","当于","、","相当于","将","元素","和","值","个","小于","。","分别"," ","相当","接近",",","$","：","arccos","tan","cos","arcsosh","三角函数","的","方根","arcsinh","e","sign","使用","对于","保留","数","一个","计算","，","反","非复","或者","数学",")","2","独立","形式","为","数组"],"title":"数学函数","title_tokens":["函数","数学"]},{"location":"pandas笔记/7.1.Series.html","text":"import pandas as pd from pandas import Series Series是能够保存任何类型的数据的一维数组。 Series类似numpy的一维ndarray，但是和ndarray又不同，ndarray的所有元素的类型或结构必须相同 1 ，而Series能保存不同类型、结构的数据；另外Series的元素带有索引。Series像一个有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中。 可以通过以下方式创建Series数据结构： 字典 一维NumPy数组 单个标量：数值标量、字符串 list、tuple（可以是多层嵌套的list、tuple） Series类 class pandas.Series(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False) 参数： data ： dict 、 array-like 、 list 、 scalar 。如果是序列或数组，则必须是一维的 如果是字典，则字典的键指定了 label 。如果同时使用了 index ，则以 index 为准。 如果是标量，则结果为：该标量扩充为 index 长度相同的列表。 index ：一个 array-like 或者一个 Index 对象。它指定了 label 。其值要求 hashable ，但不要求惟一，长度与 data 一致。如果未提供，则使用 RangeIndex (0, 1, 2, ..., n) 。 name ： str ， Series 的名字。 dtype ：指定数据类型。如果为 None ，则数据类型被自动推断 copy ：一个布尔值。如果为 True ，则拷贝输入数据 data 还可以通过类方法创建 Series ： Series.from_array(arr, index=None, name=None, dtype=None, copy=False, fastpath=False) 但 from_array 类方法会在未来的版本中被移除。 从 dict 来创建 如果只传入一个字典，则结果Series中的索引就是原字典的键： sdata = { 'Ohio' : 35000 , 'Texas' : 71000 , 'Oregon' : 16000 , 'Utah' : 5000 } # dict的key是无序的，但series的index是有序的 Series ( sdata ) Ohio 35000 Texas 71000 Oregon 16000 Utah 5000 dtype: int64 也可以指定原字典的key的排列顺序： 注意 如果传入dict和并指定index，index需要和dict的键匹配，若index不在dict的key中，对应的series值则为NaN。 sdata = { 'Ohio' : 35000 , 'Texas' : 71000 , 'Oregon' : 16000 , 'Utah' : 5000 } states = [ 'California' , 'Ohio' , 'Oregon' , 'Texas' ] Series ( sdata , index = states ) California NaN Ohio 35000.0 Oregon 16000.0 Texas 71000.0 dtype: float64 从NumPy数组来创建 数组必须是一维的： import numpy as np a = np . array ([ 1 , 2 , 3 ]) Series ( a ) 0 1 1 2 2 3 dtype: int32 从标量创建 如果提供索引，将重复标量值以匹配索引的长度。 Series ( 5 , index = [ 0 , 1 , 2 , 3 ]) 0 5 1 5 2 5 3 5 dtype: int64 实际上numpy可以定义储存不同类型数据的结构数组。 ↩","text_tokens":["要求","一致",":","1","np","布尔值","以","创建","index","nan","tuple","拷贝","同时","data","键","对应","相同","其值","方式","不","输入","而","name","中","数据类型","arr","dtype","则","推断","5","sdata","like","false","布尔","71000.0","函数","但","35000","16000.0","_","定义","如果","}","注意","移除","标量","还","值则","0","只","值以","提供","索引","未来","原","在","'","texas","rangeindex","版本","字符串","是","a","指定","并","未","series","{","none","(","true","结果","会","ndarray","带有","hashable","自动","str","类似","copy","单个","as","dict","utah","能够","该","pd","也","保存","可以","但是","能","参数","值到","from","了","重复","scalar","states","不同","序列","实际上","任何","扩充","ohio","3","就是","长度","通过","排列","数值","储存","numpy","另外","原本","许多","又","16000","、","将","一维","用","[","元素","它","实际","和","array","california","n","来","值","int64","。","被","结构","传入","需要","class","有序","；"," ","-","key","（","数据","映射","）","为准","名字","顺序","对象","float64","或","...","=","oregon","35000.0","列表",",","↩","]","：","惟一","5000","以下","所有","嵌套","fastpath","的","匹配","pandas","#",".","必须","使用","因为","import","类型","与","方法","一个","int32","多层","，","数据结构","像","或者","若",")","字典","字符","list","2","label","71000","从","为","类","数组","无序"],"title":"7.1.Series","title_tokens":[".","7.1","series"]},{"location":"pandas笔记/7.1.Series.html#series","text":"class pandas.Series(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False) 参数： data ： dict 、 array-like 、 list 、 scalar 。如果是序列或数组，则必须是一维的 如果是字典，则字典的键指定了 label 。如果同时使用了 index ，则以 index 为准。 如果是标量，则结果为：该标量扩充为 index 长度相同的列表。 index ：一个 array-like 或者一个 Index 对象。它指定了 label 。其值要求 hashable ，但不要求惟一，长度与 data 一致。如果未提供，则使用 RangeIndex (0, 1, 2, ..., n) 。 name ： str ， Series 的名字。 dtype ：指定数据类型。如果为 None ，则数据类型被自动推断 copy ：一个布尔值。如果为 True ，则拷贝输入数据 data 还可以通过类方法创建 Series ： Series.from_array(arr, index=None, name=None, dtype=None, copy=False, fastpath=False) 但 from_array 类方法会在未来的版本中被移除。","text_tokens":["要求","一致","1","布尔值","以","创建","index","拷贝","同时","data","键","相同","其值","输入","不","name","中","数据类型","arr","dtype","则","推断","like","false","布尔","但","_","如果","移除","标量","还","0","提供","未来","在","rangeindex","版本","是","指定","未","series","类","none","(","true","结果","会","hashable","自动","str","copy","dict","该","可以","参数","from","了","scalar","序列","扩充","长度","通过","、","一维","它","array","n","。","被","class"," ","-","数据","为准","名字","对象","或","...","=","列表",",","：","惟一","fastpath","的","pandas",".","必须","使用","与","类型","方法","一个","，","或者",")","字典","list","2","为","label","数组"],"title":"Series类","title_tokens":["类","series"]},{"location":"pandas笔记/7.1.Series.html#dict","text":"如果只传入一个字典，则结果Series中的索引就是原字典的键： sdata = { 'Ohio' : 35000 , 'Texas' : 71000 , 'Oregon' : 16000 , 'Utah' : 5000 } # dict的key是无序的，但series的index是有序的 Series ( sdata ) Ohio 35000 Texas 71000 Oregon 16000 Utah 5000 dtype: int64 也可以指定原字典的key的排列顺序： 注意 如果传入dict和并指定index，index需要和dict的键匹配，若index不在dict的key中，对应的series值则为NaN。 sdata = { 'Ohio' : 35000 , 'Texas' : 71000 , 'Oregon' : 16000 , 'Utah' : 5000 } states = [ 'California' , 'Ohio' , 'Oregon' , 'Texas' ] Series ( sdata , index = states ) California NaN Ohio 35000.0 Oregon 16000.0 Texas 71000.0 dtype: float64","text_tokens":["也",":","可以","值则","顺序","float64","只","=","oregon","索引","35000.0","原","在","'","texas",",","index","nan","states","]","键","：","ohio","是","对应","5000","指定","就是","排列","并","不","中","series","{","的","匹配","(","#","则","16000","dtype","sdata","[","结果","key","和","为","california","一个","但","35000","71000.0","16000.0","，","如果","int64","若","}","字典",")","。","dict","71000","传入","utah","需要","注意","有序"," ","无序"],"title":"从dict来创建","title_tokens":["dict","来","创建","从"]},{"location":"pandas笔记/7.1.Series.html#numpy","text":"数组必须是一维的： import numpy as np a = np . array ([ 1 , 2 , 3 ]) Series ( a ) 0 1 1 2 2 3 dtype: int32","text_tokens":[":","1","np","0","=",",","]","是","：","a","3","series","numpy","的","(","dtype",".","必须","一维","[","import","array","int32",")","2","as"," ","数组"],"title":"从NumPy数组来创建","title_tokens":["numpy","来","从","创建","数组"]},{"location":"pandas笔记/7.1.Series.html#_1","text":"如果提供索引，将重复标量值以匹配索引的长度。 Series ( 5 , index = [ 0 , 1 , 2 , 3 ]) 0 5 1 5 2 5 3 5 dtype: int64 实际上numpy可以定义储存不同类型数据的结构数组。 ↩","text_tokens":[":","可以","1","0","值以","提供","=","索引","重复","index",",","不同","实际上","↩","]","3","长度","储存","series","numpy","匹配","的","(","5","dtype","将","[","实际","类型","标量","，","定义","如果","int64","。",")","结构","2"," ","数组","数据"],"title":"从标量创建","title_tokens":["标量","创建","从"]},{"location":"pandas笔记/7.2.DataFrame.html","text":"from pandas import DataFrame from pandas import Series import numpy as np DataFrame类 DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型 1 （数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做是Series的容器。 pandas中的 DataFrame 可以使用以下构造函数创建 - pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) data ：数据可以是各种形式，如: ndarray ， series ， map ， lists ， dict ， constant 和另一个 DataFrame 。 index ：行标签。默认为 np.arrange(n) 。 columns ：列标签。默认为 np.arrange(n) 。 dtype ：数据类型。 copy ：是否复制数据。 可以输入给DataFrame构造器的数据： 类型 说明 二维ndarray 由数组、列表或元组组成的字典 每个序列作为DataFrame的一列。 所有序列的长度必须相同 。 NumPy的结构化/记录数组 类似于“由数组组成的字典” 由Series组成的字典 每个Series会成为一列。如果没有显式指定index，则 各Series的index会被合并成结果的行索引。 每个Series的长度不要求必须相同 ，DataFrame会以NaN填充。 由字典组成的字典 各内层字典会成为一列。键会被合并成结果的行索 弓丨，跟由“Series组成的字典”的情况一样 字典或Series的列表 各项将会成为DataFrame的一行。字典键或Series索引 的并集将会成为DataFrame的列标 由list或tuple组成的list 类似于“二维ndarray” 另—个DataFrame 该DataFrame的索引将会被沿用，除非显式指定了其他索引 NumPy 的 Masked Array 类似于“二维ndarray”的情况，只是掩码值在结果 DataFrame会变成NA/缺失值 总的来说，支持输入的数据类型是： dict 、 list 、 ndarray 、 DataFrame 。 从列表创建 可以使用 单个列表 或 列表内嵌列表 来创建DataFrame。 单个列表的例子： data = [ 1 , 2 , 3 , 4 , 5 ] DataFrame ( data ) 0 0 1 1 2 2 3 3 4 4 5 列表内嵌列表的例子： data = [[ 'Alex' , 10 ],[ 'Bob' , 12 ],[ 'Clarke' , 13 ]] DataFrame ( data , columns = [ 'Name' , 'Age' ]) Name Age 0 Alex 10 1 Bob 12 2 Clarke 13 从包含ndarrays/Lists的字典创建 传入一个由等长list或ndarray组成的字典： 结果DataFrame会自动加上索引（跟Series一样），且全部列 会被有序排列。 data = { 'state' : [ 'Ohio' , 'Ohio' , 'Ohio' , 'Nevada' , 'Nevada' ], 'year' : [ 2000 , 2001 , 2002 , 2001 , 2002 ], 'pop' : [ 1.5 , 1.7 , 3.6 , 2.4 , 2.9 ]} DataFrame ( data ) state year pop 0 Ohio 2000 1.5 1 Ohio 2001 1.7 2 Ohio 2002 3.6 3 Nevada 2001 2.4 4 Nevada 2002 2.9 如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列： DataFrame ( data , columns = [ 'year' , 'state' , 'pop' ]) year state pop 0 2000 Ohio 1.5 1 2001 Ohio 1.7 2 2002 Ohio 3.6 3 2001 Nevada 2.4 4 2002 Nevada 2.9 从字典列表创建 data = [{ 'a' : 1 , 'b' : 2 },{ 'a' : 5 , 'b' : 10 , 'c' : 20 }] DataFrame ( data , index = [ 'first' , 'second' ]) a b c first 1 2 NaN second 5 10 20.0 从Series的字典创建 d = { 'one' : Series ([ 1 , 2 , 3 ], index = [ 'a' , 'b' , 'c' ]), 'two' : Series ([ 1 , 2 , 3 , 4 ], index = [ 'a' , 'b' , 'c' , 'd' ])} df = DataFrame ( d ) df [[ \"two\" , \"two\" ]] two two a 1 1 b 2 2 c 3 3 d 4 4 替代构造函数 DataFrame.from_dict DataFrame.from_dict(data, orient=\"columns\", dtype=None, columns=None) DataFrame.from_dict 接受dict或类似数组的序列的dict并返回DataFrame。 DataFrame . from_dict ( dict ([( 'A' , [ 1 , 2 , 3 ]), ( 'B' , [ 4 , 5 , 6 ])])) DataFrame . from_dict ( dict ([( 'A' , [ 1 , 2 , 3 ]), ( 'B' , [ 4 , 5 , 6 ])]), orient = 'index' , columns = [ 'one' , 'two' , 'three' ]) one two three A 1 2 3 B 4 5 6 DataFrame.from_records DataFrame.from_records( data, index=None, exclude=None, columns=None, coerce_float=False, nrows=None, ) DataFrame.from_records 接受具有结构化dtype的元组或ndarray的列表。它与普通的 DataFrame 构造函数相似，除了所得的DataFrame索引可能是结构化dtype的特定字段。例如： data = np . array ([( 1 , 2. , b 'Hello' ), ( 2 , 3. , b 'World' )], dtype = [( 'A' , '<i4' ), ( 'B' , '<f4' ), ( 'C' , 'S10' )]) DataFrame . from_records ( data , index = 'C' ) A B C b'Hello' 1 2.0 b'World' 2 3.0 DataFrame.from_items DataFrame . from_items ( items , columns = None , orient = 'columns' ) # items ：为元组序列，元组格式为： ( key , value ) # 当 orient = 'index' 时必须传入（此时 key 指定的是行的 label ），且长度不能大于 DataFrame的列数 。 # 当 orient = ' columns时 ， key就是列的label ，此时 columns关键字参数指定的列label必须等于某个key ；否则抛出异常。 从元组序列中创建 DataFrame 。 实际上，DataFrame每一个值都可以是不同的数据类型。 ↩","text_tokens":["要求",":","1","np","布尔值","缺失","关键","exclude","由","每个","时","标签","成","且","一列","dataframe","元组","创建","index","nan","lists","tuple","丨","器","显式","于","返回","表格","data","组成","键","na","相同","one","复制","two","普通","看做","13","d","输入","不","关键字","name","masked","2000","中","构造函数","数据类型","总的来说","每列","掩码","dtype","则","除非","5","将会","含有","false","布尔","20","函数","2.0","某个","_","型","可能","说明","如果","包含","内嵌","}","等","构造","1.5","全部列","成为","其他","0","arrange","除了","3.0","作为","索引","2.4","在","'","—","例子","字符串","是","a","first","列标","指定","加上","都","结构化","并","2002","一组","字","series","{","none","(","如","alex","结果","/","只是","会","ndarray","state","items","自动","当","value","既有","类似","year","按照","copy","dict","as","单个","大于","hello","nrows","等于","该","也","可以","弓","10","填充","支持","一行","参数","from","沿用","默认","f4","各项","有列","了","容器","“","3.6","每","不同","序列","b","相似","列数","实际上","4","是否","3","给","columns","ohio","各","orient","records","就是","constant","长度","排列","会以","数值","world","numpy","行索","记录","2.9","、","特定","将","2001","[","<","nevada","6","它","实际","和","array","就","否则","age","n","来","值","pop","12","个","df","s10","。","被","结构","二维","集","传入","有序"," ","段","-","key","（","数据","；","）","接受","各种","clarke","顺序","或","c","键会","=","情况","抛出","一样","map","内层","列表",",","↩","]","具有","例如","：","20.0","替代","以下","所有","bob","另","所得","来说","长","格式","i4","的","pandas","1.7","#",".","使用","必须","coerce","与","import","类型","\"","three","一个","行","异常","没有","ndarrays","合并","，","变成","数据结构","列","全部","进行","second",")","字典","此时","字符","list","2","label","float","形式","跟","为","”","类","数组","从","不能"],"title":"7.2.DataFrame","title_tokens":["dataframe",".","7.2"]},{"location":"pandas笔记/7.2.DataFrame.html#dataframe","text":"DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型 1 （数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做是Series的容器。 pandas中的 DataFrame 可以使用以下构造函数创建 - pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) data ：数据可以是各种形式，如: ndarray ， series ， map ， lists ， dict ， constant 和另一个 DataFrame 。 index ：行标签。默认为 np.arrange(n) 。 columns ：列标签。默认为 np.arrange(n) 。 dtype ：数据类型。 copy ：是否复制数据。 可以输入给DataFrame构造器的数据： 类型 说明 二维ndarray 由数组、列表或元组组成的字典 每个序列作为DataFrame的一列。 所有序列的长度必须相同 。 NumPy的结构化/记录数组 类似于“由数组组成的字典” 由Series组成的字典 每个Series会成为一列。如果没有显式指定index，则 各Series的index会被合并成结果的行索引。 每个Series的长度不要求必须相同 ，DataFrame会以NaN填充。 由字典组成的字典 各内层字典会成为一列。键会被合并成结果的行索 弓丨，跟由“Series组成的字典”的情况一样 字典或Series的列表 各项将会成为DataFrame的一行。字典键或Series索引 的并集将会成为DataFrame的列标 由list或tuple组成的list 类似于“二维ndarray” 另—个DataFrame 该DataFrame的索引将会被沿用，除非显式指定了其他索引 NumPy 的 Masked Array 类似于“二维ndarray”的情况，只是掩码值在结果 DataFrame会变成NA/缺失值 总的来说，支持输入的数据类型是： dict 、 list 、 ndarray 、 DataFrame 。","text_tokens":["要求",":","1","np","布尔值","缺失","由","每个","标签","成","一列","dataframe","元组","创建","index","nan","lists","tuple","丨","器","显式","于","表格","data","组成","键","na","相同","复制","看做","输入","不","masked","中","构造函数","数据类型","总的来说","每列","掩码","dtype","则","除非","将会","含有","false","布尔","函数","型","说明","如果","等","构造","成为","其他","arrange","作为","索引","在","—","字符串","是","列标","指定","结构化","并","一组","series","none","(","如","结果","/","只是","会","ndarray","既有","类似","copy","dict","该","也","可以","弓","填充","支持","一行","沿用","默认","各项","有列","了","容器","“","不同","序列","是否","给","columns","各","constant","长度","会以","数值","numpy","行索","记录","、","将","它","和","array","n","值","个","。","被","结构","二维","集","有序"," ","-","（","数据","）","各种","或","键会","=","情况","一样","map","内层","列表",",","：","以下","所有","另","来说","的","pandas",".","使用","必须","类型","一个","行","没有","合并","，","变成","数据结构","列",")","字典","字符","list","形式","跟","为","”","数组"],"title":"DataFrame类","title_tokens":["dataframe","类"]},{"location":"pandas笔记/7.2.DataFrame.html#_1","text":"可以使用 单个列表 或 列表内嵌列表 来创建DataFrame。 单个列表的例子： data = [ 1 , 2 , 3 , 4 , 5 ] DataFrame ( data ) 0 0 1 1 2 2 3 3 4 4 5 列表内嵌列表的例子： data = [[ 'Alex' , 10 ],[ 'Bob' , 12 ],[ 'Clarke' , 13 ]] DataFrame ( data , columns = [ 'Name' , 'Age' ]) Name Age 0 Alex 10 1 Bob 12 2 Clarke 13","text_tokens":["可以","1","clarke","0","10","或","=","dataframe","创建","'","列表",",","例子","]","4","data","：","3","columns","bob","13","name","的","(","5","使用","[","alex","age","来","12","。","内嵌",")","单个","2"," "],"title":"从列表创建","title_tokens":["创建","列表","从"]},{"location":"pandas笔记/7.2.DataFrame.html#ndarrayslists","text":"传入一个由等长list或ndarray组成的字典： 结果DataFrame会自动加上索引（跟Series一样），且全部列 会被有序排列。 data = { 'state' : [ 'Ohio' , 'Ohio' , 'Ohio' , 'Nevada' , 'Nevada' ], 'year' : [ 2000 , 2001 , 2002 , 2001 , 2002 ], 'pop' : [ 1.5 , 1.7 , 3.6 , 2.4 , 2.9 ]} DataFrame ( data ) state year pop 0 Ohio 2000 1.5 1 Ohio 2001 1.7 2 Ohio 2002 3.6 3 Nevada 2001 2.4 4 Nevada 2002 2.9 如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列： DataFrame ( data , columns = [ 'year' , 'state' , 'pop' ]) year state pop 0 2000 Ohio 1.5 1 2001 Ohio 1.7 2 2002 Ohio 3.6 3 2001 Nevada 2.4 4 2002 Nevada 2.9","text_tokens":["全部列",":","1","顺序","0","由","或","且","=","索引","一样","dataframe","3.6","2.4","了","'",",","序列","]","4","组成","：","data","ohio","3","columns","指定","加上","排列","2002","长","2000","series","{","2.9","的","(","1.7","则","2001","[","结果","nevada","会","就","ndarray","state","自动","一个","pop","，","全部","列","进行","如果","。","被","字典","year","}","list","等","传入",")","2","按照","跟","有序"," ","（","1.5","）"],"title":"从包含ndarrays/Lists的字典创建","title_tokens":["ndarrays","的","包含","字典","/","从","创建","lists"]},{"location":"pandas笔记/7.2.DataFrame.html#_2","text":"data = [{ 'a' : 1 , 'b' : 2 },{ 'a' : 5 , 'b' : 10 , 'c' : 20 }] DataFrame ( data , index = [ 'first' , 'second' ]) a b c first 1 2 NaN second 5 10 20.0","text_tokens":[":","1","10","c","=","dataframe","'","index",",","nan","b","]","data","a","first","20.0","{","(","5","[","20","second","}",")","2"," "],"title":"从字典列表创建","title_tokens":["创建","列表","字典","从"]},{"location":"pandas笔记/7.2.DataFrame.html#series","text":"d = { 'one' : Series ([ 1 , 2 , 3 ], index = [ 'a' , 'b' , 'c' ]), 'two' : Series ([ 1 , 2 , 3 , 4 ], index = [ 'a' , 'b' , 'c' , 'd' ])} df = DataFrame ( d ) df [[ \"two\" , \"two\" ]] two two a 1 1 b 2 2 c 3 3 d 4 4","text_tokens":[":","1","c","=","dataframe","index","'",",","b","]","4","3","one","a","two","d","series","{","(","[","\"","df",")","}","2"," "],"title":"从Series的字典创建","title_tokens":["的","字典","从","创建","series"]},{"location":"pandas笔记/7.2.DataFrame.html#_3","text":"","text_tokens":[],"title":"替代构造函数","title_tokens":["函数","构造","替代","构造函数"]},{"location":"pandas笔记/7.2.DataFrame.html#dataframefrom_dict","text":"DataFrame.from_dict(data, orient=\"columns\", dtype=None, columns=None) DataFrame.from_dict 接受dict或类似数组的序列的dict并返回DataFrame。 DataFrame . from_dict ( dict ([( 'A' , [ 1 , 2 , 3 ]), ( 'B' , [ 4 , 5 , 6 ])])) DataFrame . from_dict ( dict ([( 'A' , [ 1 , 2 , 3 ]), ( 'B' , [ 4 , 5 , 6 ])]), orient = 'index' , columns = [ 'one' , 'two' , 'three' ]) one two three A 1 2 3 B 4 5 6","text_tokens":["接受","1","或","from","=","dataframe","'","index",",","序列","b","]","返回","4","data","orient","a","columns","3","one","two","并","none","的","(","dtype",".","5","[","6","\"","three","_","类似",")","。","dict","2"," ","数组"],"title":"DataFrame.from_dict","title_tokens":["_",".","from","dict","dataframe"]},{"location":"pandas笔记/7.2.DataFrame.html#dataframefrom_records","text":"DataFrame.from_records( data, index=None, exclude=None, columns=None, coerce_float=False, nrows=None, ) DataFrame.from_records 接受具有结构化dtype的元组或ndarray的列表。它与普通的 DataFrame 构造函数相似，除了所得的DataFrame索引可能是结构化dtype的特定字段。例如： data = np . array ([( 1 , 2. , b 'Hello' ), ( 2 , 3. , b 'World' )], dtype = [( 'A' , '<i4' ), ( 'B' , '<f4' ), ( 'C' , 'S10' )]) DataFrame . from_records ( data , index = 'C' ) A B C b'Hello' 1 2.0 b'World' 2 3.0","text_tokens":["接受","1","np","exclude","或","from","除了","c","f4","=","3.0","索引","dataframe","元组","index","列表",",","相似","b","'","具有","]","例如","data","是","普通","：","columns","records","3","a","结构化","所得","字","构造函数","hello","world","i4","none","的","(","dtype",".","特定","[","<","coerce","它","false","与","ndarray","array","函数","2.0","s10","_","，","可能","。",")","结构","2","float","段"," ","nrows","构造"],"title":"DataFrame.from_records","title_tokens":["_",".","records","from","dataframe"]},{"location":"pandas笔记/7.2.DataFrame.html#dataframefrom_items","text":"DataFrame . from_items ( items , columns = None , orient = 'columns' ) # items ：为元组序列，元组格式为： ( key , value ) # 当 orient = 'index' 时必须传入（此时 key 指定的是行的 label ），且长度不能大于 DataFrame的列数 。 # 当 orient = ' columns时 ， key就是列的label ，此时 columns关键字参数指定的列label必须等于某个key ；否则抛出异常。 从元组序列中创建 DataFrame 。 实际上，DataFrame每一个值都可以是不同的数据类型。 ↩","text_tokens":["可以","关键","参数","from","时","且","=","抛出","dataframe","每","元组","创建","'","index",",","序列","实际上","不同","↩","列数","数据","：","orient","是","columns","指定","就是","都","长度","关键字","格式","中","等于","数据类型","none","的","(","#",".","必须","key","实际","类型","items","行","否则","异常","当","一个","value","值"," ","_","，","此时","列","某个","。",")","传入","大于","不能","；","为","从","label","（","）"],"title":"DataFrame.from_items","title_tokens":["_",".","from","dataframe","items"]},{"location":"开发环境管理/5.1.conda笔记.html","text":"conda usage : conda - script . py [ - h ] [ - V ] command ... conda is a tool for managing and deploying applications , environments and packages . Options : positional arguments : command clean 删除未使用的包和缓存 。 config 修改 . condarc中的配置值 。 create Create a new conda environment from a list of specified packages . help Displays a list of available conda commands and their help strings . info 显示有关当前安装的conda的信息 。 init Initialize conda for shell interaction . [ Experimental ] install 把一个列表中包含的包安装到指定的conda环境 。 list 列出链接到某个conda环境的所有包名 。 remove 从指定的conda环境移除列表中包含的包 。 uninstall conda remove的别名 。 run 在 conda 环境中运行可执行文件 。 [ 实验 ] search Search for packages and display associated information . The input is a MatchSpec , a query language for conda packages . See examples below . update 将 conda 包更新为最新的兼容版本 。 upgrade conda update的别名 optional arguments : - h , -- help Show this help message and exit . - V , -- version Show the conda version number and exit . conda命令 conda info 该命令可以查看当前安装的 conda 的详细信息，包括 conda 版本、python 版本、软件包仓库地址、新建环境的存放路径等。 usage: conda-script.py info [ -h ] [ --json ] [ -v ] [ -q ] [ -a ] [ --base ] [ -e ] [ -s ] [ --unsafe-channels ] Display information about current conda install. Options: optional arguments: -h, --help Show this help message and exit. -a, --all 显示所有信息。 --base 基本显示 base 环境路径。 -e, --envs 列出所有已知的Conda环境。 -s, --system 列出环境变量。 --unsafe-channels Display list of channels with tokens exposed. Output, Prompt, and Flow Control Options: --json Report all output as json. Suitable for using conda programmatically. -v, --verbose Use once for info, twice for debug, three times for trace. -q, --quiet Do not display progress bar. conda create usage: conda-script.py create [ -h ] [ --clone ENV ] [ -n ENVIRONMENT | -p PATH ] [ -c CHANNEL ] [ --use-local ] [ --override-channels ] [ --repodata-fn REPODATA_FNS ] [ --strict-channel-priority ] [ --no-channel-priority ] [ --no-deps | --only-deps ] [ --no-pin ] [ --copy ] [ --no-shortcuts ] [ -C ] [ -k ] [ --offline ] [ -d ] [ --json ] [ -q ] [ -v ] [ -y ] [ --download-only ] [ --show-channel-urls ] [ --file FILE ] [ --no-default-packages ] [ --dev ] [ package_spec [ package_spec ... ]] Create a new conda environment from a list of specified packages. To use the created environment, use 'source activate envname' look in that directory first. This command requires either the -n NAME or -p PREFIX option. Options: positional arguments: package_spec Packages to install or update in the conda environment. optional arguments: -h, --help Show this help message and exit. --clone ENV 通过克隆其他环境来创建一个新环境， 'ENV' 可以是现有本地环境的路径（或名 称）。 --file FILE 从文件创建环境 ( 从给定的文件读入指定版本的包 ) 。可以传递重复的文件规范（例 如--file = file1 --file = file2）。 --dev Use ` sys.executable -m conda ` in wrapper scripts instead of CONDA_EXE This is mainly for use during tests where we test new conda source against old Python versions. Target Environment Specification: -n ENVIRONMENT, --name ENVIRONMENT Name of environment. -p PATH, --prefix PATH Full path to environment location ( i.e. prefix ) . Channel Customization: -c CHANNEL, --channel CHANNEL 用于搜索包的其他通道。这些 URL 按给定顺序搜索 ( 包括本地目录file:// ) 。然 后,搜索 .condarc 中的默认值或通道 ( 除非提供 --override-channels ) 。 您可以使用 \"defaults\" 获取 conda 的默认包。您还可以使用任何名称, .condarc的channel_alias值将预置。默认的channel_alias是 http://conda.anaconda.org/。 --use-local 使用本地构建的包。等同于 \"-c local\" 。 --override-channels 不在 default 或者 .condarc channels 中搜索. Requires --channel. --repodata-fn REPODATA_FNS Specify name of repodata on remote server. Conda will try whatever you specify, but will ultimately fall back to repodata.json if your specs are not satisfiable with what you specify here. This is used to employ repodata that is reduced in time scope. You may pass this flagmore than once. Leftmost entries are tried first, and the fallback torepodata.json is added for you automatically. Solver Mode Modifiers: --strict-channel-priority Packages in lower priority channels are not considered if a package with the same name appears in a higher priority channel. --no-channel-priority Package version takes precedence over channel priority. Overrides the value given by ` conda config --show channel_priority ` . --no-deps Do not install, update, remove, or change dependencies. This WILL lead to broken environments and inconsistent behavior. Use at your own risk. --only-deps Only install dependencies. --no-pin Ignore pinned file. --no-default-packages Ignore create_default_packages in the .condarc file. Package Linking and Install-time Options: --copy Install all packages using copies instead of hard- or soft-linking. --no-shortcuts Don 't install start menu shortcuts Networking Options: -C, --use-index-cache Use cache of channel index files, even if it has expired. -k, --insecure Allow conda to perform \"insecure\" SSL connections and transfers. Equivalent to setting ' ssl_verify ' to ' false '. --offline Offline mode. Don' t connect to the Internet. Output, Prompt, and Flow Control Options: -d, --dry-run Only display what would have been done . --json Report all output as json. Suitable for using conda programmatically. -q, --quiet Do not display progress bar. -v, --verbose Can be used multiple times. Once for INFO, twice for DEBUG, three times for TRACE. -y, --yes Do not ask for confirmation. --download-only Solve an environment and ensure package caches are populated, but exit prior to unlinking and linking packages into the prefix. --show-channel-urls Show channel urls. Overrides the value given by ` conda config --show show_channel_urls ` . conda常用命令 查看信息 # 查看conda的信息 ## 该命令可以查看当前安装的 conda 的详细信息，包括 conda 版本、python 版本、软件包仓库地址、新建环境的存放路径等。 conda info # 查看conda版本信息 conda -V conda --version 环境管理 # 查看环境信息 ## 查看系统中安装的所有环境： ### 这两个命令都可以查看当前 conda 中已经创建的环境列表，处于激活状态的环境旁边会有一个*的字样。 conda env list conda info –-envs conda info -e ## 查看 Conda 环境系统信息： conda info –-system conda info –s ## 查看环境系统更加详细的信息： conda info –-all conda info –a # 进入指定环境 conda activate <env> # 推出环境 conda deactivate # 导出环境 ## 导出环境之前首先要进入该环境 conda list -e > package-list.txt conda list -e > package-list.yml ## 或者这样 ### 这会将当前环境中由 conda 管理的包和由 pip 安装的包同时导出到文件中，所以当根据文件创建环境时，无需重新安装 pip 的包。 conda env export –-name base –-file base_bunnies.yml # 创建环境 ## 新建一个名为 newenv 的环境，并指定新环境中的 python 版本为 3.6 创建出来的环境中只带有最基本的包 conda create --name newenv python = 3 .6 ## 也可以在创建环境时候，包含某些程序或者包 conda create --name newenv python = 3 .6 biopython ipython ## 通过克隆创建一个新环境 conda create –-name newenv –clone base ## 从文件创建环境 ### 如果是用 conda env export --name 导出的文件，则可用下列命令创建： conda env create -f package-list.yml ### 如果是用 conda list -e 导出的文件，则用如下方式创建： conda create –-name <env> –-file <deps file> # 更新环境 conda env update –-name <env> –file = <deps file> # 删除环境 ## 删除环境中指定的包： conda remove –-name <env> ipython biopython ## 彻底删除环境： conda env remove –name <env> 从指定路径安装环境 conda 创建出来的环境默认放在 /User/<yourname>/anaconda/env 目录下，你可以将其中的某个环境文件夹整体拷贝走，复制到另一台机器上，然后基于此文件夹创建环境。 包管理 conda list # 查看已经安装的包 conda update conda # 升级conda自身 conda search requests # 查询某个包 conda install requests # 安装新包 conda install -n base requests # 将包安装到指定环境 conda update --all # 更新所有包 conda update requests # 升级包 conda remove requests # 移除包 conda remove -n base requests # 从指定环境中移除包 conda 不提供检查可更新的包的命令，update 所有包时会有提示，列出所有可更新的包，并让用户确认是否全部更新。 为 anaconda 指定国内镜像源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes 使用 conda config --show channels 命令可以查看当前的源仓库地址。","text_tokens":["用户","twice","env","由","k","导出","version",">","时","verify","usage","file2","查看","priority","broken","index","clean","有关","同时","配置","拷贝","system","bunnies","进入","兼容","times","name","新","torepodata","considered","fn","environment","menu","unlinking","已经","cn","dry","包含","|","envs","称","pass","环境变","lead","复制到","flagmore","搜索","还","安装","arguments","exit","在","or","free","path","no","详细信息","requires","time","彻底","a","this","指定","by","options","其中","unsafe","fallback","tried","channel","files","获取","当","config","customization","cache","基于","copy","你","is","仓库","pinned","也","可以","tokens","and","把","无需","默认","f","where","test","是否","done","message","output","通过","新安","传递","fall","或名","the","input","、","mode","<","用","6","这会","may","程序","conda","别名","本地","optional","against","what","connections","v","see","此"," ","added","名为","包","query","后","precedence","try","c","激活","specified","remove","programmatically","列表","更加","look","help","positional","an","strings","所有","equivalent","it","#","使用","\"","旁边","一个","solve","i","repodata","their","offline","从","init",":","info","overrides","等同","###","行文","all","查询","will","让","executable","own","deps","yourname","scope","can","文件夹","set","full","最新","display","modifiers","new","读入","source","leftmost","sys","已知","_","environments","放在","but","soft","这样","两个","等同于","given","of","either","download","软件包","that","available","been","remote","可执行文件","command","current","base","over","现有","修改","edu","状态","directory","managing","location","您","按","/","even","带有","可用","到","python","可","at","某些","链接","exe","if","do","pkgs","during","提示","user","地址","确认","from","fns","anaconda","给定","back","删除","任何","specify","employ","重新安装","3","目录","显示","pip","包名","packages","old","同于","处于","基本","将","below","缓存","scripts","之前","来","dependencies","uninstall","整体","ssl","ignore","mainly","than","存放","出来","we","to","appears","...","=","bar","org",",","progress","multiple","如下","behavior","所以","file","e","be","only","全部","时会","upgrade","tests","执行","升级包","deploying","in","report","ultimately","tool","channels","激活状态","inconsistent","然后","not","d","export","networking","中","takes","url","文件创建","h","option","除非","则","pin","with","自身","系统","某个","如果","expired","等","trace","另一台","search","initialize","same","deactivate","其他","yes","into","flow","clone","caches","shortcuts","环境变量","use","install","路径","并","未","预置","y","上","prefix","p","实验","会","strict","server","环境","experimental","override","script","一台","higher","该","这些","json","confirmation","package","镜像","机器","当前","默认值","transfers","update","*","commands","file1","associated","详细","defaults","connect","interaction","n","shell","matchspec","更新","language","condarc","-","然","about","once","版本信息","例","reduced","has","satisfiable","main","]","applications","检查","软件","urls","displays","时候","–","ensure",".","tsinghua","，","yml","local",")","这","list","下","常用","examples","number","perform","克隆","用于","下列","通道","suitable","创建","信息","change","s","复制","show","方式","不","specs","envname","源","件夹","最","false","根据","新建","名称","populated","add","requests","走","移除","default","have","run","顺序搜索","tuna","只","activate","提供","q","命令","环境中运行","'","linking","`","版本","start","m","you","是","first","spec","created","specification","重新","都","管理","instead","(","如","wrapper","on","internet","using","ask","allow","value","hard","exposed","as","prior","your","升级","lower","used","information","setting","字样","https","首先","prompt","3.6","重复","copies","要","quiet","target","alias","whatever","推出","entries","http","列出","txt","create","[","solver","和","versions","包括","值","would","ipython","。","biopython","automatically","dev","（","）","verbose","mirrors","顺序","here","t","或","常用命令","don","构建","文件","：","国内","规范","insecure","的","运行","debug","##","control","three","for","py","are","新包","newenv","有","或者","risk","变量","为"],"title":"5.1.conda笔记","title_tokens":[".","conda","5.1","笔记"]},{"location":"开发环境管理/5.1.conda笔记.html#conda","text":"usage : conda - script . py [ - h ] [ - V ] command ... conda is a tool for managing and deploying applications , environments and packages . Options : positional arguments : command clean 删除未使用的包和缓存 。 config 修改 . condarc中的配置值 。 create Create a new conda environment from a list of specified packages . help Displays a list of available conda commands and their help strings . info 显示有关当前安装的conda的信息 。 init Initialize conda for shell interaction . [ Experimental ] install 把一个列表中包含的包安装到指定的conda环境 。 list 列出链接到某个conda环境的所有包名 。 remove 从指定的conda环境移除列表中包含的包 。 uninstall conda remove的别名 。 run 在 conda 环境中运行可执行文件 。 [ 实验 ] search Search for packages and display associated information . The input is a MatchSpec , a query language for conda packages . See examples below . update 将 conda 包更新为最新的兼容版本 。 upgrade conda update的别名 optional arguments : - h , -- help Show this help message and exit . - V , -- version Show the conda version number and exit .","text_tokens":[":","info","examples","number","tool","version","usage","行文","信息","clean","有关","配置","兼容","show","中","最新","h","display","new","environment","某个","environments","包含","search","initialize","移除","of","run","安装","available","arguments","exit","在","环境中运行","版本","可执行文件","command","a","this","install","指定","options","修改","未","managing","实验","config","环境","到","experimental","链接","script","is","information","and","把","from","删除","当前","message","显示","包名","update","packages","列出","commands","associated","the","input","create","将","[","below","缓存","和","interaction","conda","shell","matchspec","值","别名","更新","uninstall","optional","。","language","v","see","condarc"," ","-","包","query","...","specified","remove","列表",",","]","applications","文件","help","positional","strings","所有","displays","的","运行",".","使用","for","py","一个","upgrade","执行","their","list","从","为","deploying","init"],"title":"conda","title_tokens":["conda"]},{"location":"开发环境管理/5.1.conda笔记.html#conda_1","text":"","text_tokens":[],"title":"conda命令","title_tokens":["命令","conda"]},{"location":"开发环境管理/5.1.conda笔记.html#conda-info","text":"该命令可以查看当前安装的 conda 的详细信息，包括 conda 版本、python 版本、软件包仓库地址、新建环境的存放路径等。 usage: conda-script.py info [ -h ] [ --json ] [ -v ] [ -q ] [ -a ] [ --base ] [ -e ] [ -s ] [ --unsafe-channels ] Display information about current conda install. Options: optional arguments: -h, --help Show this help message and exit. -a, --all 显示所有信息。 --base 基本显示 base 环境路径。 -e, --envs 列出所有已知的Conda环境。 -s, --system 列出环境变量。 --unsafe-channels Display list of channels with tokens exposed. Output, Prompt, and Flow Control Options: --json Report all output as json. Suitable for using conda programmatically. -v, --verbose Use once for info, twice for debug, three times for trace. -q, --quiet Do not display progress bar.","text_tokens":[":","info","twice","usage","all","channels","查看","suitable","信息","s","system","times","show","not","h","display","with","已知","新建","envs","等","trace","环境变","of","软件包","安装","arguments","q","exit","flow","命令","版本","环境变量","current","详细信息","base","use","a","this","install","路径","options","unsafe","using","环境","python","exposed","as","script","do","仓库","该","information","可以","tokens","and","地址","prompt","json","quiet","当前","message","显示","output","列出","基本","、","详细","[","conda","包括","optional","。","v","存放"," ","-","about","verbose","once","bar","programmatically",",","progress","]","help","软件","所有","的","e",".","debug","control","three","for","py","，","list","变量","report"],"title":"conda info","title_tokens":[" ","info","conda"]},{"location":"开发环境管理/5.1.conda笔记.html#conda-create","text":"usage: conda-script.py create [ -h ] [ --clone ENV ] [ -n ENVIRONMENT | -p PATH ] [ -c CHANNEL ] [ --use-local ] [ --override-channels ] [ --repodata-fn REPODATA_FNS ] [ --strict-channel-priority ] [ --no-channel-priority ] [ --no-deps | --only-deps ] [ --no-pin ] [ --copy ] [ --no-shortcuts ] [ -C ] [ -k ] [ --offline ] [ -d ] [ --json ] [ -q ] [ -v ] [ -y ] [ --download-only ] [ --show-channel-urls ] [ --file FILE ] [ --no-default-packages ] [ --dev ] [ package_spec [ package_spec ... ]] Create a new conda environment from a list of specified packages. To use the created environment, use 'source activate envname' look in that directory first. This command requires either the -n NAME or -p PREFIX option. Options: positional arguments: package_spec Packages to install or update in the conda environment. optional arguments: -h, --help Show this help message and exit. --clone ENV 通过克隆其他环境来创建一个新环境， 'ENV' 可以是现有本地环境的路径（或名 称）。 --file FILE 从文件创建环境 ( 从给定的文件读入指定版本的包 ) 。可以传递重复的文件规范（例 如--file = file1 --file = file2）。 --dev Use ` sys.executable -m conda ` in wrapper scripts instead of CONDA_EXE This is mainly for use during tests where we test new conda source against old Python versions. Target Environment Specification: -n ENVIRONMENT, --name ENVIRONMENT Name of environment. -p PATH, --prefix PATH Full path to environment location ( i.e. prefix ) . Channel Customization: -c CHANNEL, --channel CHANNEL 用于搜索包的其他通道。这些 URL 按给定顺序搜索 ( 包括本地目录file:// ) 。然 后,搜索 .condarc 中的默认值或通道 ( 除非提供 --override-channels ) 。 您可以使用 \"defaults\" 获取 conda 的默认包。您还可以使用任何名称, .condarc的channel_alias值将预置。默认的channel_alias是 http://conda.anaconda.org/。 --use-local 使用本地构建的包。等同于 \"-c local\" 。 --override-channels 不在 default 或者 .condarc channels 中搜索. Requires --channel. --repodata-fn REPODATA_FNS Specify name of repodata on remote server. Conda will try whatever you specify, but will ultimately fall back to repodata.json if your specs are not satisfiable with what you specify here. This is used to employ repodata that is reduced in time scope. You may pass this flagmore than once. Leftmost entries are tried first, and the fallback torepodata.json is added for you automatically. Solver Mode Modifiers: --strict-channel-priority Packages in lower priority channels are not considered if a package with the same name appears in a higher priority channel. --no-channel-priority Package version takes precedence over channel priority. Overrides the value given by ` conda config --show channel_priority ` . --no-deps Do not install, update, remove, or change dependencies. This WILL lead to broken environments and inconsistent behavior. Use at your own risk. --only-deps Only install dependencies. --no-pin Ignore pinned file. --no-default-packages Ignore create_default_packages in the .condarc file. Package Linking and Install-time Options: --copy Install all packages using copies instead of hard- or soft-linking. --no-shortcuts Don 't install start menu shortcuts Networking Options: -C, --use-index-cache Use cache of channel index files, even if it has expired. -k, --insecure Allow conda to perform \"insecure\" SSL connections and transfers. Equivalent to setting ' ssl_verify ' to ' false '. --offline Offline mode. Don' t connect to the Internet. Output, Prompt, and Flow Control Options: -d, --dry-run Only display what would have been done . --json Report all output as json. Suitable for using conda programmatically. -q, --quiet Do not display progress bar. -v, --verbose Can be used multiple times. Once for INFO, twice for DEBUG, three times for TRACE. -y, --yes Do not ask for confirmation. --download-only Solve an environment and ensure package caches are populated, but exit prior to unlinking and linking packages into the prefix. --show-channel-urls Show channel urls. Overrides the value given by ` conda config --show show_channel_urls ` .","text_tokens":["twice","env","k","version","verify","usage","file2","priority","broken","index","times","name","新","torepodata","considered","fn","environment","menu","unlinking","dry","|","称","pass","lead","flagmore","搜索","还","arguments","exit","在","or","path","no","requires","time","a","this","指定","by","options","fallback","tried","channel","files","获取","config","customization","cache","copy","is","pinned","可以","and","默认","where","test","done","message","output","通过","传递","fall","或名","the","mode","may","conda","本地","optional","against","what","connections","v"," ","added","包","后","precedence","try","c","specified","remove","programmatically","look","help","positional","an","equivalent","it","使用","\"","一个","solve","i","repodata","offline","从",":","overrides","info","等同","all","will","executable","own","deps","scope","can","full","display","modifiers","new","读入","source","leftmost","sys","_","environments","but","soft","等同于","given","of","either","download","that","been","remote","command","over","现有","directory","location","您","按","/","even","python","at","exe","if","do","during","fns","from","anaconda","给定","back","任何","specify","employ","目录","packages","old","同于","将","scripts","来","dependencies","ssl","ignore","mainly","than","we","to","appears","...","=","bar","org",",","progress","multiple","behavior","file","e","be","only","tests","in","report","ultimately","channels","inconsistent","not","d","networking","中","takes","url","文件创建","h","option","除非","pin","with","expired","trace","same","其他","yes","into","flow","clone","caches","shortcuts","use","install","路径","预置","y","prefix","p","strict","server","环境","override","script","higher","这些","json","confirmation","package","默认值","transfers","update","file1","defaults","connect","n","condarc","-","然","once","例","reduced","has","satisfiable","]","urls","ensure",".","，","local",")","list","perform","克隆","用于","通道","创建","suitable","change","show","不","specs","envname","false","名称","populated","default","have","run","顺序搜索","activate","提供","q","'","linking","start","`","版本","m","you","是","first","spec","created","specification","instead","(","如","wrapper","on","internet","using","ask","allow","value","hard","as","prior","your","lower","used","setting","prompt","重复","copies","quiet","target","alias","whatever","entries","http","create","[","solver","versions","包括","值","would","。","automatically","dev","（","）","verbose","顺序","here","t","或","don","构建","文件","规范","insecure","的","debug","control","three","for","py","are","或者","risk"],"title":"conda create","title_tokens":[" ","conda","create"]},{"location":"开发环境管理/5.1.conda笔记.html#conda_2","text":"","text_tokens":[],"title":"conda常用命令","title_tokens":["常用","命令","conda","常用命令"]},{"location":"开发环境管理/5.1.conda笔记.html#_1","text":"# 查看conda的信息 ## 该命令可以查看当前安装的 conda 的详细信息，包括 conda 版本、python 版本、软件包仓库地址、新建环境的存放路径等。 conda info # 查看conda版本信息 conda -V conda --version","text_tokens":["软件包","可以","info","地址","安装","版本信息","version","命令","查看","信息","版本","当前","详细信息","软件","路径","的","#","、","详细","##","conda","包括","环境","，","新建","python","。","等","v","存放"," ","仓库","-","该"],"title":"查看信息","title_tokens":["信息","查看"]},{"location":"开发环境管理/5.1.conda笔记.html#_2","text":"# 查看环境信息 ## 查看系统中安装的所有环境： ### 这两个命令都可以查看当前 conda 中已经创建的环境列表，处于激活状态的环境旁边会有一个*的字样。 conda env list conda info –-envs conda info -e ## 查看 Conda 环境系统信息： conda info –-system conda info –s ## 查看环境系统更加详细的信息： conda info –-all conda info –a # 进入指定环境 conda activate <env> # 推出环境 conda deactivate # 导出环境 ## 导出环境之前首先要进入该环境 conda list -e > package-list.txt conda list -e > package-list.yml ## 或者这样 ### 这会将当前环境中由 conda 管理的包和由 pip 安装的包同时导出到文件中，所以当根据文件创建环境时，无需重新安装 pip 的包。 conda env export –-name base –-file base_bunnies.yml # 创建环境 ## 新建一个名为 newenv 的环境，并指定新环境中的 python 版本为 3.6 创建出来的环境中只带有最基本的包 conda create --name newenv python = 3 .6 ## 也可以在创建环境时候，包含某些程序或者包 conda create --name newenv python = 3 .6 biopython ipython ## 通过克隆创建一个新环境 conda create –-name newenv –clone base ## 从文件创建环境 ### 如果是用 conda env export --name 导出的文件，则可用下列命令创建： conda env create -f package-list.yml ### 如果是用 conda list -e 导出的文件，则用如下方式创建： conda create –-name <env> –-file <deps file> # 更新环境 conda env update –-name <env> –file = <deps file> # 删除环境 ## 删除环境中指定的包： conda remove –-name <env> ipython biopython ## 彻底删除环境： conda env remove –name <env>","text_tokens":["info","env","由","克隆","导出",">","时","下列","###","all","创建","查看","信息","激活状态","s","同时","system","bunnies","进入","deps","export","方式","name","中","新","文件创建","则","最","已经","根据","系统","_","新建","如果","包含","envs","这样","两个","deactivate","安装","只","activate","clone","在","命令","版本","base","彻底","是","a","重新","指定","都","并","管理","状态","会","带有","当","可用","环境","到","python","某些","该","也","可以","字样","无需","首先","删除","f","3.6","要","package","当前","重新安装","3","推出","pip","update","通过","新安","*","处于","基本","txt","详细","将","create","<","用","6","这会","和","程序","conda","之前","更新","ipython","。","biopython"," ","-","名为","包","出来","=","激活","remove","列表","更加","文件","：","所有","时候","如下","–","的","所以","file","e","#",".","##","旁边","一个","newenv","有","，","yml","或者","这","list","从","为"],"title":"环境管理","title_tokens":["管理","环境"]},{"location":"开发环境管理/5.1.conda笔记.html#_3","text":"conda 创建出来的环境默认放在 /User/<yourname>/anaconda/env 目录下，你可以将其中的某个环境文件夹整体拷贝走，复制到另一台机器上，然后基于此文件夹创建环境。","text_tokens":["可以","出来","user","env","anaconda",">","默认","创建","机器","拷贝","然后","文件","目录","复制","yourname","其中","文件夹","的","上","将","件夹","<","/","conda","环境","，","放在","某个","基于","。","整体","下","走","此","你","一台","另一台"," ","复制到"],"title":"从指定路径安装环境","title_tokens":["环境","安装","路径","指定","从"]},{"location":"开发环境管理/5.1.conda笔记.html#_4","text":"conda list # 查看已经安装的包 conda update conda # 升级conda自身 conda search requests # 查询某个包 conda install requests # 安装新包 conda install -n base requests # 将包安装到指定环境 conda update --all # 更新所有包 conda update requests # 升级包 conda remove requests # 移除包 conda remove -n base requests # 从指定环境中移除包 conda 不提供检查可更新的包的命令，update 所有包时会有提示，列出所有可更新的包，并让用户确认是否全部更新。","text_tokens":["用户","提示","确认","安装","提供","all","remove","查看","命令","查询","让","base","是否","install","检查","指定","所有","update","并","不","列出","中","的","#","将","新包","已经","自身","conda","n","有","某个","环境","到","更新","可","，","时会","升级包","全部","requests","。","list","search","从","移除"," ","-","升级","包"],"title":"包管理","title_tokens":["管理","包"]},{"location":"开发环境管理/5.1.conda笔记.html#anaconda","text":"conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes 使用 conda config --show channels 命令可以查看当前的源仓库地址。","text_tokens":["mirrors",":","可以","地址","https","tuna","anaconda","yes","channels","命令","查看","free","当前","main","urls","show","edu","set","的",".","源","channel","使用","/","tsinghua","conda","cn","config","_","。","add","pkgs"," ","仓库","-"],"title":"为 anaconda 指定国内镜像源","title_tokens":["镜像"," ","源","国内","anaconda","指定","为"]},{"location":"开发环境管理/5.3.pip对比conda.html","text":"了解conda and pip的异同 本文翻译自 Understanding Conda and Pip ( Jonathan Helmus )。 Conda和pip这两个工具有一些重叠的功能，因此它们常常被认为是没什么区别的，但实际上它们被设计用于不同的目的。 pip 是Python Packaging Authority 推荐的从 Python Package Index (PyPI)安装包的工具。 pip可以安装打包为wheels格式的包，或者直接从源代码编译安装。从源代码文件安装可能需要系统安装兼容的编译器和相应的库 1 。 Conda 是跨平台的包和环境管理器，可以安装和管理来自 Anaconda repository 和 Anaconda Cloud 的conda包。Conda包是二进制文件，不需要使用编译器来安装。另外，conda包不限于Python包，还可以包含C或C++ 库、R包或任何其他软件。 这是conda和pip的关键区别。pip只能安装Python包，而conda安装的包可以是用任何语言编写的。例如，在使用pip之前，必须通过”系统程序管理器“或”下载并运行安装程序“来安装Python解释器，而Conda可以直接安装Python包和Python解释器。 这两个工具的另一个显著区别是conda可以为不同版本的python或package创建隔离的环境。这在使用数据科学工具时非常有用，因为不同的工具可能包含冲突的依赖，这可能会导致它们不适合安装到相同的环境中。pip没有内置的环境管理功能，而是依赖于 virtualenv 或 venv 等其他工具来创建隔离环境。 pipenv、poetry、hatch wrap pip、virtualenv等工具提供了统一的方法来创建单独的环境。 pip和conda在如何实现环境中的依赖关系方面也有所不同。安装包时，pip会在递归的串行循环中安装依赖项，没有努力确保同时满足所有包的依赖性。如果较早安装的包与稍后安装的包具有不兼容的依赖，环境就会被破坏。相反的，conda使用一个satisfiability (SAT)的处理程序去检查环境中的所有包的依赖是否都得到满足。此检查可能需要额外的时间，但可以防止创建一个被破坏的环境。只要包含依赖关系的package metadata是正确的，conda就可以创建有效的环境。 考虑到conda和pip之间的相似性，有些人试图将这些工具结合起来创建数据科学环境也就不足为奇了。将pip与conda结合的主要原因是有些包只能通过pip安装。在Anaconda repository中有1500多个包可用，其中涵盖了最流行的数据科学、机器学习和AI框架。另外，在conda-forge和bioconda的channel还有数以千计的包可以使用conda安装。尽管Anaconda cloud有大量的包，但与PyPI上可提供的150,000多个包相比，数量仍然很少。有时候需要的包没有相应的conda包，但在PyPI上有安装文件，则可以用pip安装。 补充 conda 安装包路径是 \\Anaconda3\\pkgs pip 安装包路径在虚拟环境下是 \\Anaconda3\\envs\\Lib\\site-packages pip可能会生成存在冲突的环境，而conda不会 pip与conda不会重复安装已经安装的依赖 pip安装的包不会显示在anaconda navigation的环境中 conda 为多个环境安装包时，对于同一个包只安装一次，由conda集中管理 pip 为多个环境安装包时，因为每个环境安装包使用的pip在不同的路径下，因此会重复安装 关于Python包管理工具的发展历史可以参考 Python's New Package Landscape (andrew)，其中文翻译版本 在这 。插图来自https://www.xkcd.com/1987/。 编译器和库用于编译源代码。 ↩","text_tokens":[":","1","常常","正确","关键","安装程序","由","每个","什么","用于","时","hatch","方面","创建","index","大量","区别","异同","尽管","s","同时","\\","虚拟","相同","兼容","统一","000","不足","不","结合","主要","而","中","之间","则","框架","sat","最","学习","new","r","已经","但","冲突","系统","可能","源代码","项","如果","包含","forge","释器","envs","等","管理器","helmus","插图","两个","库","来自","防止","还","相似性","赖于","其他","安装","功能","ai","1500","显著","提供","涵盖","有时候","循环","在","'","适合","较","流行","xkcd","版本","c++","依赖于","是","virtualenv","翻译","没什么","repository","路径","都","并","其中","管理","历史","确保","打包","同一","上","(","二进制","参考","channel","语言","bioconda","额外","同一个","/","jonathan","相应","编写","会","处理","pypi","重叠","可用","自","环境","早","到","python","不足为奇","有些","可","lib","1987","努力","起来","考虑","进制","pkgs","如何","人","也","可以","pipenv","限于","处理程序","and","工具","这些","https","包只","wrap","anaconda","内置","推荐","landscape","还有","了","“","重复","理工","包不","不同","相似","实际上","package","试图","机器","任何","安装包","是否","www","集中管理","pip","显示","关于","不会","通过","wheels","原因","packages","只能","数以千计","包是","另外","中文翻译","navigation","代码","、","解释器","隔离","只要","将","发展","用","破坏","实际","导致","和","就","metadata","程序","集中","conda","跨平台","之前","来","去","相反","满足","仍然","。","被","本文","生成","需要","这是","此","认为","packaging"," ","-","cloud","包","数据","安装文件","补充","中文","authority","解释","satisfiability","它们","依赖性","多个","虚拟环境","venv","有所","单独","或","递归","c","中有","很少","管理工具","150","平台","理器","一些","实现","有时","poetry",",","com","而是","串行","时间","↩","具有","例如","文件","数量","因此","目的","检查","软件","编译器","所有","有效","另","时候","格式","site","关系","得到","的","其","编译","运行","understanding","非常",".","存在","使用","必须","科学","对于","因为","与","方法","相比","anaconda3","一个","没有","有","有所不同","一次","了解","，","有用","或者","稍后",")","这","其他软件","设计","下","下载","从","依赖","为","”","andrew","直接"],"title":"5.3.pip对比conda","title_tokens":["5.3",".","pip","对比","conda"]},{"location":"开发环境管理/5.3.pip对比conda.html#conda-and-pip","text":"本文翻译自 Understanding Conda and Pip ( Jonathan Helmus )。 Conda和pip这两个工具有一些重叠的功能，因此它们常常被认为是没什么区别的，但实际上它们被设计用于不同的目的。 pip 是Python Packaging Authority 推荐的从 Python Package Index (PyPI)安装包的工具。 pip可以安装打包为wheels格式的包，或者直接从源代码编译安装。从源代码文件安装可能需要系统安装兼容的编译器和相应的库 1 。 Conda 是跨平台的包和环境管理器，可以安装和管理来自 Anaconda repository 和 Anaconda Cloud 的conda包。Conda包是二进制文件，不需要使用编译器来安装。另外，conda包不限于Python包，还可以包含C或C++ 库、R包或任何其他软件。 这是conda和pip的关键区别。pip只能安装Python包，而conda安装的包可以是用任何语言编写的。例如，在使用pip之前，必须通过”系统程序管理器“或”下载并运行安装程序“来安装Python解释器，而Conda可以直接安装Python包和Python解释器。 这两个工具的另一个显著区别是conda可以为不同版本的python或package创建隔离的环境。这在使用数据科学工具时非常有用，因为不同的工具可能包含冲突的依赖，这可能会导致它们不适合安装到相同的环境中。pip没有内置的环境管理功能，而是依赖于 virtualenv 或 venv 等其他工具来创建隔离环境。 pipenv、poetry、hatch wrap pip、virtualenv等工具提供了统一的方法来创建单独的环境。 pip和conda在如何实现环境中的依赖关系方面也有所不同。安装包时，pip会在递归的串行循环中安装依赖项，没有努力确保同时满足所有包的依赖性。如果较早安装的包与稍后安装的包具有不兼容的依赖，环境就会被破坏。相反的，conda使用一个satisfiability (SAT)的处理程序去检查环境中的所有包的依赖是否都得到满足。此检查可能需要额外的时间，但可以防止创建一个被破坏的环境。只要包含依赖关系的package metadata是正确的，conda就可以创建有效的环境。 考虑到conda和pip之间的相似性，有些人试图将这些工具结合起来创建数据科学环境也就不足为奇了。将pip与conda结合的主要原因是有些包只能通过pip安装。在Anaconda repository中有1500多个包可用，其中涵盖了最流行的数据科学、机器学习和AI框架。另外，在conda-forge和bioconda的channel还有数以千计的包可以使用conda安装。尽管Anaconda cloud有大量的包，但与PyPI上可提供的150,000多个包相比，数量仍然很少。有时候需要的包没有相应的conda包，但在PyPI上有安装文件，则可以用pip安装。","text_tokens":["1","常常","正确","关键","安装程序","什么","用于","时","hatch","方面","创建","index","大量","区别","尽管","同时","相同","兼容","统一","000","不足","不","结合","主要","而","中","之间","则","框架","sat","最","学习","r","但","冲突","系统","可能","源代码","项","如果","包含","forge","释器","等","管理器","helmus","两个","库","来自","防止","还","相似性","赖于","其他","安装","功能","ai","1500","显著","提供","涵盖","有时候","循环","在","适合","较","流行","版本","c++","依赖于","是","virtualenv","翻译","没什么","repository","都","并","其中","管理","确保","打包","上","(","二进制","channel","语言","bioconda","额外","jonathan","相应","编写","会","处理","pypi","重叠","可用","自","环境","早","到","python","不足为奇","有些","可","努力","起来","考虑","进制","如何","人","也","可以","pipenv","限于","处理程序","and","工具","这些","wrap","anaconda","内置","推荐","还有","了","“","包不","不同","相似","实际上","package","试图","机器","任何","安装包","是否","pip","通过","wheels","原因","只能","数以千计","包是","另外","代码","、","解释器","隔离","只要","将","用","破坏","实际","导致","和","就","metadata","程序","conda","跨平台","之前","来","去","相反","满足","仍然","。","被","本文","需要","这是","此","认为","packaging"," ","-","cloud","包","数据","安装文件","authority","解释","satisfiability","它们","依赖性","多个","venv","有所","单独","或","递归","c","中有","很少","150","平台","理器","一些","实现","有时","poetry",",","而是","串行","时间","具有","例如","文件","数量","因此","目的","检查","软件","编译器","所有","有效","另","时候","格式","关系","得到","的","编译","运行","understanding","非常","使用","必须","科学","因为","与","方法","相比","一个","没有","有","有所不同","，","有用","或者","稍后",")","这","其他软件","设计","下载","从","依赖","为","”","直接"],"title":"了解conda and pip的异同","title_tokens":["异同","的","了解","and","pip"," ","conda"]},{"location":"开发环境管理/5.3.pip对比conda.html#_1","text":"conda 安装包路径是 \\Anaconda3\\pkgs pip 安装包路径在虚拟环境下是 \\Anaconda3\\envs\\Lib\\site-packages pip可能会生成存在冲突的环境，而conda不会 pip与conda不会重复安装已经安装的依赖 pip安装的包不会显示在anaconda navigation的环境中 conda 为多个环境安装包时，对于同一个包只安装一次，由conda集中管理 pip 为多个环境安装包时，因为每个环境安装包使用的pip在不同的路径下，因此会重复安装 关于Python包管理工具的发展历史可以参考 Python's New Package Landscape (andrew)，其中文翻译版本 在这 。插图来自https://www.xkcd.com/1987/。 编译器和库用于编译源代码。 ↩","text_tokens":[":","由","每个","用于","时","s","\\","虚拟","而","中","new","已经","冲突","可能","源代码","envs","插图","库","来自","安装","在","'","xkcd","版本","是","翻译","路径","历史","管理","同一","(","参考","同一个","/","会","环境","lib","python","1987","pkgs","可以","工具","https","包只","anaconda","landscape","理工","重复","不同","package","安装包","www","集中管理","pip","显示","关于","不会","packages","navigation","代码","发展","和","集中","conda","。","生成"," ","-","包","中文","多个","虚拟环境","管理工具","com","↩","因此","编译器","site","的","其","编译",".","存在","使用","对于","anaconda3","与","因为","一个","一次","，",")","这","下","andrew","依赖","为","中文翻译"],"title":"补充","title_tokens":["补充"]},{"location":"开发环境管理/5.4.anaconda.html","text":"Anaconda下各个文件夹作用 anacoda3/conda-meta/history ：记录用户使用conda命令安装、卸载、升级包的操作 anaconda3/pkgs/urls.txt ：记录用户使用conda命令下载包的地址，直接复制地址到浏览器中也可以下载 anaconda3/conda-meta/ ：文件夹里保存着与各个包同名的.json文件（有些包会有多个.json文件），这些json文件会记录对应的包的版本、存放位置、md5值等信息 anaconda3/pkgs/ ：这个文件夹里存放了每个包刚下载来的文件，格式是.tar.gz2，另外也会自动解压到这个文件夹里。比如你下载了six这个包，anaconda3/pkgs/这个文件夹里会多出如下2个文件。另外，当你卸载包的时候，这里的2个文件是不会被删除的 anaconda3/lib/python3.6/site-packages/ ：包的存放目录 anaconda3/bin ：安装一些包的时候会往里添加一些可执行文件 anaconda3/lib ：安装一些包的时候会往里添加一些.so文件 anaconda3/include ：安装一些包的时候会往里添加了一些文件 anaconda3/man ：安装一些包的时候会往里里添加了一些文件 anaconda3/share ：安装一些包的时候会往里里添加了一些文件","text_tokens":["用户","每个","行文","信息","对应","比如","多出","复制","包刚","位置","文件夹","中","包会","解压","件夹","这个","等","作用","着","安装","里会","six","命令","版本","可执行文件","是","python3.6","添加","so","meta","history","/","会","自动","当","到","lib","有些","你","pkgs","升级","也","保存","man","可以","这些","地址","anaconda","删除","include","json","了","卸载","这里","目录","不会","tar","packages","各个","记录","另外","anacoda3","txt","、","浏览器","操作","conda","来","值","个","。","被","存放"," ","-","（","包","里","）","多个","浏览","share","一些","文件","：","urls","会往","如下","格式","时候","site","的",".","gz2","md5","使用","anaconda3","与","有","，","升级包","bin","执行","2","下","下载","同名","直接"],"title":"5.4.anaconda","title_tokens":[".","5.4","anaconda"]},{"location":"开发环境管理/5.4.anaconda.html#anaconda","text":"anacoda3/conda-meta/history ：记录用户使用conda命令安装、卸载、升级包的操作 anaconda3/pkgs/urls.txt ：记录用户使用conda命令下载包的地址，直接复制地址到浏览器中也可以下载 anaconda3/conda-meta/ ：文件夹里保存着与各个包同名的.json文件（有些包会有多个.json文件），这些json文件会记录对应的包的版本、存放位置、md5值等信息 anaconda3/pkgs/ ：这个文件夹里存放了每个包刚下载来的文件，格式是.tar.gz2，另外也会自动解压到这个文件夹里。比如你下载了six这个包，anaconda3/pkgs/这个文件夹里会多出如下2个文件。另外，当你卸载包的时候，这里的2个文件是不会被删除的 anaconda3/lib/python3.6/site-packages/ ：包的存放目录 anaconda3/bin ：安装一些包的时候会往里添加一些可执行文件 anaconda3/lib ：安装一些包的时候会往里添加一些.so文件 anaconda3/include ：安装一些包的时候会往里添加了一些文件 anaconda3/man ：安装一些包的时候会往里里添加了一些文件 anaconda3/share ：安装一些包的时候会往里里添加了一些文件","text_tokens":["用户","每个","行文","信息","对应","比如","多出","复制","包刚","位置","文件夹","中","包会","解压","件夹","这个","等","着","安装","里会","six","命令","版本","可执行文件","是","python3.6","添加","so","meta","history","/","会","自动","当","到","lib","有些","你","pkgs","升级","也","保存","man","可以","这些","地址","删除","include","json","了","卸载","这里","目录","不会","tar","packages","各个","记录","另外","anacoda3","txt","、","浏览器","操作","conda","来","值","个","。","被","存放"," ","-","（","包","里","）","多个","浏览","share","一些","文件","：","urls","会往","如下","格式","时候","site","的",".","gz2","md5","使用","anaconda3","与","有","，","升级包","bin","执行","2","下载","同名","直接"],"title":"Anaconda下各个文件夹作用","title_tokens":["文件","件夹","anaconda","下","作用","文件夹","各个"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html","text":"让代码窗口输出全部结果 将此代码放置在jupyter单元中： from IPython.core.interactiveshell import InteractiveShell InteractiveShell . ast_node_interactivity = \"all\" 修改全局设置 在Windows中，以下步骤会使更改永久生效。应该适用于其他操作系统。您可能必须更改路径。 C:\\Users\\your_profile\\\\.ipython\\profile_default 做一个ipython_config.py文件与下面的代码profile_defaults： c = get_config () c . InteractiveShell . ast_node_interactivity = \"all\" 使用 print 函数 快捷键使用指南 Jupyter Notebook 有两种键盘输入模式。即命令模式和编辑模式，这与 Vim 有些类似。在编辑模式下，可以往cell中键入代码或文本，此时命令模式下的快捷键不生效。在命令模式下，可以用快捷键命令运行单元格，移动单元格，切换单元格编辑状态等等，此时编辑模式下的快捷键不生效。 从命令模式进入编辑模式需按 Enter 键，从编辑模式切换到命令模式需按 Esc 键。 以下两表分别是对命令和编辑两种模式下快捷键的简单说明： 命令模式快捷键（按 Esc 键开启）: 快捷键 作用 说明 Enter 转入编辑模式 Shift-Enter 运行本单元，选中下个单元 新单元默认为命令模式 Ctrl-Enter 运行本单元 Alt-Enter 运行本单元，在其下插入新单元 新单元默认为编辑模式 Y 单元转入代码状态 M 单元转入 markdown 状态 R 单元转入 raw 状态 1 设定 1 级标题 仅在 markdown 状态下时建议使用标题相关快捷键，如果单元处于其他状态，则会强制切换到 markdown 状态 2 设定 2 级标题 3 设定 3 级标题 4 设定 4 级标题 5 设定 5 级标题 6 设定 6 级标题 Up 选中上方单元 K 选中上方单元 Down 选中下方单元 J 选中下方单元 Shift-K 连续选择上方单元 Shift-J 连续选择下方单元 A 在上方插入新单元 B 在下方插入新单元 X 剪切选中的单元 C 复制选中的单元 Shift-V 粘贴到上方单元 V 粘贴到下方单元 Z 恢复删除的最后一个单元 D,D 删除选中的单元 连续按两个 D 键 Shift-M 合并选中的单元 Ctrl-S 保存当前 NoteBook S 保存当前 NoteBook L 开关行号 编辑框的行号是可以开启和关闭的 O 转换输出 Shift-O 转换输出滚动 Esc 关闭页面 Q 关闭页面 H 显示快捷键帮助 I,I 中断 NoteBook 内核 0,0 重启 NoteBook 内核 Shift 忽略 Shift-Space 向上滚动 Space 向下滚动 编辑模式快捷键（ 按 Enter 键启动）: 快捷键 作用 说明 Tab 代码补全或缩进 Shift-Tab 提示 输出帮助信息，部分函数、类、方法等会显示其定义原型，如果在其后加 ? 再运行会显示更加详细的帮助 Ctrl-] 缩进 向右缩进 Ctrl-[ 解除缩进 向左缩进 Ctrl-A 全选 Ctrl-Z 撤销 Ctrl-Shift-Z 重做 Ctrl-Y 重做 Ctrl-Home 跳到单元开头 Ctrl-Up 跳到单元开头 Ctrl-End 跳到单元末尾 Ctrl-Down 跳到单元末尾 Ctrl-Left 跳到左边一个字首 Ctrl-Right 跳到右边一个字首 Ctrl-Backspace 删除前面一个字 Ctrl-Delete 删除后面一个字 Esc 切换到命令模式 Ctrl-M 切换到命令模式 Shift-Enter 运行本单元，选中下一单元 新单元默认为命令模式 Ctrl-Enter 运行本单元 Alt-Enter 运行本单元，在下面插入一单元 新单元默认为编辑模式 Ctrl-Shift-- 分割单元 按光标所在行进行分割 Ctrl-Shift-Subtract 分割单元 Ctrl-S 保存当前 NoteBook Shift 忽略 Up 光标上移或转入上一单元 Down 光标下移或转入下一单元 Ctrl-/ 注释整行/撤销注释 仅代码状态有效 注： 如果快捷键被系统中的其它应用占用，则可能会失效 在任意目录下打开notebook 在该目录下：shift + 右键 👉 打开powershell，输入jupter notebook 自定义主题 通过 pip 安装 jupyterthemes package： # 安装 pip install jupyterthemes # 更新jupyterthemes pip install --upgrade jupyterthemes 安装好 jupyterthemes package之后，就可以在命令行输入 jupyterthemes 的命令： # 列出所有安装好的主题 jt -l # 使用帮助 jt -h 具体使用方法参见： jupyterthemes官方说明 安装扩展 安装 jupyter_contrib_nbextensions 包。该插件并不是jupyter notebook官方的插件。具体参考 Unofficial Jupyter Notebook Extensions 和 为Jupyter Notebook安装扩展并启用Configurator 。 # 安装 pip install jupyter_contrib_nbextensions # 或者通过conda安装 conda install -c conda-forge jupyter_contrib_nbextensions # 激活 jupyter contrib nbextension install --user # 启用 jupyter nbextensions_configurator enable --user 输出带有中文的pdf jupyter notebook本身不能输出pdf，输出pdf依赖于$\\LaTeX$引擎。目前，带有中文的ipynb文件输出为pdf会报错，主要原因是jupyter的$\\LaTeX$模板设置了$\\text{pdf}\\LaTeX$引擎，但是Pdf$\\LaTeX$不可以直接编译中文文档的。因此，需要把jupyter的$\\LaTeX$引擎改为$\\text{Xe}\\LaTeX$引擎。 修改模板，模板位置为：...\\site-packages\\nbconvert\\templates\\latex\\article.tplx，将latex模板类由article改为ctexart。 原来的代码： ((* block docclass *)) \\documentclass [11pt] { article } ((* endblock docclass *)) 修改后的代码： ((* block docclass *)) \\documentclass [13pt] { ctexart } ((* endblock docclass *)) 或者，依然使用PdfLatex引擎，但引入xeCJK宏包： \\documentclass [11pt] { article } \\usepackage { xeCJK } % 如果设置mainfont，必须设置为已安装的中文字体，例如微软雅黑。 %\\setCJKmainfont{SourceHanSansCN-Light} 想要修改输出pdf的排版，则需要修改其预定义的latex排版模板，即base.tplx文件。例如可以在base.tplx加入如下代码控制输出的pdf的页边距。 \\geometry { a4paper,left=2cm,right=2cm,top=1cm,bottom=1cm } 但是，可能改了jupyter的latex模板，jupyter notebook输出pdf依然报错。例如下面的报错信息： nbconvert failed: PDF creating failed, captured latex output: This is XeTeX, Version 3.14159265-2.6-0.99999 (TeX Live 2018/W32TeX) (preloaded format=xelatex) restricted \\write18 enabled. entering extended mode ! Undefined control sequence. <*> .\\notebook .tex ? ! Emergency stop. <*> .\\notebook .tex No pages of output. Transcript written on ?. 这是jupyter中控制调用latex引擎的脚本pdf.py有bug，位于66行。 原来的代码： writer = Instance ( \"nbconvert.writers.FilesWriter\" , args = (), kw = { 'build_directory' : '.' }) 正确的代码： writer = Instance ( \"nbconvert.writers.FilesWriter\" , args = (), kw = { 'build_directory' : '' }) 原来的代码给xelatex引擎发送了错误的文件路径： 错误的路径： xelatex .\\notebook.tex 正确的路径： xelatex notebook.tex 详细内容参考这里 Problem in Converting Jupyter notebook to pdf #144 。 版本控制 Save and CheckPoint 和 Revert to CheckPoint。","text_tokens":["node","1","light","0.99999","重启","排版","正确","由","k","version",">","微软","11pt","启用","恢复","13pt","内核","重做","对","144","进入","粘贴","开启","加","输入","主要","简单","sequence","自定","新","vim","窗口","5","插件","编辑框","改为","函数","forge","作用","开关","contrib","之后","建议","interactiveshell","赖于","0","切换","后面","安装","tab","在","setcjkmainfont","no","a","this","writer","windows","字","即","config","article","使用指南","有些","向下","剪切","原来","enabled","ctexart","undefined","帮助","is","参见","全选","可以","其它","and","应用","profile","转入","其后","右键","把","默认","想要","做","right","xetex","b","下个","a4paper","4","这里","left","给","output","通过","操作系统","backspace","checkpoint","代码","mode","、","好","<","用","6","右","就","preloaded","conda","相关","整行","跳","此","v"," ","包","中文","后","c","激活","占用","更加","xe","因此","所有","有效","#","左","使用","import","\"","方法","一个","i","此时","注","从","解除","其下",":","tplx","模板","补全","all","下移","让","notebook","注释","适用","problem","r","end","geometry","位于","_","说明","get","raw","光标","两个","jupter","format","行号","of","发送","缩进","up","written","unofficial","右边","依赖于","base","usepackage","stop","captured","前面","引入","修改","状态","级","nbextension","directory","l","依然","kw","您","插入","按","/","pdflatex","带有","%","到","加入","endblock","ast","mainfont","提示","user","但是","from","failed","latex","删除","transcript","nbextensions","文档","3","文本","目录","下方","具体","显示","pip","space","packages","页","控制","下时","处于","主题","delete","将","操作","失效","sourcehansanscn","top","被","tex","instance","需要","字首","快捷键","to","print","...","converting","=","字体","bottom","生效","左边",",","$","宏包","write18","以下","subtract","转换","任意","如下","改了","revert","标题","打开","官方","enable","全部","进行","upgrade","esc","templates","configurator","不能","类","in","输出","直接","部分","ctrl","下面","距","预定","+","cell","往","extensions","位置","d","args","中","本","extended","h","则","docclass","放置","命令行","系统","2cm","如果","xecjk","等","其他","目前","?","使","shift","x","pdf","install","等等","路径","键入","并","设定","{","y","上","参考","文字","会","3.14159265","最后","bug","2.6","👉","该","分割","down","强制","所在","了","设置","package","当前","键盘输入","j","自定义","原因","*","home","脚本","1cm","详细","defaults","边","一","引擎","中文字体","中断","更新","这是","撤销","-","save","快捷","]","例如","指南","忽略","内容","site","其","单元格",".","必须","错误","build","与","本身","单元","滚动","行","雅黑","，","interactivity",")","这","2","下","向","nbconvert","restricted","z","已","信息","s","于","\\","键","复制","jt","不","应该","pages","调用","fileswriter","但","可能","定义","!","powershell","}","义","default","w32tex","core","q","documentclass","命令","'","xelatex","版本","2018","永久","m","o","是","选择","两种","开头","启动","末尾","(","on","结果","连续","再","类似","需","更改","关闭","your","保存","writers","markdown","ipynb","键盘","向上","emergency","block","entering","alt","live","users","列出","仅","jupyterthemes","[","jupyter","和","原型","text","步骤","ipython","。","分别","报错","66","（","）","上移","选中","或","creating","两表","文件","：","移动","enter","扩展","编辑","的","编译","运行","模式","上方","版本控制","control","py","页面","有","合并","或者","依赖","为","全局","不是"],"title":"5.5.jupyter使用笔记","title_tokens":[".","使用","5.5","jupyter","笔记"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_1","text":"将此代码放置在jupyter单元中： from IPython.core.interactiveshell import InteractiveShell InteractiveShell . ast_node_interactivity = \"all\" 修改全局设置 在Windows中，以下步骤会使更改永久生效。应该适用于其他操作系统。您可能必须更改路径。 C:\\Users\\your_profile\\\\.ipython\\profile_default 做一个ipython_config.py文件与下面的代码profile_defaults： c = get_config () c . InteractiveShell . ast_node_interactivity = \"all\" 使用 print 函数","text_tokens":["ast","interactiveshell",":","node","其他","profile","print","from","core","c","下面","=","做","all","生效","在","设置","使","永久","于","\\","文件","：","以下","路径","修改","windows","应该","操作系统","users","中","的","适用","代码","(",".","您","将","defaults","必须","使用","放置","jupyter","操作","import","\"","会","py","单元","一个","与","函数","config","系统","_","interactivity","，","步骤","ipython","可能","。","get",")","此","更改"," ","全局","your","default"],"title":"让代码窗口输出全部结果","title_tokens":["全部","窗口","让","代码","结果","输出"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_2","text":"Jupyter Notebook 有两种键盘输入模式。即命令模式和编辑模式，这与 Vim 有些类似。在编辑模式下，可以往cell中键入代码或文本，此时命令模式下的快捷键不生效。在命令模式下，可以用快捷键命令运行单元格，移动单元格，切换单元格编辑状态等等，此时编辑模式下的快捷键不生效。 从命令模式进入编辑模式需按 Enter 键，从编辑模式切换到命令模式需按 Esc 键。 以下两表分别是对命令和编辑两种模式下快捷键的简单说明：","text_tokens":["快捷键","可以","键盘","切换","或","快捷","生效","在","命令","两表","cell","键","移动","键盘输入","文本","是","等等","进入","notebook","两种","往","以下","对","键入","输入","不","简单","enter","状态","中","编辑","vim","的","代码","运行","单元格","模式","：","用","按","jupyter","与","和","即","单元","有","，","此时","到","说明","有些","。","类似","这","esc","需","分别","下","从"," "],"title":"快捷键使用指南","title_tokens":["快捷键","使用指南","指南","使用","快捷"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#esc","text":"快捷键 作用 说明 Enter 转入编辑模式 Shift-Enter 运行本单元，选中下个单元 新单元默认为命令模式 Ctrl-Enter 运行本单元 Alt-Enter 运行本单元，在其下插入新单元 新单元默认为编辑模式 Y 单元转入代码状态 M 单元转入 markdown 状态 R 单元转入 raw 状态 1 设定 1 级标题 仅在 markdown 状态下时建议使用标题相关快捷键，如果单元处于其他状态，则会强制切换到 markdown 状态 2 设定 2 级标题 3 设定 3 级标题 4 设定 4 级标题 5 设定 5 级标题 6 设定 6 级标题 Up 选中上方单元 K 选中上方单元 Down 选中下方单元 J 选中下方单元 Shift-K 连续选择上方单元 Shift-J 连续选择下方单元 A 在上方插入新单元 B 在下方插入新单元 X 剪切选中的单元 C 复制选中的单元 Shift-V 粘贴到上方单元 V 粘贴到下方单元 Z 恢复删除的最后一个单元 D,D 删除选中的单元 连续按两个 D 键 Shift-M 合并选中的单元 Ctrl-S 保存当前 NoteBook S 保存当前 NoteBook L 开关行号 编辑框的行号是可以开启和关闭的 O 转换输出 Shift-O 转换输出滚动 Esc 关闭页面 Q 关闭页面 H 显示快捷键帮助 I,I 中断 NoteBook 内核 0,0 重启 NoteBook 内核 Shift 忽略 Shift-Space 向上滚动 Space 向下滚动","text_tokens":["1","重启","k","ctrl","z","恢复","s","内核","键","复制","粘贴","notebook","开启","d","新","本","5","则","h","r","编辑框","说明","如果","raw","作用","开关","两个","行号","建议","up","其他","0","切换","q","在","命令","shift","m","o","x","是","a","选择","设定","状态","级","y","l","插入","按","会","连续","最后","到","向下","剪切","帮助","关闭","保存","down","可以","markdown","强制","转入","向上","默认","删除","b","下个","当前","4","alt","3","j","下方","显示","space","下时","处于","仅","代码","输出","6","和","相关","中断","v"," ","-","快捷键","选中","c","快捷",",","忽略","转换","enter","编辑","的","运行","模式","使用","上方","标题","单元","一个","滚动","页面","i","合并","，","esc","2","为","其下"],"title":"命令模式快捷键（按 Esc 键开启）:","title_tokens":["快捷键","命令",":","键","esc","模式","按","开启","快捷"," ","（","）"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#enter","text":"快捷键 作用 说明 Tab 代码补全或缩进 Shift-Tab 提示 输出帮助信息，部分函数、类、方法等会显示其定义原型，如果在其后加 ? 再运行会显示更加详细的帮助 Ctrl-] 缩进 向右缩进 Ctrl-[ 解除缩进 向左缩进 Ctrl-A 全选 Ctrl-Z 撤销 Ctrl-Shift-Z 重做 Ctrl-Y 重做 Ctrl-Home 跳到单元开头 Ctrl-Up 跳到单元开头 Ctrl-End 跳到单元末尾 Ctrl-Down 跳到单元末尾 Ctrl-Left 跳到左边一个字首 Ctrl-Right 跳到右边一个字首 Ctrl-Backspace 删除前面一个字 Ctrl-Delete 删除后面一个字 Esc 切换到命令模式 Ctrl-M 切换到命令模式 Shift-Enter 运行本单元，选中下一单元 新单元默认为命令模式 Ctrl-Enter 运行本单元 Alt-Enter 运行本单元，在下面插入一单元 新单元默认为编辑模式 Ctrl-Shift-- 分割单元 按光标所在行进行分割 Ctrl-Shift-Subtract 分割单元 Ctrl-S 保存当前 NoteBook Shift 忽略 Up 光标上移或转入上一单元 Down 光标下移或转入下一单元 Ctrl-/ 注释整行/撤销注释 仅代码状态有效 注： 如果快捷键被系统中的其它应用占用，则可能会失效","text_tokens":["部分","补全","ctrl","下面","z","下移","信息","s","重做","notebook","加","注释","中","新","本","则","end","函数","系统","定义","可能","说明","如果","等","作用","光标","缩进","up","切换","后面","tab","右边","在","?","命令","shift","m","a","前面","状态","开头","字","末尾","类","y","上","插入","按","/","会","再","到","帮助","全选","分割","down","保存","提示","其它","应用","其后","转入","默认","删除","所在","right","当前","alt","left","显示","backspace","仅","代码","home","、","详细","delete","[","右","原型","失效","一","整行","跳","被","撤销","字首"," ","-","快捷键","上移","选中","或","快捷","左边","占用","更加","]","：","忽略","subtract","有效","enter","编辑","其","的","运行","模式","左","方法","单元","一个","行","，","进行","esc","注","下","向","为","解除","输出"],"title":"编辑模式快捷键（ 按 Enter 键启动）:","title_tokens":["快捷键","启动","编辑",":","键","模式","按","快捷"," ","enter","（","）"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#notebook","text":"在该目录下：shift + 右键 👉 打开powershell，输入jupter notebook","text_tokens":["打开","shift","，","jupter","：","powershell","右键","目录","下","notebook","👉","输入"," ","在","该","+"],"title":"在任意目录下打开notebook","title_tokens":["打开","目录","下","notebook","任意","在"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_3","text":"通过 pip 安装 jupyterthemes package： # 安装 pip install jupyterthemes # 更新jupyterthemes pip install --upgrade jupyterthemes 安装好 jupyterthemes package之后，就可以在命令行输入 jupyterthemes 的命令： # 列出所有安装好的主题 jt -l # 使用帮助 jt -h 具体使用方法参见： jupyterthemes官方说明","text_tokens":["可以","安装","在","命令","package","：","install","具体","所有","pip","jt","输入","通过","列出","的","主题","l","#","h","jupyterthemes","好","使用","命令行","就","方法","官方","，","更新","说明","upgrade","帮助"," ","-","参见","之后"],"title":"自定义主题","title_tokens":["自定义","自定","主题","定义"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_4","text":"安装 jupyter_contrib_nbextensions 包。该插件并不是jupyter notebook官方的插件。具体参考 Unofficial Jupyter Notebook Extensions 和 为Jupyter Notebook安装扩展并启用Configurator 。 # 安装 pip install jupyter_contrib_nbextensions # 或者通过conda安装 conda install -c conda-forge jupyter_contrib_nbextensions # 激活 jupyter contrib nbextension install --user # 启用 jupyter nbextensions_configurator enable --user","text_tokens":["user","安装","unofficial","c","该","激活","启用","nbextensions","install","具体","notebook","pip","extensions","并","通过","扩展","nbextension","的","参考","#","jupyter","插件","和","为","conda","官方","enable","_","forge","或者","。","configurator","contrib"," ","-","不是","包"],"title":"安装扩展","title_tokens":["扩展","安装"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#pdf","text":"jupyter notebook本身不能输出pdf，输出pdf依赖于$\\LaTeX$引擎。目前，带有中文的ipynb文件输出为pdf会报错，主要原因是jupyter的$\\LaTeX$模板设置了$\\text{pdf}\\LaTeX$引擎，但是Pdf$\\LaTeX$不可以直接编译中文文档的。因此，需要把jupyter的$\\LaTeX$引擎改为$\\text{Xe}\\LaTeX$引擎。 修改模板，模板位置为：...\\site-packages\\nbconvert\\templates\\latex\\article.tplx，将latex模板类由article改为ctexart。 原来的代码： ((* block docclass *)) \\documentclass [11pt] { article } ((* endblock docclass *)) 修改后的代码： ((* block docclass *)) \\documentclass [13pt] { ctexart } ((* endblock docclass *)) 或者，依然使用PdfLatex引擎，但引入xeCJK宏包： \\documentclass [11pt] { article } \\usepackage { xeCJK } % 如果设置mainfont，必须设置为已安装的中文字体，例如微软雅黑。 %\\setCJKmainfont{SourceHanSansCN-Light} 想要修改输出pdf的排版，则需要修改其预定义的latex排版模板，即base.tplx文件。例如可以在base.tplx加入如下代码控制输出的pdf的页边距。 \\geometry { a4paper,left=2cm,right=2cm,top=1cm,bottom=1cm } 但是，可能改了jupyter的latex模板，jupyter notebook输出pdf依然报错。例如下面的报错信息： nbconvert failed: PDF creating failed, captured latex output: This is XeTeX, Version 3.14159265-2.6-0.99999 (TeX Live 2018/W32TeX) (preloaded format=xelatex) restricted \\write18 enabled. entering extended mode ! Undefined control sequence. <*> .\\notebook .tex ? ! Emergency stop. <*> .\\notebook .tex No pages of output. Transcript written on ?. 这是jupyter中控制调用latex引擎的脚本pdf.py有bug，位于66行。 原来的代码： writer = Instance ( \"nbconvert.writers.FilesWriter\" , args = (), kw = { 'build_directory' : '.' }) 正确的代码： writer = Instance ( \"nbconvert.writers.FilesWriter\" , args = (), kw = { 'build_directory' : '' }) 原来的代码给xelatex引擎发送了错误的文件路径： 错误的路径： xelatex .\\notebook.tex 正确的路径： xelatex notebook.tex 详细内容参考这里 Problem in Converting Jupyter notebook to pdf #144 。","text_tokens":[":","tplx","0.99999","light","模板","restricted","排版","正确","由","version",">","下面","微软","距","预定","11pt","已","13pt","信息","\\","144","notebook","位置","args","主要","不","sequence","中","pages","调用","extended","则","problem","docclass","fileswriter","改为","但","geometry","位于","_","可能","2cm","如果","!","xecjk","}","义","format","of","发送","written","赖于","安装","w32tex","目前","documentclass","在","setcjkmainfont","?","'","xelatex","2018","pdf","no","依赖于","base","是","usepackage","this","stop","路径","captured","引入","修改","writer","{","directory","依然","(","kw","参考","on","文字","/","会","pdflatex","带有","3.14159265","即","article","%","bug","原来","加入","2.6","enabled","ctexart","endblock","undefined","is","mainfont","可以","writers","ipynb","但是","把","failed","latex","想要","了","right","emergency","设置","xetex","block","transcript","entering","文档","a4paper","这里","left","给","live","output","原因","packages","*","页","控制","代码","mode","1cm","输出","脚本","将","详细","[","<","jupyter","preloaded","边","sourcehansanscn","text","引擎","top","中文字体","。","tex","instance","需要","报错","这是","66"," ","-","中文","后","to","...","converting","字体","=","bottom","creating",",","]","例如","$","文件","：","xe","因此","宏包","write18","内容","site","如下","改了","的","其","编译","#",".","使用","必须","build","错误","control","\"","本身","py","行","雅黑","有","，","或者",")","templates","不能","依赖","为","类","in","直接","nbconvert"],"title":"输出带有中文的pdf","title_tokens":["中文","的","pdf","带有","输出"]},{"location":"开发环境管理/5.5.jupyter使用笔记.html#_5","text":"Save and CheckPoint 和 Revert to CheckPoint。","text_tokens":["save","checkpoint","revert","and","to","。","和"," "],"title":"版本控制","title_tokens":["控制","版本","版本控制"]},{"location":"计算机基础/1.1.计算机与程序结构.html","text":"CPU 计算机的工作过程就是计算机执行程序的过程。程序是一个指令序列，这个序列明确告诉计算机应该执行什么操作，在什么地方能够找到用来操作的数据。 一旦把程序装入主存储器，计算机就可以自动执行取出指令和执行指令的任务。 专门用来完成此项工作的计算机部件称为中央处理器（Central Processing Unit，CPU） ，做成单片集成电路的CPU通常又称为微处理器（Microprocessor），在一个集成电路中集成了两个 CPU 芯片，称之为双核（dual core）微处理器。现代的个人计算机一般都是使用微处理器作为CPU。 注意：CPU不是指一个特定的某一类东西，而是具有某种功能的部件的总称。所以，不管是何种形态、设计、原理的部件，只要它能具有取出指令、执行指令的功能，它就是CPU。 简而言之， CPU 是用来表示计算机内部元件功能的术语。 下图为陶瓷PGA封装的Intel 80486 DX2 CPU： 计算机工业从1960年代早期开始使用CPU这个术语。迄今为止，CPU从形态、设计到实现都已发生了巨大的变化，但是其基本工作原理却一直没有大的变化。 早期的CPU通常是为大型、特定的应用而定制的。目前，这种为特定应用而设计定制CPU的昂贵方法，在很大程度上已经让位于可大规模生产的通用处理器。这种标准化趋势，诞生于分立晶体管大型计算机（Mainframe）和小型计算机（Minicomputer）年代，并且随着集成电路（IC）的普及而大大加速。 现代的CPU使用集成电路制作，集成电路可以把日益复杂的CPU设计制造在很小的空间里。CPU的小型化和标准化，大大增加了这些数字器件在现代生活中的应用范围，远远超出了专用运算机器这一有限的应用。现代微处理器已经随处可见，从汽车到手机，甚至儿童玩具。 ​ ——参考于 英特尔文档：CPU的功能和组成 CPU和内存由数字集成电路（数字芯片）构成，集成电路通常称为IC（Integrated Circuit），它由晶体管组成，每一个晶体管具有ON/OFF两个状态。 从功能方面来看 ，CPU的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。 寄存器可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有20～100 个寄存器。 控制器负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。 运算器负责运算从内存读入寄存器的数据。 时钟负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。 寄存器的主要种类和功能 根据功能的不同，我们可以将寄存器大致划分为八类。可以看出，==寄存器中存储的内容既可以是指令也可以是数据。其中，数据分为“用于运算的数值”和“表示内存地址的数值”两种。==数据种类不同，存储该数值的寄存器也不同。CPU 中每个寄存器的功能都是不同的。 种类 功能 累加寄存器 accumulator 存储执行运算的数据和运算后的数据 标志寄存器 flag register 存储运算处理后的 CPU 的状态 程序计数器 program counter 存储下一条指令所在内存的地址 基址寄存器 base register 存储数据内存的起始地址 变址寄存器 index register 存储基址寄存器的相对地址 通用寄存器 general purpose register 存储任意数据 指令寄存器 instruction register 存储指令。CPU 内部使用，程序员无法通过程序对该寄存器进行读写操作 栈寄存器 stack register 存储栈区域的起始地址 寄存器对程序员来说比较特殊，因为寄存器是编程中的一个对象，例如在汇编语言中： # 汇编语言编写的程序示例 mov eax, dword ptr [ebp-8] …把数值从内存复制到 eax add eax, dword ptr [ebp-0Ch] …exa 的数值和内存的数值相加 mov dword ptr [ebp-4], eax …把 exa 的数值（上一步的相加结果）存储在内存中 eax 和 ebp 是 CPU 内部的寄存器的名称。内存的存储场所通过地址编号来区分，而寄存器的种类则通过名字来区分。 main memory 通常所说的内存指的是计算机的主存储器（main memory），简称主存。 主存通过控制芯片等与 CPU 相连， 主要负责存储指令和数据。 主存由可读写的元素构成，每个字节（1 Byte = 8 bit ）都带有一个地址编号。 CPU 可以通过该地址读取主存中的指令和数据，以及写入数据。 如何通过内存索引数据？ 内存的构成单位是一个字节（8位），每一个字节都有一个地址编号，这个地址编号是它的逻辑地址。 CPU中的寄存器（基址寄存器、变址寄存器）会储存中被运算的数据的编号地址。CPU寄存器的空间大小决定了CPU能识别多大的内存。 比如说，一个32位的寄存器，它能表示的最大数为$2^{32}-1=4294967295$（十进制数，从0开始；换成16进制数就是FFFFFFFF）。也就是说它能表示$2^{32}=4294967296$种状态。而4g的内存一共有$4\\times1024\\times1024\\times1024=4294967296$个byte，也就是说一个具有32位的寄存器的CPU最多能识别4g的内存。 通过基址寄存器和变址寄存器，我们可以对主内存上特定的内存区域进行划分。首先，我们用十六进制数 将计算机内存上 00000000～FFFFFFFF的地址划分出来。那么，凡是该范围的内存区域，只要有一个 32 位的 寄存器，即可查看全部的内存地址。 CPU所生成的地址通常称为逻辑地址(logical address)，而内存单元所看到的地址（即加载到内存地址寄存器(memory-address register)中的地址）通常称为物理地址(physical address) 。 逻辑地址与物理地址的对应关系并不是固定不变的，这取决于执行的地址绑定方案。因此，逻辑地址又称为虚拟地址。虚拟地址通过 映射 与物理地址对应起来。完成这种映射的硬件设备是 内存管理单元 (memory-management unit, MMU)，完成映射的方法有多种，也就是地址绑定方案有多种。程序无法访问物理地址，只能基于虚拟地址进行操作。","text_tokens":["1","最大","某种","由","不过","index","查看","相连","组成","对","取决","看出","主要","累加","这种","规模","integrated","大型","已经","英特","20","存储栈","指令寄存器","玩具","通常","电流","4294967295","编号","minicomputer","复制到","0","大","种","作为","索引","在","exa","发出","—","通用寄存器","一种","ptr","十进制","其中","byte","一般","栈","这一","暂存","即","单片","不管","集成","有些","基于","如何","中央处理器","标志","也","可以","能","应用","把","每","序列","4","物理地址","既","0ch","通过","储存","行程","程序员","汽车","、","用","它","就","程序","logical","无法","逻辑","生成","为止","；"," ","100","字节","很大","后","方案","开始","对象","指令","称之为","实现","何种","完成","以及","具有","因此","processing","过程","unit","#","使用","register","方法","一个","用来","一步","没有","器件","counter","十六进制","特尔","？","mmu","从","八类","mainframe","4294967296","凡是","随着","写入","eax","无法访问","日益","大数","让","种类","即可","也就是说","内存地址","构成","大规模","微处理器","这个","比较","趋势","读入","位于","固定","ic","计数器","注意","两个","一条","大大增加","场所","microprocessor","工业","下图","16","base","却","此项","状态","相对","一共","虚拟地址","绑定","大增","/","访问","off","带有","整个","可用","purpose","80486","instruction","到","可","寄存器","不变","但是","地址","运算器","比如说","程度","主存储器","dual","存储","很小","不同","文档","读取","就是","bit","控制","地方","基本","又","～","将","accumulator","元素","操作","东西","读写","来","元件","被","program","双核","定制","最多能","出来","发生","=","理器",",","负责","times1024","示例","$","ffffffff","任意","4g","内存","关系","所以","多种","集成电路","数","加速","存储器","划分","制造","全部","进行","执行","8","设计","dword","计数","mov","部分","什么","方面","执行程序","告诉","年代","我们","指令和数据","中","之间","central","则","一旦","晶体管","等","可见","控制器","区域","设备","目前","指","一直","并且","​","算机","intel","通用","标准","并","多大","flag","{","变化","上","取决于","英特尔","参考","语言","寄存","会","编写","处理","自动","一类","小型","复杂","计时","进制","晶体","此项工作","能够","远远","该","儿童玩具","这些","昂贵","看到","汇编","所在","了","“","而言","取出","生产","机器","physical","各","加载","只要","1960","读写操作","决定","普及","制作","所说","编程","个","大规","中央","内部","-","随处","时钟","那么","相互","名字","换成","现代","特殊","外部","]","main","例如","装入","相加","内容","变址","来说","其","电路","之为","大致","因为","与","标准化","工作","单元","32","称为","，","就是说","芯片","对主",")","这","management","2","下","stack","计算机","生活","…","cpu","每个","用于","信号","做成","已","general","硬件","部件","某","于","\\","虚拟","对应","任务","比如","复制","dx2","物理","pga","应该","而","识别","专门","小型化","看作","原理","甚至","根据","专用","手机","名称","add","随处可见","}","四个","有限","找到","功能","core","位","形态","是","两种","都","巨大","分立","管理","增加","算器","(","on","结果","范围","单位","ebp","简称","儿童","起来","汇编语言","00000000","大小","封装","连通","基址","数字","大大","首先","处理器","起始","超出","所","迄今","address","早期","明确","^","数值","来看","只能","特定","[","术语","空间","和","表示","。","主存","运算","个人","（","数据","总称","）","里","映射","成电","诞生","而是","简而言之","：","最大数","memory","的","十六","区分","circuit","最多","计算","有","陶瓷","分为","迄今为止","为","”","不是"],"title":"1.1.计算机与程序结构","title_tokens":["算机","1.1",".","结构","与","程序结构","计算机","程序","计算"]},{"location":"计算机基础/1.1.计算机与程序结构.html#cpu","text":"计算机的工作过程就是计算机执行程序的过程。程序是一个指令序列，这个序列明确告诉计算机应该执行什么操作，在什么地方能够找到用来操作的数据。 一旦把程序装入主存储器，计算机就可以自动执行取出指令和执行指令的任务。 专门用来完成此项工作的计算机部件称为中央处理器（Central Processing Unit，CPU） ，做成单片集成电路的CPU通常又称为微处理器（Microprocessor），在一个集成电路中集成了两个 CPU 芯片，称之为双核（dual core）微处理器。现代的个人计算机一般都是使用微处理器作为CPU。 注意：CPU不是指一个特定的某一类东西，而是具有某种功能的部件的总称。所以，不管是何种形态、设计、原理的部件，只要它能具有取出指令、执行指令的功能，它就是CPU。 简而言之， CPU 是用来表示计算机内部元件功能的术语。 下图为陶瓷PGA封装的Intel 80486 DX2 CPU： 计算机工业从1960年代早期开始使用CPU这个术语。迄今为止，CPU从形态、设计到实现都已发生了巨大的变化，但是其基本工作原理却一直没有大的变化。 早期的CPU通常是为大型、特定的应用而定制的。目前，这种为特定应用而设计定制CPU的昂贵方法，在很大程度上已经让位于可大规模生产的通用处理器。这种标准化趋势，诞生于分立晶体管大型计算机（Mainframe）和小型计算机（Minicomputer）年代，并且随着集成电路（IC）的普及而大大加速。 现代的CPU使用集成电路制作，集成电路可以把日益复杂的CPU设计制造在很小的空间里。CPU的小型化和标准化，大大增加了这些数字器件在现代生活中的应用范围，远远超出了专用运算机器这一有限的应用。现代微处理器已经随处可见，从汽车到手机，甚至儿童玩具。 ​ ——参考于 英特尔文档：CPU的功能和组成 CPU和内存由数字集成电路（数字芯片）构成，集成电路通常称为IC（Integrated Circuit），它由晶体管组成，每一个晶体管具有ON/OFF两个状态。 从功能方面来看 ，CPU的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。 寄存器可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有20～100 个寄存器。 控制器负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。 运算器负责运算从内存读入寄存器的数据。 时钟负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。","text_tokens":["部分","随着","cpu","某种","由","什么","信号","做成","不过","方面","执行程序","告诉","已","日益","部件","年代","某","让","于","种类","组成","任务","dx2","pga","应该","构成","而","专门","中","小型化","之间","大规模","central","微处理器","这种","看作","这个","规模","原理","趋势","integrated","读入","大型","一旦","已经","晶体管","甚至","英特","根据","专用","20","位于","手机","ic","随处可见","玩具","通常","可见","电流","注意","控制器","两个","minicomputer","等","四个","有限","找到","大大增加","大","功能","core","目前","microprocessor","工业","作为","指","下图","在","一直","并且","​","发出","算机","—","形态","intel","却","是","此项","通用","一种","都","巨大","标准","并","分立","状态","变化","上","增加","算器","英特尔","参考","一般","大增","on","寄存","结果","这一","/","会","处理","为","off","自动","暂存","整个","单片","不管","可用","一类","80486","集成","到","小型","可","范围","有些","儿童","复杂","寄存器","计时","封装","晶体","连通","中央处理器","此项工作","能够","数字","大大","远远","也","儿童玩具","可以","这些","昂贵","但是","能","应用","把","运算器","程度","处理器","主存储器","dual","存储","了","很小","超出","每","而言","不同","序列","取出","生产","机器","文档","迄今","各","早期","就是","明确","行程","来看","控制","地方","基本","又","汽车","、","特定","只要","1960","将","～","术语","普及","操作","它","就","和","东西","表示","程序","空间","制作","来","元件","个","大规","。","中央","主存","运算","个人","双核","为止","定制"," ","内部","100","随处","（","数据","总称","）","很大","里","时钟","成电","相互","开始","发生","对象","指令","称之为","现代","理器","实现","诞生","何种","负责","而是","完成","简而言之","外部","具有","装入","：","processing","过程","内存","的","所以","其","unit","电路","之为","使用","集成电路","circuit","方法","工作","标准化","一个","计算","用来","加速","存储器","没有","有","器件","称为","，","陶瓷","制造","芯片","特尔","执行","迄今为止","设计","从","计算机","mainframe","生活","不是"],"title":"CPU","title_tokens":["cpu"]},{"location":"计算机基础/1.1.计算机与程序结构.html#_1","text":"根据功能的不同，我们可以将寄存器大致划分为八类。可以看出，==寄存器中存储的内容既可以是指令也可以是数据。其中，数据分为“用于运算的数值”和“表示内存地址的数值”两种。==数据种类不同，存储该数值的寄存器也不同。CPU 中每个寄存器的功能都是不同的。 种类 功能 累加寄存器 accumulator 存储执行运算的数据和运算后的数据 标志寄存器 flag register 存储运算处理后的 CPU 的状态 程序计数器 program counter 存储下一条指令所在内存的地址 基址寄存器 base register 存储数据内存的起始地址 变址寄存器 index register 存储基址寄存器的相对地址 通用寄存器 general purpose register 存储任意数据 指令寄存器 instruction register 存储指令。CPU 内部使用，程序员无法通过程序对该寄存器进行读写操作 栈寄存器 stack register 存储栈区域的起始地址 寄存器对程序员来说比较特殊，因为寄存器是编程中的一个对象，例如在汇编语言中： # 汇编语言编写的程序示例 mov eax, dword ptr [ebp-8] …把数值从内存复制到 eax add eax, dword ptr [ebp-0Ch] …exa 的数值和内存的数值相加 mov dword ptr [ebp-4], eax …把 exa 的数值（上一步的相加结果）存储在内存中 eax 和 ebp 是 CPU 内部的寄存器的名称。内存的存储场所通过地址编号来区分，而寄存器的种类则通过名字来区分。","text_tokens":["…","cpu","每个","用于","general","index","eax","八类","种类","对","复制","我们","看出","内存地址","而","中","累加","则","比较","根据","名称","存储栈","add","计数器","指令寄存器","编号","复制到","mov","一条","区域","场所","功能","在","exa","通用寄存器","base","是","通用","ptr","两种","都","其中","flag","状态","相对","上","语言","栈","寄存","结果","编写","处理","purpose","instruction","ebp","寄存器","汇编语言","基址","该","标志","也","可以","地址","汇编","把","所在","存储","“","起始","不同","4","既","0ch","通过","数值","程序员","将","读写操作","[","accumulator","操作","和","表示","程序","读写","来","编程","无法","。","运算","program","内部"," ","-","数据","（","）","后","名字","对象","指令","=",",","特殊","示例","]","例如","：","相加","任意","内容","变址","来说","内存","的","#","区分","使用","大致","register","因为","一个","一步","划分","counter","，","进行","分为","执行","8","下","stack","dword","从","计数","为","”"],"title":"寄存器的主要种类和功能","title_tokens":["的","种类","寄存器","功能","寄存","和","主要"]},{"location":"计算机基础/1.1.计算机与程序结构.html#main-memory","text":"通常所说的内存指的是计算机的主存储器（main memory），简称主存。 主存通过控制芯片等与 CPU 相连， 主要负责存储指令和数据。 主存由可读写的元素构成，每个字节（1 Byte = 8 bit ）都带有一个地址编号。 CPU 可以通过该地址读取主存中的指令和数据，以及写入数据。","text_tokens":["可以","1","地址","cpu","指令","由","每个","=","该","主存储器","存储","指","写入","负责","相连","算机","main","以及","数据","读取","是","都","通过","主要","指令和数据","构成","byte","bit","内存","控制","memory","中","的","计算机","元素","与","带有","一个","计算","存储器","读写","所说","，","可","芯片","简称","。","主存","8","等","通常","编号"," ","字节","（","）"],"title":"main memory","title_tokens":[" ","memory","main"]},{"location":"计算机基础/1.1.计算机与程序结构.html#_2","text":"内存的构成单位是一个字节（8位），每一个字节都有一个地址编号，这个地址编号是它的逻辑地址。 CPU中的寄存器（基址寄存器、变址寄存器）会储存中被运算的数据的编号地址。CPU寄存器的空间大小决定了CPU能识别多大的内存。 比如说，一个32位的寄存器，它能表示的最大数为$2^{32}-1=4294967295$（十进制数，从0开始；换成16进制数就是FFFFFFFF）。也就是说它能表示$2^{32}=4294967296$种状态。而4g的内存一共有$4\\times1024\\times1024\\times1024=4294967296$个byte，也就是说一个具有32位的寄存器的CPU最多能识别4g的内存。 通过基址寄存器和变址寄存器，我们可以对主内存上特定的内存区域进行划分。首先，我们用十六进制数 将计算机内存上 00000000～FFFFFFFF的地址划分出来。那么，凡是该范围的内存区域，只要有一个 32 位的 寄存器，即可查看全部的内存地址。 CPU所生成的地址通常称为逻辑地址(logical address)，而内存单元所看到的地址（即加载到内存地址寄存器(memory-address register)中的地址）通常称为物理地址(physical address) 。 逻辑地址与物理地址的对应关系并不是固定不变的，这取决于执行的地址绑定方案。因此，逻辑地址又称为虚拟地址。虚拟地址通过 映射 与物理地址对应起来。完成这种映射的硬件设备是 内存管理单元 (memory-management unit, MMU)，完成映射的方法有多种，也就是地址绑定方案有多种。程序无法访问物理地址，只能基于虚拟地址进行操作。","text_tokens":["1","最大","cpu","硬件","查看","无法访问","大数","\\","即可","对应","虚拟","也就是说","比如","取决","我们","内存地址","物理","构成","而","识别","中","计算机","这种","这个","固定","}","4294967295","通常","编号","区域","0","设备","种","算机","位","16","是","都","十进制","并","多大","byte","管理","状态","{","一共","上","取决于","虚拟地址","(","绑定","寄存","访问","会","即","范围","单位","到","基于","不是","寄存器","起来","00000000","大小","不变","进制","基址","该","也","可以","地址","能","看到","比如说","首先","每","了","4","物理地址","physical","所","address","就是","加载","储存","^","通过","只能","又","、","特定","～","将","只要","决定","用","它","空间","和","表示","操作","程序","logical","个","无法","。","被","逻辑","运算","生成","最多能","；"," ","-","字节","数据","（","映射","）","那么","方案","出来","开始","换成","=","times1024",",","完成","具有","$","最大数","因此","ffffffff","4g","变址","内存","关系","memory","的","多种","unit","十六","register","与","数","最多","方法","单元","一个","计算","32","有","划分","称为","，","就是说","十六进制","进行","全部","对主","management",")","这","8","执行","2","mmu","从","为","4294967296","凡是"],"title":"如何通过内存索引数据？","title_tokens":["通过","？","索引","如何","数据","内存"]},{"location":"计算机基础/1.2.基本概念.html","text":"程序和编程语言 程序（Program） 告诉计算机应如何完成一个计算任务，这里的计算可以是数学运算，比如解方程，也可以是符号运算，比如查找和替换文档中的某个单词。从根本上说，==计算机是由数字电路组成的运算机器，只能对数字做运算，程序之所以能做符号运算，是因为符号在计算机内部也是用数字表示的。==此外，程序还可以处理声音和图像，声音和图像在计算机内部必然也是用数字表示的，这些数字经过专门的硬件设备转换成人可以听到、看到的声音和图像。 程序由一系列 指令（Instruction） 组成，指令是指示计算机做某种运算的命令，通常包括以下几类： 输入（Input）：从键盘、文件或者其它设备获取数据。 输出（Output）：把数据显示到屏幕，或者存入一个文件，或者发送到其它设备。 基本运算：执行最基本的数学运算（加减乘除）和数据存取。 测试和分支：测试某个条件，然后根据不同的测试结果执行不同的后续指令。 循环：重复执行一系列操作。 对于程序来说，有上面这几类指令就足够了。你曾用过的任何一个程序，不管它有多么复杂，都是由这几类指令组成的。程序是那么的复杂，而编写程序可以用的指令却只有这么简单的几种，这中间巨大的落差就要由程序员去填了，所以编写程序理应是一件相当复杂的工作。 编写程序可以说就是这样一个过程：把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。 编程语言 ：编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。 机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，==语句是计算机指令的抽象表示。==举个例子，同样一个语句用C语言、汇编语言和机器语言分别表示如下： 低级编程语言使用计算机指令编写程序； 高级编程语言使用语句编写程序。 计算机只能对数字做运算，符号、声音、图像在计算机内部都要用数字表示，指令也不例外，上表中的机器语言完全由十六进制数字组成。最早的程序员都是直接用机器语言编程，但是很麻烦，需要查大量的表格来确定每个数字表示什么意思，编写出来的程序很不直观，而且容易出错，于是有了==汇编语言，把机器语言中一组一组的数字用助记符（Mnemonic）表示，直接用这些助记符写出汇编程序，然后让汇编器（Assembler）去查表把助记符替换成数字，也就把汇编语言翻译成了机器语言。== 从上面的例子可以看出， 汇编语言和机器语言的指令是一一对应的，汇编语言有三条指令，机器语言也有三条指令，汇编器就是做一个简单的替换工作 ，例如在第一条指令中，把 movl ?,%eax 这种格式的指令替换成机器码 a1 ? ，?表示一个地址，在汇编指令中是 0x804a01c ，转换成机器码之后是 1c a0 04 08 （这是指令中的十六进制数的小端表示，小端表示将在 第 5.1 节 “目标文件” 介绍）。 从上面的例子还可以看出，==高级语言的语句和低级语言的指令之间不是简单的一一对应关系，==一条 a=b+1; 语句要翻译成三条汇编或机器指令，这个过程称为 编译（Compile） ，由编译器（Compiler）来完成，显然编译器的功能比汇编器要复杂得多。用高级语言编写的程序必须经过编译转成机器指令才能被计算机执行，编译需要花一些时间，这是用高级语言编程的一个缺点，然而更多的是优点。首先，用高级语言编程更容易，写出来的代码更紧凑，可读性更强，出了错也更容易改正。其次，高级语言是可移植的（Portable）或者称为平台无关的（Platform Independent）。 平台 这个词有很多种解释，可以指计算机体系结构（Architecture），也可以指操作系统（Operating System），也可以指开发平台（编译器、链接器等）。不同的计算机体系结构有不同的指令集（Instruction Set），可以识别的机器指令格式是不同的，直接用某种体系结构的汇编或机器指令写出来的程序只能在这种体系结构的计算机上运行，然而各种体系结构的计算机都有各自的C编译器，可以把C程序编译成各种不同体系结构的机器指令，这意味着用C语言写的程序只需稍加修改甚至不用修改就可以在各种不同的计算机上编译运行。各种高级语言都具有C语言的这些优点，所以绝大部分程序是用高级语言编写的，只有和硬件关系密切的少数程序（例如驱动程序）才会用到低级语言。还要注意一点，即使在相同的体系结构和操作系统下，用不同的C编译器（或者同一个C编译器的不同版本）编译同一个程序得到的结果也有可能不同，C语言有些语法特性在C标准中并没有明确规定，各编译器有不同的实现，编译出来的指令的行为特性也会不同，应该尽量避免使用不可移植的语法特性。 总结一下编译执行的过程，首先你用文本编辑器写一个C程序，然后保存成一个文件，例如 program.c （通常C程序的文件名后缀是 .c ），这称为源代码（Source Code）或源文件，然后运行编译器对它进行编译，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，再加上一些描述信息，生成一个新的文件，例如 a.out ，这称为可执行文件，可执行文件可以被操作系统加载运行，计算机执行该文件中由编译器生成的指令，如下图所示： 有些高级语言以解释（Interpret）的方式执行，解释执行过程和C语言的编译执行过程很不一样。例如编写一个Shell脚本 script.sh ，内容如下： #! /bin/sh VAR = 1 VAR = $(( $VAR + 1 )) echo $VAR 定义Shell变量 VAR 的初始值是1，然后自增1，然后打印 VAR 的值。用Shell程序 /bin/sh 解释执行这个脚本，结果如下： $ / bin / sh script . sh 2 这里的 /bin/sh 称为解释器（Interpreter），它把脚本中的每一行当作一条命令解释执行，而不需要先生成包含机器指令的可执行文件再执行。如果把脚本中的这三行当作三条命令直接敲到Shell提示符下，也能得到同样的结果： $ VAR = 1 $ VAR = $ (( $ VAR + 1 )) $ echo $ VAR 2 编程语言仍在发展演化。以上介绍的机器语言称为第一代语言（1GL，1st Generation Programming Language），汇编语言称为第二代语言（2GL，2nd Generation Programming Language），C、C++、Java、Python等可以称为第三代语言（3GL，3rd Generation Programming Language）。目前已经有了4GL（4th Generation Programming Language）和5GL（5th Generation Programming Language）的概念。3GL的编程语言虽然是用语句编程而不直接用指令编程，但语句也分为输入、输出、基本运算、测试分支和循环等几种，和指令有直接的对应关系。而4GL以后的编程语言更多是描述要做什么（Declarative）而不描述具体一步一步怎么做（Imperative），具体一步一步怎么做完全由编译器或解释器决定，例如SQL语言（SQL，Structured Query Language，结构化查询语言）就是这样的例子。 解释执行的语言相比编译执行的语言有什么优缺点？ 这是我们的第一个思考题。本书的思考题通常要求读者系统地总结当前小节的知识，结合以前的知识，并经过一定的推理，然后作答。本书强调的是基本概念，读者应该抓住概念的定义和概念之间的关系来总结，比如本节介绍了很多概念：程序由语句或指令组成，计算机只能执行 低级语言 中的指令（汇编语言的指令要先转成机器码才能执行），高级语言要执行就必须先翻译成低级语言，翻译的方法有两种：编译和解释，虽然有这样的不便，但高级语言有一个好处是平台无关性。什么是平台？一种平台，就是一种体系结构，就是一种指令集，就是一种机器语言，这些都可看作是一一对应的，上文并没有用“一一对应”这个词，但读者应该能推理出这个结论，而高级语言和它们不是一一对应的，因此高级语言是平台无关的，概念之间像这样的数量对应关系尤其重要。那么编译和解释的过程有哪些不同？主要的不同在于什么时候翻译和什么时候执行。 现在回答这个思考题，根据编译和解释的不同原理，你能否在执行效率和平台无关性等方面做一下比较？ 程序的调试 编程是一件复杂的工作，因为是人做的事情，所以难免经常出错。据说有这样一个典故：早期的计算机体积都很大，有一次一台计算机不能正常工作，工程师们找了半天原因最后发现是一只臭虫钻进计算机中造成的。从此以后，程序中的错误被叫做臭虫（Bug），而找到这些Bug并加以纠正的过程就叫做调试（Debug）。有时候调试是一件非常复杂的工作，要求程序员概念明确、逻辑清晰、性格沉稳，还需要一点运气。调试的技能我们在后续的学习中慢慢培养，但首先我们要区分清楚程序中的Bug分为哪几类。 编译时错误 编译器只能翻译语法正确的程序，否则将导致编译失败，无法生成可执行文件。对于自然语言来说，一点语法错误不是很严重的问题，因为我们仍然可以读懂句子。而编译器就没那么宽容了，只要有哪怕一个很小的语法错误，编译器就会输出一条错误提示信息然后罢工，你就得不到你想要的结果。虽然大部分情况下编译器给出的错误提示信息就是你出错的代码行，但也有个别时候编译器给出的错误提示信息帮助不大，甚至会误导你。在开始学习编程的前几个星期，你可能会花大量的时间来纠正语法错误。等到有了一些经验之后，还是会犯这样的错误，不过会少得多，而且你能更快地发现错误原因。等到经验更丰富之后你就会觉得，语法错误是最简单最低级的错误，编译器的错误提示也就那么几种，即使错误提示是有误导的也能够立刻找出真正的错误原因是什么。相比下面两种错误，语法错误解决起来要容易得多。 运行时错误 编译器检查不出这类错误，仍然可以生成可执行文件，但在运行时会出错而导致程序崩溃。对于我们接下来的几章将编写的简单程序来说，运行时错误很少见，到了后面的章节你会遇到越来越多的运行时错误。读者在以后的学习中要时刻 注意区分编译时和运行时（Run-time）这两个概念 ，不仅在调试时需要区分这两个概念，在学习C语言的很多语法时都需要区分这两个概念，有些事情在编译时做，有些事情则在运行时做。 逻辑错误和语义错误 第三类错误是逻辑错误和语义错误。如果程序里有逻辑错误，编译和运行都会很顺利，看上去也不产生任何错误信息，但是程序没有干它该干的事情，而是干了别的事情。当然不管怎么样，计算机只会按你写的程序去做，问题在于你写的程序不是你真正想要的，这意味着程序的意思（即语义）是错的。找到逻辑错误在哪需要十分清醒的头脑，要通过观察程序的输出回过头来判断它到底在做什么。 通过本书你将掌握的最重要的技巧之一就是调试。调试的过程可能会让你感到一些沮丧，但调试也是编程中最需要动脑的、最有挑战和乐趣的部分。从某种角度看调试就像侦探工作，根据掌握的线索来推断是什么原因和过程导致了你所看到的结果。调试也像是一门实验科学，每次想到哪里可能有错，就修改程序然后再试一次。如果假设是对的，就能得到预期的正确结果，就可以接着调试下一个Bug，一步一步逼近正确的程序；如果假设错误，只好另外再找思路再做假设。“当你把不可能的全部剔除，剩下的——即使看起来再怎么不可能——就一定是事实。”（即使你没看过福尔摩斯也该看过柯南吧）。 也有一种观点认为，编程和调试是一回事，编程的过程就是逐步调试直到获得期望的结果为止。你应该总是从一个能正确运行的小规模程序开始，每做一步小的改动就立刻进行调试，这样的好处是总有一个正确的程序做参考：如果正确就继续编程，如果不正确，那么一定是刚才的小改动出了问题。例如，Linux操作系统包含了成千上万行代码，但它也不是一开始就规划好了内存管理、设备管理、文件系统、网络等等大的模块，一开始它仅仅是Linus Torvalds用来琢磨Intel 80386芯片而写的小程序。据Larry Greenfield 说，“Linus的早期工程之一是编写一个交替打印AAAA和BBBB的程序，这玩意儿后来进化成了Linux。”（引自The Linux User's Guide Beta1版）在后面的章节中会给出更多关于调试和编程实践的建议。 变量及其行为 变量（Variable）是编程语言最重要的概念之一。 变量是计算机存储器中的一块命名的空间，可以在里面存储一个值（Value），存储的值是可以随时变的，比如这次存个字符 'a' 下次存个字符 'b' ，正因为变量的值可以随时变所以才叫变量。 也就是说，变量有一个储存地址，该地址储存的值是可以改变的。或者说，变量是一种使用方便的占位符，用于引用计算机内存地址，变量创建后会占用一定的内存空间。 不要弄混变量和变量名，变量名是标识符的一种。 占位符 ：先占住一个固定的位置，等待值添加到该位置的符号。 变量的类型决定了它所占的存储空间的大小。 变量的行为一共有四种：声明、定义、初始化、赋值。 声明 ：告诉编译器/解析器有这个变量的存在，这个行为不分配内存空间。 定义 ：为变量分配内存空间。 实际上，从广义的角度来说，声明有两种： 引用性声明（defining declaration）：不需要建立储存空间的声明，例如 extern in a 中的变量 a 已经在别的文件中被定义。 定义性声明（referencing declaration）：需要建立储存空间的声明，例如 int a 在声明时就建立了 a 的储存空间。 可见从广义的角度来说，声明包含了定义，而并非所有的声明都是定义。一般的情况下我们常常这样叙述，把建立空间的声明称之为\"定义\"，而把不需要建立存储空间称之为\"声明\"。 定义和声明的本质区别就是：定义会给变量分配内存空间，而声明则不会。 初始化 ：在定义变量之后，系统为变量分配的内存空间内并没有值，此时值是不确定的。为保证程序的安全性和确定性，需要对这个内存空间进行初始化。初始化一般伴随着定义而产生。初始化是从无到有的过程。 如果变量的定义没有初始化，那这个最初分配的空间的值是随机的（空间上原来存储的值）。不经过初始化的变量可能会为程序带来不安全与不确定性。 赋值 ：赋值是变量值得刷新操作。赋值是从旧到新的过程。 基础概念（python） assignment ：Assignments do not copy data — they just bind names to objects. assignment操作不会拷贝，只是把名字和对象做一个绑定。也就是assignment语句是起一个绑定或重绑定的作用（bind or rebind）。函数调用的参数传递是传引用，不是拷贝。 引用（reference ） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。因此，引用亦常被称为==该资料==的 指标 或 位址 。 标识符（identifier，缩写为ID） ：又称为识别码，是一个用来识别不同对象的名称。 在编程语言中，标识符就是程序员自己规定的具有特定含义的词，比如函数名、方法名、类名，变量名、常量名等。 对象（object） ：是一个记忆体位址，其中拥有值，这个位址可能有标识符指向此处。台湾译作物件。对象是某个类的实例。我们将数据和对数据的操作融为一体，形成具有静态信息和动态行为的对象。 每个对象都具有一个ID、一个类型、一个值。对象一旦建立，ID便不会改变。这里所说的ID是是对象在内存中的地址，而不是identifier。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 标识符并不是对象的属性，一个对象可以指向不同的标识符。而管理这些名字（标识符）的事物就是“命名空间”。 命名空间（Namespace） ：名字（标识符）到对象的==映射==。 A namespace is a mapping from names to objects. 各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。 现今 Python 的大部分命名空间是通过字典来实现的，也即一个命名空间就是名字到对象的映射，标识符是键，对象则是值。 与命名空间相对的一个概念就是“作用域” 。 作用域（Scope） ：本质是一块文本区域，Python 通过该文本区域可以 直接访问 相应的命名空间。 直接访问 ：Python 中不加 . 的访问为直接访问，反之为属性访问。 命名空间与作用域的联系 ：作用域是 Python 的一块文本区域，即一块代码区域，需要代码区域引用名字（标识符）来访问变量，那么作用域与命名空间之间就有了联系。 名字作用域 ：名字可以影响到的代码文本区域。 命名空间的作用域 ：就是这个命名空间可以影响到的代码文本区域。 显然可以存在这样的一个代码文本区域，它可以被多个命名空间影响。 面向对象编程 ：基于对象概念来分析问题和设计解法，这就是面向对象编程（object-orientation programming，简称OOP）。通过OOP所得到的程序是一个由很多对象组成的系统，可以向对象发送消息来实现对数据的处理，全体对象通过相互协作来完成程序的数据处理功能。 面向过程编程 ：得到的程序是一组对数据进行操作的过程，通过按顺序执行这些过程来实现程序功能。 类的概念 类是类型概念的发展。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 用计算机解决问题时，首先需要明确问题中涉及哪些数据，并在程序中将这些数据用编程语言提供的数据类型表示出来，然后再去考虑需要对这些数据执行何种操作。 为了表示数据，编程语言一般提供若干 基本数据类型 （如Python的int、float、str和list等类型） ，并为这些基本类型提供相应的基本操作（如Python中对int、float、str和list都提供了+运算，尽管含义不同）。 然而，实际问题中往往涉及很复杂的数据，不能用基本数据类型直接表示。为了表示复杂数据，大体有两种办法： 一种是将复杂数据分解成若干个简单数据项，以便每个数据项可以用基本类型表示 另一种是由用户自定义新的数据类型，以便对复杂数据进行直接的、整体的表示。 例如，如果要表示一个学生的姓名，可以简单地用一个字符串数据表示；如果要表示一个学生的年龄，可以简单地用一个整数数据表示。但如果要整体表示一个“学生”，包括该学生的姓名、年龄、地址等信息，就没法用基本数据类型直接表示了。 一种解决办法是将整体的“学生”分解成姓名、年龄、地址等简单数据，并通过分别处理这些简单数据而达到处理“学生”数据的目的。但这不是好办法，因为这种表示法丢失了数据的整体性，在维护姓名、年龄、地址等数据间的联系时很麻烦。 另一种解决办法是将学生整体视为一个数据值，并为这种数据值定义新的数据类型（因为编程语言中没有现成的类型能够表示该数据）。 假设我们要为“学生“数据定义一个新的数据类型S，那么S应该是由若干更简单的数据项构成的（如学号、姓名等），我们称这些构成S的成员数据为S的属性。除了定义S类型数据的属性，还需要定义能对S数据执行什么操作（如修改姓名或年龄、读取地址等）。可以利用编程语言提供的基本类型和新类型定义机制来实现S，例如用str类型表示姓名和学号，用int类型表示年龄之类，用函数实现对S数据的操作。定义了S，就好像为编程语言添加了一个新的数据类型，应用程序就可以像使用整数、字符串等基本类型一样去使用S。 由此，我们从传统的数据类型概念发展出了“类”的概念。类（class）是广义的数据类型，能够定义复杂数据的特性，包括静态特性（即数据）和动态特性（即对数据的操作方法）。 类的值就是“对象”，也称为类的实例。 对象 vs 变量 python的入门者可能很容易把变量和对象混为一谈，实际上，可以说python中不存在变量这样的概念，所谓的变量实质上是对象的名字。 在python中，对象属于某一个类型，而变量是没有类型的。所有的变量都是内存中一个对象的“引用”，也就是说变量的值实际上是对象的地址，而不是对象本身的值。 例如： nfoo = 1 #一个指向int数据类型的nfoo（再次提醒，nfoo没有类型），在这里，具有类型的是1 lstFoo = [ 1 ] #一个指向list类型的lstFoo，这个list中包含一个整数1 可更改(mutable) vs 不可更改(immutable) 在python中，strings、tuples、numbers是不可更改(immutable)的对象，而list、dict等则是可以修改(mutable)的对象。那么，这些所谓的可改变和不可改的本质是什么呢？ mutable、immutable只是python语言的一个规定。从硬件角度说，硬件提供给用户的接口是按照规定设定好的。比如说，操作内存的方式是固定的，不存在可变和不可变。实现python的可变、不可变就是调用了不同的底层api，或者是不同底层api相互组合来实现的。python将这些规定以python语法的形式提供给用户使用，最后还是编译成0、1去让计算机执行。对于用户来说，可变和不可变对象是语言提供的一个特性，可以完成一些功能，但是对于计算机其实是没区别的。 而在python中，不可变就是对象本身无法被修改，比如对象的值无法被修改。修改不可变对象只能创建新对象，旧对象若没有引用，则会被内存回收机制销毁。而可变对象的值是可以修改的。 接下来看一个例子： nfoo = 1 nfoo = 2 lstFoo = [ 1 ] lstFoo [ 0 ] = 2 代码第2行中，内存中原始的1对象因为不能改变，于是被“抛弃”，另nfoo指向一个新的int对象，其值为2。 代码第5行中，更改list中第一个元素的值，因为list是可改变的，所以，第一个元素变更为2。其实应该说，lstFoo指向一个 列表对象 。赋值所发生的事情，lstFoo所指向的列表对象的第一个元素被替换为新的值，但是对于lstFoo本身来说，它的值（列表的地址）没有变换，只是列表对象的内容发生变化了。 如下图所示： 但有时候，即使对象被复制了，修改原对象，两个变量指向的对象都改变了，怎么回事？ def fun2 (): a = [ 1 , 2 , 3 ,[ 1 , 2 ]] b = a . copy () a [ 1 ] = a [ 3 ][ 0 ] = 10 print ( a , ' \\n ' , b ) def fun2_2 (): a = [ 1 , 2 , 3 ,[ 1 , 2 ]] b = a . copy () a [ 1 ] = a [ 3 ] = 10 print ( a , ' \\n ' , b ) 上面定义了两个函数，两个函数输出的结果会一样吗？让我们看看： fun2 ------------------- [ 1 , 10 , 3 , [ 10 , 2 ]] [ 1 , 2 , 3 , [ 10 , 2 ]] fun2_2 ------------------- [ 1 , 10 , 3 , 10 ] [ 1 , 2 , 3 , [ 1 , 2 ]] 为什么 fun2 中b的第2个元素的值不变，而第四个元素的值却被改变了，而在 fun2_2 中b的值都没变？ 因为list储存的不是值，而是对象的引用。 Python的函数参数传递：传值？引用？ python函数参数传递可以理解为就是变量传值操作，入门者可能会发现，不可变对象作为参数，看似是传引用；而可变对象作为参数，看似是传值。举一个例子： 不可变对象参数调用 def ChangeInt ( a ): a = 10 nfoo = 2 ChangeInt ( nfoo ) print nfoo #结果是2 这时发生了什么？让我们看一下 nfoo 和 a 实际的值的变化： nfoo = 2 # nfoo：对象2的地址 # 进行传参： a = nfoo # 函数参数a：对象2的地址 # 对a进行赋值 a = 10 # 函数参数a：对象10的地址；此时，nfoo的值：对象2的地址 也就是说，当 nfoo 传参给 ChangeInt() 的时候，是传递了 nfoo 的值，是 值传递 。如下图： 因为对象是不可变的，所以对b重新赋值的时候，只能创建一个新的对象10，将对象10放进新的地址，而不是将储存于1的地址的值删除，再把10放进1的地址。 但可变对象不同于不可变对象： 可变对象参数调用 def ChangeList ( a ): a [ 0 ] = 10 lstFoo = [ 2 ] ChangeList ( lstFoo ) print lstFoo #结果是[10] 这时发生了什么？让我们看一下 nfoo 和 a 实际的值的变化： lstFoo = [ 2 ] # nfoo：对象[2]的地址 # 进行传参： a = lstFoo # 函数参数a：对象[2]的地址 # 对a进行赋值 a [ 0 ] = 10 # 函数参数a：对象[2]的地址；此时，nfoo的值：对象[2]的地址 当 lstFoo 传参给 ChangeList() 的时候， 变量仍旧是“传值” ，a复制了变量 lstFoo 的值，于是 a 和 lstFoo 指向同一个对象，但是，list是可以改变的对象，对 a[0] 进行赋值，就是更改原对象的值，而 lstFoo 也指向原对象。于是，这时的 a[0] = 10 ，就是更改了 lstFoo 指向的对象的第一个元素。所以，再次输出 lstFoo 时，显示 [10] ，因此，看起来是 lstFoo 的值改变了。但实际上 lstFoo 的值还是原对象的地址， lstFoo 的值并没有改变，改变的是对象。 综上所以，python的传参，传进去的是name（变量）的值，而name的值是object的引用。也就是说，传参传的是name的值（object的引用）。传参无法把对象的值传进去。","text_tokens":["changelist","不到","由","转换成","利用","普通","一对","是因为","本质区别","属性","沉稳","新","实例","定性","5","这种","学习","objects","发现","一一对","屏幕","确定","包含","之后","建议","性","后面","机制","模块","原","把子","后缀","time","上万","一体","mapping","使用方便","即","这时","原始","一只","你","帮助","orientation","引自","严重","等待","应用","想要","做","标识符","这里","给","mutable","经过","行程","上文","各个","代码","、","初始","它","立刻","无法","逻辑","生成","从无到有","很大","语义","对象","指令","涉及","何种","完成","时间","到底","哪里","因此","一代","没法用","剔除","#","id","names","此时","假设","字典","第二代","imperative","观点",":","基础","第一","assignments","自然","scope","提醒","set","在于","或者说","避免","出错","固定","越来","源代码","哪","接下来","初始值","循环","顺利","却","编程序","非常复杂","叫做","线索","extern","按","/","接着","a0","乐趣","宽容","装置","指向","链接","吗","不变","一块","do","汇编器","declaration","提示","from","很小","资料","任何","3","sql","显示","3gl","半天","很多","提示符","真正","操作","达到","来","内","亦","program","整体","总是","几个","出","print","敲到","翻译成","体系结构","会少","非常","系统地","据","变量名","演化","剩下","进行","完全","in","部分","下面","方面","2gl","区别","琢磨","改","08","便","掌握","其值","引用","命名","之间","本","整数","读者","一旦","符","紧凑","0x804a01c","三条","含义","目前","影响","?","形成","常量","变化","或重","语言","实验","处理","怎么样","得不到","最后","bug","一台","可更改","可读性","转","一行","成千","torvalds","当前","changeint","自定义","记忆体","慢慢","会犯","逼近","这类","n","编程","章节","优点","直观","内部","code","意味","以上","名字","实践","解析器","例如","本书","侦探","目的","发送到","1st","来说","时候","tuples","之为","必须","对于","行","称为","芯片","nfoo","向","很","总有","常常","为什么","创建","表格","第三代","data","方式","说","识别","numbers","调用","看作","原理","消息","但","名称","!","识别码","行为","语法错误","找到","变","才能","命令","抽象","小端","只好","重新","钻进","都","丢失","相应","臭虫","仅仅","value","第三类","最早","oop","起来","传统","数字","保存","必然","重复","行中","怎么","一一","从根本上","明确","常","编程语言","只能","中一","一定","包括","学号","回收","数据","能否","时刻","里","portable","觉得","得到","区分","查","计算","角度","刷新","分为","bin","福尔","float","条件","通过观察","不过","回过头来","larry","看出","接下","输入","获取数据","移植","自定","不出","观察","通常","确定性","见","还","柯南","在","前","不用","a","送到","其中","刚才","错误信息","一般","填","解法","能","曾","每","面向","实际上","此外","声明","介绍","output","input","好","the","程序","声音","；","相当","称之为","实现","词有","占用","错","无关","没变","器写","第一条","直到","效率","意思","？","若","defining","形式","标识","及其","查询","理解","让","再试一次","也就是说","内存地址","构成","以后","推断","乘除","source","不仅","_","关系密切","传","注意","例外","综上","一条","机器指令","思考题","相互协作","解析","1c","体性","just","协作","绑定","其次","只是","访问","一一对应","instruction","%","到","然而","文件名","间","参数","从此以后","动态","文档","读取","文本","就是","办法","将","元素","变换","助记符","号","仍然","被","class","占","看起来","应用程序","体积","几种","=","重名","一些",",","看上","$","举","正","内存","关系","好像","所以","语法","找出","科学","小规模","数","正常","执行","设计","不能","尽量","直接","输出","要求","数据处理","三类","举个","失败","大量","存","尽管","里面","指示","1gl","assignment","赋值","会为","则","体系","可见","第三","越来越","发现错误","指","上表","哪些","intel","思路","标准","误导","查找","看过","查表","静态","编写","测试","第二","人","现成","这些","汇编","“","看","architecture","获得","各","加载","a1","原因","脚本","期望","决定","解决","解方程","shell","摩斯","去","个","随机","这是","referencing","稍加","那么","整体性","很少","identifier","最初","位址","情况","操作方法","variable","开发","]","找","格式","替换","自然语言","地用","错误","因为","与","相比","工作","运气","没","间接","本身","层层","下","计算机","成","事物","转成","第一代","某","\\","产生","比如","一门","之类","不","而","专门","一点","经验","可能","immutable","伴随","四个","中间","功能","有时候","同样","是","看看","中要","绝大部分","数据项","加上","第","两种","纠正","数传","(","还是","反之","再","可变","逐步","考虑","大小","更改","作答","初始化","拥有","首先","混为","姓名","早期","星期","回过","助记","指令集","80386","解释器","特定","表示","值","5gl","并非","分别","足够","沮丧","小","建立","顺序","或","high","一样","句子","不便","而是","数量","可移植","04","int","保证","编译","运行","vs","重要","改动","网络","物件","有","当作","推理","一次","学生","字符","这次","哪怕","用户","某种","时","linus","拷贝","generation","system","相同","operating","培养","写","实质","2nd","占住","继续","读懂","释器","称","5th","机器码","造成","大","汇编程序","旧到","作为","安全","or","以便","programming","—","一种","个别","各自","基于","原来","copy","is","如何","想到","回事","大体","多","其它","把","挑战","编译成","通过","操作系统","传递","落差","程序员","用","就","之一","头脑","过","广义","低级语言","台湾","为止","函数参数","认为"," ","判断","后","开始","分解","机器语言","具有","过头","strings","过程","另","platform","入门者","方法","\"","一个","用来","一步","数学","明确规定","从","大部","改正","以","规定","行文","lstfoo","回答","一下","比较","现在","文件系统","目标","不加","着","low","下次","object","图像","理应","相对","reference","那","源文件","可","概念","虽然","dict","视为","地址","删除","存储","4gl","清醒","具体","fun2","同于","进去","linux","发展","structured","只会","先占住","方程","全体","compiler","需要","数字电路","出来","to","发生","不同于","清晰","看似","只有","仍旧","以下","转换","数字电","guide","底层","存储器","其实","密切","不要","先生","存入","第一个","什么","declarative","+","然后","我们","位置","not","beta1","本质","一系列","echo","系统","弄混","某个","如果","像是","statement","其他","设备","词","此处","算机","字符串","翻译","等等","并","一组","指标","上","更强","参考","同一个","会","内存空间","str","入门","复杂","script","更","语句","该","看到","单词","了","rebind","存储空间","机器","容易","二代","比","电脑","sh","一","结构","-","成人","换成","它们","放进","检查","再次","融为","缺点","看起",".","电路","compile","，","像","这","bind","程式","好处","缩写","抛弃","每个","用于","三代","基本概念","信息","会花","s","于","对应","任务","角度看","用到","后续","最","c语言","甚至","定义","解决办法","往往","名","福尔摩斯","只","提供","安全性","是从","不确定性","自增","丰富","巨大","组合","图","添加","aaaa","尽量避免","简称","按照","需","汇编语言","叫","几类","大部分","若干个","查询语言","记忆","实际","和","思考","发生变化","映射","各种","听到","有时","接口","尤其","independent","没法","们","呢","上去","得","assembly","或者","成员","变量","交替","1","正确","var","加以","别的","强调","组成","对","结合","简单","主要","name","动脑","显然","解决问题","规模","属于","已经","加减乘除","函数","遇到","中是","作用","占位","定义新","0","当然","编写程序","第四","结构化","可读","先","成千上万","中不加","获取","当","不管","有些","经常","一件","融为一体","也","可以","抓住","销毁","interpret","还要","b","若干","变更","函数调用","储存","所示","导致","绝大","greenfield","query","多个","c","性格","列表","基本操作","花","编译器","所有","麻烦","使用","如学","没有","十六进制","独立","传值","清楚","千上万","于是","eax","分支","值得","起","难免","怎么回事","这个","def","技巧","类名","崩溃","由此","5.1","这样","两个","上面","看上去","发送","给出","小节","调试","可执行文件","文本编辑","修改","一共","旧","第四个","年龄","interpreter","三行","python","打印","工程","从此","api","user","但是","比如说","不同","才","据说","另外","基本","又","namespace","否则","知识","个字符",";","类型定义","驱动程序","传参","解释","结论","4th","assembler","联系","如下","方便","多种","所谓","mnemonic","类型","全部","时会","这么","地","下来","类","分配内存","进化","后来","执行程序","告诉","现今","优缺点","仍","典故","中","感到","几章","事实","等","预期","区域","工程师","叙述","即使","设定","快","进制","能够","一系","技能","为了","干","等到","之所以","带来","维护","而言","machine","数据表","level","关于","改变","生变","out","一般而言","只要","所说","总结","language","十分","相互","误信","节","随时","内容","分解成","事情","替换成","存在","就是说","参数传递",")","数据表示","2","list","混为一谈","自己","bbbb","传参传","they","高级","符号","多么","写出","硬件","器","键","复制","应该","低级","特性","数据类型","意味着","分配","问题","根据","java","3rd","表示法","movl","run","除了","加减","'","版本","c++","例子","规划","四种","少数","提示信息","管理","同一","系列","如","结果","应","中将","分析","版","考题","10","键盘","不可","存取","要","所","子","不会","[","最有","空间","每次","玩意儿","。","运算","实体","驱动","（","）","而且","罢工","译作","就要","平台","文件","：","译成","作用域","面向对象编程","编辑","的","玩意","十六","debug","根本","吧","以前","描述","为","”","不是"],"title":"1.2.基本概念","title_tokens":["基本",".","概念","1.2","基本概念"]},{"location":"计算机基础/1.2.基本概念.html#_1","text":"程序（Program） 告诉计算机应如何完成一个计算任务，这里的计算可以是数学运算，比如解方程，也可以是符号运算，比如查找和替换文档中的某个单词。从根本上说，==计算机是由数字电路组成的运算机器，只能对数字做运算，程序之所以能做符号运算，是因为符号在计算机内部也是用数字表示的。==此外，程序还可以处理声音和图像，声音和图像在计算机内部必然也是用数字表示的，这些数字经过专门的硬件设备转换成人可以听到、看到的声音和图像。 程序由一系列 指令（Instruction） 组成，指令是指示计算机做某种运算的命令，通常包括以下几类： 输入（Input）：从键盘、文件或者其它设备获取数据。 输出（Output）：把数据显示到屏幕，或者存入一个文件，或者发送到其它设备。 基本运算：执行最基本的数学运算（加减乘除）和数据存取。 测试和分支：测试某个条件，然后根据不同的测试结果执行不同的后续指令。 循环：重复执行一系列操作。 对于程序来说，有上面这几类指令就足够了。你曾用过的任何一个程序，不管它有多么复杂，都是由这几类指令组成的。程序是那么的复杂，而编写程序可以用的指令却只有这么简单的几种，这中间巨大的落差就要由程序员去填了，所以编写程序理应是一件相当复杂的工作。 编写程序可以说就是这样一个过程：把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。 编程语言 ：编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。 机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，==语句是计算机指令的抽象表示。==举个例子，同样一个语句用C语言、汇编语言和机器语言分别表示如下： 低级编程语言使用计算机指令编写程序； 高级编程语言使用语句编写程序。 计算机只能对数字做运算，符号、声音、图像在计算机内部都要用数字表示，指令也不例外，上表中的机器语言完全由十六进制数字组成。最早的程序员都是直接用机器语言编程，但是很麻烦，需要查大量的表格来确定每个数字表示什么意思，编写出来的程序很不直观，而且容易出错，于是有了==汇编语言，把机器语言中一组一组的数字用助记符（Mnemonic）表示，直接用这些助记符写出汇编程序，然后让汇编器（Assembler）去查表把助记符替换成数字，也就把汇编语言翻译成了机器语言。== 从上面的例子可以看出， 汇编语言和机器语言的指令是一一对应的，汇编语言有三条指令，机器语言也有三条指令，汇编器就是做一个简单的替换工作 ，例如在第一条指令中，把 movl ?,%eax 这种格式的指令替换成机器码 a1 ? ，?表示一个地址，在汇编指令中是 0x804a01c ，转换成机器码之后是 1c a0 04 08 （这是指令中的十六进制数的小端表示，小端表示将在 第 5.1 节 “目标文件” 介绍）。 从上面的例子还可以看出，==高级语言的语句和低级语言的指令之间不是简单的一一对应关系，==一条 a=b+1; 语句要翻译成三条汇编或机器指令，这个过程称为 编译（Compile） ，由编译器（Compiler）来完成，显然编译器的功能比汇编器要复杂得多。用高级语言编写的程序必须经过编译转成机器指令才能被计算机执行，编译需要花一些时间，这是用高级语言编程的一个缺点，然而更多的是优点。首先，用高级语言编程更容易，写出来的代码更紧凑，可读性更强，出了错也更容易改正。其次，高级语言是可移植的（Portable）或者称为平台无关的（Platform Independent）。 平台 这个词有很多种解释，可以指计算机体系结构（Architecture），也可以指操作系统（Operating System），也可以指开发平台（编译器、链接器等）。不同的计算机体系结构有不同的指令集（Instruction Set），可以识别的机器指令格式是不同的，直接用某种体系结构的汇编或机器指令写出来的程序只能在这种体系结构的计算机上运行，然而各种体系结构的计算机都有各自的C编译器，可以把C程序编译成各种不同体系结构的机器指令，这意味着用C语言写的程序只需稍加修改甚至不用修改就可以在各种不同的计算机上编译运行。各种高级语言都具有C语言的这些优点，所以绝大部分程序是用高级语言编写的，只有和硬件关系密切的少数程序（例如驱动程序）才会用到低级语言。还要注意一点，即使在相同的体系结构和操作系统下，用不同的C编译器（或者同一个C编译器的不同版本）编译同一个程序得到的结果也有可能不同，C语言有些语法特性在C标准中并没有明确规定，各编译器有不同的实现，编译出来的指令的行为特性也会不同，应该尽量避免使用不可移植的语法特性。 总结一下编译执行的过程，首先你用文本编辑器写一个C程序，然后保存成一个文件，例如 program.c （通常C程序的文件名后缀是 .c ），这称为源代码（Source Code）或源文件，然后运行编译器对它进行编译，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，再加上一些描述信息，生成一个新的文件，例如 a.out ，这称为可执行文件，可执行文件可以被操作系统加载运行，计算机执行该文件中由编译器生成的指令，如下图所示： 有些高级语言以解释（Interpret）的方式执行，解释执行过程和C语言的编译执行过程很不一样。例如编写一个Shell脚本 script.sh ，内容如下： #! /bin/sh VAR = 1 VAR = $(( $VAR + 1 )) echo $VAR 定义Shell变量 VAR 的初始值是1，然后自增1，然后打印 VAR 的值。用Shell程序 /bin/sh 解释执行这个脚本，结果如下： $ / bin / sh script . sh 2 这里的 /bin/sh 称为解释器（Interpreter），它把脚本中的每一行当作一条命令解释执行，而不需要先生成包含机器指令的可执行文件再执行。如果把脚本中的这三行当作三条命令直接敲到Shell提示符下，也能得到同样的结果： $ VAR = 1 $ VAR = $ (( $ VAR + 1 )) $ echo $ VAR 2 编程语言仍在发展演化。以上介绍的机器语言称为第一代语言（1GL，1st Generation Programming Language），汇编语言称为第二代语言（2GL，2nd Generation Programming Language），C、C++、Java、Python等可以称为第三代语言（3GL，3rd Generation Programming Language）。目前已经有了4GL（4th Generation Programming Language）和5GL（5th Generation Programming Language）的概念。3GL的编程语言虽然是用语句编程而不直接用指令编程，但语句也分为输入、输出、基本运算、测试分支和循环等几种，和指令有直接的对应关系。而4GL以后的编程语言更多是描述要做什么（Declarative）而不描述具体一步一步怎么做（Imperative），具体一步一步怎么做完全由编译器或解释器决定，例如SQL语言（SQL，Structured Query Language，结构化查询语言）就是这样的例子。","text_tokens":["1","某种","由","转换成","var","generation","组成","system","对","相同","一对","看出","operating","是因为","输入","获取数据","简单","移植","显然","写","新","这种","属于","已经","加减乘除","2nd","一一对","屏幕","确定","中是","包含","释器","通常","5th","机器码","之后","还","汇编程序","在","把子","programming","后缀","编写程序","不用","a","送到","结构化","可读","获取","各自","不管","填","有些","一件","你","如何","也","可以","多","其它","能","曾","把","interpret","做","每","还要","b","此外","这里","经过","介绍","编译成","output","操作系统","落差","行程","程序员","代码","input","、","用","所示","它","初始","就","程序","过","绝大","声音","低级语言","生成","；"," ","相当","query","指令","分解","c","实现","词有","机器语言","完成","时间","具有","错","无关","花","编译器","过程","麻烦","器写","一代","platform","第一条","直到","#","使用","一个","一步","没有","十六进制","意思","数学","明确规定","第二代","从","大部","改正","imperative","于是","以","规定","第一","行文","eax","分支","查询","让","以后","一下","set","乘除","这个","避免","source","目标","出错","源代码","5.1","这样","关系密切","注意","例外","上面","发送","low","一条","初始值","机器指令","循环","可执行文件","却","1c","文本编辑","编程序","图像","修改","理应","interpreter","其次","/","三行","一一对应","a0","instruction","%","到","然而","python","源文件","打印","链接","概念","虽然","汇编器","文件名","提示","但是","地址","不同","文档","任何","才","4gl","文本","sql","具体","显示","就是","3gl","提示符","基本","发展","structured","将","操作","方程","助记符","来",";","被","program","compiler","需要","数字电路","驱动程序","解释","出来","出","几种","=","一些",",","只有","4th","敲到","assembler","$","以下","翻译成","转换","数字电","体系结构","如下","关系","所以","多种","语法","mnemonic","数","演化","全部","这么","进行","密切","执行","完全","尽量","直接","输出","存入","先生","部分","什么","举个","执行程序","告诉","2gl","大量","declarative","+","指示","然后","08","仍","1gl","中","之间","一系列","体系","echo","系统","某个","如果","紧凑","等","0x804a01c","第三","statement","三条","设备","目前","指","上表","?","算机","即使","翻译","标准","并","查找","一组","上","更强","语言","查表","同一个","编写","会","处理","测试","最后","复杂","script","进制","更","语句","一系","该","第二","可读性","这些","转","看到","单词","汇编","一行","之所以","了","“","机器","machine","容易","level","architecture","各","二代","加载","a1","比","out","脚本","决定","sh","解方程","shell","去","编程","优点","总结","language","结构","直观","这是","内部","-","code","意味","成人","以上","稍加","那么","换成","节","开发","例如","发送到","1st","内容","来说","格式","替换","分解成","缺点","替换成",".","电路","必须","对于","compile","因为","工作","称为","，","层层",")","这","2","下","计算机","很","每个","三代","成","高级","符号","多么","写出","硬件","信息","第一代","器","表格","对应","任务","第三代","比如","方式","不","应该","低级","而","说","识别","专门","特性","用到","意味着","一点","后续","最","c语言","根据","甚至","但","java","可能","定义","3rd","!","行为","movl","中间","功能","只","才能","加减","命令","版本","抽象","小端","c++","例子","同样","是","绝大部分","加上","都","巨大","第","少数","自增","图","同一","系列","(","结果","应","再","最早","尽量避免","需","汇编语言","数字","保存","键盘","不可","首先","必然","重复","存取","几类","要","怎么","一一","大部分","从根本上","子","明确","助记","编程语言","只能","查询语言","指令集","解释器","和","表示","包括","值","5gl","。","运算","分别","驱动","（","数据","足够","）","而且","各种","或","high","听到","就要","平台","一样","而是","文件","：","可移植","04","independent","portable","译成","得到","编辑","的","编译","运行","十六","查","根本","计算","得","有","当作","assembly","或者","分为","bin","描述","变量","”","不是","条件"],"title":"程序和编程语言","title_tokens":["编程语言","编程","语言","和","程序"]},{"location":"计算机基础/1.2.基本概念.html#_2","text":"这是我们的第一个思考题。本书的思考题通常要求读者系统地总结当前小节的知识，结合以前的知识，并经过一定的推理，然后作答。本书强调的是基本概念，读者应该抓住概念的定义和概念之间的关系来总结，比如本节介绍了很多概念：程序由语句或指令组成，计算机只能执行 低级语言 中的指令（汇编语言的指令要先转成机器码才能执行），高级语言要执行就必须先翻译成低级语言，翻译的方法有两种：编译和解释，虽然有这样的不便，但高级语言有一个好处是平台无关性。什么是平台？一种平台，就是一种体系结构，就是一种指令集，就是一种机器语言，这些都可看作是一一对应的，上文并没有用“一一对应”这个词，但读者应该能推理出这个结论，而高级语言和它们不是一一对应的，因此高级语言是平台无关的，概念之间像这样的数量对应关系尤其重要。那么编译和解释的过程有哪些不同？主要的不同在于什么时候翻译和什么时候执行。 现在回答这个思考题，根据编译和解释的不同原理，你能否在执行效率和平台无关性等方面做一下比较？","text_tokens":["要求","第一个","由","什么","第一","高级","转成","方面","基本概念","强调","然后","组成","对应","回答","比如","一对","我们","结合","应该","低级","主要","而","一下","中","之间","本","在于","读者","看作","这个","比较","现在","原理","根据","但","体系","系统","定义","一一对","这样","通常","等","机器码","性","词","才能","小节","思考题","在","算机","哪些","是","一种","翻译","两种","都","并","先","语言","一一对应","可","概念","虽然","汇编语言","你","语句","作答","考题","这些","抓住","能","汇编","做","了","“","不同","要","机器","当前","一一","经过","就是","介绍","很多","只能","上文","指令集","基本","一定","用","和","就","程序","知识","来","低级语言","。","总结","结构","思考","这是"," ","（","能否","）","解释","那么","它们","出","指令","或","节","平台","不便","机器语言","结论","数量","尤其","本书","：","无关","因此","翻译成","过程","译成","体系结构","时候","关系","的","编译","重要","必须","系统地","方法","一个","计算","没有","有","推理","效率","，","像","？","执行","以前","计算机","”","不是","好处"],"title":"解释执行的语言相比编译执行的语言有什么优缺点？","title_tokens":["有","解释","的","编译","缺点","？","执行","语言","什么","优缺点","相比"]},{"location":"计算机基础/1.2.基本概念.html#_3","text":"编程是一件复杂的工作，因为是人做的事情，所以难免经常出错。据说有这样一个典故：早期的计算机体积都很大，有一次一台计算机不能正常工作，工程师们找了半天原因最后发现是一只臭虫钻进计算机中造成的。从此以后，程序中的错误被叫做臭虫（Bug），而找到这些Bug并加以纠正的过程就叫做调试（Debug）。有时候调试是一件非常复杂的工作，要求程序员概念明确、逻辑清晰、性格沉稳，还需要一点运气。调试的技能我们在后续的学习中慢慢培养，但首先我们要区分清楚程序中的Bug分为哪几类。 编译时错误 编译器只能翻译语法正确的程序，否则将导致编译失败，无法生成可执行文件。对于自然语言来说，一点语法错误不是很严重的问题，因为我们仍然可以读懂句子。而编译器就没那么宽容了，只要有哪怕一个很小的语法错误，编译器就会输出一条错误提示信息然后罢工，你就得不到你想要的结果。虽然大部分情况下编译器给出的错误提示信息就是你出错的代码行，但也有个别时候编译器给出的错误提示信息帮助不大，甚至会误导你。在开始学习编程的前几个星期，你可能会花大量的时间来纠正语法错误。等到有了一些经验之后，还是会犯这样的错误，不过会少得多，而且你能更快地发现错误原因。等到经验更丰富之后你就会觉得，语法错误是最简单最低级的错误，编译器的错误提示也就那么几种，即使错误提示是有误导的也能够立刻找出真正的错误原因是什么。相比下面两种错误，语法错误解决起来要容易得多。 运行时错误 编译器检查不出这类错误，仍然可以生成可执行文件，但在运行时会出错而导致程序崩溃。对于我们接下来的几章将编写的简单程序来说，运行时错误很少见，到了后面的章节你会遇到越来越多的运行时错误。读者在以后的学习中要时刻 注意区分编译时和运行时（Run-time）这两个概念 ，不仅在调试时需要区分这两个概念，在学习C语言的很多语法时都需要区分这两个概念，有些事情在编译时做，有些事情则在运行时做。 逻辑错误和语义错误 第三类错误是逻辑错误和语义错误。如果程序里有逻辑错误，编译和运行都会很顺利，看上去也不产生任何错误信息，但是程序没有干它该干的事情，而是干了别的事情。当然不管怎么样，计算机只会按你写的程序去做，问题在于你写的程序不是你真正想要的，这意味着程序的意思（即语义）是错的。找到逻辑错误在哪需要十分清醒的头脑，要通过观察程序的输出回过头来判断它到底在做什么。 通过本书你将掌握的最重要的技巧之一就是调试。调试的过程可能会让你感到一些沮丧，但调试也是编程中最需要动脑的、最有挑战和乐趣的部分。从某种角度看调试就像侦探工作，根据掌握的线索来推断是什么原因和过程导致了你所看到的结果。调试也像是一门实验科学，每次想到哪里可能有错，就修改程序然后再试一次。如果假设是对的，就能得到预期的正确结果，就可以接着调试下一个Bug，一步一步逼近正确的程序；如果假设错误，只好另外再找思路再做假设。“当你把不可能的全部剔除，剩下的——即使看起来再怎么不可能——就一定是事实。”（即使你没看过福尔摩斯也该看过柯南吧）。 也有一种观点认为，编程和调试是一回事，编程的过程就是逐步调试直到获得期望的结果为止。你应该总是从一个能正确运行的小规模程序开始，每做一步小的改动就立刻进行调试，这样的好处是总有一个正确的程序做参考：如果正确就继续编程，如果不正确，那么一定是刚才的小改动出了问题。例如，Linux操作系统包含了成千上万行代码，但它也不是一开始就规划好了内存管理、设备管理、文件系统、网络等等大的模块，一开始它仅仅是Linus Torvalds用来琢磨Intel 80386芯片而写的小程序。据Larry Greenfield 说，“Linus的早期工程之一是编写一个交替打印AAAA和BBBB的程序，这玩意儿后来进化成了Linux。”（引自The Linux User's Guide Beta1版）在后面的章节中会给出更多关于调试和编程实践的建议。","text_tokens":["哪怕","不到","正确","某种","通过观察","时","不过","linus","加以","别的","回过头来","larry","对","接下","简单","培养","动脑","沉稳","写","不出","学习","规模","发现","观察","遇到","继续","读懂","包含","之后","见","建议","还","造成","大","后面","柯南","模块","当然","在","前","—","time","上万","一种","个别","刚才","成千上万","错误信息","即","当","不管","经常","有些","一件","一只","你","帮助","想到","回事","引自","也","可以","严重","多","能","把","想要","做","每","挑战","通过","操作系统","程序员","代码","the","、","好","它","导致","就","之一","程序","头脑","立刻","无法","逻辑","生成","greenfield","为止","认为","；"," ","判断","很大","开始","语义","性格","时间","错","过头","到底","哪里","编译器","过程","剔除","直到","一个","用来","一步","没有","意思","假设","从","大部","清楚","观点","千上万","行文","让","再试一次","难免","自然","以后","在于","推断","技巧","崩溃","文件系统","不仅","出错","越来","这样","哪","注意","两个","看上去","一条","接下来","给出","顺利","调试","可执行文件","非常复杂","修改","叫做","线索","按","接着","乐趣","到","宽容","打印","概念","虽然","工程","从此","提示","user","但是","从此以后","很小","任何","清醒","据说","就是","半天","很多","另外","真正","linux","只会","将","操作","否则","来","仍然","被","需要","总是","看起来","几个","出","体积","几种","清晰","一些","看上","guide","会少","内存","所以","语法","非常","找出","科学","小规模","据","剩下","正常","全部","时会","进行","执行","地","不能","下来","输出","要求","部分","三类","什么","下面","进化","后来","失败","大量","琢磨","然后","我们","典故","掌握","中","beta1","感到","读者","几章","则","系统","事实","如果","预期","第三","像是","越来越","发现错误","设备","工程师","算机","即使","intel","思路","翻译","等等","误导","并","看过","参考","语言","实验","会","编写","快","得不到","怎么样","最后","bug","复杂","一台","人","更","能够","该","技能","这些","看到","成千","干","等到","了","“","torvalds","容易","获得","关于","原因","慢慢","会犯","只要","逼近","期望","解决","这类","一","摩斯","去","编程","章节","十分","-","意味","那么","很少","误信","情况","实践","例如","本书","侦探","检查","找","时候","来说","事情","看起","自然语言","错误","对于","因为","相比","工作","运气","没","行","，","像","芯片","这","下","计算机","很","好处","总有","bbbb","成","信息","会花","s","产生","一门","角度看","不","应该","低级","而","说","意味着","一点","后续","最","c语言","问题","甚至","但","根据","经验","可能","福尔摩斯","语法错误","run","找到","有时候","'","是","只好","规划","中要","钻进","丰富","都","纠正","提示信息","两种","管理","还是","aaaa","结果","臭虫","仅仅","再","第三类","逐步","起来","版","首先","几类","要","怎么","所","大部分","早期","星期","回过","明确","只能","80386","一定","最有","和","每次","玩意儿","。","（","里","）","而且","时刻","沮丧","小","罢工","有时","句子","而是","文件","：","觉得","得到","的","编译","运行","玩意","重要","区分","改动","debug","们","网络","吧","计算","上去","角度","得","有","一次","分为","福尔","”","不是","交替"],"title":"程序的调试","title_tokens":["调试","程序","的"]},{"location":"计算机基础/1.2.基本概念.html#_4","text":"变量（Variable）是编程语言最重要的概念之一。 变量是计算机存储器中的一块命名的空间，可以在里面存储一个值（Value），存储的值是可以随时变的，比如这次存个字符 'a' 下次存个字符 'b' ，正因为变量的值可以随时变所以才叫变量。 也就是说，变量有一个储存地址，该地址储存的值是可以改变的。或者说，变量是一种使用方便的占位符，用于引用计算机内存地址，变量创建后会占用一定的内存空间。 不要弄混变量和变量名，变量名是标识符的一种。 占位符 ：先占住一个固定的位置，等待值添加到该位置的符号。 变量的类型决定了它所占的存储空间的大小。 变量的行为一共有四种：声明、定义、初始化、赋值。 声明 ：告诉编译器/解析器有这个变量的存在，这个行为不分配内存空间。 定义 ：为变量分配内存空间。 实际上，从广义的角度来说，声明有两种： 引用性声明（defining declaration）：不需要建立储存空间的声明，例如 extern in a 中的变量 a 已经在别的文件中被定义。 定义性声明（referencing declaration）：需要建立储存空间的声明，例如 int a 在声明时就建立了 a 的储存空间。 可见从广义的角度来说，声明包含了定义，而并非所有的声明都是定义。一般的情况下我们常常这样叙述，把建立空间的声明称之为\"定义\"，而把不需要建立存储空间称之为\"声明\"。 定义和声明的本质区别就是：定义会给变量分配内存空间，而声明则不会。 初始化 ：在定义变量之后，系统为变量分配的内存空间内并没有值，此时值是不确定的。为保证程序的安全性和确定性，需要对这个内存空间进行初始化。初始化一般伴随着定义而产生。初始化是从无到有的过程。 如果变量的定义没有初始化，那这个最初分配的空间的值是随机的（空间上原来存储的值）。不经过初始化的变量可能会为程序带来不安全与不确定性。 赋值 ：赋值是变量值得刷新操作。赋值是从旧到新的过程。","text_tokens":["标识","常常","用于","时","分配内存","符号","告诉","创建","别的","区别","存","里面","产生","值得","对","也就是说","比如","我们","内存地址","位置","引用","不","本质区别","而","中","命名","赋值","新","或者说","本质","分配","定性","则","会为","最","这个","已经","系统","弄混","固定","占住","定义","可能","符","确定","如果","包含","行为","这样","可见","占位","确定性","着","伴随","之后","性","旧到","变","下次","在","'","安全","叙述","解析","算机","安全性","是","是从","a","一种","四种","不确定性","两种","都","并","一共","extern","上","使用方便","添加","一般","语言","/","会","为","内存空间","value","那","到","原来","概念","一块","叫","大小","该","初始化","declaration","可以","等待","地址","把","标识符","存储","了","带来","b","存储空间","实际上","声明","所","才","给","经过","就是","不会","储存","编程语言","改变","一定","、","先占住","决定","初始","它","空间","和","之一","实际","就","程序","操作","编程","值","个字符","广义","内","并非","。","被","随机","需要","从无到有"," ","占","（","referencing","）","后","建立","称之为","最初","情况","variable","占用","解析器","随时","例如","文件","：","编译器","int","所有","过程","保证","来说","方便","正","内存","的","所以","编译","之为","重要","存在","使用","因为","与","类型","\"","一个","计算","变量名","存储器","角度","没有","有","刷新","，","就是说","此时","进行","或者","不要","字符","这次","变量","defining","下","从","计算机","in"],"title":"变量及其行为","title_tokens":["及其","行为","变量"]},{"location":"计算机基础/1.2.基本概念.html#python","text":"assignment ：Assignments do not copy data — they just bind names to objects. assignment操作不会拷贝，只是把名字和对象做一个绑定。也就是assignment语句是起一个绑定或重绑定的作用（bind or rebind）。函数调用的参数传递是传引用，不是拷贝。 引用（reference ） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。因此，引用亦常被称为==该资料==的 指标 或 位址 。 标识符（identifier，缩写为ID） ：又称为识别码，是一个用来识别不同对象的名称。 在编程语言中，标识符就是程序员自己规定的具有特定含义的词，比如函数名、方法名、类名，变量名、常量名等。 对象（object） ：是一个记忆体位址，其中拥有值，这个位址可能有标识符指向此处。台湾译作物件。对象是某个类的实例。我们将数据和对数据的操作融为一体，形成具有静态信息和动态行为的对象。 每个对象都具有一个ID、一个类型、一个值。对象一旦建立，ID便不会改变。这里所说的ID是是对象在内存中的地址，而不是identifier。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 标识符并不是对象的属性，一个对象可以指向不同的标识符。而管理这些名字（标识符）的事物就是“命名空间”。 命名空间（Namespace） ：名字（标识符）到对象的==映射==。 A namespace is a mapping from names to objects. 各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。 现今 Python 的大部分命名空间是通过字典来实现的，也即一个命名空间就是名字到对象的映射，标识符是键，对象则是值。 与命名空间相对的一个概念就是“作用域” 。 作用域（Scope） ：本质是一块文本区域，Python 通过该文本区域可以 直接访问 相应的命名空间。 直接访问 ：Python 中不加 . 的访问为直接访问，反之为属性访问。 命名空间与作用域的联系 ：作用域是 Python 的一块文本区域，即一块代码区域，需要代码区域引用名字（标识符）来访问变量，那么作用域与命名空间之间就有了联系。 名字作用域 ：名字可以影响到的代码文本区域。 命名空间的作用域 ：就是这个命名空间可以影响到的代码文本区域。 显然可以存在这样的一个代码文本区域，它可以被多个命名空间影响。 面向对象编程 ：基于对象概念来分析问题和设计解法，这就是面向对象编程（object-orientation programming，简称OOP）。通过OOP所得到的程序是一个由很多对象组成的系统，可以向对象发送消息来实现对数据的处理，全体对象通过相互协作来完成程序的数据处理功能。 面向过程编程 ：得到的程序是一组对数据进行操作的过程，通过按顺序执行这些过程来实现程序功能。","text_tokens":["数据处理","标识","部分","某种","每个","由","规定","they","事物","assignments","现今","信息","拷贝","让","于","data","便","普通","对","键","比如","组成","起","我们","not","引用","scope","而","识别","assignment","中","数据类型","属性","实例","调用","命名","本质","之间","显然","则","直接","objects","这个","问题","类名","属于","一旦","消息","函数","但","系统","某个","名称","可能","识别码","等","行为","作用","传","这样","不加","名","发送","区域","其他","含义","功能","词","在","影响","or","此处","形成","相互协作","programming","—","是","a","object","都","常量","just","其中","并","管理","协作","数传","一组","一体","相对","指标","mapping","或重","绑定","一般","语言","静态","按","只是","会","访问","相应","中不加","即","反之","reference","处理","解法","到","python","基于","简称","装置","融为一体","指向","copy","概念","oop","一块","is","do","语句","分析","该","orientation","视为","也","可以","这些","地址","把","参数","拥有","from","做","标识符","了","“","存取","面向","而言","rebind","不同","资料","动态","任何","所","这里","大部分","文本","记忆体","就是","函数调用","不会","储存","常","通过","传递","编程语言","各个","很多","改变","电脑","程序员","中一","一般而言","代码","记忆","又","、","特定","将","操作","空间","和","就","namespace","它","程序","所说","来","值","编程","广义","大部","台湾","全体","。","被","亦","需要","实体"," ","-","（","数据","映射","）","那么","名字","建立","相互","to","对象","多个","顺序","或","identifier","位址","=","译作","重名","一样","实现","完成","联系","具有","：","因此","过程","作用域","面向对象编程","融为","内存","关系","得到","的","所以",".","存在","id","与","方法","间接","类型","一个","变量名","用来","物件","没有","names","有","称为","，","进行","参数传递","执行","字典","这","设计","变量","独立","向","bind","程式","为","”","类","不能","不是","自己","缩写"],"title":"基础概念（python）","title_tokens":["基础","python","概念","（","）"]},{"location":"计算机基础/1.2.基本概念.html#_5","text":"类是类型概念的发展。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 用计算机解决问题时，首先需要明确问题中涉及哪些数据，并在程序中将这些数据用编程语言提供的数据类型表示出来，然后再去考虑需要对这些数据执行何种操作。 为了表示数据，编程语言一般提供若干 基本数据类型 （如Python的int、float、str和list等类型） ，并为这些基本类型提供相应的基本操作（如Python中对int、float、str和list都提供了+运算，尽管含义不同）。 然而，实际问题中往往涉及很复杂的数据，不能用基本数据类型直接表示。为了表示复杂数据，大体有两种办法： 一种是将复杂数据分解成若干个简单数据项，以便每个数据项可以用基本类型表示 另一种是由用户自定义新的数据类型，以便对复杂数据进行直接的、整体的表示。 例如，如果要表示一个学生的姓名，可以简单地用一个字符串数据表示；如果要表示一个学生的年龄，可以简单地用一个整数数据表示。但如果要整体表示一个“学生”，包括该学生的姓名、年龄、地址等信息，就没法用基本数据类型直接表示了。 一种解决办法是将整体的“学生”分解成姓名、年龄、地址等简单数据，并通过分别处理这些简单数据而达到处理“学生”数据的目的。但这不是好办法，因为这种表示法丢失了数据的整体性，在维护姓名、年龄、地址等数据间的联系时很麻烦。 另一种解决办法是将学生整体视为一个数据值，并为这种数据值定义新的数据类型（因为编程语言中没有现成的类型能够表示该数据）。 假设我们要为“学生“数据定义一个新的数据类型S，那么S应该是由若干更简单的数据项构成的（如学号、姓名等），我们称这些构成S的成员数据为S的属性。除了定义S类型数据的属性，还需要定义能对S数据执行什么操作（如修改姓名或年龄、读取地址等）。可以利用编程语言提供的基本类型和新类型定义机制来实现S，例如用str类型表示姓名和学号，用int类型表示年龄之类，用函数实现对S数据的操作。定义了S，就好像为编程语言添加了一个新的数据类型，应用程序就可以像使用整数、字符串等基本类型一样去使用S。 由此，我们从传统的数据类型概念发展出了“类”的概念。类（class）是广义的数据类型，能够定义复杂数据的特性，包括静态特性（即数据）和动态特性（即对数据的操作方法）。 类的值就是“对象”，也称为类的实例。","text_tokens":["用户","某种","每个","由","什么","时","利用","+","信息","尽管","s","然后","普通","对","我们","之类","构成","简单","应该","而","属性","中","数据类型","特性","自定","新","实例","整数","这种","解决问题","问题","属于","由此","但","函数","定义","如果","表示法","解决办法","等","定义新","往往","称","还","含义","机制","除了","提供","在","以便","算机","哪些","字符串","是","体性","一种","两种","数据项","都","修改","并","添加","丢失","一般","语言","如","年龄","静态","相应","为","处理","即","str","再","然而","中将","python","不是","复杂","概念","考虑","传统","更","能够","该","大体","视为","现成","也","可以","这些","间","地址","能","应用","为了","首先","了","“","维护","动态","不同","要","姓名","若干","数据表","读取","自定义","就是","明确","通过","编程语言","若干个","基本","办法","发展","、","好","将","用","操作","实际","和","表示","解决","就","程序","达到","包括","去","号","编程","广义","值","来","。","学号","运算","整体","分别","类型定义","需要","class","；"," ","（","数据","）","那么","出来","应用程序","对象","出","分解","整体性","或","操作方法","一样","实现","涉及","何种","基本操作","联系","例如","：","因此","目的","int","麻烦","另","没法用","好像","分解成","的","地用","没法","使用","因为","类型","方法","一个","计算","如学","没有","有","学生","称为","，","进行","假设","像","执行","数据表示","这","字符","list","成员","float","不能","从","计算机","”","类","直接","很"],"title":"类的概念","title_tokens":["概念","类","的"]},{"location":"计算机基础/1.2.基本概念.html#vs","text":"python的入门者可能很容易把变量和对象混为一谈，实际上，可以说python中不存在变量这样的概念，所谓的变量实质上是对象的名字。 在python中，对象属于某一个类型，而变量是没有类型的。所有的变量都是内存中一个对象的“引用”，也就是说变量的值实际上是对象的地址，而不是对象本身的值。 例如： nfoo = 1 #一个指向int数据类型的nfoo（再次提醒，nfoo没有类型），在这里，具有类型的是1 lstFoo = [ 1 ] #一个指向list类型的lstFoo，这个list中包含一个整数1","text_tokens":["可以","名字","1","对象","地址","把","混为","=","“","在","实际上","lstfoo","某","容易","具有","]","例如","数据","是","：","这里","也就是说","所有","int","就是","都","再次","引用","不","提醒","而","说","中","内存","数据类型","的","上","整数","所谓","#","入门者","存在","实质","[","这个","实际","属于","和","类型","本身","一个","没有","值"," ","入门","可能","，","python","就是说","（","。","包含","指向","概念","这样","变量","nfoo","list","混为一谈","”","不是","很","）"],"title":"对象  vs  变量","title_tokens":["对象","vs","变量"," "]},{"location":"计算机基础/1.2.基本概念.html#mutable-vs-immutable","text":"在python中，strings、tuples、numbers是不可更改(immutable)的对象，而list、dict等则是可以修改(mutable)的对象。那么，这些所谓的可改变和不可改的本质是什么呢？ mutable、immutable只是python语言的一个规定。从硬件角度说，硬件提供给用户的接口是按照规定设定好的。比如说，操作内存的方式是固定的，不存在可变和不可变。实现python的可变、不可变就是调用了不同的底层api，或者是不同底层api相互组合来实现的。python将这些规定以python语法的形式提供给用户使用，最后还是编译成0、1去让计算机执行。对于用户来说，可变和不可变对象是语言提供的一个特性，可以完成一些功能，但是对于计算机其实是没区别的。 而在python中，不可变就是对象本身无法被修改，比如对象的值无法被修改。修改不可变对象只能创建新对象，旧对象若没有引用，则会被内存回收机制销毁。而可变对象的值是可以修改的。 接下来看一个例子： nfoo = 1 nfoo = 2 lstFoo = [ 1 ] lstFoo [ 0 ] = 2 代码第2行中，内存中原始的1对象因为不能改变，于是被“抛弃”，另nfoo指向一个新的int对象，其值为2。 代码第5行中，更改list中第一个元素的值，因为list是可改变的，所以，第一个元素变更为2。其实应该说，lstFoo指向一个 列表对象 。赋值所发生的事情，lstFoo所指向的列表对象的第一个元素被替换为新的值，但是对于lstFoo本身来说，它的值（列表的地址）没有变换，只是列表对象的内容发生变化了。 如下图所示： 但有时候，即使对象被复制了，修改原对象，两个变量指向的对象都改变了，怎么回事？ def fun2 (): a = [ 1 , 2 , 3 ,[ 1 , 2 ]] b = a . copy () a [ 1 ] = a [ 3 ][ 0 ] = 10 print ( a , ' \\n ' , b ) def fun2_2 (): a = [ 1 , 2 , 3 ,[ 1 , 2 ]] b = a . copy () a [ 1 ] = a [ 3 ] = 10 print ( a , ' \\n ' , b ) 上面定义了两个函数，两个函数输出的结果会一样吗？让我们看看： fun2 ------------------- [ 1 , 10 , 3 , [ 10 , 2 ]] [ 1 , 2 , 3 , [ 10 , 2 ]] fun2_2 ------------------- [ 1 , 10 , 3 , 10 ] [ 1 , 2 , 3 , [ 1 , 2 ]] 为什么 fun2 中b的第2个元素的值不变，而第四个元素的值却被改变了，而在 fun2_2 中b的值都没变？ 因为list储存的不是值，而是对象的引用。","text_tokens":["用户","第一个","1",":","抛弃","以","于是","什么","规定","第一","为什么","硬件","创建","区别","lstfoo","改","让","\\","比如","复制","我们","其值","引用","方式","不","接下","应该","怎么回事","而","说","numbers","中","特性","新","调用","赋值","本质","5","则","def","但","函数","固定","_","定义","immutable","等","两个","四个","上面","0","接下来","机制","功能","变","有时候","提供","原","在","'","算机","例子","即使","却","是","a","看看","都","第","修改","第四","设定","组合","变化","图","旧","(","第四个","还是","语言","结果","只是","会","为","原始","最后","python","可","可变","不是","按照","指向","dict","copy","吗","不变","更改","回事","api","可以","这些","销毁","10","但是","地址","不可","比如说","了","“","看","行中","不同","b","怎么","所","3","给","mutable","变更","就是","编译成","储存","fun2","只能","改变","生变","代码","、","好","将","[","元素","所示","操作","它","和","变换","n","去","来","值","个","无法","。","被","回收","发生变化"," ","-","（","）","那么","相互","对象","发生","print","=","一样","实现","一些","有时","列表",",","而是","完成","接口","]","：","没变","strings","int","译成","内容","另","来说","如下","替换","时候","内存","事情","的","所以","语法","编译","所谓","tuples",".","存在","底层","使用","对于","因为","呢","没","本身","一个","计算","”","角度","没有","，","其实","或者","？",")","执行","若","list","2","nfoo","变量","从","形式","计算机","下来","不能","输出"],"title":"可更改(mutable)  vs  不可更改(immutable)","title_tokens":["(","vs",")","mutable","不可","immutable","更改"," ","可更改"]},{"location":"计算机基础/1.2.基本概念.html#python_1","text":"python函数参数传递可以理解为就是变量传值操作，入门者可能会发现，不可变对象作为参数，看似是传引用；而可变对象作为参数，看似是传值。举一个例子： 不可变对象参数调用 def ChangeInt ( a ): a = 10 nfoo = 2 ChangeInt ( nfoo ) print nfoo #结果是2 这时发生了什么？让我们看一下 nfoo 和 a 实际的值的变化： nfoo = 2 # nfoo：对象2的地址 # 进行传参： a = nfoo # 函数参数a：对象2的地址 # 对a进行赋值 a = 10 # 函数参数a：对象10的地址；此时，nfoo的值：对象2的地址 也就是说，当 nfoo 传参给 ChangeInt() 的时候，是传递了 nfoo 的值，是 值传递 。如下图： 因为对象是不可变的，所以对b重新赋值的时候，只能创建一个新的对象10，将对象10放进新的地址，而不是将储存于1的地址的值删除，再把10放进1的地址。 但可变对象不同于不可变对象： 可变对象参数调用 def ChangeList ( a ): a [ 0 ] = 10 lstFoo = [ 2 ] ChangeList ( lstFoo ) print lstFoo #结果是[10] 这时发生了什么？让我们看一下 nfoo 和 a 实际的值的变化： lstFoo = [ 2 ] # nfoo：对象[2]的地址 # 进行传参： a = lstFoo # 函数参数a：对象[2]的地址 # 对a进行赋值 a [ 0 ] = 10 # 函数参数a：对象[2]的地址；此时，nfoo的值：对象[2]的地址 当 lstFoo 传参给 ChangeList() 的时候， 变量仍旧是“传值” ，a复制了变量 lstFoo 的值，于是 a 和 lstFoo 指向同一个对象，但是，list是可以改变的对象，对 a[0] 进行赋值，就是更改原对象的值，而 lstFoo 也指向原对象。于是，这时的 a[0] = 10 ，就是更改了 lstFoo 指向的对象的第一个元素。所以，再次输出 lstFoo 时，显示 [10] ，因此，看起来是 lstFoo 的值改变了。但实际上 lstFoo 的值还是原对象的地址， lstFoo 的值并没有改变，改变的是对象。 综上所以，python的传参，传进去的是name（变量）的值，而name的值是object的引用。也就是说，传参传的是name的值（object的引用）。传参无法把对象的值传进去。","text_tokens":[":","changelist","1","第一个","传参传","于是","什么","时","第一","创建","lstfoo","理解","让","于","对","也就是说","复制","我们","引用","而","一下","name","赋值","调用","新","def","函数","但","发现","可能","传","综上","0","变","作为","原","例子","是","a","object","重新","并","数传","变化","图","同一","(","还是","同一个","结果","会","当","再","这时","入门","python","可变","指向","起来","更改","也","可以","10","地址","但是","参数","不可","把","删除","了","“","看","不同","b","实际上","changeint","给","显示","就是","储存","传递","只能","同于","改变","进去","输出","将","[","元素","操作","实际","和","值","无法","。","函数参数","；"," ","传参","（","看起来","）","对象","发生","print","放进","=","不同于","看似","仍旧","]","：","因此","举","再次","时候","如下","的","所以","看起","#","入门者","因为","一个","没有","此时","，","就是说","进行","参数传递","？",")","2","list","变量","nfoo","为","”","不是","传值"],"title":"Python的函数参数传递：传值？引用？","title_tokens":["的","python","参数传递","：","？","参数","传递","引用","函数","数传","传值"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html","text":"编译型语言和解释型语言的优缺点对比 编程语言可以分为：完全的编译型，纯粹的解释型或者两者相互混合的编程语言。实际上，大部分现有的编程语言都同时拥有其编译型和解释型版本。 编译型语言和解释型语言分别有其各自的优势和不足。下面从编译型语言开始介绍。 编译型语言： 编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%。 编译型程序比解释型程序消耗的内存更少。 不利的一面——编译器比解释器要难写得多。 编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置。 可执行的编译型代码要比相同的解释型代码大许多。例如，C/C++的.exe文件要比同样功能的Java的.class文件大很多。 编译型程序是面向特定平台的因而是平台依赖的。 编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的） 由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。 解释型语言： 解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的。 另一个优势是解释器比编译器容易实现 解释型语言最大的优势之一是其平台独立性 解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的 中间语言代码的大小比编译型可执行代码小很多 平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素。 解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存。 由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多。 解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。 原文链接： http://www.codeproject.com/Articles/1825/The-Common-Language-Runtime-CLR-and-Java-Runtime-E Pros and cons of compiled and interpreted languages Languages can be developed either as fully-compiled, pure-interpreted, or hybrid compiled-interpreted. As a matter of fact, most of the current programming languages have both a compiled and interpreted versions available. Both compiled and interpreted approaches have their advantages and disadvantages. I will start with the compiled languages. Compiled languages One of the biggest advantages of Compiled languages is their execution speed. A program written in C/C++ runs 30-70 % faster then an equivalent program written in Java. Compiled code also takes less memory as compared to an interpreted program. On the down side - a compiler is much more difficult to write than an interpreter. A compiler does not provide much help in debugging a program - how many times have you received a \"Null pointer exception\" in your C code and have spent hours trying to figure out where in your source code did the exception occurred. The executable Compiled code is much bigger in size than an equivalent interpreted code e.g. a C/C++ .exe file is much bigger than an equivalent Java .class file Compiled programs are targeted towards a particular platform and hence are platform dependent. Compiled programs do not allow security to be implemented with in the code - e.g. a compiled program can access any area of the memory, and can do whatever it wants with your PC (most of the viruses are made in compiled languages). Due to loose security and platform dependence - a compiled language is not particularly suited to be used to develop Internet or web-based applications. Interpreted languages Interpreted language provides excellent debugging support. A Java programmer only spends a few minutes fixing a \"Null pointer exception\", because Java runtime not only specifies the nature of exception but also gives the exact line number and function call sequence (the famous stack trace information) where the exception occurred. This facility is something that a compiled language can never provide. Another advantage is that Interpreters are much easier to build then a compiler. One of the biggest advantages of Interpreters is that they make platform-independence possible. Interpreted language also allow high degree of security - something badly needed for an Internet application. An intermediate language code size is much smaller than a compiled executable code. Platform independence, and tight security are the two most important factors that make an interpreted language ideally suited for Internet and web-based applications. Interpreted languages have some serious drawbacks. The interpreted applications take up more memory and CPU resources. This is because in order to run a program written in interpreted language; the corresponding interpreter must be run first. Interpreters are sophisticated, intelligent and resource hungry programs and they take up lot of CPU cycles and RAM. Due to interpreted application's decode-fetch-execute cycle; they are much slower than compiled programs. Interpreters also do lot of code-optimization, security violation checking at run-time; these extra steps take up even more resources and further slows the application down.","text_tokens":["最大","时","violation","进一步","spent","interpreters","同时","suited","对","相同","hours","times","不足","sequence","写","runs","严密","函数","codeproject","further","towards","遇到","释器","由于","hungry","优势","分钟","大","好几个","极佳","在","安全","or","programming","不了","—","fact","advantage","time","a","this","次","额外","area","各自","fetch","exception","resources","基于","不利","dependence","你","帮助","is","resource","也","可以","好几","严重","多","and","factors","serious","应用","loose","做","面向","where","advantages","pointer","实际上","support","函数调用","介绍","因特网","堆栈","程序员","代码","许多","the","用","对比","它","就","之一","程序","相关","lot","trying","line","hence","无法","particular","did","；"," ","小时","开始","依赖性","execute","c","实现","some","占用","以及","到底","an","help","编译器","另","equivalent","原文","platform","it","使用","\"","一个","异常","一步","i","代码优化","their","minutes","独立","从","common","大部","occurred",":","smaller","must","languages","another","混合","will","easier","想","one","executable","two","intelligent","disadvantages","side","can","wants","解码","不仅","source","型","速度","but","这样","more","access","行号","of","either","written","up","checking","that","available","给出","fully","调试","current","现有","based","nature","pros","debugging","不太","interpreter","excellent","/","访问","even","慢","独立性","%","可","needed","at","链接","fixing","exe","do","性质","compiled","一名","extra","drawbacks","修复","tight","任何","病毒","www","important","具体","就是","很多","does","智能","资源","because","figure","来","faster","gives",";","program","compiler","需要","class","than","never","降低","解释","几个","发生","to","一些","clr","高度","few","com",",","slows","内存","file","e","provide","corresponding","be","定位","only","runtime","执行","完全","因而","in","order","call","部分","周期","比用","什么","多少","下面","因特","大量","biggest","优缺点","write","位置","not","中","语言所","takes","optimization","几分钟","70%","badly","with","any","g","著名","programmer","then","迫切","bigger","specifies","trace","spends","facility","成为","区域","互联","并且","much","most","适合","使","cycles","make","并","possible","语言","指针","编写","会","ideally","快","环境","degree","复杂","cycle","更","down","这些","pure","支持","为了","了","“","both","less","容易","approaches","famous","difficult","比","out","编程","个","指明","language","这是","intermediate","-","code","相互","它们","many","something","调试程序","联网","programs","开发","applications","例如","检查","空","independence","made","cons","事情","其","缺点",".","几分","错误","存在","必须","build","因为","”","因而是","articles","，","消耗",")","2","1825","stack","因素","30%","application","develop","cpu","number","they","slower","compared","received","信息","s","null","how","不","调用","security","最","c语言","size","两者","java","sophisticated","these","have","hybrid","run","also","中间","功能","松散","只","提供","speed","'","start","版本","c++","you","同样","安全性","是","70","first","都","provides","dependent","(","implemented","on","少","internet","理想","allow","viruses","纯粹","as","大小","优化","your","decode","used","information","interpreted","拥有","首先","程序运行","要","targeted","大部分","whatever","明确","web","编程语言","http","function","解释器","特定","pc","便利","实际","和","steps","versions","迫切需要","步骤","30","。","花费","分别","（","）","而且","小","matter","顺序","high","平台","take","而是","exact","文件","：","developed","保证","memory","的","编译","运行","ram","难","重要","for","are","execution","互联网","得","有","一面","跟踪","分为","或者","due","依赖","抓取","particularly"],"title":"1.3.编译型语言和解释型语言的优缺点对比","title_tokens":["解释","1.3","的","型","编译","缺点",".","优缺点","语言","对比","和"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#_1","text":"编程语言可以分为：完全的编译型，纯粹的解释型或者两者相互混合的编程语言。实际上，大部分现有的编程语言都同时拥有其编译型和解释型版本。 编译型语言和解释型语言分别有其各自的优势和不足。下面从编译型语言开始介绍。","text_tokens":["优势","解释","可以","相互","开始","部分","拥有","下面","实际上","版本","同时","混合","：","大部分","现有","都","介绍","不足","编程语言","的","其","编译","语言","实际","和","两者","各自","有","编程"," ","，","型","分为","或者","。","分别","纯粹","从","完全","大部"],"title":"编译型语言和解释型语言的优缺点对比","title_tokens":["解释","的","型","编译","缺点","优缺点","语言","对比","和"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#_2","text":"编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%。 编译型程序比解释型程序消耗的内存更少。 不利的一面——编译器比解释器要难写得多。 编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置。 可执行的编译型代码要比相同的解释型代码大许多。例如，C/C++的.exe文件要比同样功能的Java的.class文件大很多。 编译型程序是面向特定平台的因而是平台依赖的。 编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的） 由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。","text_tokens":["最大","部分","比用","什么","多少","时","因特","想","对","相同","位置","不","中","写","70%","c语言","java","遇到","型","速度","释器","由于","优势","区域","大","好几个","功能","松散","提供","并且","在","安全","适合","调试","不了","c++","—","同样","安全性","是","次","语言","不太","少","/","指针","编写","访问","快","可","基于","不利","你","exe","帮助","更","可以","好几","多","支持","应用","做","面向","“","程序运行","要","任何","病毒","大部分","就是","明确","web","因特网","很多","比","代码","许多","解释器","特定","pc","用","它","和","之一","程序","来","大部","。","花费","需要","class"," ","-","（","）","小时","解释","几个","依赖性","调试程序","c","平台","实现","开发","而是","例如","文件","到底","编译器","空","内存","事情","的","其","编译","运行",".","难","错误","使用","一个","异常","因而是","得","一面","有","，","消耗","或者","执行","依赖","30%","”","因而"],"title":"编译型语言：","title_tokens":["：","型","语言","编译"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#_3","text":"解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的。 另一个优势是解释器比编译器容易实现 解释型语言最大的优势之一是其平台独立性 解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的 中间语言代码的大小比编译型可执行代码小很多 平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素。 解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存。 由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多。 解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。 原文链接： http://www.codeproject.com/Articles/1825/The-Common-Language-Runtime-CLR-and-Java-Runtime-E","text_tokens":[":","最大","cpu","周期","时","大量","进一步","信息","位置","语言所","调用","几分钟","严密","解码","最","函数","不仅","著名","codeproject","java","型","速度","释器","迫切","这样","由于","行号","优势","成为","分钟","互联","中间","极佳","只","给出","提供","并且","安全","适合","调试","使","—","安全性","是","并","语言","额外","/","指针","编写","会","fetch","慢","理想","独立性","环境","可","复杂","链接","大小","更","性质","优化","decode","也","可以","严重","这些","多","and","支持","应用","一名","为了","首先","做","了","修复","“","容易","www","具体","函数调用","web","堆栈","http","很多","比","程序员","智能","代码","资源","the","解释器","便利","就","和","之一","程序","抓取","相关","迫切需要","个","步骤","无法","指明","。","language","需要","这是","；"," ","-","（","降低","）","而且","解释","小","它们","顺序","发生","execute","联网","平台","实现","一些","clr","高度","占用","com","以及","：","检查","编译器","空","另","保证","原文","内存","的","其","编译","运行","缺点","e",".","重要","几分","存在","必须","定位","因为","runtime","一个","异常","一步","互联网","articles","代码优化","，","跟踪","消耗","执行","2","1825","独立","因素","common","”"],"title":"解释型语言：","title_tokens":["：","解释","语言","型"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#pros-and-cons-of-compiled-and-interpreted-languages","text":"Languages can be developed either as fully-compiled, pure-interpreted, or hybrid compiled-interpreted. As a matter of fact, most of the current programming languages have both a compiled and interpreted versions available. Both compiled and interpreted approaches have their advantages and disadvantages. I will start with the compiled languages. Compiled languages One of the biggest advantages of Compiled languages is their execution speed. A program written in C/C++ runs 30-70 % faster then an equivalent program written in Java. Compiled code also takes less memory as compared to an interpreted program. On the down side - a compiler is much more difficult to write than an interpreter. A compiler does not provide much help in debugging a program - how many times have you received a \"Null pointer exception\" in your C code and have spent hours trying to figure out where in your source code did the exception occurred. The executable Compiled code is much bigger in size than an equivalent interpreted code e.g. a C/C++ .exe file is much bigger than an equivalent Java .class file Compiled programs are targeted towards a particular platform and hence are platform dependent. Compiled programs do not allow security to be implemented with in the code - e.g. a compiled program can access any area of the memory, and can do whatever it wants with your PC (most of the viruses are made in compiled languages). Due to loose security and platform dependence - a compiled language is not particularly suited to be used to develop Internet or web-based applications. Interpreted languages Interpreted language provides excellent debugging support. A Java programmer only spends a few minutes fixing a \"Null pointer exception\", because Java runtime not only specifies the nature of exception but also gives the exact line number and function call sequence (the famous stack trace information) where the exception occurred. This facility is something that a compiled language can never provide. Another advantage is that Interpreters are much easier to build then a compiler. One of the biggest advantages of Interpreters is that they make platform-independence possible. Interpreted language also allow high degree of security - something badly needed for an Internet application. An intermediate language code size is much smaller than a compiled executable code. Platform independence, and tight security are the two most important factors that make an interpreted language ideally suited for Internet and web-based applications. Interpreted languages have some serious drawbacks. The interpreted applications take up more memory and CPU resources. This is because in order to run a program written in interpreted language; the corresponding interpreter must be run first. Interpreters are sophisticated, intelligent and resource hungry programs and they take up lot of CPU cycles and RAM. Due to interpreted application's decode-fetch-execute cycle; they are much slower than compiled programs. Interpreters also do lot of code-optimization, security violation checking at run-time; these extra steps take up even more resources and further slows the application down.","text_tokens":["call","application","develop","cpu","number","they","slower","smaller","violation","compared","must","received","spent","biggest","languages","another","interpreters","will","easier","s","null","suited","one","executable","two","hours","write","how","disadvantages","not","side","times","intelligent","can","sequence","wants","takes","optimization","runs","security","size","with","any","g","source","further","java","towards","sophisticated","programmer","then","but","bigger","specifies","these","trace","more","spends","access","hungry","have","either","of","written","hybrid","facility","up","run","checking","also","that","available","speed","much","'","or","fully","most","start","programming","fact","c++","advantage","you","current","70","time","cycles","a","this","first","make","based","provides","dependent","possible","nature","debugging","implemented","(","order","on","interpreter","internet","excellent","/","area","even","ideally","fetch","allow","viruses","%","exception","degree","resources","needed","at","as","dependence","fixing","exe","cycle","is","do","resource","your","decode","used","down","information","pure","interpreted","and","factors","serious","compiled","loose","extra","drawbacks","where","advantages","pointer","both","less","tight","targeted","support","whatever","important","approaches","web","famous","difficult","function","out","does","the","pc","because","figure","steps","versions","lot","trying","faster","line","gives","30","hence",";","particular","language","program","compiler","did","class","than"," ","intermediate","code","-","never","matter","to","many","something","execute","high","c","programs","some","few",",","take","exact","applications","help","an","developed","independence","slows","equivalent","platform","made","it","memory","file","provide","e",".","corresponding","be","ram","build","only","\"","for","runtime","are","execution","i",")","their","due","minutes","stack","badly","occurred","particularly","in"],"title":"Pros and cons of compiled and interpreted languages","title_tokens":["languages","pros","and","interpreted","compiled","of"," ","cons"]},{"location":"计算机基础/1.4.命名空间与作用域.html","text":"命名空间 == Namespace : A namespace is a mapping from names to objects. 命名空间，也称名字空间，是从名字（标识符）到对象的映射。==在 Python 中，命名空间由字典来实现的，即{key:value} ↔{名字:对象}。 命名空间的最重要的作用是避免名字冲突，各个命名空间是独立的，因此不同的命名空间可以重名。 Namespace的种类 常见的命名空间有： 内置命名空间 ：存放着built-in Functions（内置函数）的名字、内置的异常的名字、内置常量，内置类型。 全局命名空间 ：每个模块（ .py 文件）拥有它自己的命名空间，包含了直接定义在模块中的名字，例如类、函数、导入的其它模块等等。 局部命名空间 ：每个函数都有着自已的命名空间，它记录了函数的名字（函数的参数、局部定义的名字） local namespace：局部命名空间 global namespace：全局命名空间 Built-in namespace：内置命名空间 另外： 一个对象的属性集合，也构成了一个命名空间。但通常使用 objname.attrname 的间接方式访问属性，而不是直接访问，故不将其列入命名空间讨论。 类定义的命名空间，通常解释器进入类定义时，即执行到 class ClassName: 语句，会新建一个命名空间。(见官方对类定义的 说明 ) 命名空间的生命周期 标识符产生地点决定标识符所处的命名空间。 不同类型的命名空间有不同的生命周期： built-in：在 Python 解释器启动时创建，解释器退出时销毁 global：在模块定义被解释器读入时创建，通常也会一直保存到解释器退出 local：这里要区分 function 以及 class 定义： 函数的局部命名空间：在函数调用时创建，函数返回或者由未捕获的异常时销毁 类定义的命名空间：在解释器读到类定义创建，类定义结束后销毁。（关于类定义的命名空间，在类定义结束后销毁，但其实类对象就是这个命名空间内容的包装，见官方对类定义的 说明 ） 命名空间的查看 局部命名空间可以通过 locals() 来访问。 全局 （模块级别）命名空间可以通过 globals() 来访问。 locals 实际返回的是一个局部名字空间的拷贝，所以修改 locals() 对象并不会影响局部名字空间。 globals 返回是全局名字空间，而不是其拷贝，所以修改 globals() 对象会影响全局名字。 # 修改局部命名空间无效 def func1 ( i ): x = 123 print ( \"当前的局部作用域\" , locals (), sep = \" \\n \" ) locals ()[ \"x\" ] = 6789 print ( \"修改局部作用域后，并不影响x的值\" ) print ( \"x =\" , x ) 当前的局部作用域 {'i': 10, 'x': 123} 修改局部作用域后，并不影响x的值 x = 123 # 修改全局命名空间生效 y = 456 globals ()[ \"y\" ] = 789 print ( \"y =\" , y ) y = 789 总结 模块的名字空间不仅仅包含模块级的变量和常量，还包括所有在模块中定义的函数和类。除此以外，它还包括了任何被导入到模块中的东西。 内置命名也同样被包含在一个模块中，它被称作 built-in。 回想一下 from module import 和 import module 之间的不同： 使用 import module ，模块自身被导入，但是它保持着自已的名字空间，即 module.function 。 使用 from module import function ，实际上是从另一个模块中将指定的函数和属性导入当前名字空间，因此可以直接访问它们。使用 globals 函数，可以展现这一过程的变化。 作用域 scope : A scopeis a textual region of a Python program where a namespace is directly accessible. 作用域是 Python 的一块文本区域，这个区域中，命名空间可以被“直接引用”。 直接引用：直接使用名字访问，如 name ，这种方式尝试在名字空间中搜索名字 name 。 间接引用：使用形如 objname.attrname 的方式，即属性引用，这种方式不会在命名空间中搜索名字 attrname ，而是搜索名字 objname ，再访问其属性。 作用域与命名空间的关系 现在，命名空间持有了名字。作用域是 Python 的一块文本区域，即一块代码区域，需要代码区域引用名字（访问变量），那么作用域与命名空间之间就有了联系。 顾名思义，名字作用域就是名字可以影响到的代码文本区域，命名空间的作用域就是这个命名空间可以影响到的代码文本区域。那么也存在这样一个代码文本区域，多个命名空间可以影响到它。 作用域只是文本区域，其定义是静态的；而名字空间却是动态的，只有随着解释器的执行，命名空间才会产生。那么，在静态的作用域中访问动态命名空间中的名字，造成了作用域使用的动态性。 那么，可以这样认为： 静态的作用域，是一个或多个命名空间按照一定规则叠加影响代码区域；运行时动态的作用域，是按照特定层次组合起来的命名空间。 在一定程度上，可以认为 动态的作用域就是命名空间 。在后面的表述中，我会把动态的作用域与其对应命名空间等同起来。 在Python中，scope是由namespace按特定的层级结构组合起来的。scope一定是namespace，但namespace不一定是scope. 名字搜索顺序 当一行代码需要使用名字 X 所对应的值，python会从当前层级的Namespace开始，并根据以下顺序，去查找 X 这个名字： local namespace： 包含局部名字的最内层（innermost）作用域，如函数、方法、类的内部局部作用域。 Enclosing 根据嵌套层次从内到外搜索，包含非局部（nonlocal）非全局（nonglobal）名字的任意封闭函数的作用域。如两个嵌套的函数，内层函数的作用域是局部作用域，外层函数作用域就是内层函数的 Enclosing作用域。 Global Built-in 如果 Python 在这些namespace找不到 X ，它将放弃查找并引发一个 NameError 异常： NameError: name 'aa' is not defined 程序在运行时，local、global、built-in三个namespace一定存在，但Enclosing namespace不一定存在。 引用作用域需要注意的问题 不能在名字未定义前引用该名字 if 、 for 语句并不会引入新的作用域 外层作用域不能引用内层作用域的变量 def try_to_define_name (): '''函数中定义了名字i，并绑定了一个整数对象1''' i = 1 try_to_define_name () print ( i ) #引用名字i之前，调用了函数 在引用名字 i 之前，明明调用了函数，定义了名字 i ，可是还是找不到这个名字： Traceback (most recent call last): File \"scope_test.py\", line 20, in <module> print(i) #引用名字i之前，调用了函数 NameError: name 'i' is not defined 虽然定义了名字 i ，但是定义在了函数的局部作用域对应的局部命名空间中，按照 LEGB 搜索规则，在全局作用域中自然访问不到局部作用域；再者，函数调用结束后，这个命名空间被销毁了。 引用变量总是与作用域相关的，因此：在Python中一个名字只有在定义之后，才能在合适的作用域引用。 一般来说， B,G 两个作用域的引入是不能够通过代码操作的（参考命名空间的生命周期），能够通过语句引入的作用域只有 E,L 了。Python中引入新作用域的语句很有限，总的来说只有如下三种： 通过定义函数引入 local 作用域或者 Enclosing 作用域；本质上， lambda 和生成器表达式也是函数，会引入新作用域。 类定义引入 local 作用域； 列表推导式引入 local 作用域，传说在 python2 中列表推导式不引入新的作用域 import语句 ： def import_sys (): '''import sys module''' import sys import_sys () print ( sys . path ) # NameError: name 'sys' is not defined 这个算非正常程序员的写法了，在另一篇文章 《Python进阶 - 对象，名字以及绑定》 中介绍过， import 语句在函数 import_sys 中将名字 sys 和对应模块绑定，那 sys 这个名字还是定义在局部作用域，跟上面的例子没有任务区别。 global 和 nonlocal 的作用 任何时候，python都可以直接读取全局变量，但是却不可以在内层作用域直接改写上层变量，来看一个典型的 闭包 结构： #e.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv = [ 'gv' ] + gv #UnboundLocalError:local variable 'gv' referenced before assignment lv = [] def inn_func (): lv = lv + [ v ] #UnboundLocalError:local variable 'lv' referenced before assignment gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 实际 调用 func() 函数后，上面两处对 gv 和 lv 进行赋值操作的地方都会发生 UnboundLocalError ： 因为 Python 在执行函数前，会首先生成各层命名空间和作用域 ，因此 Python 在执行赋值前会将 func 内的 'gv' 'lv' 写入局部命名空间和闭包命名空间，当 Python 执行 赋值时会在局部作用域、闭包作用域内发现局部命名空间和闭包命名空间内已经具有 'gv' 和 'lv' 标识符，但这两个非全局标识符在该赋值语句执行之前并没有被赋值，也即没有对象与标识符关联，因此无法参与四则运算，从而引发错误。 这段程序本意只是想让具有对象的全局变量 gv 和局部变量 lv 参与运算，为了避免类似的情况发生， Python 便引入了 global 、 nonlocal 语句来说明所修饰的 gv 、 lv 分别来自全局命名空间和局部命名空间 ，声明之后，就可以在 func 和 inn_func 内直接改写上层命名空间内 gv 和 lv 的值： #f.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): global gv gv = [ 'gv' ] + gv lv = [] print ( id ( lv )) def inn_func (): nonlocal lv lv = lv + [ v ] print ( id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) # 2608229974344 a () # 2608229974344 # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] print ( gv ) # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] 如上，全局变量 gv 值被函数改写了， inn_func 修改的也确实是父函数 lv 的值 （依据 ID 判断）。 借壳 那么是不是不使用 global 和 nonlocal 就不能达到上面的目的呢？来看看这段程序： #g.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv . insert ( 0 , 'gv' ) # 注意的是.insert只是对gv的元素进行修改，而不是修改gv整个对象,gv是list，元素可变 lv = [] print ( id ( lv )) def inn_func (): lv . append ( v ) # 注意的是.insert只是对lv的元素进行修改，而不是修改lv整个对象 print ( id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 执行的结果： a = func ( 'is' ) # 2608110869168 a () # 2608110869168 # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] print ( gv ) # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] 可以发现，执行结果同上面完全一致，问题自然来了：“为什么不用 global nonlocal 也可以改写全局变量 gv 和父函数变量 lv 的值？ 为了看清楚这个过程，我们将上面的 gv.insert(0, 'gv') 和 lv.append(v) 改写为 gv[0:0] = ['gv'] 和 lv[:] = [v] ： #h.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv [ 0 : 0 ] = [ 'gv' ] lv = [] print ( id ( lv )) def inn_func (): lv [:] = [ v ] print ( id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 执行结果： a = func ( 'is' ) # 2608229959496 a () # 2608229959496 # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] 同 g.py 文件的执行结果完全一致，事实上两者之间的内在也是完全一样的。 其实，我们其实改写的不是 gv 和 lv ,而是 gv 和 lv 的元素 gv[0:0] 和 lv[:] 。因此，不需要 global 和 nonlocal 修饰就可以直接改写， 这就是“借壳”， 这是因为list是可变对象。 在 nonlocal 尚未引入 Python 中，比如 Python 2.x 若要在子函数中改写父函数变量的值就得通过这种方法。当然借壳蕴藏着一个相对复杂的标识符创建的问题：比如子函数通过借壳修改父函数变量 lv 的值，那么子函数的标识符 lv 是怎么绑定到父函数变量 lv 的值 ID 的上的？ 关于这个问题，这里有个问答就是讨论这个的： python的嵌套函数中局部作用域问题? 这个问题在python函数传参的内容有讲清楚。 global 和 nonlocal 语句对标识符创建的不同影响 另外，需要注意的是：global 语句只是声明该标识符引用的变量来自于全局变量，但并不能直接在当前层创建该标识符；nonlocal 语句则会在子函数命名空间中创建与父函数变量同名的标识符： #j.py gv = 'a global var' def func (): global gv lv = 'a local var' print ( locals ()) def inn_func (): nonlocal lv global gv print ( locals ()) return inn_func 执行结果： c = func () { 'lv' : 'a local var' } #运行 `func` 函数后，`global` 语句并未将 `gv` 变量引入局部命名空间 c () { 'lv' : 'a local var' } #运行闭包函数后，`nonlocal` 语句将父函数变量 `lv` 引入闭包命名空间 之所以 nonlocal 语句与 global 语句的处置不同，在于全局变量的作用域生存期很长，在模块内随时都可以访问，而父函数的局部作用域在父函数执行完毕后便会直接释放，因此 nonlocal 语句必须将父函数变量的标识符和引用写入闭包命名空间。 类的局部命名空间 首先，函数和类执行时都会产生局部命名空间，但类的执行机制不同于函数： # i . py def a (): print ( 'function' ) class A (): print ( 1 ) class B (): print ( 2 ) class C (): print ( 3 ) 执行文件，结果为： 1 2 3 如上，类就是一个可执行的代码块，只要该类被加载，就会被执行，这一点不同于函数。 类之所以这么设计的原因在于：类是创建其他实例（生成其他的类或者具体的对象）的对象，因此必须在实例之前被创建，而类又可能涉及到与其他类的继承、重载等一系列问题，故在代码加载时就被创建利于提高效率和降低逻辑复杂度。 其次，与函数不同的是，类的局部命名空间并非作用域 class A(): a = 1 b = [a + i for i in range(3)] #NameError: name 'a' is not defined 执行上段代码，我们可以发现在类 A 内列表推导式无法调取 a 的值，但函数却可以： def func (): a = 1 b = [ a + i for i in range ( 3 )] print ( b ) func () # [ 1 , 2 , 3 ] 因此， A 中的 a 不同于函数 func 中的 a 在局部命名空间中可以被任意读取，之所以说是“不可以被任意”读取而不是“不可被读取”，原因在于在类 A 的局部空间内， a 其实一定程度上是可以直接被读取的： class A(): a = 1 c = a + 2 执行上段代码后： A.c #3 而上例中 b 的赋值操作不能执行，原因在于列表推导式会创建自己的局部命名空间，因此难以访问到 a 。 总结 啰嗦了这么多，终于该结尾了！ 我们再来回过头来看下文章开头的栗子： 1、为什么 b.py 只是导入 a.py 中的 class A ,却执行了整个 a.py 文件? 答：因为 Python 并不知道 class A 在 a.py 文档的何处，为了能够找到 class A ，Python 需要执行整个文档。 2、为什么 b.py 的导入执行了整个 a.py 文档，却在 b 中难以调用 a 的全局变量 va ？ 答：Python 的全局变量指的是模块全局，因此不可以跨文档，因此 global 语句也是不可以跨文档的。另外， b 只是导入了 a 的 class A ，因此并不会导入 a 中所有的标识符，所以 类似 a.va 这样的调用也是不起作用的。 关于命名空间： 1、赋值、定义类和函数都会产生新的标识符； 2、全局变量的标识符不能跨文档； 3、各级命名空间相互独立互不影响； 4、Python 总是从当前层逐渐向上寻找标识符； 5、内层作用域若想直接修改上层变量，需要通过 global nonlocal 语句先声明； 6、单纯的 global 语句并不能为所在层级创建相应标识符，但 nonlocal 语句可以在闭包空间中创建相应标识符； 7、类的局部命名空间不是作用域。","text_tokens":["1","完毕","不到","由","123",">","时","var","导入到","scopeis","查看","回过头来","globals","拷贝","对","进入","从而","是因为","name","属性","新","实例","讲清楚","5","封闭","objects","这种","规则","20","函数","已经","寻找","发现","包含","释器","通常","作用","functions","互不","称","之后","见","若想","搜索","还","造成","0","后面","全局变量","机制","模块","当然","在","非","很长","前","path","生命周期","不用","a","指定","顾名思义","借壳","textual","mapping","先","一般","这一","提高效率","即","当","表达","读到","四则","is","classname","完全一致","7","也","可以","销毁","其它","多","把","标识符","f","where","事实上","test","提高","实际上","b","上层","传说","声明","4","这里","父","函数调用","介绍","通过","叠加","各个","程序员","代码","、","形","lv","<","6","它","就","程序","看清楚","相关","闭包","过","line","无法","逻辑","层次","生成","va","调取","v","认为","；"," ","展现","外","判断","子函数","一般来说","后","开始","对象","多个","try","两处","c","除此","实现","内层","涉及","列表","以及","具有","文章","过头","因此","逐渐","所有","过程","另","nameerror","gv","nonglobal","式","#","除此以外","使用","id","import","\"","方法","一个","异常","没有","i","names","效率","？","字典","知道","独立","从","2608229959496","清楚","一致",":","蕴藏","标识","等同","并不知道","locals","随着","before","写入","inn","结束","让","种类","表达式","想","段程序","自然","构成","scope","一下","放弃","达式","在于","地点","这个","def","现在","写法","生存期","读入","避免","三种","不仅","enclosing","sys","将父","_","define","说明","traceback","重载","这样","注意","两个","着","外层","上面","of","legb","若要","却","层级","引入","修改","处置","相对","利于","捕获","级","l","绑定","看清","按","其次","访问","只是","整个","那","到","python","可","虽然","释放","一块","if","啰嗦","顾名","但是","参数","from","内置","程度","本意","动态","不同","文档","任何","456","读取","才","3","文本","依据","该类","具体","就是","讨论","module","6789","aa","同于","继承","记录","另外","地方","不知","又","有着","将","built","元素","操作","达到","东西","namespace","讲清","关联","之前","来","内","被","program","class","需要","存放","传参","总是","降低","解释","to","发生","print","=","不同于","重名","生效","生成器",",","region","只有","联系","集合","以下","任意","改写","如下","关系","故","所以","return","file","e","修饰","类型","栗子","官方","正常","生命","尚未","时会","其实","进行","这么","执行","保持","设计","以外","不能","完全","类","in","直接","nonlocal","call","有个","周期","明明","什么","insert","《","区别","+","返回","便","答","我们","not","引用","难以","中","命名","之间","assignment","赋值","本质","整数","一系列","h","innermost","则","append","g","而类","自身","冲突","事实","如果","并未","等","来自","accessible","789","区域","其他","指","一直","影响","典型","most","?","x","func1","块","等等","未定","常量","并","未","查找","{","变化","y","上","无效","参考","静态","↔","会","到父","复杂","语句","能够","该","一系","这些","一行","为了","last","之所以","了","“","不能引用","看","结尾","所在","当前","j","python2","关于","加载","原因","三个","不仅仅","func","只要","defined","不起作用","表述","决定","未定义","自已","n","去","存期","再者","总结","结构","内部","-","引发","那么","生存","名字","它们","参与","相互","range","recent","何处","情况","variable","随时","]","例如","目的","对类","找","内容","来说","时候","其","与其","2608229974344",".","存在","错误","必须","与","因为","间接","常见","高效","，","local",")","这","list","2","下","各层","同名","自己","很","进阶","合适","每个","一篇","退出","同","为什么","创建","问答","objname","\\","产生","于","对应","任务","比如","方式","不","referenced","各级","而","lambda","说","调用","总的来说","称作","》","一点","最","问题","可是","根据","但","两者","定义","新建","可能","}","成器","却是","非正常","有限","directly","找到","才能","2608110869168","'","`","unboundlocalerror","例子","同样","是","是从","看看","级别","跨","都","但类","组合","开头","启动","系列","global","！","(","还是","如","结果","相应","而父","仅仅","再","回想","value","包装","中将","导入","类似","可变","按照","起来","终于","尝试","局部","保存","10","拥有","不可","内在","首先","向上","单纯","局部变量","要","怎么","所","列入","两者之间","复杂度","回过","推导","不会","来看","四则运算","function","一定","解释器","特定","[","层","是不是","实际","空间","和","包括","值","所处","并非","。","运算","分别","段","key","（","映射","）","前会","确实","顺序","sep","或","被称作","我会","attrname","持有","一样","而是","上例","动态性","文件","：","作用域","嵌套","的","运行","重要","区分","算","呢","for","py","高效率","得","有","或者","变量","跟","为","”","全局","不是"],"title":"1.4.命名空间与作用域","title_tokens":["命名",".","作用","与","空间","作用域","1.4"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_1","text":"== Namespace : A namespace is a mapping from names to objects. 命名空间，也称名字空间，是从名字（标识符）到对象的映射。==在 Python 中，命名空间由字典来实现的，即{key:value} ↔{名字:对象}。 命名空间的最重要的作用是避免名字冲突，各个命名空间是独立的，因此不同的命名空间可以重名。","text_tokens":["也",":","可以","名字","标识","to","对象","由","from","=","标识符","重名","实现","在","不同","是","是从","a","因此","各个","中","命名","{","mapping","的",".","重要","objects","最","key","空间","↔","namespace","即","避免","冲突","names","来","value","，","到","python","。","}","字典","作用","独立","称","is"," ","（","映射","）"],"title":"命名空间","title_tokens":["命名","空间"]},{"location":"计算机基础/1.4.命名空间与作用域.html#namespace","text":"常见的命名空间有： 内置命名空间 ：存放着built-in Functions（内置函数）的名字、内置的异常的名字、内置常量，内置类型。 全局命名空间 ：每个模块（ .py 文件）拥有它自己的命名空间，包含了直接定义在模块中的名字，例如类、函数、导入的其它模块等等。 局部命名空间 ：每个函数都有着自已的命名空间，它记录了函数的名字（函数的参数、局部定义的名字） local namespace：局部命名空间 global namespace：全局命名空间 Built-in namespace：内置命名空间 另外： 一个对象的属性集合，也构成了一个命名空间。但通常使用 objname.attrname 的间接方式访问属性，而不是直接访问，故不将其列入命名空间讨论。 类定义的命名空间，通常解释器进入类定义时，即执行到 class ClassName: 语句，会新建一个命名空间。(见官方对类定义的 说明 )","text_tokens":[":","每个","时","objname","进入","方式","构成","不","而","属性","中","命名","函数","但","定义","新建","说明","包含","释器","通常","functions","着","见","模块","在","等等","都","常量","global","(","访问","会","即","全局","到","导入","不是","classname","语句","也","局部","其它","参数","拥有","内置","了","列入","讨论","记录","另外","、","解释器","有着","将","built","它","空间","自已","namespace","。","class","存放"," ","-","（","）","解释","名字","对象","attrname","例如","文件","：","集合","对类","的","故","其",".","使用","类型","间接","py","一个","异常","常见","官方","有","，","local","执行",")","类","in","直接","自己"],"title":"Namespace的种类","title_tokens":["namespace","的","种类"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_2","text":"标识符产生地点决定标识符所处的命名空间。 不同类型的命名空间有不同的生命周期： built-in：在 Python 解释器启动时创建，解释器退出时销毁 global：在模块定义被解释器读入时创建，通常也会一直保存到解释器退出 local：这里要区分 function 以及 class 定义： 函数的局部命名空间：在函数调用时创建，函数返回或者由未捕获的异常时销毁 类定义的命名空间：在解释器读到类定义创建，类定义结束后销毁。（关于类定义的命名空间，在类定义结束后销毁，但其实类对象就是这个命名空间内容的包装，见官方对类定义的 说明 ）","text_tokens":["标识","周期","由","退出","时","创建","结束","返回","产生","命名","调用","地点","这个","读入","函数","但","定义","说明","释器","通常","见","模块","一直","在","生命周期","未","启动","捕获","global","会","包装","到","python","读到","也","局部","保存","销毁","标识符","不同","要","这里","函数调用","关于","就是","function","解释器","决定","built","空间","所处","。","被","class"," ","-","（","）","解释","后","对象","以及","：","对类","内容","的","区分","类型","异常","官方","有","生命","，","其实","local","或者","类","in"],"title":"命名空间的生命周期","title_tokens":["命名","的","生命","生命周期","周期","空间"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_3","text":"局部命名空间可以通过 locals() 来访问。 全局 （模块级别）命名空间可以通过 globals() 来访问。 locals 实际返回的是一个局部名字空间的拷贝，所以修改 locals() 对象并不会影响局部名字空间。 globals 返回是全局名字空间，而不是其拷贝，所以修改 globals() 对象会影响全局名字。 # 修改局部命名空间无效 def func1 ( i ): x = 123 print ( \"当前的局部作用域\" , locals (), sep = \" \\n \" ) locals ()[ \"x\" ] = 6789 print ( \"修改局部作用域后，并不影响x的值\" ) print ( \"x =\" , x ) 当前的局部作用域 {'i': 10, 'x': 123} 修改局部作用域后，并不影响x的值 x = 123 # 修改全局命名空间生效 y = 456 globals ()[ \"y\" ] = 789 print ( \"y =\" , y ) y = 789","text_tokens":["局部",":","可以","名字","后","789","对象","locals","sep","10","123","print","=","模块","生效","影响","'",",","globals","拷贝","x","当前","返回","func1","\\","是","]","456","级别","修改","并","通过","不会","作用域","6789","而","不","{","命名","的","所以","其","(","无效","#","y","[","def","访问","空间","实际","会","\"","一个","n","i","来","值","，","。",")","不是","}","作用"," ","全局","（","）"],"title":"命名空间的查看","title_tokens":["命名","的","查看","空间"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_4","text":"模块的名字空间不仅仅包含模块级的变量和常量，还包括所有在模块中定义的函数和类。除此以外，它还包括了任何被导入到模块中的东西。 内置命名也同样被包含在一个模块中，它被称作 built-in。 回想一下 from module import 和 import module 之间的不同： 使用 import module ，模块自身被导入，但是它保持着自已的名字空间，即 module.function 。 使用 from module import function ，实际上是从另一个模块中将指定的函数和属性导入当前名字空间，因此可以直接访问它们。使用 globals 函数，可以展现这一过程的变化。","text_tokens":["导入到","globals","一下","属性","中","命名","之间","称作","函数","不仅","自身","定义","包含","着","还","模块","在","同样","是从","指定","常量","变化","级","这一","访问","即","仅仅","回想","中将","导入","也","可以","但是","from","内置","了","不同","实际上","任何","当前","module","不仅仅","function","built","它","空间","和","东西","自已","实际","包括","。","被","展现"," ","-","名字","它们","被称作","除此","：","因此","所有","过程","另","的",".","除此以外","使用","import","一个","，","保持","变量","以外","类","in","直接"],"title":"总结","title_tokens":["总结"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_5","text":"scope : A scopeis a textual region of a Python program where a namespace is directly accessible. 作用域是 Python 的一块文本区域，这个区域中，命名空间可以被“直接引用”。 直接引用：直接使用名字访问，如 name ，这种方式尝试在名字空间中搜索名字 name 。 间接引用：使用形如 objname.attrname 的方式，即属性引用，这种方式不会在命名空间中搜索名字 attrname ，而是搜索名字 objname ，再访问其属性。","text_tokens":["accessible","搜索",":","可以","名字","区域","directly","attrname","where","scopeis","“","在","region","而是","objname","是","：","a","文本","作用域","引用","scope","方式","不会","name","属性","中","textual","命名","的","其",".","如","形","这种","使用","这个","访问","空间","间接","namespace","即","再","尝试","，","python","。","被","program","作用","一块","is"," ","”","直接","of"],"title":"作用域","title_tokens":["作用","作用域"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_6","text":"现在，命名空间持有了名字。作用域是 Python 的一块文本区域，即一块代码区域，需要代码区域引用名字（访问变量），那么作用域与命名空间之间就有了联系。 顾名思义，名字作用域就是名字可以影响到的代码文本区域，命名空间的作用域就是这个命名空间可以影响到的代码文本区域。那么也存在这样一个代码文本区域，多个命名空间可以影响到它。 作用域只是文本区域，其定义是静态的；而名字空间却是动态的，只有随着解释器的执行，命名空间才会产生。那么，在静态的作用域中访问动态命名空间中的名字，造成了作用域使用的动态性。 那么，可以这样认为： 静态的作用域，是一个或多个命名空间按照一定规则叠加影响代码区域；运行时动态的作用域，是按照特定层次组合起来的命名空间。 在一定程度上，可以认为 动态的作用域就是命名空间 。在后面的表述中，我会把动态的作用域与其对应命名空间等同起来。 在Python中，scope是由namespace按特定的层级结构组合起来的。scope一定是namespace，但namespace不一定是scope.","text_tokens":["等同","随着","由","时","产生","对应","引用","scope","不","而","中","命名","之间","这个","现在","规则","但","定义","释器","这样","作用","却是","区域","造成","后面","影响","在","是","层级","顾名思义","组合","上","静态","按","访问","只是","会","即","到","python","按照","起来","一块","顾名","也","可以","把","程度","了","动态","才","文本","就是","叠加","代码","一定","解释器","特定","表述","它","空间","就","namespace","。","层次","结构","需要","认为","；"," ","（","）","那么","解释","名字","多个","或","我会","持有","只有","动态性","联系","：","作用域","的","其","运行","与其",".","存在","使用","与","一个","有","，","执行","变量"],"title":"作用域与命名空间的关系","title_tokens":["命名","关系","的","作用","与","空间","作用域"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_7","text":"当一行代码需要使用名字 X 所对应的值，python会从当前层级的Namespace开始，并根据以下顺序，去查找 X 这个名字： local namespace： 包含局部名字的最内层（innermost）作用域，如函数、方法、类的内部局部作用域。 Enclosing 根据嵌套层次从内到外搜索，包含非局部（nonlocal）非全局（nonglobal）名字的任意封闭函数的作用域。如两个嵌套的函数，内层函数的作用域是局部作用域，外层函数作用域就是内层函数的 Enclosing作用域。 Global Built-in 如果 Python 在这些namespace找不到 X ，它将放弃查找并引发一个 NameError 异常： NameError: name 'aa' is not defined 程序在运行时，local、global、built-in三个namespace一定存在，但Enclosing namespace不一定存在。","text_tokens":[":","不到","时","对应","not","不","name","放弃","innermost","封闭","最","这个","根据","函数","但","enclosing","如果","包含","作用","两个","外层","搜索","在","'","非","x","是","层级","并","查找","类","global","如","会","当","全局","到","python","is","局部","这些","一行","当前","所","就是","三个","aa","代码","一定","、","defined","将","built","它","namespace","程序","去","值","内","。","层次","需要","内部"," ","-","外","（","）","引发","名字","开始","顺序","内层","：","以下","找","任意","作用域","nameerror","嵌套","nonglobal","的","运行","存在","使用","方法","一个","异常","，","local","从","nonlocal","in"],"title":"名字搜索顺序","title_tokens":["搜索","名字","顺序"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_8","text":"不能在名字未定义前引用该名字 if 、 for 语句并不会引入新的作用域 外层作用域不能引用内层作用域的变量 def try_to_define_name (): '''函数中定义了名字i，并绑定了一个整数对象1''' i = 1 try_to_define_name () print ( i ) #引用名字i之前，调用了函数 在引用名字 i 之前，明明调用了函数，定义了名字 i ，可是还是找不到这个名字： Traceback (most recent call last): File \"scope_test.py\", line 20, in <module> print(i) #引用名字i之前，调用了函数 NameError: name 'i' is not defined 虽然定义了名字 i ，但是定义在了函数的局部作用域对应的局部命名空间中，按照 LEGB 搜索规则，在全局作用域中自然访问不到局部作用域；再者，函数调用结束后，这个命名空间被销毁了。 引用变量总是与作用域相关的，因此：在Python中一个名字只有在定义之后，才能在合适的作用域引用。 一般来说， B,G 两个作用域的引入是不能够通过代码操作的（参考命名空间的生命周期），能够通过语句引入的作用域只有 E,L 了。Python中引入新作用域的语句很有限，总的来说只有如下三种： 通过定义函数引入 local 作用域或者 Enclosing 作用域；本质上， lambda 和生成器表达式也是函数，会引入新作用域。 类定义引入 local 作用域； 列表推导式引入 local 作用域，传说在 python2 中列表推导式不引入新的作用域 import语句 ： def import_sys (): '''import sys module''' import sys import_sys () print ( sys . path ) # NameError: name 'sys' is not defined 这个算非正常程序员的写法了，在另一篇文章 《Python进阶 - 对象，名字以及绑定》 中介绍过， import 语句在函数 import_sys 中将名字 sys 和对应模块绑定，那 sys 这个名字还是定义在局部作用域，跟上面的例子没有任务区别。","text_tokens":["call",":","1","不到","合适","进阶","周期","一篇","明明",">","《","区别","结束","表达式","对应","任务","not","自然","引用","scope","不","name","lambda","达式","中","命名","新","调用","总的来说","本质","整数","》","这个","def","规则","可是","写法","g","20","函数","三种","enclosing","sys","_","定义","define","traceback","成器","作用","两个","外层","之后","上面","非正常","搜索","有限","才能","模块","在","'","most","legb","前","path","例子","是","生命周期","未定","引入","并","类","上","l","(","绑定","参考","还是","一般","访问","会","那","表达","中将","python","按照","虽然","is","if","语句","能够","该","也","局部","销毁","但是","last","了","不能引用","test","b","传说","python2","函数调用","介绍","module","不会","通过","推导","程序员","代码","、","defined","<","操作","未定义","空间","和","程序","相关","过","之前","line","。","被","再者","生成","；"," ","-","总是","（","）","一般来说","后","名字","to","try","对象","print","recent","=","内层","生成器","列表",",","只有","以及","文章","：","因此","找","作用域","另","nameerror","来说","如下","式","的","file","e","#",".","算","与","import","\"","for","py","一个","没有","i","正常","，","生命","local","或者",")","变量","不能","跟","全局","in","很"],"title":"引用作用域需要注意的问题","title_tokens":["的","问题","需要","作用","注意","作用域","引用"]},{"location":"计算机基础/1.4.命名空间与作用域.html#global-nonlocal","text":"任何时候，python都可以直接读取全局变量，但是却不可以在内层作用域直接改写上层变量，来看一个典型的 闭包 结构： #e.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv = [ 'gv' ] + gv #UnboundLocalError:local variable 'gv' referenced before assignment lv = [] def inn_func (): lv = lv + [ v ] #UnboundLocalError:local variable 'lv' referenced before assignment gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 实际 调用 func() 函数后，上面两处对 gv 和 lv 进行赋值操作的地方都会发生 UnboundLocalError ： 因为 Python 在执行函数前，会首先生成各层命名空间和作用域 ，因此 Python 在执行赋值前会将 func 内的 'gv' 'lv' 写入局部命名空间和闭包命名空间，当 Python 执行 赋值时会在局部作用域、闭包作用域内发现局部命名空间和闭包命名空间内已经具有 'gv' 和 'lv' 标识符，但这两个非全局标识符在该赋值语句执行之前并没有被赋值，也即没有对象与标识符关联，因此无法参与四则运算，从而引发错误。 这段程序本意只是想让具有对象的全局变量 gv 和局部变量 lv 参与运算，为了避免类似的情况发生， Python 便引入了 global 、 nonlocal 语句来说明所修饰的 gv 、 lv 分别来自全局命名空间和局部命名空间 ，声明之后，就可以在 func 和 inn_func 内直接改写上层命名空间内 gv 和 lv 的值： #f.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): global gv gv = [ 'gv' ] + gv lv = [] print ( id ( lv )) def inn_func (): nonlocal lv lv = lv + [ v ] print ( id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) # 2608229974344 a () # 2608229974344 # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] print ( gv ) # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] 如上，全局变量 gv 值被函数改写了， inn_func 修改的也确实是父函数 lv 的值 （依据 ID 判断）。","text_tokens":[":","1","标识","var","insert","各层","before","写入","inn","+","让","便","想","对","段程序","从而","不","referenced","assignment","命名","赋值","调用","def","避免","已经","函数","但","发现","_","说明","作用","两个","上面","来自","之后","0","全局变量","在","典型","'","非","unboundlocalerror","前","却","是","a","都","引入","修改","并","上","global","(","如","只是","会","即","当","python","类似","四则","is","语句","该","也","局部","可以","但是","为了","本意","首先","标识符","f","了","局部变量","上层","任何","声明","读取","所","依据","父","来看","func","四则运算","地方","、","lv","将","[","实际","操作","和","空间","就","程序","关联","闭包","之前","来","值","内","无法","。","被","运算","结构","生成","分别","v"," ","判断","（","）","前会","后","引发","参与","nonlocal","确实","发生","两处","对象","print","=","情况","variable","内层",",","]","具有","：","因此","作用域","改写","时候","gv","的","return","e","#",".","修饰","2608229974344","错误","id","因为","与","py","一个","没有","，","时会","进行","local",")","执行","这","变量","全局","直接"],"title":"global和 nonlocal的作用","title_tokens":["的","global","作用","和"," ","nonlocal"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_9","text":"那么是不是不使用 global 和 nonlocal 就不能达到上面的目的呢？来看看这段程序： #g.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv . insert ( 0 , 'gv' ) # 注意的是.insert只是对gv的元素进行修改，而不是修改gv整个对象,gv是list，元素可变 lv = [] print ( id ( lv )) def inn_func (): lv . append ( v ) # 注意的是.insert只是对lv的元素进行修改，而不是修改lv整个对象 print ( id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 执行的结果： a = func ( 'is' ) # 2608110869168 a () # 2608110869168 # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] print ( gv ) # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] 可以发现，执行结果同上面完全一致，问题自然来了：“为什么不用 global nonlocal 也可以改写全局变量 gv 和父函数变量 lv 的值？ 为了看清楚这个过程，我们将上面的 gv.insert(0, 'gv') 和 lv.append(v) 改写为 gv[0:0] = ['gv'] 和 lv[:] = [v] ： #h.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv [ 0 : 0 ] = [ 'gv' ] lv = [] print ( id ( lv )) def inn_func (): lv [:] = [ v ] print ( id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 执行结果： a = func ( 'is' ) # 2608229959496 a () # 2608229959496 # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] 同 g.py 文件的执行结果完全一致，事实上两者之间的内在也是完全一样的。 其实，我们其实改写的不是 gv 和 lv ,而是 gv 和 lv 的元素 gv[0:0] 和 lv[:] 。因此，不需要 global 和 nonlocal 修饰就可以直接改写， 这就是“借壳”， 这是因为list是可变对象。 在 nonlocal 尚未引入 Python 中，比如 Python 2.x 若要在子函数中改写父函数变量的值就得通过这种方法。当然借壳蕴藏着一个相对复杂的标识符创建的问题：比如子函数通过借壳修改父函数变量 lv 的值，那么子函数的标识符 lv 是怎么绑定到父函数变量 lv 的值 ID 的上的？ 关于这个问题，这里有个问答就是讨论这个的： python的嵌套函数中局部作用域问题? 这个问题在python函数传参的内容有讲清楚。","text_tokens":["一致",":","蕴藏","1","标识","有个","什么","var","insert","同","为什么","创建","问答","inn","对","比如","段程序","我们","自然","是因为","不","而","中","之间","讲清楚","h","直接","这种","这个","问题","def","append","g","函数","两者","发现","_","事实","作用","注意","着","上面","0","全局变量","2608110869168","当然","在","'","若要","?","x","是","不用","看看","a","引入","修改","借壳","相对","上","global","(","看清","绑定","结果","只是","到父","整个","全局","python","可变","复杂","is","完全一致","也","局部","可以","为了","内在","标识符","了","“","事实上","怎么","这里","父","两者之间","就是","关于","讨论","通过","func","lv","将","[","元素","是不是","达到","和","就","讲清","程序","看清楚","来","值","。","v","需要"," ","传参","子函数","那么","对象","print","=","一样",",","而是","]","文件","：","因此","目的","过程","作用域","内容","改写","gv","嵌套","的","return","修饰","#",".","使用","id","因为","呢","方法","py","一个","得","有","2608229959496","，","尚未","进行","其实","？",")","这","执行","list","2","变量","不能","完全","为","”","nonlocal","不是","清楚"],"title":"借壳","title_tokens":["借壳"]},{"location":"计算机基础/1.4.命名空间与作用域.html#global-nonlocal_1","text":"另外，需要注意的是：global 语句只是声明该标识符引用的变量来自于全局变量，但并不能直接在当前层创建该标识符；nonlocal 语句则会在子函数命名空间中创建与父函数变量同名的标识符： #j.py gv = 'a global var' def func (): global gv lv = 'a local var' print ( locals ()) def inn_func (): nonlocal lv global gv print ( locals ()) return inn_func 执行结果： c = func () { 'lv' : 'a local var' } #运行 `func` 函数后，`global` 语句并未将 `gv` 变量引入局部命名空间 c () { 'lv' : 'a local var' } #运行闭包函数后，`nonlocal` 语句将父函数变量 `lv` 引入闭包命名空间 之所以 nonlocal 语句与 global 语句的处置不同，在于全局变量的作用域生存期很长，在模块内随时都可以访问，而父函数的局部作用域在父函数执行完毕后便会直接释放，因此 nonlocal 语句必须将父函数变量的标识符和引用写入闭包命名空间。","text_tokens":[":","标识","完毕","locals","var","写入","创建","inn","于","便","引用","中","命名","在于","则","def","生存期","但","函数","将父","_","}","并未","作用","注意","来自","全局变量","模块","在","'","`","很长","是","a","都","引入","并","处置","{","global","(","结果","只是","会","访问","而父","全局","释放","语句","该","局部","可以","标识符","之所以","不同","当前","声明","j","父","func","另外","lv","将","层","空间","和","闭包","存期","内","。","需要","；"," ","子函数","后","生存","print","c","=","随时","：","因此","作用域","gv","的","所以","return","运行","#",".","必须","与","py","，","local",")","执行","变量","不能","nonlocal","同名","直接"],"title":"global 和 nonlocal 语句对标识符创建的不同影响","title_tokens":["的","global","标识","语句","对","影响","标识符","和"," ","nonlocal","创建","不同"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_10","text":"首先，函数和类执行时都会产生局部命名空间，但类的执行机制不同于函数： # i . py def a (): print ( 'function' ) class A (): print ( 1 ) class B (): print ( 2 ) class C (): print ( 3 ) 执行文件，结果为： 1 2 3 如上，类就是一个可执行的代码块，只要该类被加载，就会被执行，这一点不同于函数。 类之所以这么设计的原因在于：类是创建其他实例（生成其他的类或者具体的对象）的对象，因此必须在实例之前被创建，而类又可能涉及到与其他类的继承、重载等一系列问题，故在代码加载时就被创建利于提高效率和降低逻辑复杂度。 其次，与函数不同的是，类的局部命名空间并非作用域 class A(): a = 1 b = [a + i for i in range(3)] #NameError: name 'a' is not defined 执行上段代码，我们可以发现在类 A 内列表推导式无法调取 a 的值，但函数却可以： def func (): a = 1 b = [ a + i for i in range ( 3 )] print ( b ) func () # [ 1 , 2 , 3 ] 因此， A 中的 a 不同于函数 func 中的 a 在局部命名空间中可以被任意读取，之所以说是“不可以被任意”读取而不是“不可被读取”，原因在于在类 A 的局部空间内， a 其实一定程度上是可以直接被读取的： class A(): a = 1 c = a + 2 执行上段代码后： A.c #3 而上例中 b 的赋值操作不能执行，原因在于列表推导式会创建自己的局部命名空间，因此难以访问到 a 。","text_tokens":[":","1","时","创建","+","产生","我们","not","不","name","说","而","中","命名","难以","实例","在于","赋值","一系列","一点","直接","def","问题","函数","而类","但","发现","可能","重载","等","作用","其他","机制","在","'","却","是","a","块","都","但类","利于","上","系列","(","如","结果","其次","访问","会","提高效率","到","可","复杂","is","一系","局部","可以","不可","程度","首先","之所以","“","不同","提高","b","读取","3","该类","具体","就是","复杂度","加载","推导","原因","同于","func","function","继承","代码","又","一定","、","只要","defined","[","操作","空间","和","就","之前","值","内","并非","。","被","逻辑","无法","生成","调取","class","段"," ","（","降低","）","后","对象","print","c","range","不同于","=","涉及","列表",",","上例","]","文件","：","因此","任意","作用域","nameerror","式","的","所以","故","#",".","必须","与","for","py","一个","高效率","i","高效","效率","，","这么","其实","或者","执行",")","这","2","设计","不能","为","”","类","in","不是","自己"],"title":"类的局部命名空间","title_tokens":["命名","局部","的","空间","类"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_11","text":"啰嗦了这么多，终于该结尾了！ 我们再来回过头来看下文章开头的栗子： 1、为什么 b.py 只是导入 a.py 中的 class A ,却执行了整个 a.py 文件? 答：因为 Python 并不知道 class A 在 a.py 文档的何处，为了能够找到 class A ，Python 需要执行整个文档。 2、为什么 b.py 的导入执行了整个 a.py 文档，却在 b 中难以调用 a 的全局变量 va ？ 答：Python 的全局变量指的是模块全局，因此不可以跨文档，因此 global 语句也是不可以跨文档的。另外， b 只是导入了 a 的 class A ，因此并不会导入 a 中所有的标识符，所以 类似 a.va 这样的调用也是不起作用的。 关于命名空间： 1、赋值、定义类和函数都会产生新的标识符； 2、全局变量的标识符不能跨文档； 3、各级命名空间相互独立互不影响； 4、Python 总是从当前层逐渐向上寻找标识符； 5、内层作用域若想直接修改上层变量，需要通过 global nonlocal 语句先声明； 6、单纯的 global 语句并不能为所在层级创建相应标识符，但 nonlocal 语句可以在闭包空间中创建相应标识符； 7、类的局部命名空间不是作用域。","text_tokens":["1","标识","并不知道","什么","为什么","创建","回过头来","产生","答","我们","不","各级","难以","中","命名","赋值","调用","新","5","函数","寻找","但","定义","这样","互不","作用","若想","找到","全局变量","模块","指","在","?","影响","却","是","跨","a","层级","都","修改","并","开头","类","先","global","！","只是","会","相应","整个","再","python","导入","类似","不是","啰嗦","语句","能够","终于","该","7","也","局部","可以","多","为了","向上","单纯","标识符","所在","了","看","结尾","b","上层","文档","当前","4","声明","3","回过","关于","不会","通过","另外","不知","、","不起作用","层","6","空间","和","闭包","来","。","va","class","需要","；"," ","总是","nonlocal","相互","何处","内层",",","文章","文件","：","过头","因此","逐渐","所有","作用域","的","所以",".","因为","py","栗子","，","这么","？","执行","2","下","知道","变量","独立","不能","从","为","全局","直接"],"title":"总结","title_tokens":["总结"]},{"location":"计算机基础/1.5.字符编码.html","text":"相对于数字，字符串比较特殊的是还有一个编码问题。 一般，计算机的系统结构是基于数字信号来搭建的，计算机中的计算基于数字电路。在计算机内部，所有信息最终都是一个二进制值。计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。 每一个二进制位（bit）有 0 和 1 两种状态，最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），因此一个字节可以表示256种状态（$2^8=256$），每一个状态对应一个符号，就是256个符号，从 00000000 到 11111111 。一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是 65535 ，4个字节可以表示的最大整数是 4294967295 。 ASCII码 因为计算机是美国人发明的，所以在上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。ASCII 码一共规定了128个字符的编码，比如空格 SPACE 是32（二进制 00100000 ），大写的字母 A 是65（二进制 01000001 ）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为 0 。 非ASCII码 英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的 é 的编码为130（二进制 10000010 ）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了 é ，在希伯来语编码中却代表了字母 Gimel ( ג )，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。 GB2312码 汉字多达10万左右，要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了 GB2312 编码，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 可以想得到的是，全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。 Unicode 正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode就像它的名字都表示的，这是一种所有符号的编码。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，可以查询 unicode.org ，或者专门的 汉字对应表 。 Unicode 的问题 需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。（ 这里说的储存是储存在 ROM 中，比如说硬盘。 ） 比如，汉字 严 的 Unicode 是十六进制数 4E25 ，转换成二进制数足足有15位（ 100111000100101 ），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0 ，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 因此不能用Unicode码直接储存文件。 它们造成的结果是： 出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。 Unicode 在很长一段时间内无法推广，直到互联网的出现。 UTF-8 互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。 ==强调一下Unicode和UTF-8的区别：UTF-8是Unicode的一种储存形式，但计算机只能读取二进制的内容，因此计算机读取UTF-8编码的文件，需要将文件转码为Unicode（Unicode是完全二进制的形式）。也就是说，文件以UTF-8的形式储存在硬盘上，以Unicode的形式储存在内存（Ram）中。==例如： 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。 所以你看到很多网页的源码上会有类似 <meta charset=\"UTF-8\" /> 的信息，表示该网页正是用的UTF-8编码。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为 0 ，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于 n 字节的符号（ n > 1 ），第一个字节的前 n 位都设为 1 ，第 n + 1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母 x 表示可用编码的位。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） ----------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是 0 ，则这个字节单独就是一个字符；如果第一位是 1 ，则连续有多少个 1 ，就表示当前字符占用多少个字节。 下面，还是以汉字 严 为例，演示如何实现 UTF-8 编码。 严 的 Unicode 是 4E25 （ 100111000100101 ），根据上表，可以发现 4E25 处在第三行的范围内（ 0000 0800 - 0000 FFFF ），因此 严 的 UTF-8 编码需要三个字节，即格式是 1110xxxx 10xxxxxx 10xxxxxx 。然后，从 严 的最后一个二进制位开始，依次从后向前填入格式中的 x ，多出的位补 0 。这样就得到了， 严 的 UTF-8 编码是 11100100 10111000 10100101 ，转换成十六进制就是 E4B8A5 。 UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。 参考 字符编码笔记：ASCII，Unicode 和 UTF-8","text_tokens":["哪怕","1","~","最大","强烈要求","发信人","转换成","为例",">","时","0000","俄语","不过","利用","128","强调","记事","各国","汉字","对","相同","统一","简单","显然","新","15","规模","规则","容纳","charset","正如","已经","发现","继续","出现","|","4294967295","还","码","0","表","造成","至少","后面","设为","种","作为","最终","更大","在","提及","非","很长","前","解读","不用","a","一种","100111000100101","十进制","历史","byte","硬盘","先","只用","一般","4e25","meta","额外","即","gb","当","不管","基于","你","如何","7","65","也","0080","可以","多万","严重","多","韩国","浪费","能","把","沿用","做","每","制定","实际上","文本文件","4","这里","0010","不可避免","储存","操作系统","代码","许多","搭建","<","用","一部","毫无","它","就","邮件","单字节","音符","无法","ג","生成","ffff","；"," ","100","字节","第三行","中文","很大","后","开始","多个","实现","占用","10100101","时间","完成","再有","希伯来","因此","无关","所有","10111000","英文字母","另","位为","填入","直到","这样一来","使用","\"","一个","用来","韩文","没有","十六进制","？","10000010","知道","从","形式","一段时间","闲置","于是","以","规定","第一","110xxxxx","查询","混合","想","也就是说","不管怎样","一下","空格","比较","乱码","现在","这个","源码","编码方式","避免","_","一节","这样","注意","两个","着","0800","二条","130","想得到","16","却","前面","后文","状态","推广","相对","一共","/","只是","三行","可用","到","位补","打印","ascii","虽然","收信","但是","11100100","比如说","存储","动态","不同","读取","3","文本","显示","就是","space","bit","很多","控制","日文","基本","又","发展","将","浏览器","第二个","操作","国家","否则","来","个字符","内","被","需要","数字电路","接受","解释","理论","出来","=","有二到","一些","org","日本","只有","二三倍","多达","就够","$","集合","系统结构","一来","注音","转换","数字电","内存","关系","上个世纪","所以","多种","非常","欧洲","euc","数","打开","剩下","全部","发明","英语","大多数","二进制位","8","设计","01000001","地","不能","完全","类","直接","要求","第一个","务器","部分","什么","多少","255","极大","下面","下表","大量","区别","+","年代","然后","多出","我们","笔记","unicode","变长","中","之间","从后","整数","则","万左右","体系","冲突","系统","如果","第三","0001","其他","互联","足足有","e4b8a5","二个","11110xxx","一直","多万个","上表","shift","万个","算机","x","字符串","收信人","标准","变化","上","65536","英文","二进制","参考","语言","同一个","文字","会","处理","大出","沿用至今","最后","进制","更","人","电子","第二","该","这些","支持","看到","正是","左右","10xxxxxx","rom","还有","了","一位","一段","11111111","怎样","当前","服务","长度","三个","美国","最广","决定","普及","英文字","应运","码是","百种","n","所说","编程","个","总结","结构","本文","集","发信","这是","内部","-","汉字编码","一律","那么","名字","它们","换成","采用","现代","非常简单","单独","联网","0xxxxxxx","特殊","网页","许多种","例如","软件","上会","内容","来说","格式","时候","应运而生","大多",".","电路","第一位","07ff","存在","错误","必须","对于","因为","与","注音符号","工作","32","全世界","字母","称为","，","最高","就是说","大写","像","记事本",")","这","2","下","计算机","很","好处","常用","传输","单字","常常","严","每个","信号","00100000","成","符号","为什么","信息","于","代表","对应","比如","kr","方式","不","应该","而","说","一套","专门","用到","最","问题","世纪","多数","甚至","但","根据","演示","希伯来语","可能","三倍","四个","é","强烈","足足","只","才能","比特","数字信号","不够","位","世界","设","处在","是","两种","不断","都","第","段时间","同一","(","还是","结果","电子邮件","跟据","gimel","一部分","1110xxxx","再","连续","二三","007f","范围","最早","类似","至今","256","127","00000000","大小","数字","保存","10","依次","不可","必然","两位","要","怎么","60","不会","^","编程语言","只能","法语","utf","从文件","实际","和","表示","包括","值","65535","。","分别","gb2312","看成","（","里","）","编码","而且","编入","浏览","或","中国","一样","服务器","遗留","文件","：","偏僻","上个","得到","编辑","的","ram","十六","上方","最多","呢","毫无关系","计算","向前","互联网","有","编","或者","特点","位设","字符","转码","jis","为","不是"],"title":"1.5.字符编码","title_tokens":["编码",".","1.5","字符"]},{"location":"计算机基础/1.5.字符编码.html#ascii","text":"因为计算机是美国人发明的，所以在上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。ASCII 码一共规定了128个字符的编码，比如空格 SPACE 是32（二进制 00100000 ），大写的字母 A 是65（二进制 01000001 ）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为 0 。","text_tokens":["规定","00100000","符号","年代","128","对","比如","统一","一套","空格","之间","计算机","最","世纪","码","0","后面","只","一直","在","算机","位","是","a","前面","一共","二进制","沿用至今","至今","打印","ascii","进制","人","7","65","沿用","做","了","一位","制定","60","space","美国","控制","包括","个字符","个","。","被"," ","字节","（","）","编码","出来","占用","上个","关系","上个世纪","的","所以","因为","与","一个","计算","32","字母","称为","，","发明","英语","大写","二进制位","这","字符","01000001","不能","为"],"title":"ASCII码","title_tokens":["ascii","码"]},{"location":"计算机基础/1.5.字符编码.html#ascii_1","text":"英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的 é 的编码为130（二进制 10000010 ）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了 é ，在希伯来语编码中却代表了字母 Gimel ( ג )，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。","text_tokens":["哪怕","闲置","于是","255","俄语","符号","利用","128","代表","比如","不管怎样","方式","不","中","新","问题","编码方式","体系","希伯来语","出现","这样","é","码","其他","0","130","在","不够","位","却","是","都","(","二进制","语言","只是","会","gimel","不管","ascii","256","127","进制","可以","这些","但是","了","不同","一段","怎样","这里","法语","又","用","决定","它","就","表示","国家","个","音符","无法","。","ג"," ","字节","-","（","）","编码","编入","它们","一样","一些","就够","希伯来","一来","因此","所有","注音","另","的","欧洲","这样一来","上方","使用","注音符号","最多","一个","用来","有","字母","，","最高","英语",")","这","10000010","为"],"title":"非ASCII码","title_tokens":["ascii","非","码"]},{"location":"计算机基础/1.5.字符编码.html#gb2312","text":"汉字多达10万左右，要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了 GB2312 编码，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 可以想得到的是，全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。","text_tokens":["符号","混合","各国","汉字","kr","unicode","中","显然","最","乱码","万左右","避免","冲突","_","出现","两个","还","至少","在","想得到","shift","不够","x","世界","是","都","标准","后文","上","65536","语言","结果","会","处理","gb","到","ascii","256","虽然","可以","多","10","但是","韩国","把","不可","左右","了","制定","要","文本","显示","就是","不可避免","日文","utf","用","毫无","和","表示","百种","就","个","。","需要","gb2312"," ","-","字节","汉字编码","里","编码","中文","而且","理论","出来","多个","中国","=","日本","多达","无关","关系","得到","的","所以","使用","euc","与","毫无关系","一个","全世界","韩文","有","编","，","8","地","jis","不能","类"],"title":"GB2312码","title_tokens":["gb2312","码"]},{"location":"计算机基础/1.5.字符编码.html#unicode","text":"正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode就像它的名字都表示的，这是一种所有符号的编码。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，可以查询 unicode.org ，或者专门的 汉字对应表 。","text_tokens":["常用","常常","发信人","每个","什么","成","符号","为什么","查询","对应","想","汉字","统一","方式","不","unicode","一套","专门","用到","最","乱码","问题","现在","规模","容纳","正如","多数","编码方式","但","系统","一节","出现","如果","这样","两个","着","表","在","多万个","万个","解读","世界","是","一种","收信人","不断","都","标准","同一","上","二进制","语言","同一个","电子邮件","会","到","进制","电子","数字","收信","也","可以","多万","支持","把","了","不同","要","文本文件","4","文本","就是","不会","操作系统","编程语言","发展","用","它","应运","就","邮件","和","否则","表示","操作","所说","编程","个","。","被","本文","发信","这是","需要"," ","100","字节","（","里","编码","）","很大","解释","名字","现代","一样","org","再有","文件","集合","因此","偏僻","所有","应运而生","的","多种","大多","非常",".","存在","必须","错误","使用","因为","一个","打开","，","大多数","像","或者","？","字符","知道","直接"],"title":"Unicode","title_tokens":["unicode"]},{"location":"计算机基础/1.5.字符编码.html#unicode_1","text":"需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。（ 这里说的储存是储存在 ROM 中，比如说硬盘。 ） 比如，汉字 严 的 Unicode 是十六进制数 4E25 ，转换成二进制数足足有15位（ 100111000100101 ），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0 ，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 因此不能用Unicode码直接储存文件。 它们造成的结果是： 出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。 Unicode 在很长一段时间内无法推广，直到互联网的出现。","text_tokens":["第一个","严","每个","转换成","规定","极大","第一","符号","区别","汉字","也就是说","比如","我们","统一","方式","应该","unicode","说","而","中","15","直接","这个","问题","甚至","已经","可能","如果","出现","三倍","注意","两个","四个","码","其他","0","造成","足足","至少","互联","足足有","只","才能","二个","更大","在","很长","前","算机","位","却","是","100111000100101","都","段时间","推广","硬盘","只用","英文","二进制","4e25","结果","文字","只是","会","大出","二三","ascii","大小","进制","如何","更","第二","浪费","严重","可以","多","比如说","rom","必然","了","存储","不同","一段","文本文件","4","怎么","这里","3","文本","就是","储存","三个","代码","许多","用","第二个","它","英文字","就","表示","和","个","无法","内","。","分别","集","本文","需要","这是"," ","字节","（","）","接受","那么","换成","它们","或","有二到","联网","二三倍","时间","许多种","就够","文件","：","因此","转换","英文字母","来说","格式","的","多种","直到","十六","对于","数","呢","一个","计算","用来","互联网","没有","有","字母","，","就是说","十六进制","或者","？","这","2","知道","不能","计算机","不是","一段时间"],"title":"Unicode 的问题","title_tokens":[" ","问题","的","unicode"]},{"location":"计算机基础/1.5.字符编码.html#utf-8","text":"互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。 ==强调一下Unicode和UTF-8的区别：UTF-8是Unicode的一种储存形式，但计算机只能读取二进制的内容，因此计算机读取UTF-8编码的文件，需要将文件转码为Unicode（Unicode是完全二进制的形式）。也就是说，文件以UTF-8的形式储存在硬盘上，以Unicode的形式储存在内存（Ram）中。==例如： 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。 所以你看到很多网页的源码上会有类似 <meta charset=\"UTF-8\" /> 的信息，表示该网页正是用的UTF-8编码。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为 0 ，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于 n 字节的符号（ n > 1 ），第一个字节的前 n 位都设为 1 ，第 n + 1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母 x 表示可用编码的位。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） ----------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是 0 ，则这个字节单独就是一个字符；如果第一位是 1 ，则连续有多少个 1 ，就表示当前字符占用多少个字节。 下面，还是以汉字 严 为例，演示如何实现 UTF-8 编码。 严 的 Unicode 是 4E25 （ 100111000100101 ），根据上表，可以发现 4E25 处在第三行的范围内（ 0000 0800 - 0000 FFFF ），因此 严 的 UTF-8 编码需要三个字节，即格式是 1110xxxx 10xxxxxx 10xxxxxx 。然后，从 严 的最后一个二进制位开始，依次从后向前填入格式中的 x ，多出的位补 0 。这样就得到了， 严 的 UTF-8 编码是 11100100 10111000 10100101 ，转换成十六进制就是 E4B8A5 。 UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。","text_tokens":["要求","传输","第一个","务器","1","~","强烈要求","最大","单字","以","严","为例","转换成","多少",">","0000","第一","下面","不过","符号","110xxxxx","下表","大量","区别","+","信息","强调","记事","然后","汉字","也就是说","相同","多出","统一","方式","简单","unicode","一下","变长","中","而","从后","则","这个","规则","源码","charset","编码方式","根据","但","演示","发现","继续","如果","出现","|","这样","两个","第三","0800","四个","0001","还","码","强烈","其他","0","互联","后面","e4b8a5","设为","只","二条","11110xxx","上表","在","提及","前","算机","16","位","x","设","解读","不用","是","处在","一种","100111000100101","都","第","历史","变化","硬盘","上","(","二进制","还是","4e25","meta","额外","跟据","/","会","三行","为","即","一部分","当","可用","再","1110xxxx","连续","007f","最后","到","范围","类似","位补","ascii","你","进制","如何","该","7","0080","保存","可以","10","看到","正是","依次","11100100","把","支持","10xxxxxx","了","一位","动态","不同","两位","实际上","当前","4","读取","0010","服务","就是","长度","储存","三个","只能","很多","基本","部分","utf","最广","从文件","将","<","用","普及","浏览器","一部","它","码是","和","表示","就","实际","单字节","n","包括","个","内","。","被","总结","生成","ffff","需要","；"," ","看成","字节","-","（","里","）","编码","一律","第三行","后","开始","换成","浏览","非常简单","单独","或","联网","=","0xxxxxxx","实现","服务器","占用","只有","10100101","完成","遗留","网页","例如","文件","：","因此","软件","10111000","上会","转换","内容","时候","位为","格式","填入","内存","得到","编辑","的","所以","非常","ram","第一位","07ff","十六","使用","对于","\"","工作","一个","计算","向前","32","互联网","剩下","没有","有","记事本","字母","，","就是说","全部","英语","十六进制","或者","特点","位设","二进制位","8","字符","2","转码",")","下","形式","完全","计算机","从","很","好处"],"title":"UTF-8","title_tokens":["utf","8","-"]},{"location":"计算机基础/1.5.字符编码.html#_1","text":"字符编码笔记：ASCII，Unicode 和 UTF-8","text_tokens":["，","：","utf","和","字符","ascii","8","笔记"," ","-","unicode","编码"],"title":"参考","title_tokens":["参考"]}]}