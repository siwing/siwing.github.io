{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Python基础/2.1.python基本语法.html","text":"简介 Python是一种解释型语言，Python解释器通过一次执行一条语句的方式运行程序。标准的交互式python解释器(CPython)可以在cmd窗口通过 python 命令启动。标准的交互式python解释器的提示符是 >>> 。 而加强的交互式解释器(IPython)的提示符是一种编号的风格，如 In[2] ，而不是标准的 >>> 。 python保留字 保留字即关键字，我们不能把它们用作任何标识符名称。Python的标准库提供了一个keyword模块，可以输出当前版本的所有关键字： import keyword keyword . kwlist print ( keyword . kwlist ) ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 注释 Python中单行注释以 # 开头。多行注释则使用： ''' 或者 \"\"\" 。实际上python只有单行注释。多行注释的本质是字符串对象。 # 这里是单行注释 ''' 这里是多行注释 这里是多行注释 ''' 代码块 python最具特色的就是使用缩进来表示代码块，不是使用大括号{}。而冒号表示一段缩进代码块的开始，其后所有相同层次的代码必须保持相同的缩进量，缩进量则可以随意，直至代码块结束。 一般约定俗成使用4个空格的缩进。 if True : print ( \"True\" ) else : print ( \"False\" ) True 代码续行 如果语句很长，可以使用反斜杠 \\ 来续行，例如： a = 3 + \\ 4 + \\ 5 a 12 在 [] , {} , 或 () 中的多行语句，不需要使用反斜杠 \\ ，例如： total = [ 'item_one' , 'item_two' , 'item_three' , 'item_four' , 'item_five' ] total ['item_one', 'item_two', 'item_three', 'item_four', 'item_five'] 同一行书写多条语句 Python可以在同一行中使用多条语句，语句之间使用分号 ; 分割。但这样的做法一般不推荐，因为会使代码的可读性变差。 空行 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同， 空行并不是Python语法的一部分。 书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。空行也是程序代码的一部分。 Print 输出 print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=\"\"： x = \"a\" y = \"b\" # 换行输出 print ( x ) print ( y ) print ( '---------' ) # 不换行输出 print ( x , end = \" \" ) print ( y , end = \" \" ) print () a b --------- a b import 与 from...import 在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块 ( module ) 导入： import somemodule 从某个模块中导入某个函数： from somemodule import somefunction 从某个模块中导入多个函数： from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入： from somemodule import * 转义符 \\ 如果要在字符串中输入一些特殊的字符（这些特殊的字符特殊之处在于不能直接输出），这就需要“转义符”。所谓转义，就是不采用符号原先的含义，而采用另外一含义。在Pyhton中， \\ 代表转义符。 下面表格中列出常用的转义符： 转义字符 描述 \\ (在行尾时) 续行符 \\ 反斜杠符号 \\' 单引号 \\\" 双引号 \\a 响铃 \\b 退格(Backspace) \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\oyy 八进制数，yy代表的字符，例如：\\o12代表换行 \\xyy 十六进制数，yy代表的字符，例如：\\x0a代表换行 \\other 其它的字符以普通格式输出 有时候，字符串包含了很多转义符 \\ ，但实际上我们想输出的是反斜杠符号 \\ ，而不是把 \\ 看作转义符（例如输入文件路径）。此时，自然可以在反斜杠前加上转义符 \\ ，但是这样未免太麻烦。Python提供了一个简化的操作，Pyhon允许用 r'字符串内容' 表示 '字符串内容' 内部的字符串默认不转义： print ( ' \\\\\\t\\\\ ' ) print ( '---------' ) print ( r ' \\\\ \\t \\\\ ' ) \\ \\ --------- \\\\\\t\\\\ name与object 实际上，Python中没有类似c\\c++中的变量这个概念，python中只有name和object。因此在python中，变量（name）无法被声明。同时也正是因为没有变量这个概念，在Python中也没有所谓的初始化、赋值的行为。 Objects All Python objects have this: a unique identity (an integer, returned by id(x))（notice：identity not identifier） a type (returned by type(x)) some content（值） You cannot change the identity. You cannot change the type. 改变位于某一地址的对象的引用与类型是不可能的，只能把对象销毁，然后重新创建。 Some objects allow you to change their content (without changing the identity or the type, that is). Some objects don’t allow you to change their content . The type is represented by a type object, which knows more about objects of this type(how many bytes of memory they usually occupy, what methods they have, etc). (Update: In CPython 2.2 and later, you can change the type under some rather limited circumstances.) 一个对象可以有： zero or more methods (provided by the type object)zero or more names Some objects have methods that allow you to change the contents of the object (modify it in place, that is). Some objects only have methods that allow you to access the contents, not change it. Some objects don’t have any methods at all. Even if they have methods, you can never change the type, nor the identity. Names The names are a bit different — they’re not really properties of the object,and the object itself doesn’t know what it’s called. 所有name在创建时必须关联（bind）到一个object，否则在需要引用该name时会报错。 name可以在创建以后指向任何一个object（包括不同类型），所以name本身没有类别，但name关联的object是有类别的。 在python中可以使用type（name）来查看name关联的object的类型。 一个对象可以关联（bind）多个名字，也可以没有名字。 Names live in namespaces (such as a module namespace, an instance namespace, a function’s local namespace). assignment python也有assignment这个英文概念，但与之对应的中文却不应该成为赋值，而是分配，或者说命名。 Assignment statements modify namespaces, not objects.换而言之，如果在python中有一个assignment statement如下： a = 10 这个assignment语句使得相应的namespace的a键所对应的value为10。另外assignment语句还有这样的作用： name = [] name . append （ 1 ） 第一条语句将 name 关联到一个空列表对象，第二条语句修改了该列表的内容，这并不会触及namespace。 综上所述，assignment statement在python中有两个作用：1. 用于（重新）将名称绑定到对象2. 修改可变对象的属性（内容） 单引号与双引号 在Python中单引号和双引号都可以用来表示一个字符串，比如： str1 = 'python' str2 = \"python\" str1和str2是没有任何区别的。 Python以其易用性而著名，但单引号和双引号却不仅仅是为了方便。想想I'm a big fans of Python.这个字符串应该怎么定义？可以这样写： str3 = 'I \\' m a big fan of Python.' 那么We all know that 'A' and 'B' are two capital letters.又该怎么定义呢？ str4 = 'We all know that \\' A \\' and \\' B \\' are two capital letters.' 显然太多的转义符看起来并不好看，而且容易出错了。那么，在Python中，还可以这样写： str4 = \"We all know that 'A' and 'B' are two capital letters.\" 这样就人性化多了，这就是Python支持双引号和单引号都能用来定义字符串的原因。反之，如果字符串中有双引号，为了避免使用转义符，你可以使用单引号来定义这个字符串。比如： str5 = 'The teacher said: \"Practice makes perfect\" is a very famous proverb.' 这就是Python易用性和人性化的一个极致体现，当你用单引号' '定义字符串的时候，它就会认为你字符串里面的双引号\" \"是普通字符，从而不需要转义。反之当你用双引号定义字符串的时候，就会认为你字符串里面的单引号是普通字符无需转义。 Lambdas 正常创建函数（使用def）会自动将其赋值给变量，这与创建其他对象（例如字符串和整数）不同，后者可以动态创建，而无需将它们分配给变量。但只要使用lambda语法创建函数，函数也可以这样做，以这种方式创建的函数称为匿名（anonymous）函数。将简单函数作为参数传递给另一个函数时，最常使用此方法。语法如下： # my_func是正常创建的函数（named function） def my_func ( f , arg ): return f ( arg ) my_func ( lambda x : 2 * x * x , 5 ) 50 在上面的代码中，我们动态创建了一个匿名函数，并使用参数调用它。Lambda函数没有命名函数（named function）那么强大。Lambda函数只能包含一个表达式，通常相当于一行代码。实际上，Lambda函数可以分配给变量，并像普通函数一样使用。但是，很少有充分的理由这样做。通常使用def来定义函数通常更好。 double = lambda x : x * 2 print ( double ( 7 )) 14 运算符 算术运算符 运算符 描述 + 加 - 减 * 乘 / 除 % 取模 ** 幂 // 取整除 比较运算符 运算符 描述 == 等于 != 不等于 > 大于 \\< 小于 >= 大于等于 \\<= 小于等于 赋值运算符 运算符 描述 = 简单的赋值运算符 += 加法赋值运算符 -= 减法赋值运算符 *= 乘法赋值运算符 /= 除法赋值运算符 %= 取模赋值运算符 **= 幂赋值运算符 //= 取整除赋值运算符 位运算符 运算符 描述 & 按位与运算符：参与运算的两个值,如果两个相应位都为1，则该位的结果为1，否则为0 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1 \\^ 按位异或运算符：当两对应的二进位相异时，结果为1 \\~ 按位取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1。\\~x 类似于 -x-1 \\<\\< 左移动运算符：运算数的各二进位全部左移若干位，由”\\<\\<“右边的数指定移动的位数，高位丢弃，低位补0 >> 右移动运算符：把”>>“左边的运算数的各二进位全部右移若干位，”>>“右边的数指定移动的位数 逻辑运算符 运算符 逻辑表达式 描述 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值 or x or y 布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True 成员运算符 运算符 描述 in 如果在指定的序列中找到值返回 True，否则返回 False not in 如果在指定的序列中没有找到值返回 True，否则返回 False 身份运算符 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False 运算符优先级 运算符 描述 (expressions...), [expressions...], {key: value...}, {expressions...} 表示绑定或元组、表示列表、表示字典、表示集合 x[index], x[index:index], x(arguments...), xattribute 下标、切片、调用、属性引用 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +\\@ 和 -\\@) * / % // 乘，除，取模和取整除 + - 加法减法 >> << 右移，左移运算符 & 位 ‘AND’ ^ 按位异或运算符 <= < > >= 比较运算符 == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 and or not 逻辑运算符 if - else 条件表达式 lambda Lambda 表达式 具有相同优先级的运算符将从左至右的方式依次进行。用小括号 () 可以改变运算顺序。","text_tokens":["assignment","一行","全部","续行符","相同","an","它们","value","letters","之","转义字符","i","nor","以其","有时候","优先","know","2","f","不","层次","低位","理由","变差","进来","never","回车","*","the","定义","str1","保持","或者","插入","print","原因","当于","itself","右移","非","多条","即","横向","给","人性","/","lambdas","，","多行","运行","换行","若干位","末尾","一","否则","那么","分割","lambda","二进位","空","又","不仅","能","默认","一般","入口","多个","两个","很多","而言","动态创建","允许","一些","每个","用作","statement","zero","不仅仅","表格","制表","具有","is","'","raise","二进制位","anonymous","more","布尔",">","时","bytes","m","方便","或者说","报错","某个","销毁","under","自动","乘法","类似","方式","太多","名字","特殊","同时","等于","引用","语句","two","交互式","字典","实例","实际上","了","return","成为","通过","便于","one","index","objects","普通","？","同一个","麻烦","their","memory","但","标识","还有","动态","3","如下","double","不同","identity","强大","用","about","async","makes","if","个","符号","与","’","这里","行","这","匿名","一元","其他","左边","想","要","十六进制","任何","常","arguments","最高","无法","约定","named","while","str2","end","会","做","键","易用性","1","with","加强","小于","第一条","怎么","可变","从而","类","said","使","~","上面","下面","字符串","而是","可读性","y","除","2.2","交互","very","应该","有时","what","达式","换页","最后","module","!","来","five","finally","o12","有","]","采用","secondfunc","缩进","随意","pyhton","导入","创建","数据","只要","按位","not","常用","整除","）","格式","continue","分配","而","def","概念","kwlist","新","纵向","左","four","型","版本","语言","later","have","and"," ","部分","减","使用","中","翻转","000","用于","{","缩","names","各","地址","行为","未免太","“","of","中文","相异","...","proverb","本质","参数传递","正常","很长","显然","也","名为","括号","ipython","类型","指向","place","所","直至","其","allow","变为","语法","这些","class","风格","退格","小括号","把","成员","python","关键","my","none","一部","you","极致","(","object","doesn","famous","切片","修改","触及","整个","用来","e","取模","etc","12","符","加法","计算","函数","是不是","在","t","expressions","并","keyword","除法","<","解释器","位于","此","|","集合","global","最","丢弃","释器","看起","声明","实际","启动","必须","为","当前","true","改变","xattribute","可以","50","加","字符","re","或类","cpython","only","arg","响铃","我们","列出","程序","数","包括","出错","二条","取","big","加号","该","重新","any","they","v","usually","bind","pass","支持","bit","returned","开头","右","起来","易用","位数","pyhon","指数","看起来","或","many","关键字","yy","前","保留","包含","含义","进制","若干","乘","（","表达式","和","运算符","update","内容","反之","空行","时候","assert","开始","而且","制表符","该位","大括号","for","access","表达","代表","同一","你","突出","认为","0","还","右边","在于","约定俗成","elif","转义","changing",";","因此","_","正是","行尾","id","are","例如","日后","integer","item","对应","关联","位","之间","function","逻辑","补","调用","后者","一样","属性","双引号","推荐","other","另外","一个","”","don","两段","s","\"","分隔","以","。","进位","直接","three","算符","xyy","区别","未免","容易","运算","cmd","instance","注释","一次","分","somefunction","fan","一段","some","相当","such","取反","%","好看","窗口","really","提供","所述","‘","避免","type","contents","this","c++","false","特色","值","statements","else","找到","从","路径","返回","维护","第二","两","由","作用","-","7","notice","by","所谓","如","英文","capital","except","、","methods","二进制","break","a","十六","14","identifier","名称","描述","就","判断","此时","结束","量","留字","依次","呢","左移","其后","—","yield","减号","查看","that","做法","当","书写","很少","它","初始化","backspace","为了",")","执行","就是","充分","参与","第一","del","这个","we","保留字","对","续行","幂","total","str3","序列","通常","块","自然","的","里面","原先","实现","行中","冒号","元组","b","无需","limited","处","但是","&","rather","高位","其它","文件","modify","without","n","properties","某一","provided","使得","初始","somemodule","引号","重构","移动","功能","简化","称为","nonlocal","namespace","库","不是","模块","firstfunc","参数","最具","因为","even","@","方法","更好","比如","没有","标识符","人性化","practice","这样","不会","仅仅","号","live","perfect","本身","时会","却","namespaces","fans","}","c","knows","简介","反","teacher","try","综上","str4","r","it","different","10","都","整数","5","\\","算术","can","绑定","提示符","name","所有","一种","which","则","优先级","将","4","想想","多","local","thirdfunc","简单","指定","命令","条件","命名","输出","作为","表示","数传","输入","解释","import","对象","oyy","只能","著名","提示","结果","as","换","=","身份","#","append","x","这种","相应","写","操作","单行","str5",".",",","unique","到","是","大于","不能","类别","至","[","减法","内部","传递","比较","看作","change","以后","被","像","赋值","自","代码","一条","cannot","represented","相当于","然后","程序代码","or","await","于","八进制","all","编号","x0a","异或","+","in","circumstances","只有","变量","二个","空格","中有","需要","斜杠","called","第二条","可读","可能","from","at","综上所述","加上","一部分","单引号","to","所以","另","content","下标","进行","func","occupy","key","顺序","如果","how","^",":","标准","体现","列表","："],"title":"2.1.python基本语法","title_tokens":[".","python","2.1","语法","基本"]},{"location":"Python基础/2.1.python基本语法.html#_1","text":"Python是一种解释型语言，Python解释器通过一次执行一条语句的方式运行程序。标准的交互式python解释器(CPython)可以在cmd窗口通过 python 命令启动。标准的交互式python解释器的提示符是 >>> 。 而加强的交互式解释器(IPython)的提示符是一种编号的风格，如 In[2] ，而不是标准的 >>> 。","text_tokens":["释器","而","型","解释","启动","的","语言","提示","风格","，"," ","编号","python","运行","可以","2",">","in","命令","窗口","cpython","交互","(","ipython","程序","是","方式","[","语句","。","提示符","]","一种","交互式","不是",")","执行","在","一条","解释器","如","标准","通过","cmd","一次","加强"],"title":"简介","title_tokens":["简介"]},{"location":"Python基础/2.1.python基本语法.html#python","text":"保留字即关键字，我们不能把它们用作任何标识符名称。Python的标准库提供了一个keyword模块，可以输出当前版本的所有关键字： import keyword keyword . kwlist print ( keyword . kwlist ) ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']","text_tokens":["关键字","的","保留","它们","assert","finally","nonlocal","for","print","]","库","模块","not","elif","即","continue","def","标识符","kwlist","版本","and","，"," ","try","lambda","一个","。","所有","输出","用作","import","class","as","is","把","'","raise","python","关键","none","提供","(",".",",","false","不能","[","else","keyword","了","return","except","global","or","标识","await","break","名称","当前","true","可以","in","async","留字","if","我们","yield","from","任何",")","pass","while","del","标准","with","保留字","："],"title":"python保留字","title_tokens":["python","保留字","保留","留字"]},{"location":"Python基础/2.1.python基本语法.html#_2","text":"Python中单行注释以 # 开头。多行注释则使用： ''' 或者 \"\"\" 。实际上python只有单行注释。多行注释的本质是字符串对象。 # 这里是单行注释 ''' 这里是多行注释 这里是多行注释 '''","text_tokens":["实际","对象","的"," ","多行","'","#","python","使用","字符串","中","字符","只有","单行","这里","是","本质","\"","或者","以","。","则","实际上","开头","注释","："],"title":"注释","title_tokens":["注释"]},{"location":"Python基础/2.1.python基本语法.html#_3","text":"python最具特色的就是使用缩进来表示代码块，不是使用大括号{}。而冒号表示一段缩进代码块的开始，其后所有相同层次的代码必须保持相同的缩进量，缩进量则可以随意，直至代码块结束。 一般约定俗成使用4个空格的缩进。 if True : print ( \"True\" ) else : print ( \"False\" ) True","text_tokens":["而","表示","直至","相同","一段","块","必须","的","true","，"," ","python","冒号","使用","可以","结束","量","}","层次","个","if","{","缩","进来","(","空格","其后","开始","保持","大括号","false","特色","\"","。","else","print","所有","缩进","随意","一般","不是","约定","就是","则","最具",")","4","代码",":","约定俗成","括号"],"title":"代码块","title_tokens":["代码","块"]},{"location":"Python基础/2.1.python基本语法.html#_4","text":"如果语句很长，可以使用反斜杠 \\ 来续行，例如： a = 3 + \\ 4 + \\ 5 a 12 在 [] , {} , 或 () 中的多行语句，不需要使用反斜杠 \\ ，例如： total = [ 'item_one' , 'item_two' , 'item_three' , 'item_four' , 'item_five' ] total ['item_one', 'item_two', 'item_three', 'item_four', 'item_five']","text_tokens":["total","_","或","four","例如","item","a","3","的","=","，"," ","多行","'","+","可以","使用","中","不","}","反","{","(","需要","斜杠",",","5","来","five","\\","[","语句","很长","12","]","two","three","如果","在",")","续行","4","one","："],"title":"代码续行","title_tokens":["代码","续行"]},{"location":"Python基础/2.1.python基本语法.html#_5","text":"Python可以在同一行中使用多条语句，语句之间使用分号 ; 分割。但这样的做法一般不推荐，因为会使代码的可读性变差。","text_tokens":["分","但","这样","的","号","使","，"," ","行中","之间","python","可以","使用","不","可读性","变差","分割","推荐","可读","做法","语句","。","一般","同一","在","因为","代码","会","多条",";"],"title":"同一行书写多条语句","title_tokens":["同一","书写","语句","多条","行"]},{"location":"Python基础/2.1.python基本语法.html#_6","text":"函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同， 空行并不是Python语法的一部分。 书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。空行也是程序代码的一部分。","text_tokens":["一行","释器","或","程序代码","表示","新","解释","一段","不会","语法","类","日后","的","含义","，"," ","不同","部分","之间","python","运行","用","和","时","不","但是","或类","一部","与","空行","程序","开始","出错","是","两段","重构","书写","功能","分隔","以","一部分","。","插入","缩进","维护","也","不是","函数","入口","突出","并","作用","方法","代码","在于","解释器","便于"],"title":"空行","title_tokens":["空行"]},{"location":"Python基础/2.1.python基本语法.html#print","text":"print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=\"\"： x = \"a\" y = \"b\" # 换行输出 print ( x ) print ( y ) print ( '---------' ) # 不换行输出 print ( x , end = \" \" ) print ( y , end = \" \" ) print () a b --------- a b","text_tokens":["输出","a","的","实现","=","，"," ","'","#","x","换行","b","不","末尾","y","变量","(","需要",",","是","\"","加上","print","要","默认","如果","在",")","-","end","："],"title":"Print 输出","title_tokens":[" ","输出","print"]},{"location":"Python基础/2.1.python基本语法.html#import-fromimport","text":"在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块 ( module ) 导入： import somemodule 从某个模块中导入某个函数： from somemodule import somefunction 从某个模块中导入多个函数： from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入： from somemodule import *","text_tokens":["全部","somefunction","import","的"," ","python","用","中","相应","(","某个","*",",","module","...","整个","somemodule","来","from","或者","。","从","secondfunc","函数","模块","在",")","firstfunc","导入","将","多个","thirdfunc","："],"title":"import 与 from...import","title_tokens":["...","from","import","与"," "]},{"location":"Python基础/2.1.python基本语法.html#_7","text":"如果要在字符串中输入一些特殊的字符（这些特殊的字符特殊之处在于不能直接输出），这就需要“转义符”。所谓转义，就是不采用符号原先的含义，而采用另外一含义。在Pyhton中， \\ 代表转义符。 下面表格中列出常用的转义符： 转义字符 描述 \\ (在行尾时) 续行符 \\ 反斜杠符号 \\' 单引号 \\\" 双引号 \\a 响铃 \\b 退格(Backspace) \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\oyy 八进制数，yy代表的字符，例如：\\o12代表换行 \\xyy 十六进制数，yy代表的字符，例如：\\x0a代表换行 \\other 其它的字符以普通格式输出 有时候，字符串包含了很多转义符 \\ ，但实际上我们想输出的是反斜杠符号 \\ ，而不是把 \\ 看作转义符（例如输入文件路径）。此时，自然可以在反斜杠前加上转义符 \\ ，但是这样未免太麻烦。Python提供了一个简化的操作，Pyhon允许用 r'字符串内容' 表示 '字符串内容' 内部的字符串默认不转义： print ( ' \\\\\\t\\\\ ' ) print ( '---------' ) print ( r ' \\\\ \\t \\\\ ' ) \\ \\ --------- \\\\\\t\\\\","text_tokens":["续行符","yy","自然","的","前","原先","包含","含义","之","转义字符","进制","下面","（","有时候","字符串","b","f","处","不","但是","其它","文件","内容","有时","回车","换页","n","时候","制表符","引号","简化","o12","print","采用","代表","不是","pyhton","在于","常用","转义","）","格式","横向","而","纵向","行尾","这样","例如","，"," ","换行","中","一","反","000","未免太","“","r","双引号","other","另外","空","”","一个","\"","\\","以","。","直接","默认","xyy","很多","未免","允许","一些","输出","表示","输入","表格","这些","oyy","制表","退格","把","'","python","时","操作","提供","(","是","特殊","不能","e","内部","路径","看作","符","在","t","-","实际上","了","所谓","普通","麻烦","但","实际","a","十六","描述","就","八进制","x0a","此时","可以","用","字符","符号","响铃","这","我们","：","需要","列出","斜杠","数","加上","单引号","想","要","十六进制","backspace","v","如果",")","就是","pyhon","续行"],"title":"转义符\\","title_tokens":["转义","\\","符"]},{"location":"Python基础/2.1.python基本语法.html#nameobject","text":"实际上，Python中没有类似c\\c++中的变量这个概念，python中只有name和object。因此在python中，变量（name）无法被声明。同时也正是因为没有变量这个概念，在Python中也没有所谓的初始化、赋值的行为。","text_tokens":["、","没有","因此","正是","概念","声明","实际","的","，","（","python","和","中","c","只有","变量","object","行为","类似","c++","初始","同时","\\","。","name","初始化","被","也","无法","在","赋值","因为","实际上","这个","所谓","）"],"title":"name与object","title_tokens":["object","与","name"]},{"location":"Python基础/2.1.python基本语法.html#objects","text":"All Python objects have this: a unique identity (an integer, returned by id(x))（notice：identity not identifier） a type (returned by type(x)) some content（值） You cannot change the identity. You cannot change the type. 改变位于某一地址的对象的引用与类型是不可能的，只能把对象销毁，然后重新创建。 Some objects allow you to change their content (without changing the identity or the type, that is). Some objects don’t allow you to change their content . The type is represented by a type object, which knows more about objects of this type(how many bytes of memory they usually occupy, what methods they have, etc). (Update: In CPython 2.2 and later, you can change the type under some rather limited circumstances.) 一个对象可以有： zero or more methods (provided by the type object)zero or more names Some objects have methods that allow you to change the contents of the object (modify it in place, that is). Some objects only have methods that allow you to access the contents, not change it. Some objects don’t have any methods at all. Even if they have methods, you can never change the type, nor the identity.","text_tokens":["many","an","的","nor","（","limited","update","不","rather","2.2","modify","never","without","what","the","某一","provided","有","access","创建","even","not","）","changing","id","integer","later","have","and"," ","，","knows","names","地址","of","it","don","一个","。","can","which","类型","place","allow","zero","some","对象","只能","is","把","python","x","more","bytes","you","(","object","销毁","type","under",".","contents","this","unique",",","是","值","引用","etc","change","t","cannot","notice","by","represented","位于","objects","their","然后","or","methods","memory","a","identifier","all","改变","identity","about","可以","in","circumstances","cpython","if","only","与","’","that","可能","at","to","content","重新","occupy","any","they","usually",")","returned","how",":","："],"title":"Objects","title_tokens":["objects"]},{"location":"Python基础/2.1.python基本语法.html#names","text":"The names are a bit different — they’re not really properties of the object,and the object itself doesn’t know what it’s called. 所有name在创建时必须关联（bind）到一个object，否则在需要引用该name时会报错。 name可以在创建以后指向任何一个object（包括不同类型），所以name本身没有类别，但name关联的object是有类别的。 在python中可以使用type（name）来查看name关联的object的类型。 一个对象可以关联（bind）多个名字，也可以没有名字。 Names live in namespaces (such as a module namespace, an instance namespace, a function’s local namespace).","text_tokens":["an","的","（","know","what","properties","the","module","来","有","namespace","itself","创建","not","）","没有","are","关联","and"," ","，","live","本身","function","时会","使用","namespaces","中","names","否则","of","different","it","一个","s","。","name","所有","也","多个","local","instance","类型","指向","对象","as","python","such","时","really","(","object","doesn","报错","type",".",",","到","是","名字","类别","引用","以后","在","t","但","a","必须","不同","可以","in","re","’","需要","—","包括","called","查看","该","所以","任何","they","bind",")","bit"],"title":"Names","title_tokens":["names"]},{"location":"Python基础/2.1.python基本语法.html#assignment","text":"python也有assignment这个英文概念，但与之对应的中文却不应该成为赋值，而是分配，或者说命名。 Assignment statements modify namespaces, not objects.换而言之，如果在python中有一个assignment statement如下： a = 10 这个assignment语句使得相应的namespace的a键所对应的value为10。另外assignment语句还有这样的作用： name = [] name . append （ 1 ） 第一条语句将 name 关联到一个空列表对象，第二条语句修改了该列表的内容，这并不会触及namespace。 综上所述，assignment statement在python中有两个作用：1. 用于（重新）将名称绑定到对象2. 修改可变对象的属性（内容）","text_tokens":["assignment","第一条","可变","的","value","之","（","2","不","而是","modify","内容","应该","使得","或者","有","]","namespace","not","）","分配","概念","这样","不会","对应","关联","，"," ","却","namespaces","用于","综上","中文","属性","10","另外","一个","空","。","绑定","name","也","将","两个","而言","命名","所","statement","对象","换","=","append","python","相应","或者说","所述","修改",".",",","触及","到","[","statements","语句","第二","赋值","在","作用","并","成为","一条","了","英文","objects","但","还有","a","为","名称","如下","与","这","中有","二条","第二条","综上所述","该","重新","如果","第一","这个","键","1","列表","："],"title":"assignment","title_tokens":["assignment"]},{"location":"Python基础/2.1.python基本语法.html#_8","text":"在Python中单引号和双引号都可以用来表示一个字符串，比如： str1 = 'python' str2 = \"python\" str1和str2是没有任何区别的。 Python以其易用性而著名，但单引号和双引号却不仅仅是为了方便。想想I'm a big fans of Python.这个字符串应该怎么定义？可以这样写： str3 = 'I \\' m a big fan of Python.' 那么We all know that 'A' and 'B' are two capital letters.又该怎么定义呢？ str4 = 'We all know that \\' A \\' and \\' B \\' are two capital letters.' 显然太多的转义符看起来并不好看，而且容易出错了。那么，在Python中，还可以这样写： str4 = \"We all know that 'A' and 'B' are two capital letters.\" 这样就人性化多了，这就是Python支持双引号和单引号都能用来定义字符串的原因。反之，如果字符串中有双引号，为了避免使用转义符，你可以使用单引号来定义这个字符串。比如： str5 = 'The teacher said: \"Practice makes perfect\" is a very famous proverb.' 这就是Python易用性和人性化的一个极致体现，当你用单引号' '定义字符串的时候，它就会认为你字符串里面的双引号\" \"是普通字符，从而不需要转义。反之当你用双引号定义字符串的时候，就会认为你字符串里面的单引号是普通字符无需转义。","text_tokens":["str3","怎么","从而","said","的","里面","letters","i","以其","字符串","和","know","b","无需","不","very","应该","反之","时候","the","定义","str1","而且","引号","来","原因","你","认为","还","转义","比如","没有","而","人性化","practice","这样","are","人性","仅仅","and"," ","，","perfect","却","使用","中","fans","teacher","那么","str4","of","双引号","都","一个","proverb","\"","\\","又","。","不仅","能","显然","区别","想想","多","容易","表示","不仅仅","fan","著名","is","=","'","python","m","写","好看","方便","str5","极致","famous","避免",".","是","太多","用来","two","符","在","并","了","capital","普通","？","看起","但","a","就","all","可以","用","字符","makes","这","呢","中有","需要","出错","that","当","big","该","单引号","它","任何","为了","如果","就是","支持","str2","这个","起来","易用","易用性",":","会","we","体现","看起来","："],"title":"单引号与双引号","title_tokens":["双引号","引号","单引号","与"]},{"location":"Python基础/2.1.python基本语法.html#lambdas","text":"正常创建函数（使用def）会自动将其赋值给变量，这与创建其他对象（例如字符串和整数）不同，后者可以动态创建，而无需将它们分配给变量。但只要使用lambda语法创建函数，函数也可以这样做，以这种方式创建的函数称为匿名（anonymous）函数。将简单函数作为参数传递给另一个函数时，最常使用此方法。语法如下： # my_func是正常创建的函数（named function） def my_func ( f , arg ): return f ( arg ) my_func ( lambda x : 2 * x * x , 5 ) 50 在上面的代码中，我们动态创建了一个匿名函数，并使用参数调用它。Lambda函数没有命名函数（named function）那么强大。Lambda函数只能包含一个表达式，通常相当于一行代码。实际上，Lambda函数可以分配给变量，并像普通函数一样使用。但是，很少有充分的理由这样做。通常使用def来定义函数通常更好。 double = lambda x : x * 2 print ( double ( 7 )) 14","text_tokens":["一行","通常","的","它们","包含","上面","（","表达式","字符串","和","无需","f","2","但是","理由","达式","*","定义","来","称为","有","print","表达","当于","参数","创建","方法","只要","）","更好","分配","没有","_","def","而","给","这样","例如","，"," ","function","使用","中","调用","后者","一样","那么","整数","lambda","一个","5","参数传递","以","正常","。","也","将","动态创建","简单","命名","作为","其","数传","对象","语法","只能","=","相当","#","anonymous","x","这种","时","my","(","自动",",","方式","是","传递","函数","像","赋值","在","并","7","实际上","代码","了","return","此","相当于","最","普通","动态","但","实际","14","如下","double","不同","强大","可以","50","字符","变量","与","arg","这","我们","匿名","其他","很少","另","它","常","func",")","充分","named","会","做",":","："],"title":"Lambdas","title_tokens":["lambdas"]},{"location":"Python基础/2.1.python基本语法.html#_9","text":"","text_tokens":[],"title":"运算符","title_tokens":["运算","算符","运算符"]},{"location":"Python基础/2.1.python基本语法.html#_10","text":"运算符 描述 + 加 - 减 * 乘 / 除 % 取模 ** 幂 // 取整除","text_tokens":["乘","幂","减","+","取","运算符","加","-","%","*","除","/","取模","整除","描述","运算","算符"," "],"title":"算术运算符","title_tokens":["运算","算术","运算符","算符"]},{"location":"Python基础/2.1.python基本语法.html#_11","text":"运算符 描述 == 等于 != 不等于 > 大于 \\< 小于 >= 大于等于 \\<= 小于等于","text_tokens":["=","小于","运算符",">","不","大于","!","<","等于","\\","描述","运算","算符"," "],"title":"比较运算符","title_tokens":["运算","算符","运算符","比较"]},{"location":"Python基础/2.1.python基本语法.html#_12","text":"运算符 描述 = 简单的赋值运算符 += 加法赋值运算符 -= 减法赋值运算符 *= 乘法赋值运算符 /= 除法赋值运算符 %= 取模赋值运算符 **= 幂赋值运算符 //= 取整除赋值运算符","text_tokens":["幂","的","/","描述","="," ","+","运算符","%","*","乘法","取","减法","取模","算符","加法","赋值","-","除法","整除","简单","运算"],"title":"赋值运算符","title_tokens":["运算","算符","运算符","赋值"]},{"location":"Python基础/2.1.python基本语法.html#_13","text":"运算符 描述 & 按位与运算符：参与运算的两个值,如果两个相应位都为1，则该位的结果为1，否则为0 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1 \\^ 按位异或运算符：当两对应的二进位相异时，结果为1 \\~ 按位取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1。\\~x 类似于 -x-1 \\<\\< 左移动运算符：运算数的各二进位全部左移若干位，由”\\<\\<“右边的数指定移动的位数，高位丢弃，低位补0 >> 右移动运算符：把”>>“左边的运算数的各二进位全部右移若干位，”>>“右边的数指定移动的位数","text_tokens":["全部","或","的","~","进制","若干","运算符","&","高位","低位","该位","移动","有","右边","0","只要","数据","按位","右移","即","左","对应","位"," ","，","若干位","补","否则","各","“","相异","都","二进位","一个","”","\\","。","进位","算符","则","两个","指定","运算","每个","变为","结果","把","二进制位","x",">","时","取反","相应",",","类似","值","两","由","-","<","|","丢弃","二进制","为","于","描述","就","异或","与","二个","左移","数","当","左边","如果","参与","^","右","位数","1","对","："],"title":"位运算符","title_tokens":["位","算符","运算","运算符"]},{"location":"Python基础/2.1.python基本语法.html#_14","text":"运算符 逻辑表达式 描述 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值 or x or y 布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True","text_tokens":["或","or","为","的","描述","and","true"," ","，","布尔","表达式","逻辑","运算符","x","y","与","否则","达式","是","”","false","值","。","它","表达","算符","返回","计算","如果","-","not","非","运算"],"title":"逻辑运算符","title_tokens":["运算","算符","逻辑","运算符"]},{"location":"Python基础/2.1.python基本语法.html#_15","text":"运算符 描述 in 如果在指定的序列中找到值返回 True，否则返回 False not in 如果在指定的序列中没有找到值返回 True，否则返回 False","text_tokens":["没有","序列","的","描述","true","，"," ","运算符","in","中","否则","false","值","找到","返回","算符","如果","在","not","指定","运算"],"title":"成员运算符","title_tokens":["运算","算符","成员","运算符"]},{"location":"Python基础/2.1.python基本语法.html#_16","text":"运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False","text_tokens":["标识符","id","标识","对象","结果","a","的","is","描述","true","判断"," ","=","，","不同","x","运算符","b","y","否则","(",",","类似","是","一个","false","!","引用","。","算符","返回","不是","同一","是不是","实例",")","如果","则","两个","自","not","运算","同一个"],"title":"身份运算符","title_tokens":["身份","算符","运算","运算符"]},{"location":"Python基础/2.1.python基本语法.html#_17","text":"运算符 描述 (expressions...), [expressions...], {key: value...}, {expressions...} 表示绑定或元组、表示列表、表示字典、表示集合 x[index], x[index:index], x(arguments...), xattribute 下标、切片、调用、属性引用 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +\\@ 和 -\\@) * / % // 乘，除，取模和取整除 + - 加法减法 >> << 右移，左移运算符 & 位 ‘AND’ ^ 按位异或运算符 <= < > >= 比较运算符 == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 and or not 逻辑运算符 if - else 条件表达式 lambda Lambda 表达式 具有相同优先级的运算符将从左至右的方式依次进行。用小括号 () 可以改变运算顺序。","text_tokens":["或","相同","的","value","~","乘","元组","优先","表达式","运算符","和","&","除","达式","最后","*","!","]","表达","@","方法","右移","按位","not","整除","左","/","位","and"," ","，","逻辑","调用","}","翻转","{","属性","lambda","...","\\","。","绑定","算符","优先级","名为","将","两个","括号","运算","条件","表示","具有","is","小括号","=","成员","身份","x",">","%","‘","(","切片",",","方式","至","等于","[","引用","减法","取模","else","比较","从","加法","字典","expressions","赋值","-","<","集合","index","、","or","描述","异或","改变","xattribute","+","用","可以","in","if","依次","’","左移","一元","减号","取","加号","下标","进行","arguments","最高","key","顺序",")","^","右",":","指数","列表"],"title":"运算符优先级","title_tokens":["优先","运算符","优先级","运算","算符"]},{"location":"Python基础/2.2.语句.html","text":"# -*- coding: utf-8 -*- 语句 siwing 2019.08.13 语句 条件语句 if语句的语法如下： your age is 20 adult 注意不要少写了冒号 : 。 类似R语言的else if，在python中则是使用 elif ： kid elif 是 else if 的缩写，完全可以有多个 elif ，所以 if 语句的完整形式就是： if < 条件判断1 > : < 执行1 > elif < 条件判断2 > : < 执行2 > elif < 条件判断3 > : < 执行3 > else : < 执行4 > if 判断条件还可以简写，比如写： if True : print ( 'True' ) True 在python中，False、0、''、[]、()、{}都视作False，否则为True。注意，负值也是被判断为真。 断言 assert condition 等价于 if not condition : crash program 循环 for语句 Python的循环有两种，一种是for…in循环， 依次把可迭代对象中的每个元素迭代出来 ，看例子： 执行这段代码，会依次打印 names 的每一个元素： names = [ 'Michael' , 'Bob' , 'Tracy' ] for name in names : print ( name ) Michael Bob Tracy 所以 for x in ... 循环就是把每个元素代入变量 x ，然后执行缩进块的语句。 while语句 第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现： sum = 0 n = 99 在循环内部变量 n 不断自减，直到变为 -1 时，不再满足while条件，循环退出。 while n > 0 : sum = sum + n n = n - 2 print ( sum ) 2500 break 在循环中， break 语句可以提前退出循环。例如 i = 1 while i < 100 : i = i + 1 print ( \"结束循环\" ) break print ( i ) 结束循环 break 的作用是退出当前循环， print(i) 语句不会执行。 continue continue 语句：跳过当前的这次循环，直接开始下一次循环。 n = 0 while n < 10 : n = n + 1 print ( n , end = \" \" ) 1 2 3 4 5 6 7 8 9 10 上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用 continue 语句跳过某些循环： n = 0 while n < 10 : n = n + 1 if n % 2 == 0 : # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print ( n , end = \" \" ) 1 3 5 7 9 执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。 循环中的 else 子句 else 子句不仅可以用在 if 语句，还可以用在循环语句。循环语句中的 else 子句在循环迭代完成时、执行条件为 false （对于 while ）时执行，但循环被 break 中止的情况下不会执行。 # for循环 i = 1 for i in range ( 1 , 10 , 2 ): print ( i , end = \" \" ) else : print ( \"i=\" , i ) # while循环 i = 1 while i < 5 : print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) # break子句直接结束循环，循环语句一次也没有执行，此时else子句不会执行。 # 注意，这与while子句中条件为false，循环语句没有执行不同 i = 1 for i in range ( 1 , 10 , 2 ): break print ( i , end = \" \" ) else : print ( \"i=\" , i ) i = 1 while i < 5 : break print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) 1 3 5 7 9 i= 9 1 2 3 4 i= 5 pass pass 语句什么也不做。它用于那些语法上必须要有什么语句，但程序什么也不做的场合，例如: # 死循环 while True : pass # Busy-wait for keyboard interrupt (Ctrl+C) # 创建最小结构的类: class MyEmptyClass : pass 小结 break 、 continue 语句通常都配合 if 语句使用。 要特别注意，不要滥用 break 和 continue 语句。 break 和 continue 会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到 break 和 continue 语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉 break 和 continue 语句。","text_tokens":["crash","代入","特别","通常","只","condition","什么","program","段","块","类","的","…","实现","之","i","上面","子句","分叉","（","冒号","结构","2","和","不","而是","但是","utf","*","n","assert","大多","开始","age","例子","或者","有","for","print","busy","]","2500","缩进","自减","keyboard","等价","创建","0","还","只要","not","elif","）","continue","比如","8","没有","并不需要","对于","这次","负值","tracy","例如","不会","下","语言","ctrl"," ","，","一轮","michael","那些","your","场合","使用","sum","逻辑","中","迭代","}","c","range","少写","出","看到","用于","完整","{","否则","names","r","10","coding","都","2019.08","中则","一个","...","5","中止","\"","不要","。","不仅","name","siwing","直接","视作","所有","一种","也","interrupt","后续","多个","形式","4","两个","6","adult","myemptyclass","用到","容易","一次","条件","每个","大多数","变为","99","对象","语法","断言","class","完全","第二种","is","两种","把","=","继续","'","#","python","奇数","看","x",">","二种","时","%","写","代码执行","100","上","20","跳过","(","元素","情况","修改",".",",","类似","是","小结","false","[","语句","else","满足","内部","第二","被","计算","在","9","-","真","作用","7","<","完成","代码","了","最小","配合","过多","通过","循环","退出","偶数","、","直到","然后","某些","但","kid","多数","13","break","3","为","于","必须","～","如下","可","true","判断","就","当前","不同","造成","此时","+","可以","用","in","结束","出来","不再","滥用","打印","if","依次","变量","与","改写","这","我们","提前","以内","程序","需要","出错","去掉","wait","所以","想","它","要","死循环","缩写","如果",")","就是","执行","pass","每","while","不断","注意","end",":","会","bob","做","1","简写","："],"title":"2.2.语句","title_tokens":["2.2","语句","."]},{"location":"Python基础/2.2.语句.html#_1","text":"","text_tokens":[],"title":"语句","title_tokens":["语句"]},{"location":"Python基础/2.2.语句.html#_2","text":"if语句的语法如下： your age is 20 adult 注意不要少写了冒号 : 。 类似R语言的else if，在python中则是使用 elif ： kid elif 是 else if 的缩写，完全可以有多个 elif ，所以 if 语句的完整形式就是： if < 条件判断1 > : < 执行1 > elif < 条件判断2 > : < 执行2 > elif < 条件判断3 > : < 执行3 > else : < 执行4 > if 判断条件还可以简写，比如写： if True : print ( 'True' ) True 在python中，False、0、''、[]、()、{}都视作False，否则为True。注意，负值也是被判断为真。","text_tokens":["、","负值","kid","语法","3","的","语言","完全","为","如下","is","true","判断"," ","，","'","your","冒号","python","使用","可以",">","2","中","}","写","比如","少写","if","20","条件","完整","{","否则","(","r","类似","都","中则","age","是","false","不要","[","所以","语句","。","else","有","print","]","视作","被","缩写","也","在","就是","执行","多个","形式","4",")","0","<","还","注意","了","真",":","adult","elif","1","简写","："],"title":"条件语句","title_tokens":["语句","条件"]},{"location":"Python基础/2.2.语句.html#_3","text":"assert condition 等价于 if not condition : crash program","text_tokens":["crash","等价","condition","program","if","于","not",":"," ","assert"],"title":"断言","title_tokens":["断言"]},{"location":"Python基础/2.2.语句.html#_4","text":"","text_tokens":[],"title":"循环","title_tokens":["循环"]},{"location":"Python基础/2.2.语句.html#for","text":"Python的循环有两种，一种是for…in循环， 依次把可迭代对象中的每个元素迭代出来 ，看例子： 执行这段代码，会依次打印 names 的每一个元素： names = [ 'Michael' , 'Bob' , 'Tracy' ] for name in names : print ( name ) Michael Bob Tracy 所以 for x in ... 循环就是把每个元素代入变量 x ，然后执行缩进块的语句。","text_tokens":["每个","代入","然后","tracy","对象","段","块","的","…","两种","可","把","，"," ","=","michael","'","python","看","x","in","中","出来","迭代","打印","依次","变量","names","这","元素","(",",","是","例子","一个","...","[","所以","有","for","语句","print","name","]","。","缩进","一种",")","执行","就是","每","代码","会",":","bob","循环","："],"title":"for语句","title_tokens":["语句","for"]},{"location":"Python基础/2.2.语句.html#while","text":"第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现： sum = 0 n = 99 在循环内部变量 n 不断自减，直到变为 -1 时，不再满足while条件，循环退出。 while n > 0 : sum = sum + n n = n - 2 print ( sum ) 2500","text_tokens":["直到","变为","99","第二种","实现","就","之","，"," ","=","奇数","+","可以","和","用","sum","二种","时","不","不再",">","2","100","条件","变量","我们","(","：","n","以内","是","满足","。","内部","print","要","所有","2500","自减","第二","计算","在",")","-","while","只要","不断","0","1",":","循环","退出","比如"],"title":"while语句","title_tokens":["语句","while"]},{"location":"Python基础/2.2.语句.html#break","text":"在循环中， break 语句可以提前退出循环。例如 i = 1 while i < 100 : i = i + 1 print ( \"结束循环\" ) break print ( i ) 结束循环 break 的作用是退出当前循环， print(i) 语句不会执行。","text_tokens":["例如","不会","break","的","当前","=","i","，"," ","+","可以","结束","中","循环","100","(","提前","是","\"","语句","。","print","在",")","执行","作用","while","<",":","1","退出"],"title":"break","title_tokens":["break"]},{"location":"Python基础/2.2.语句.html#continue","text":"continue 语句：跳过当前的这次循环，直接开始下一次循环。 n = 0 while n < 10 : n = n + 1 print ( n , end = \" \" ) 1 2 3 4 5 6 7 8 9 10 上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用 continue 语句跳过某些循环： n = 0 while n < 10 : n = n + 1 if n % 2 == 0 : # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print ( n , end = \" \" ) 1 3 5 7 9 执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。","text_tokens":["8","这次","continue","只","某些","不会","下","的","3","～","当前","=","，"," ","上面","继续","一轮","#","奇数","+","可以","2","用","不再","%","而是","但是","打印","看到","跳过","出","if","(","我们","n","程序","开始","10",",","是","5","\"","语句","。","想","print","直接","如果",")","9","执行","后续","4","7","0","while","<","1","end","6",":","会","代码","循环","一次","偶数","："],"title":"continue","title_tokens":["continue"]},{"location":"Python基础/2.2.语句.html#else","text":"else 子句不仅可以用在 if 语句，还可以用在循环语句。循环语句中的 else 子句在循环迭代完成时、执行条件为 false （对于 while ）时执行，但循环被 break 中止的情况下不会执行。 # for循环 i = 1 for i in range ( 1 , 10 , 2 ): print ( i , end = \" \" ) else : print ( \"i=\" , i ) # while循环 i = 1 while i < 5 : print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) # break子句直接结束循环，循环语句一次也没有执行，此时else子句不会执行。 # 注意，这与while子句中条件为false，循环语句没有执行不同 i = 1 for i in range ( 1 , 10 , 2 ): break print ( i , end = \" \" ) else : print ( \"i=\" , i ) i = 1 while i < 5 : break print ( i , end = \" \" ) i = i + 1 else : print ( \"i=\" , i ) 1 3 5 7 9 i= 9 1 2 3 4 i= 5","text_tokens":["、","没有","对于","但","不会","break","为","的","下","3","，"," ","i","子句","=","此时","（","#","+","可以","用","in","2","中","时","迭代","结束","range","if","与","(","这","情况","不同","10",",","中止","5","false","\"","语句","else","。","不仅","for","print","直接","被","也","在","执行",")","9","7","4","while","还","完成","1","end","<",":","注意","）","循环","一次","条件"],"title":"循环中的else子句","title_tokens":["中","的","else","循环","子句"]},{"location":"Python基础/2.2.语句.html#pass","text":"pass 语句什么也不做。它用于那些语法上必须要有什么语句，但程序什么也不做的场合，例如: # 死循环 while True : pass # Busy-wait for keyboard interrupt (Ctrl+C) # 创建最小结构的类: class MyEmptyClass : pass","text_tokens":["但","什么","例如","语法","类","必须","的","class","ctrl","true","，"," ","那些","#","场合","+","结构","不","c","上","用于","(","程序","wait","语句","。","它","有","busy","for","要","keyboard","死循环","也",")","pass","interrupt","创建","-","最小","while","做",":","myemptyclass","循环"],"title":"pass","title_tokens":["pass"]},{"location":"Python基础/2.2.语句.html#_5","text":"break 、 continue 语句通常都配合 if 语句使用。 要特别注意，不要滥用 break 和 continue 语句。 break 和 continue 会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到 break 和 continue 语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉 break 和 continue 语句。","text_tokens":["、","大多数","特别","通常","多数","break","的","造成","，"," ","上面","分叉","使用","和","逻辑","可以","滥用","代码执行","if","条件","改写","需要","大多","修改","出错","去掉","都","例子","不要","或者","语句","。","要","执行","两个","注意","代码","配合","会","过多","用到","容易","通过","循环","continue","并不需要"],"title":"小结","title_tokens":["小结"]},{"location":"Python基础/2.3.List.html","text":"# -*- coding: utf-8 -*- List siwing 2019.08.08 List list的方法 创建一个list list_1 = list () # 查看list的方法、属性 dir ( list_1 ) ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] 修改list元素的值 修改现有list的值，通过索引、切片来完成。 list_1 = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] # 修改某个索引对应元素的值 list_1 [ 0 ] = 12 ; list_1 [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 修改某个连续区域的值 list_1 [ 0 : 5 ] = [ 11 , 12 , 13 , 14 , 15 ]; list_1 [11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10] 添加一个新元素到末尾 append 方法每次只能添加一个新元素 list_1 . append ( 12 ); list_1 [11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10, 12] 添加任意个新元素到末尾 extend 方法允许我们通过另一个list来扩充当前的list。 实际上，这看起来像是拼接list。 list_2 = [ '0' , '00' , '000' ] list_1 + list_2 # 此时list_1没有被修改 print ( list_1 ) list_1 . extend ( list_2 ) # 此时list_1被修改 print ( list_1 ) # 显然拼接的效率回比`extend`方法的效率低 # 还可以借助切片来扩充list，像这样 list_1 [ len ( list_1 ):] = list_2 list_1 # 但是这样的可读性不高 [11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10, 12] [11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10, 12, '0', '00', '000'] [11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10, 12, '0', '00', '000', '0', '00', '000'] 在任意位置插入新元素 insert 方法将一个对象插入指定位置 list_1 . insert ( 0 , 11 ); list_1 [11, 11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10, 12, '0', '00', '000', '0', '00', '000'] # 当然，也可以借助切片在任意位置插入元素 # 注意的是，对一个list使用切片，必定会得到一个list，这就需要用一个list对切片赋值 # 这样虽然巧妙，但是可读性比不上insert list_1 [ 0 : 0 ] = [ 11 ] list_1 [11, 11, 11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10, 12, '0', '00', '000', '0', '00', '000'] 删除\\取出最后一个（任意位置的）元素 list_2 ['0', '00', '000'] # 注意，pop是list中唯一一个修改原列表，并且有返回值的方法 list_2 . pop () '000' list_2 ['0', '00'] # pop默认删除最后一个元素，但是也可以输入索引值，指定删除元素的位置 list_2 . pop ( 0 ) '0' list_2 ['00'] 删除第一次出现的元素 list_1 . remove ( 11 ) list_1 [11, 11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10, 12, '0', '00', '000', '0', '00', '000'] 反序排序 list_1 . reverse () list_1 ['000', '00', '0', '000', '00', '0', 12, 10, 9, 8, 7, 6, 5, 15, 14, 13, 12, 11, 11] 排序 方法sort接受两个可选参数：key和reverse。将key设置为一个用于排序的函数。然而，不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。对于另一个关键字参数reverse，只需将其指定为True或False，以指出是否要按相反的顺序对列表进行排序。 list_3 = [ 'aardvark' , 'abalone' , 'acme' , 'add' , 'aerate' ] list_3 . sort ( key = len ) list_3 ['add', 'acme', 'aerate', 'abalone', 'aardvark'] # 按照长度降序排序 list_3 . sort ( key = len , reverse = True ) list_3 ['aardvark', 'abalone', 'aerate', 'acme', 'add'] 统计元素出现的次数 list_1 list_1 . count ( 11 ) 2 得到某个值第一次出现时对应的索引值 list_1 list_1 . index ( \"000\" ) 0 深拷贝列表 list_4 = list_1 list_1 [ 0 ] = \"修改了\" print ( \"list_1\" , list_1 ) print ( \"list_4\" , list_4 ) print ( \" \\n \" ) # 深拷贝 list_5 = list_1 . copy () list_1 [ 0 ] = \"又修改了\" print ( \"list_1\" , list_1 ) print ( \"list_5\" , list_5 ) list_1 [ '修改了' , '00' , '0' , '000' , '00' , '0' , 12 , 10 , 9 , 8 , 7 , 6 , 5 , 15 , 14 , 13 , 12 , 11 , 11 ] list_4 [ '修改了' , '00' , '0' , '000' , '00' , '0' , 12 , 10 , 9 , 8 , 7 , 6 , 5 , 15 , 14 , 13 , 12 , 11 , 11 ] list_1 [ '又修改了' , '00' , '0' , '000' , '00' , '0' , 12 , 10 , 9 , 8 , 7 , 6 , 5 , 15 , 14 , 13 , 12 , 11 , 11 ] list_5 [ '修改了' , '00' , '0' , '000' , '00' , '0' , 12 , 10 , 9 , 8 , 7 , 6 , 5 , 15 , 14 , 13 , 12 , 11 , 11 ] 清空列表 list_1 . clear () list_1 []","text_tokens":["是否","借助","或","只","任意","位置","关键字","subclasshook","的","count","delattr","降序","acme","aardvark","contains","（","2","hash","ge","imul","取出","和","可读性","返回值","但是","而是","按照","必定会","utf","11","*","最后","唯一","repr","深","n","getattribute","来","iter","iadd","doc","比不上","插入","print","有","]","接受","rmul","参数","创建","方法","0","还","指出","）","__",";","08","8","没有","_","copy","对于","init","这样","第一次","并且","不会","对应","list","区域"," ","，","再","使用","中","末尾","当然","000","列表","用于","出现","属性","10","coding","统计","2019.08","pop","一个","5","拼接","需","回比","\"","\\","设置","以","又","format","。","siwing","直接","显然","默认","也","相反","clear","将","4","两个","`","新元","6","根据","指定","拷贝","reversed","允许","一次","反序","每个","15","其","输入","只能","对象","这些","class","按","像是","=","连续","'","#","append","关键","不高","时","次数","(","gt","mul","元素","切片","某个","原","修改","dir",".","定会",",","到","是","false","选","[","remove","值","setattr","12","返回","subclass","被","像","函数","9","在","赋值","-","7","实际上","完成","了","长度","setitem","通过","清空","index","然而","ex","、","sizeof","巧妙","看起","abalone","实际","13","14","3","为","getitem","当前","就","扩充","可","判断","true","len","reduce","此时","+","可以","低","用","索引","必定","小","个","效率","add","我们","这","排序","：","str","insert","需要","查看","可读","00","得到","添加","现有","extend","另","删除","它","进行","要","虽然","le","reverse","aerate","eq","比","key","顺序",")","ne","lt","delitem","注意",":","新元素","new","起来","第一","这个","1","键","sort","看起来","对","每次"],"title":"2.3.List","title_tokens":[".","list","2.3"]},{"location":"Python基础/2.3.List.html#list","text":"","text_tokens":[],"title":"List","title_tokens":["list"]},{"location":"Python基础/2.3.List.html#list_1","text":"创建一个list list_1 = list () # 查看list的方法、属性 dir ( list_1 ) ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']","text_tokens":["、","_","copy","sizeof","init","subclasshook","class","list","的","delattr","getitem","count","="," ","contains","len","'","#","reduce","append","hash","ge","imul","sort","index","add","(","gt","mul","属性","str","insert","dir","repr","getattribute",",","查看","pop","一个","iter","[","remove","iadd","doc","format","extend","setattr","]","le","reverse","subclass","eq","rmul",")","clear","创建","ne","方法","1","lt","delitem","new","setitem","__","reversed","ex"],"title":"list的方法","title_tokens":["的","list","方法"]},{"location":"Python基础/2.3.List.html#list_2","text":"修改现有list的值，通过索引、切片来完成。 list_1 = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] # 修改某个索引对应元素的值 list_1 [ 0 ] = 12 ; list_1 [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 修改某个连续区域的值 list_1 [ 0 : 5 ] = [ 11 , 12 , 13 , 14 , 15 ]; list_1 [11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10]","text_tokens":["、","8","_","15","13","对应","14","3","的","list","区域","=","，"," ","连续","#","2","索引","元素","11","切片","某个","修改","10",",","5","来","[","现有","值","。","12","]","9","4","7","0","完成","6",":","通过","1",";"],"title":"修改list元素的值","title_tokens":["值","的","list","元素","修改"]},{"location":"Python基础/2.3.List.html#_1","text":"append 方法每次只能添加一个新元素 list_1 . append ( 12 ); list_1 [11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10, 12]","text_tokens":["8","_","15","只能","13","14","list"," ","append","(","元素","11",".","10",",","一个","5","添加","[","12","]",")","9","7","方法","新元","6","新元素","1",";","每次"],"title":"添加一个新元素到末尾","title_tokens":["到","一个","末尾","添加","新元","新元素","元素"]},{"location":"Python基础/2.3.List.html#_2","text":"extend 方法允许我们通过另一个list来扩充当前的list。 实际上，这看起来像是拼接list。 list_2 = [ '0' , '00' , '000' ] list_1 + list_2 # 此时list_1没有被修改 print ( list_1 ) list_1 . extend ( list_2 ) # 此时list_1被修改 print ( list_1 ) # 显然拼接的效率回比`extend`方法的效率低 # 还可以借助切片来扩充list，像这样 list_1 [ len ( list_1 ):] = list_2 list_1 # 但是这样的可读性不高 [11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10, 12] [11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10, 12, '0', '00', '000'] [11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10, 12, '0', '00', '000', '0', '00', '000']","text_tokens":["8","没有","_","借助","15","看起","实际","这样","13","14","list","的","像是","当前","扩充","，"," ","=","len","此时","'","#","+","可以","2","低","不高","可读性","但是","000","效率","这","我们","(","切片","11","修改",".","10",",","一个","可读","拼接","00","5","来","回比","[","extend","另","。","print","]","12","显然","被","像",")","9","7","实际上","方法","0","`","还","6","起来",":","通过","1","看起来","允许"],"title":"添加任意个新元素到末尾","title_tokens":["到","末尾","任意","添加","新元","个","新元素","元素"]},{"location":"Python基础/2.3.List.html#_3","text":"insert 方法将一个对象插入指定位置 list_1 . insert ( 0 , 11 ); list_1 [11, 11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10, 12, '0', '00', '000', '0', '00', '000'] # 当然，也可以借助切片在任意位置插入元素 # 注意的是，对一个list使用切片，必定会得到一个list，这就需要用一个list对切片赋值 # 这样虽然巧妙，但是可读性比不上insert list_1 [ 0 : 0 ] = [ 11 ] list_1 [11, 11, 11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10, 12, '0', '00', '000', '0', '00', '000']","text_tokens":["8","_","借助","巧妙","15","位置","任意","这样","对象","13","14","list","的","就"," ","，","=","'","#","可以","使用","用","必定","当然","可读性","但是","000","必定会","(","元素","11","切片","这","需要","insert",".","10",",","定会","是","一个","5","可读","00","得到","[","比不上","插入","12","]","虽然","也",")","9","在","将","赋值","7","方法","0","6","注意",":","指定","1",";","对"],"title":"在任意位置插入新元素","title_tokens":["在","任意","位置","新元","新元素","插入","元素"]},{"location":"Python基础/2.3.List.html#_4","text":"list_2 ['0', '00', '000'] # 注意，pop是list中唯一一个修改原列表，并且有返回值的方法 list_2 . pop () '000' list_2 ['0', '00'] # pop默认删除最后一个元素，但是也可以输入索引值，指定删除元素的位置 list_2 . pop ( 0 ) '0' list_2 ['00']","text_tokens":["_","输入","位置","并且","list","的","，"," ","'","#","可以","2","索引","中","返回值","但是","000","(","元素","原","唯一","最后","修改",".",",","是","pop","一个","00","[","值","有","删除","]","返回","默认","也",")","0","方法","注意","指定","列表"],"title":"删除\\取出最后一个（任意位置的）元素","title_tokens":["（","一个","取出","任意","位置","\\","的","删除","）","元素","最后"]},{"location":"Python基础/2.3.List.html#_5","text":"list_1 . remove ( 11 ) list_1 [11, 11, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10, 12, '0', '00', '000', '0', '00', '000']","text_tokens":["8","_","15","13","14","list"," ","'","000","(","11",".","10",",","5","00","remove","[","12","]",")","9","7","0","6","1"],"title":"删除第一次出现的元素","title_tokens":["第一次","第一","的","删除","出现","元素","一次"]},{"location":"Python基础/2.3.List.html#_6","text":"list_1 . reverse () list_1 ['000', '00', '0', '000', '00', '0', 12, 10, 9, 8, 7, 6, 5, 15, 14, 13, 12, 11, 11]","text_tokens":["8","_","15","13","14","list"," ","'","000","(","11",".","10",",","5","00","[","12","]","reverse",")","9","7","0","6","1"],"title":"反序排序","title_tokens":["排序","反序"]},{"location":"Python基础/2.3.List.html#_7","text":"方法sort接受两个可选参数：key和reverse。将key设置为一个用于排序的函数。然而，不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。对于另一个关键字参数reverse，只需将其指定为True或False，以指出是否要按相反的顺序对列表进行排序。 list_3 = [ 'aardvark' , 'abalone' , 'acme' , 'add' , 'aerate' ] list_3 . sort ( key = len ) list_3 ['add', 'acme', 'aerate', 'abalone', 'aardvark'] # 按照长度降序排序 list_3 . sort ( key = len , reverse = True ) list_3 ['aardvark', 'abalone', 'aerate', 'acme', 'add']","text_tokens":["是否","或","只","关键字","的","降序","acme","aardvark","和","按照","而是","来","]","接受","参数","创建","方法","指出","_","对于","不会","list","，"," ","再","使用","用于","一个","需","设置","以","。","直接","相反","将","两个","根据","指定","每个","其","这些","按","=","'","#","关键","(","元素",".",",","false","选","[","函数","长度","然而","abalone","为","3","可","true","判断","len","小","add","排序","另","它","进行","aerate","要","reverse","比","对","key","顺序",")","这个","键","sort","列表","："],"title":"排序","title_tokens":["排序"]},{"location":"Python基础/2.3.List.html#_8","text":"list_1 list_1 . count ( 11 ) 2","text_tokens":[".","_","2",")","list","count","(","1","11"," "],"title":"统计元素出现的次数","title_tokens":["统计","次数","的","出现","元素"]},{"location":"Python基础/2.3.List.html#_9","text":"list_1 list_1 . index ( \"000\" ) 0","text_tokens":[".","_",")","0","\"","000","list","index","(","1"," "],"title":"得到某个值第一次出现时对应的索引值","title_tokens":["索引","时","得到","第一次","第一","值","对应","的","出现","某个","一次"]},{"location":"Python基础/2.3.List.html#_10","text":"list_4 = list_1 list_1 [ 0 ] = \"修改了\" print ( \"list_1\" , list_1 ) print ( \"list_4\" , list_4 ) print ( \" \\n \" ) # 深拷贝 list_5 = list_1 . copy () list_1 [ 0 ] = \"又修改了\" print ( \"list_1\" , list_1 ) print ( \"list_5\" , list_5 ) list_1 [ '修改了' , '00' , '0' , '000' , '00' , '0' , 12 , 10 , 9 , 8 , 7 , 6 , 5 , 15 , 14 , 13 , 12 , 11 , 11 ] list_4 [ '修改了' , '00' , '0' , '000' , '00' , '0' , 12 , 10 , 9 , 8 , 7 , 6 , 5 , 15 , 14 , 13 , 12 , 11 , 11 ] list_1 [ '又修改了' , '00' , '0' , '000' , '00' , '0' , 12 , 10 , 9 , 8 , 7 , 6 , 5 , 15 , 14 , 13 , 12 , 11 , 11 ] list_5 [ '修改了' , '00' , '0' , '000' , '00' , '0' , 12 , 10 , 9 , 8 , 7 , 6 , 5 , 15 , 14 , 13 , 12 , 11 , 11 ]","text_tokens":["8","_","copy","15","13","14","list","="," ","'","#","000","(","11","n","修改","深",".","10",",","5","00","\"","[","\\","又","print","12","]",")","9","4","7","0","6","了","1","拷贝"],"title":"深拷贝列表","title_tokens":["深","拷贝","列表"]},{"location":"Python基础/2.3.List.html#_11","text":"list_1 . clear () list_1 []","text_tokens":[".","_",")","clear","]","[","list","(","1"," "],"title":"清空列表","title_tokens":["清空","列表"]},{"location":"Python基础/2.4.String.html","text":"多行字符串 str_1 = \"\"\" 这是一个多行字符串 这是第二行 \"\"\" print ( str_1 ) str_1 = \"这是一个多行字符串 \\n 这是第二行\" print ( str_1 ) 这是一个多行字符串 这是第二行 这是一个多行字符串 这是第二行 转义 如果要在字符串里面输入特殊字符，需要使用转义符\\，例如输入转义符本身： str_2 = \"12 \\\\ 14\" print ( str_2 ) 12\\14 字符编码 Python有两种不同的字符串，一种存储文本，一种存储字节。对于文本，Python内部采用Unicode存储，而字节字符串显示原始字节序列或者ASCII。在Python3当中，文本字符串类型（使用Unicode数据存储）被命名为 str , 字节字符串类型被命名为 bytes 。但在python2中，文本字符串类型叫做 unicode ，字节字符串类型叫做 str 。也就是说： $$ \\begin{align } Python\\ 3\\ \\mathbf{str} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{unicode} \\ Python\\ 3\\ \\mathbf{str} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{unicode} \\end{align } $$ 所以，如果想将以unicode形式储存的字符串转换为二进制类型的字符串，需要将unicode字符串编码，反之，则需要解码。 编码：在python中，编码指的是将Unicode字符按照编码规则（如UTF-8）编成二进制序列。 在python3中实例化一个字符串 str_3 = \"中国\" print ( str_3 ) # 编码str_5 str_3 . encode () # 创建一个二进制字符串 str_4 = b ' \\xe4\\xb8\\xad\\xe5\\x9b\\xbd ' # 解码str_6 str_4 . decode () 中国 '中国' 前缀 在Python中，字符串可以添加前缀 r\\R 、 b 、 u\\U 。 r\\R：表示非转义的原始字符串，常用于正则表达式。 b：Python3里默认的str是(Python2里的)unicode, bytes是(Python2)的str,b前缀代表的就是bytes。Python2里, b前缀没什么具体意义，只是为了兼容Python3的这种写法 。 u\\U：表示unicode字符串，代表是对字符串进行unicode编码。一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。建议所有编码方式采用UTF-8。 格式化 C printf 样式的格式化 字符串具有一种特殊的内置操作：使用 % (取模)运算符，可以格式化字符串，此时 % 也被称为字符串的格式化运算符或插值运算符。对于format % values(其中format为一个字符串)，在format中的 % 转换标记符将被替换为零个或多个values条目。 其效果类似于在C语言中使用sprintf()。 'Hello, %s ' % 'world' # 省略括号 'Hello, world' 'Hi, %s , you have $ %d ' % ( 'Michael' , 10000.58 ) 'Hi, Michael, you have $10000' 转换标记符 包含两个或更多字符，由以下元素组成，且必须遵循此处规定的顺序： % 字符，用于标记转换符的起始。 映射键（可选），由加圆括号的字符序列组成(例如(somename))。 转换标志（可选） - - 表示左对齐 - + 表示转换后的内容前方加上正负号 - 空格 表示正数前方保留一个空格 - - 0 表示如果转换位置位数不够时，用0填充 最小字段宽度（可选），转换后字段的最小宽度，如果不足自动用空格补齐；如果最小字段宽度值为 * ，则从元组中读取。 5.精度（可选），在 . 之后加精度值的形式给出。如果指定为为 * ，则从元组中读取。 长度修饰符（可选）。 转换类型。 Conversion Meaning d 格式化整数 i 格式化整数 o 8 进制 u 格式化无符号整型(已过时) x 16 进制， 小写字母 X 16 进制， 大写字母 e 浮点指数格式， 小写字母 E 浮点指数格式， 大写字母 f 浮点数 F 浮点数 g 浮点数， 如果指数小于 -4 或小于精度， 则使用小写指数格式， 否则使用小数格式 G 浮点数， 类似 g , 使用大写指数 c 单个字符， 格式化字符及其 ASCII 码 r 字符串， 使用 repr() 转换任何 Python 对象 s 字符串， 使用 str() 转换任何 Python 对象 % % 字符 # + term=True # 最小字段宽度 ' %2s ' % 123456 ' %8s ' % 123456 ' %*s ' % ( 10 , 123456 ) # 精度 ' %.2f ' % 100.256 ' %.*f ' % ( 2 , 100.256 ) # 转换标志 ' %-8d ' % 123456 ' %+8d ' % 123456 ' %08d ' % 123456 # 映射键 ## 如果值是一个字典，那么必须使用映射键. 如： ' %(num)d ' % { \"num\" : 10 } '10' format方法 < 模板字符串 >. format ( < 逗号分隔的参数 > ) <模板字符串> 由一系列的槽 {} 组成，用来控制修改字符串中嵌入值出现的位置，其基本思想是将format()方法的 <逗号分隔的参数> 中的参数按照序号关系替换到 <模板字符串> 的槽中。如果大括号中没有序号，则按照出现顺序替换。该方法会创建新字符串对象，不会修改原值。 {}中指定顺序，按指定的顺序替换 print ( \" {2} : {1} : {0} \" . format ( \"1\" , \"2\" , \"3\" )) 3 : 2 : 1 没有指定顺序，按出现的顺序依次替换 print ( \" {} : {} : {} \" . format ( \"1\" , \"2\" , \"3\" )) 1 : 2 : 3 format()方法中 <模板字符串> 的槽除了包括参数序号，还可以包括格式控制信息。此时，槽的内部样式如下： 替换字段 - replacement_field ::= \"{\" [ field_name ] [ \"!\" conversion ] [ \":\" format_spec ] \"}\" 字段名 - field_name ::= arg_name ( \".\" attribute_name | \"[\" element_index \"]\" ) * 参数名 - arg_name ::= [ identifier | integer ] 属性名 - attribute_name ::= identifier 元素索引 - element_index ::= integer | index_string 索引字符串 - index_string ::= < any source character except \"]\" > + 转换字段 - conversion ::= \"r\" | \"s\" 格式规范说明符 - format_spec ::= < described in the next section > 注意事项： 参数名 可以为 整数 或 关键字 。整数为位置参数， 关键字为命名关键字参数。 如果整数类似于 {0}{1}{2}, 则可以省略， 即： {}{}{} 等价于 {0}{1}{2}. 如果参数存在属性， 可以通过 arg_name.attribute_name 的形式获取属性值。 如果参数为可迭代对象， 可以通过 arg_name[integer|index_string] 的形式获取索引位置的元素。 转换字段 由 ! 开始， r 代表调用 repr(), s 代表调用 str(). 格式规范说明符 由 : 开始。 其中， <格式控制标记> 用来控制参数显示时的格式，可以使用的参数如下： format_spec ::= [ [fill ] align ] [ sign ][ # ][ 0 ][ width ][ grouping_option ][ .precision ][ type ] fill ::= < any character > align ::= \"<\" | \">\" | \"=\" | \"^\" sign ::= \"+\" | \"-\" | \" \" width ::= digit + grouping_option ::= \"_\" | \",\" precision ::= digit + type ::= \"b\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" | \"g\" | \"G\" | \"n\" | \"o\" | \"s\" | \"x\" | \"X\" | \"%\" 填充字符 ：如果指定了对齐选项，则可以使用填充字符。默认为空格. 对齐选项 ：默认右对齐，各种对齐选项的含义如下： 选项 意义 '<' 强制字段在可用空间内左对齐（这是大多数对象的默认值）。 '>' 强制字段在可用空间内右对齐（这是数字的默认值）。 '=' 强制将填充放置在符号（如果有）之后但在数字之前。这用于以“+000000120”形式打印字段。此对齐选项仅对数字类型有效。当'0'紧接在字段宽度之前时，它成为默认值。 '^' 强制字段在可用空间内居中。 sign ：仅对数字类型有效，可以是以下之一： 选项 意义 '+' 表示标志应该用于正数和负数。 '-' 表示标志应仅用于负数（这是默认行为）。 space 表示应在正数上使用前导空格，在负数上使用减号。 # ：仅适用于数字参数，同时仅适用于2、8、16进制的数字。会在输出的数字前添加 0b、0o、0x前缀。 宽度 ：指定最小字段宽度。 千位分隔符 ：只能使用 _ 或 , 作为千位分隔符。 精度 ： 类型 ：该选项决定了数据应该如何呈现。 可用的字符串表示类型： Type Meaning s 字符串格式， 字符串的默认类型， 可省略 None 同 s 可用的整数表示类型： Type Meaning b 输出为 2 进制整数 c 输出为为相应的 unicode 字符 d 输出为 10 进制整数 o 输出为 8 进制整数 x 输出为 16 进制整数， 使用小写字母 X 输出为 16 进制整数， 使用大写字母 n 类似 d , 会使用当前区域设置插入适当的数字分隔符 None 同 d 可用的浮点数和小数值表示类型： Type Meaning e 指数表示法， 使用字母 e 以科学记数法打印数字， 默认进度为 6 E 类似 e , 使用字母 E f 浮点数， 默认进度为 6 F 浮点数， 同 f g 一般形式， 受 precision 选项影响 G 类似 g , 当使用指数表示法时， 使用 E 而不是 e n 和 g 相同， 会使用当前区域设置插入适当的数字分隔符 % 百分数表示 None 同 g # 填充、对齐、符号、宽度、分组选项、精度 \" {0:*^+20.2f} \" . format ( 120 ) # 填充*号、居中、正号标记、2精度 '******+120.00*******' \"{0:*^+20_.2f}\" . format ( 12000 ) # 填充*号、居中、正号标记、_分隔符、2精度 '*****+12_000.00*****' \" {0:*^+20,.2f} \" . format ( 12000 ) # 填充*号、居中、正号标记、,分隔符、2精度 '*****+12,000.00*****' \" {0:*<+20.2f} \" . format ( - 120 ) # 填充*号、左对齐、正号标记、2精度 '-120.00*************' \" {0:*>-20.2f} \" . format ( - 120 ) # 填充*号、左对齐、负号标记、2精度 '*************-120.00' bytes字符 文本字符类型在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把 str 变为以字节为单位的 bytes 。 Python3对 bytes 类型的数据用带 b 前缀的单引号或双引号表示。 bytes_8 = b \"ABC\" bytes_8 b'ABC' 要注意的是：bytes字面值中只允许ASCII字符（无论源代码声明的编码为何）。任何超出127的二进制值必须使用相应的转义序列形式加入bytes字面值。 例如，可以对str（unicode类型）对象使用 encode() 方法，编码为bytes的形式（16进制表示）。 '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 要注意的是， encode 的对象不能超出指定编码的范围，例如不能对中文字符使用 .encode(\"ascii\") ，因为中文不在ascii码的范围内。 '中文' . encode ( 'ascii' ) ---------------------------------------------------------------------------UnicodeEncodeError Traceback (most recent call last)<ipython-input-1-76f41cd8dafa> in <module> ----> 1 '中文'.encode('ascii') UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) 纯英文的str可以用ASCII编码为bytes，内容是一样的，但无法显示为ASCII字符的字节，用 \\x 显示（16进制转义表示）。 'ABC' . encode ( 'ascii' ) b'ABC' '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用 decode() 方法： b 'ABC' . decode ( 'ascii' ) 'ABC' b ' \\xe4\\xb8\\xad\\xe6\\x96\\x87 ' . decode ( 'utf-8' ) '中文' 如果bytes中包含无法解码的字节， decode() 方法会报错： b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' ) ---------------------------------------------------------------------------UnicodeDecodeError Traceback (most recent call last)<ipython-input-1-cd8de1b11dcd> in <module> ----> 1 b'\\xe4\\xb8\\xad\\xff'.decode('utf-8') UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte 但是，如果bytes中只有一小部分无效的字节，可以传入 errors = 'ignore' 忽略错误的字节： \"中\" . encode ( \"utf-8\" ) # 中 原来的编码 b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' , errors = 'ignore' ) '中' 在对str和bytes互相转换时，为了避免乱码问题，应该使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： # !/usr/bin/env python3 # -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释。第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，在源代码中写的中文输出可能会有乱码。 但是申明了UTF-8编码只是让Python解释器按UTF-8的编码规则读取源代码，并不意味着源代码一定是使用UT8-8编码保存的，必须并且要确保文本编辑器正在使用UTF-8编码。 方法","text_tokens":["一行","适用","本文","说明","规范","相同","指","段","i","前缀","源代码","width","2","f","不","*","the","浮点","08d","abc","或者","也就是说","print","插入","浮点数","16","存储","非","即","一旦","grouping","num","8","/","unicodeencodeerror","表示法","x9b","position","，","多行","somename","align","space","迭代","range","precision","填充","否则","000000120","10000.58","二行","宽度","那么","问题","xad","coding","储存","磁盘","其中","ut8","默认","一般","适当","文本编辑","形式","多个","两个","无效","圆括号","允许","一系列","不足","忽略","正数","按","具有","两种","后字","这是","'","只是",">","时","bytes","xb8","里","报错","100.256","printf","自动","类似","方式","之后","不带","特殊","同时","思想","解析","begin","转义序列","叫做","省略","字典","实例","了","成为","values","记数","通过","index","但","化","3","usr","如下","不同","用","由加","8d","同","errors","更","中写","符号","一系","这","申明","选项","start","想","规定","保存","要","；","数值","任何","仅","系列","无法","option","end","会","键","1","存在","小于","原来","位置","大写字母","精度","特殊字符","之前","过时","字符串","修饰符","recent","当中","应该","达式","utf","大多","module","数字","!","空间","意味着","字段","逗号","有","规则","采用","]","前方","基本","读取","创建","数据","补齐","8s","spec","范围","term","常用","接在","not","）","格式","系统","而","左","分隔符","xe4","新","character","值为","编辑","语言","区域","have"," ","网络","xe6","部分","使用","注意事项","中","如何","组成","用于","{","行为","中文","“","告诉","小写","正则表达式","修饰","需","mathbf","%+","正常","format","next","前导","也","可用","中以","括号","string","ipython","类型","一小部分","大多数","所","样式","其","变为","把","分数","python","关键","整型","有效","决定","unicode","面值","内置","hello","you","none","(","乱码","修改","内右","codec","一小","可执行程序","127","用来","序号","选","e","section","取模","c语言","已","由于","12","流","符","在","t","最小","并","0x","<","解释器","|","此","槽","嵌入","最","element","意味","零个","释器","默认值","声明","most","python2","百分数","为","必须","单个","当前","可","true","小部","可以","加","小","字符","打印","正","arg","我们","str","程序","包括","单位","该","linux","内","应仅","any","让","替换","ordinal","开头","之一","信息","右","位数","紧接","指数","超出","进度","或","bin","正负号","什么","关键字","traceback","前","保留","包含","进制","含义","若干","字","（","表达式","运算符","和","按照","内存","转换","内容","反之","读到","时候","开始","大括号","unicodedecodeerror","表达","代表","不够","你","等价","文本","0","还","转义","encode","加入","_","123456","第二行","例如","integer","对应","下","控制","michael","确保","调用","出现","一样","0xff","属性","传输","双引号","env","windows","一个","兼容","”","s","\"","写字","分隔","设置","编码","以","。","起始","120","强制","input","x96","算符","ascii","若干个","invalid","表明","后","6","运算","注释","xff","遵循","互相","负数","纯","字母","小字","条目","%","且","os","除了","2s","field","各种","元素","标志","避免","type","值","从","第二","cd8de1b11dcd","码","由","-","具体","影响","长度","如","英文","except","000.00","、","对齐","一定","ignore","及其","二进制","14","identifier","10000","就","符将","128","此时","fill","传入","紧接在","依次","映射","2f","76f41cd8dafa","编码方式","说明符","减号","longleftrightarrow","source","当","行程","添加","d","它","last","用带","为了",")","就是","执行","科学","字节","注意","第一","反过","这个","负号","120.00","对","o","控制参数","序列","呈现","通常","标记","只","格式化","u","的","里面","元组","建议","b","无论","0o","&","但是","call","文件","n","replacement","repr","$","引号","称为","就是说","分组","原值","千位","不是","参数","为何","0b","因为","g","方法","sign","python3","没有","12000","对于","world","不会","并且","号","本身","效果","没什么","}","xbd","c","大写","_.","字段名","r","第一行","10","整数","都","5","\\","can","name","所有","应","一种","记数法","写法","described","则","将","4","以下","原始","中国","正则","多","指定","conversion","命名","输出","作为","表示","characters","名","输入","解释","关系","对象","只能","百分","=","事项","两行","#","x","解码","这种","x87","错误","相应","写","上","操作","20","给出","受",".",",","到","是","不能","[","decode","内部","正在","务必","hi","无","被","digit","代码","意义","meaning","模板","显示","居中","小数","20.2","多数","byte","于","编成","器","+","in","##","索引","获取","插值","只有","xe5","放置","空格","需要","过来","attribute","小写字母","可能","所以","加上","单引号","进行","顺序","sprintf","如果","此处","正负","%.","^","反过来","文本文件","点数",":","："],"title":"2.4.String","title_tokens":[".","string","2.4"]},{"location":"Python基础/2.4.String.html#_1","text":"str_1 = \"\"\" 这是一个多行字符串 这是第二行 \"\"\" print ( str_1 ) str_1 = \"这是一个多行字符串 \\n 这是第二行\" print ( str_1 ) 这是一个多行字符串 这是第二行 这是一个多行字符串 这是第二行","text_tokens":["_","第二行","="," ","多行","这是","字符串","字符","(","二行","n","str","一个","\"","\\","print","第二",")","1"],"title":"多行字符串","title_tokens":["字符","字符串","多行"]},{"location":"Python基础/2.4.String.html#_2","text":"如果要在字符串里面输入特殊字符，需要使用转义符\\，例如输入转义符本身： str_2 = \"12 \\\\ 14\" print ( str_2 ) 12\\14","text_tokens":["_","输入","例如","14","里面","特殊字符","，"," ","=","本身","字符串","使用","2","字符","(","需要","str","特殊","\"","\\","print","12","要","符","如果","在",")","转义","："],"title":"转义","title_tokens":["转义"]},{"location":"Python基础/2.4.String.html#_3","text":"Python有两种不同的字符串，一种存储文本，一种存储字节。对于文本，Python内部采用Unicode存储，而字节字符串显示原始字节序列或者ASCII。在Python3当中，文本字符串类型（使用Unicode数据存储）被命名为 str , 字节字符串类型被命名为 bytes 。但在python2中，文本字符串类型叫做 unicode ，字节字符串类型叫做 str 。也就是说： $$ \\begin{align } Python\\ 3\\ \\mathbf{str} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{unicode} \\ Python\\ 3\\ \\mathbf{str} &\\Longleftrightarrow Python\\ 2\\ \\mathbf{unicode} \\end{align } $$ 所以，如果想将以unicode形式储存的字符串转换为二进制类型的字符串，需要将unicode字符串编码，反之，则需要解码。 编码：在python中，编码指的是将Unicode字符按照编码规则（如UTF-8）编成二进制序列。 在python3中实例化一个字符串 str_3 = \"中国\" print ( str_3 ) # 编码str_5 str_3 . encode () # 创建一个二进制字符串 str_4 = b ' \\xe4\\xb8\\xad\\xe5\\x9b\\xbd ' # 解码str_6 str_4 . decode () 中国 '中国'","text_tokens":["序列","指","的","进制","（","字符串","2","b","按照","当中","&","转换","反之","utf","$","或者","有","也就是说","规则","print","采用","就是说","创建","文本","存储","数据","python3","）","encode","8","_","对于","而","xe4","x9b","，"," ","使用","align","中","}","xbd","{","xad","储存","一个","5","\"","\\","mathbf","编码","以","。","一种","ascii","则","将","形式","4","原始","中国","6","类型","命名","两种","=","'","#","python","解码","unicode","bytes","xb8","(",".",",","是","decode","内部","begin","叫做","被","在","实例","-","如","显示","但","python2","二进制","化","为","3","编成","不同","字符","xe5","str","需要","longleftrightarrow","所以","想","如果",")","就是","字节","end","："],"title":"字符编码","title_tokens":["字符","编码"]},{"location":"Python基础/2.4.String.html#_4","text":"在Python中，字符串可以添加前缀 r\\R 、 b 、 u\\U 。 r\\R：表示非转义的原始字符串，常用于正则表达式。 b：Python3里默认的str是(Python2里的)unicode, bytes是(Python2)的str,b前缀代表的就是bytes。Python2里, b前缀没什么具体意义，只是为了兼容Python3的这种写法 。 u\\U：表示unicode字符串，代表是对字符串进行unicode编码。一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。建议所有编码方式采用UTF-8。","text_tokens":["什么","u","的","前缀","表达式","字符串","b","建议","但是","转换","达式","utf","表达","代表","采用","基本","常用","非","python3","转义","一旦","8","下","，"," ","使用","没什么","中","否则","出现","中文","r","都","兼容","正则表达式","需","\\","编码","正常","。","所有","默认","一般","写法","表明","原始","正则","所","表示","python","只是","unicode","bytes","这种","里","(","各种","乱码",",","是","方式","不带","解析","在","-","具体","意义","英文","、","python2","于","必须","就","可以","字符","str","编码方式","添加","所以","进行","；","为了",")","就是","会","对","："],"title":"前缀","title_tokens":["前缀"]},{"location":"Python基础/2.4.String.html#_5","text":"","text_tokens":[],"title":"格式化","title_tokens":["格式","格式化"]},{"location":"Python基础/2.4.String.html#c-printf","text":"字符串具有一种特殊的内置操作：使用 % (取模)运算符，可以格式化字符串，此时 % 也被称为字符串的格式化运算符或插值运算符。对于format % values(其中format为一个字符串)，在format中的 % 转换标记符将被替换为零个或多个values条目。 其效果类似于在C语言中使用sprintf()。 'Hello, %s ' % 'world' # 省略括号 'Hello, world' 'Hi, %s , you have $ %d ' % ( 'Michael' , 10000.58 ) 'Hi, Michael, you have $10000' 转换标记符 包含两个或更多字符，由以下元素组成，且必须遵循此处规定的顺序： % 字符，用于标记转换符的起始。 映射键（可选），由加圆括号的字符序列组成(例如(somename))。 转换标志（可选） - - 表示左对齐 - + 表示转换后的内容前方加上正负号 - 空格 表示正数前方保留一个空格 - - 0 表示如果转换位置位数不够时，用0填充 最小字段宽度（可选），转换后字段的最小宽度，如果不足自动用空格补齐；如果最小字段宽度值为 * ，则从元组中读取。 5.精度（可选），在 . 之后加精度值的形式给出。如果指定为为 * ，则从元组中读取。 长度修饰符（可选）。 转换类型。 Conversion Meaning d 格式化整数 i 格式化整数 o 8 进制 u 格式化无符号整型(已过时) x 16 进制， 小写字母 X 16 进制， 大写字母 e 浮点指数格式， 小写字母 E 浮点指数格式， 大写字母 f 浮点数 F 浮点数 g 浮点数， 如果指数小于 -4 或小于精度， 则使用小写指数格式， 否则使用小数格式 G 浮点数， 类似 g , 使用大写指数 c 单个字符， 格式化字符及其 ASCII 码 r 字符串， 使用 repr() 转换任何 Python 对象 s 字符串， 使用 str() 转换任何 Python 对象 % % 字符 # + term=True # 最小字段宽度 ' %2s ' % 123456 ' %8s ' % 123456 ' %*s ' % ( 10 , 123456 ) # 精度 ' %.2f ' % 100.256 ' %.*f ' % ( 2 , 100.256 ) # 转换标志 ' %-8d ' % 123456 ' %+8d ' % 123456 ' %08d ' % 123456 # 映射键 ## 如果值是一个字典，那么必须使用映射键. 如： ' %(num)d ' % { \"num\" : 10 } '10'","text_tokens":["o","序列","小于","或","标记","正负号","位置","格式化","精度","大写字母","段","u","的","保留","包含","进制","i","（","元组","过时","字符串","运算符","f","修饰符","2","转换","内容","*","repr","$","浮点","08d","称为","不够","前方","浮点数","读取","16","g","0","补齐","8s","term","）","格式","num","8","对于","左","123456","world","值为","例如","语言","have","，"," ","michael","somename","效果","使用","中","}","c","大写","组成","用于","位数","填充","否则","{","10000.58","宽度","那么","r","10","整数","小写","一个","5","修饰","其中","s","\"","写字","%+","。","format","起始","算符","一种","也","ascii","则","多个","形式","4","两个","以下","后","多","括号","圆括号","运算","指定","类型","conversion","不足","遵循","表示","其","正数","对象","具有","后字","=","字母","小字","'","#","python","整型","x","条目","时","且","%","内置","hello","2s","操作","you","(","元素","标志","给出","100.256",".","自动",",","类似","之后","是","特殊","选","e","值","取模","c语言","已","从","hi","无","符","被","省略","字典","码","在","由","-","最小","values","长度","meaning","如","最","零个","对齐","小数","及其","为","于","必须","单个","10000","可","true","符将","此时","+","可以","由加","用","加","8d","字符","##","更","插值","符号","映射","空格","2f","str","小写字母","加上","d","规定","；","任何","顺序","sprintf","此处",")","替换","如果","正负","%.","点数",":","键","负号","指数","："],"title":"C printf 样式的格式化","title_tokens":["样式","c","格式化","的"," ","格式","printf"]},{"location":"Python基础/2.4.String.html#format","text":"< 模板字符串 >. format ( < 逗号分隔的参数 > ) <模板字符串> 由一系列的槽 {} 组成，用来控制修改字符串中嵌入值出现的位置，其基本思想是将format()方法的 <逗号分隔的参数> 中的参数按照序号关系替换到 <模板字符串> 的槽中。如果大括号中没有序号，则按照出现顺序替换。该方法会创建新字符串对象，不会修改原值。 {}中指定顺序，按指定的顺序替换 print ( \" {2} : {1} : {0} \" . format ( \"1\" , \"2\" , \"3\" )) 3 : 2 : 1 没有指定顺序，按出现的顺序依次替换 print ( \" {} : {} : {} \" . format ( \"1\" , \"2\" , \"3\" )) 1 : 2 : 3 format()方法中 <模板字符串> 的槽除了包括参数序号，还可以包括格式控制信息。此时，槽的内部样式如下： 替换字段 - replacement_field ::= \"{\" [ field_name ] [ \"!\" conversion ] [ \":\" format_spec ] \"}\" 字段名 - field_name ::= arg_name ( \".\" attribute_name | \"[\" element_index \"]\" ) * 参数名 - arg_name ::= [ identifier | integer ] 属性名 - attribute_name ::= identifier 元素索引 - element_index ::= integer | index_string 索引字符串 - index_string ::= < any source character except \"]\" > + 转换字段 - conversion ::= \"r\" | \"s\" 格式规范说明符 - format_spec ::= < described in the next section > 注意事项： 参数名 可以为 整数 或 关键字 。整数为位置参数， 关键字为命名关键字参数。 如果整数类似于 {0}{1}{2}, 则可以省略， 即： {}{}{} 等价于 {0}{1}{2}. 如果参数存在属性， 可以通过 arg_name.attribute_name 的形式获取属性值。 如果参数为可迭代对象， 可以通过 arg_name[integer|index_string] 的形式获取索引位置的元素。 转换字段 由 ! 开始， r 代表调用 repr(), s 代表调用 str(). 格式规范说明符 由 : 开始。 其中， <格式控制标记> 用来控制参数显示时的格式，可以使用的参数如下： format_spec ::= [ [fill ] align ] [ sign ][ # ][ 0 ][ width ][ grouping_option ][ .precision ][ type ] fill ::= < any character > align ::= \"<\" | \">\" | \"=\" | \"^\" sign ::= \"+\" | \"-\" | \" \" width ::= digit + grouping_option ::= \"_\" | \",\" precision ::= digit + type ::= \"b\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" | \"g\" | \"G\" | \"n\" | \"o\" | \"s\" | \"x\" | \"X\" | \"%\" 填充字符 ：如果指定了对齐选项，则可以使用填充字符。默认为空格. 对齐选项 ：默认右对齐，各种对齐选项的含义如下： 选项 意义 '<' 强制字段在可用空间内左对齐（这是大多数对象的默认值）。 '>' 强制字段在可用空间内右对齐（这是数字的默认值）。 '=' 强制将填充放置在符号（如果有）之后但在数字之前。这用于以“+000000120”形式打印字段。此对齐选项仅对数字类型有效。当'0'紧接在字段宽度之前时，它成为默认值。 '^' 强制字段在可用空间内居中。 sign ：仅对数字类型有效，可以是以下之一： 选项 意义 '+' 表示标志应该用于正数和负数。 '-' 表示标志应仅用于负数（这是默认行为）。 space 表示应在正数上使用前导空格，在负数上使用减号。 # ：仅适用于数字参数，同时仅适用于2、8、16进制的数字。会在输出的数字前添加 0b、0o、0x前缀。 宽度 ：指定最小字段宽度。 千位分隔符 ：只能使用 _ 或 , 作为千位分隔符。 精度 ： 类型 ：该选项决定了数据应该如何呈现。 可用的字符串表示类型： Type Meaning s 字符串格式， 字符串的默认类型， 可省略 None 同 s 可用的整数表示类型： Type Meaning b 输出为 2 进制整数 c 输出为为相应的 unicode 字符 d 输出为 10 进制整数 o 输出为 8 进制整数 x 输出为 16 进制整数， 使用小写字母 X 输出为 16 进制整数， 使用大写字母 n 类似 d , 会使用当前区域设置插入适当的数字分隔符 None 同 d 可用的浮点数和小数值表示类型： Type Meaning e 指数表示法， 使用字母 e 以科学记数法打印数字， 默认进度为 6 E 类似 e , 使用字母 E f 浮点数， 默认进度为 6 F 浮点数， 同 f g 一般形式， 受 precision 选项影响 G 类似 g , 当使用指数表示法时， 使用 E 而不是 e n 和 g 相同， 会使用当前区域设置插入适当的数字分隔符 % 百分数表示 None 同 g # 填充、对齐、符号、宽度、分组选项、精度 \" {0:*^+20.2f} \" . format ( 120 ) # 填充*号、居中、正号标记、2精度 '******+120.00*******' \"{0:*^+20_.2f}\" . format ( 12000 ) # 填充*号、居中、正号标记、_分隔符、2精度 '*****+12_000.00*****' \" {0:*^+20,.2f} \" . format ( 12000 ) # 填充*号、居中、正号标记、,分隔符、2精度 '*****+12,000.00*****' \" {0:*<+20.2f} \" . format ( - 120 ) # 填充*号、左对齐、正号标记、2精度 '-120.00*************' \" {0:*>-20.2f} \" . format ( - 120 ) # 填充*号、左对齐、负号标记、2精度 '*************-120.00'","text_tokens":["适用","说明","规范","相同","段","前缀","width","2","f","*","the","浮点","插入","print","浮点数","16","即","grouping","8","表示法","，","align","space","迭代","precision","填充","000000120","宽度","其中","默认","一般","适当","形式","一系列","正数","按","这是","'",">","时","类似","之后","同时","思想","省略","了","成为","记数","通过","index","但","3","如下","同","符号","一系","这","选项","数值","仅","系列","option","会","1","存在","位置","大写字母","精度","之前","字符串","应该","大多","数字","!","空间","字段","逗号","有","]","基本","创建","数据","spec","接在","）","格式","左","分隔符","而","新","character","区域"," ","使用","注意事项","中","如何","组成","用于","{","行为","“","小写","next","format","前导","可用","括号","string","类型","大多数","样式","其","分数","关键","有效","决定","unicode","none","(","修改","内右","用来","序号","section","e","12","在","0x","<","|","此","槽","嵌入","element","最","默认值","百分数","为","当前","可","可以","小","字符","打印","正","arg","str","包括","该","内","应仅","any","替换","之一","信息","右","紧接","指数","进度","或","关键字","前","含义","进制","字","（","和","按照","转换","开始","大括号","代表","等价","0","还","_","integer","控制","调用","出现","属性","”","s","\"","写字","分隔","设置","以","120","。","强制","6","负数","字母","小字","%","除了","field","各种","元素","标志","type","值","由","-","影响","except","000.00","、","对齐","identifier","此时","fill","紧接在","依次","2f","说明符","减号","source","当","添加","d","它",")","科学","注意","负号","120.00","对","控制参数","o","呈现","标记","的","b","0o","replacement","n","repr","分组","原值","千位","不是","参数","0b","g","方法","sign","没有","12000","不会","号","}","c","大写","_.","字段名","r","10","整数","name","应","记数法","described","则","将","以下","指定","conversion","命名","输出","作为","表示","名","关系","对象","只能","百分","=","事项","#","x","相应","上","20","受",".",",","到","是","[","内部","digit","意义","meaning","模板","显示","居中","20.2","多数","于","+","in","索引","获取","放置","空格","attribute","小写字母","顺序","如果","^","点数",":","："],"title":"format方法","title_tokens":["format","方法"]},{"location":"Python基础/2.4.String.html#bytes","text":"文本字符类型在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把 str 变为以字节为单位的 bytes 。 Python3对 bytes 类型的数据用带 b 前缀的单引号或双引号表示。 bytes_8 = b \"ABC\" bytes_8 b'ABC' 要注意的是：bytes字面值中只允许ASCII字符（无论源代码声明的编码为何）。任何超出127的二进制值必须使用相应的转义序列形式加入bytes字面值。 例如，可以对str（unicode类型）对象使用 encode() 方法，编码为bytes的形式（16进制表示）。 '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 要注意的是， encode 的对象不能超出指定编码的范围，例如不能对中文字符使用 .encode(\"ascii\") ，因为中文不在ascii码的范围内。 '中文' . encode ( 'ascii' ) ---------------------------------------------------------------------------UnicodeEncodeError Traceback (most recent call last)<ipython-input-1-76f41cd8dafa> in <module> ----> 1 '中文'.encode('ascii') UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) 纯英文的str可以用ASCII编码为bytes，内容是一样的，但无法显示为ASCII字符的字节，用 \\x 显示（16进制转义表示）。 'ABC' . encode ( 'ascii' ) b'ABC' '中文' . encode ( 'utf-8' ) b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用 decode() 方法： b 'ABC' . decode ( 'ascii' ) 'ABC' b ' \\xe4\\xb8\\xad\\xe6\\x96\\x87 ' . decode ( 'utf-8' ) '中文' 如果bytes中包含无法解码的字节， decode() 方法会报错： b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' ) ---------------------------------------------------------------------------UnicodeDecodeError Traceback (most recent call last)<ipython-input-1-cd8de1b11dcd> in <module> ----> 1 b'\\xe4\\xb8\\xad\\xff'.decode('utf-8') UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte 但是，如果bytes中只有一小部分无效的字节，可以传入 errors = 'ignore' 忽略错误的字节： \"中\" . encode ( \"utf-8\" ) # 中 原来的编码 b ' \\xe4\\xb8\\xad\\xff ' . decode ( 'utf-8' , errors = 'ignore' ) '中' 在对str和bytes互相转换时，为了避免乱码问题，应该使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： # !/usr/bin/env python3 # -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释。第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，在源代码中写的中文输出可能会有乱码。 但是申明了UTF-8编码只是让Python解释器按UTF-8的编码规则读取源代码，并不意味着源代码一定是使用UT8-8编码保存的，必须并且要确保文本编辑器正在使用UTF-8编码。","text_tokens":["序列","一行","原来","或","本文","通常","只","bin","traceback","的","包含","进制","若干","前缀","源代码","字","（","b","和","内存","recent","按照","不","无论","但是","转换","call","文件","内容","应该","utf","读到","时候","*","module","引号","abc","!","意味着","或者","有","unicodedecodeerror","规则","16","为何","读取","你","因为","文本","数据","方法","范围","0","not","python3","）","转义","encode","加入","8","_","系统","第二行","xe4","例如","并且","编辑","对应","/","unicodeencodeerror","position","网络","，"," ","xe6","部分","确保","使用","中","range","一样","0xff","那么","二行","否则","中文","问题","传输","第一行","双引号","xad","告诉","env","coding","windows","一个","只是","磁盘","\"","\\","以","编码","。","can","ut8","input","x96","也","中以","若干个","ascii","文本编辑","形式","invalid","无效","指定","ipython","类型","允许","一小部分","xff","注释","忽略","输出","表示","变为","characters","解释","对象","按","互相","把","=","纯","这是","'","#","python","两行","x","x87",">","unicode","bytes","解码","面值","错误","相应","xb8","时","上","写","os","(","报错","避免","乱码",".","codec","一小",",","可执行程序","到","是","127","不能","值","decode","由于","正在","从","务必","转义序列","流","第二","cd8de1b11dcd","码","在","t","-","并","<","代码","了","解释器","英文","显示","意味","一定","释器","声明","但","ignore","most","二进制","byte","为","必须","3","usr","器","就","小部","128","可以","用","in","字符","errors","传入","只有","中写","我们","这","需要","str","76f41cd8dafa","过来","程序","单位","当","行程","可能","申明","所以","单引号","start","保存","进行","last","内","要","它","linux","用带","任何","让","无法","如果",")","就是","为了","执行","ordinal","反过来","开头","字节","注意","文本文件",":","反过","会","第一","这个","1","超出","对","："],"title":"bytes字符","title_tokens":["bytes","字符"]},{"location":"Python基础/2.4.String.html#_6","text":"","text_tokens":[],"title":"方法","title_tokens":["方法"]},{"location":"Python基础/2.5.Tuple.html","text":"# -*- coding: utf-8 -*- Tuple siwing 2019.08.10 Tuple tuple是一种一维的，定长的、不可变的Python对象序列，元素写在小括号 () 里，元素之间用逗号隔开，元组中的元素类型可以不相同。 不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 Tuple的陷阱——一个元素的Tuple 定义个一个Tuple，需要传入一个iterable对象。 tuple ( \"123\" ) ('1', '2', '3') 如果需要定义一个空的Tuple，则可以这样定义： # 通过tuple类来定义 a = tuple () type ( a ) # 或者用 () 定义 a = () type ( a ) # 是的，的确通过()可以定义一个空tuple tuple 但是如果要顶一个只有一个元素的tuple，就得要注意了。 # 如果我们这样定义，则是错误的 b = ( \"123\" ) type ( b ) str # 定义只有一个元素的tuple，需要这样定义 b = ( \"123\" ,) type ( b ) tuple # 或者这样定义 b = tuple ([ \"123\" ]) type ( b ) tuple 为什么会这样呢？因为 () 在python中即表示运算符的 () ，也可以表示Tuple。这就不可避免地产生了歧义，为了消除歧义，Python规定括号里面只有一个元素时， #’ 按运算符的`()`进行解析。 Tuple的陷阱——“可变的”Tuple 前面说过，Tuple是一种不可变的对象。但是有时我们又会发现Tuple是“可变的”。 c = ( 'a' , 'b' , [ 'A' , 'B' ]) print ( \"原始定义的Tuple：\" , c ) c [ 2 ][ 0 ] = 'X' c [ 2 ][ 1 ] = 'Y' print ( \"修改后的Tuple：\" , c ) 原始定义的Tuple： ('a', 'b', ['A', 'B']) 修改后的Tuple： ('a', 'b', ['X', 'Y']) 前面说过tuple一旦定义后就不可变，那上面的c怎么就改变了呢？其实，c的元素并没有改变，改变的只是list中的元素，tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素的指向永远不变。即指向 a ，就不能改成指向 b ，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 所以要创建一个内容也不变的tuple，那就必须保证tuple的每一个元素本身也不能变。 Tuple的方法 因为Tuple是一个不可变的列表，所以Tuple对象的方法很少。 d = ( 0 , 1 , 2 , 3 , 4 , 4 ) dir ( d ) ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index'] 统计元素出现的次数 d . count ( 4 ) 2 得到某个值第一次出现时对应的索引值 d . index ( 4 ) 4","text_tokens":["陷阱","序列","怎么","相同","什么","可变","subclasshook","的","里面","delattr","count","iterable","包含","保证","中即","上面","产生","contains","元组","b","2","不可","运算符","改成","ge","不","消除","发现","但是","y","hash","说","内容","有时","utf","*","安全","repr","定义","开始","getattribute","类来","或者","iter","逗号","有","doc","print","]","永远","rmul","歧义","因为","创建","0","方法","那","即","一旦","的确","地","__","比如","8","没有","_","init","tuple","这样","第一次","对应","尽量","list","，"," ","之间","本身","中","c","一","出现","“","10","coding","统计","2019.08","一个","空","”","代替","\"","隔开","又","。","不可避免","format","siwing","算符","一种","也","为什么","则","4","`","后","原始","括号","运算","得","类型","一次","每个","指向","表示","对象","按","class","小括号","=","123","#","python","'","x","只是","错误","时","次数","写","里","(","元素","gt","避免","mul","某个","type","修改",".","dir",",","！","是","不能","变","[","值","解析","setattr","subclass","在","-","并","定长","能用","代码","了","意义","所谓","通过","index","？","ex","、","一维","sizeof","不变","但","a","3","必须","其实","顶","getitem","就","改变","len","reduce","getnewargs","用","可以","索引","更","传入","只有","个","add","’","我们","这","呢","需要","str","—","可能","其他","得到","很少","所以","d","它","规定","进行","过","要","虽然","前面","别的","le","eq","如果",")","为了","ne","每","注意","lt","这个",":","会","new","第一","1","列表","："],"title":"2.5.Tuple","title_tokens":[".","2.5","tuple"]},{"location":"Python基础/2.5.Tuple.html#tuple","text":"tuple是一种一维的，定长的、不可变的Python对象序列，元素写在小括号 () 里，元素之间用逗号隔开，元组中的元素类型可以不相同。 不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。","text_tokens":["、","一维","序列","tuple","但","相同","什么","对象","可变","尽量","的","list","就","包含","小括号","，"," ","改变","之间","python","元组","用","可以","不可","中","不","更","写","里","列表","(","元素","安全","是","可能","变","代替","逗号","有","。","所以","它","虽然","一种","如果","在",")","因为","定长","能用","代码","意义","括号","类型","隔开","？","比如"],"title":"Tuple","title_tokens":["tuple"]},{"location":"Python基础/2.5.Tuple.html#tupletuple","text":"定义个一个Tuple，需要传入一个iterable对象。 tuple ( \"123\" ) ('1', '2', '3') 如果需要定义一个空的Tuple，则可以这样定义： # 通过tuple类来定义 a = tuple () type ( a ) # 或者用 () 定义 a = () type ( a ) # 是的，的确通过()可以定义一个空tuple tuple 但是如果要顶一个只有一个元素的tuple，就得要注意了。 # 如果我们这样定义，则是错误的 b = ( \"123\" ) type ( b ) str # 定义只有一个元素的tuple，需要这样定义 b = ( \"123\" ,) type ( b ) tuple # 或者这样定义 b = tuple ([ \"123\" ]) type ( b ) tuple 为什么会这样呢？因为 () 在python中即表示运算符的 () ，也可以表示Tuple。这就不可避免地产生了歧义，为了消除歧义，Python规定括号里面只有一个元素时， #’ 按运算符的`()`进行解析。","text_tokens":["什么","的","里面","iterable","中即","产生","b","2","运算符","不可","消除","但是","定义","类来","或者","]","歧义","因为","的确","tuple","这样","，"," ","一个","空","\"","。","不可避免","算符","也","为什么","则","`","括号","运算","得","表示","对象","按","=","123","'","#","python","错误","时","(","元素","避免","type",",","是","[","解析","在","了","通过","？","a","3","顶","就","可以","用","传入","只有","个","’","我们","这","呢","：","需要","str","规定","进行","要","如果",")","为了","注意","会","1","地"],"title":"Tuple的陷阱——一个元素的Tuple","title_tokens":["陷阱","tuple","一个","的","元素","—"]},{"location":"Python基础/2.5.Tuple.html#tupletuple_1","text":"前面说过，Tuple是一种不可变的对象。但是有时我们又会发现Tuple是“可变的”。 c = ( 'a' , 'b' , [ 'A' , 'B' ]) print ( \"原始定义的Tuple：\" , c ) c [ 2 ][ 0 ] = 'X' c [ 2 ][ 1 ] = 'Y' print ( \"修改后的Tuple：\" , c ) 原始定义的Tuple： ('a', 'b', ['A', 'B']) 修改后的Tuple： ('a', 'b', ['X', 'Y']) 前面说过tuple一旦定义后就不可变，那上面的c怎么就改变了呢？其实，c的元素并没有改变，改变的只是list中的元素，tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素的指向永远不变。即指向 a ，就不能改成指向 b ，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 所以要创建一个内容也不变的tuple，那就必须保证tuple的每一个元素本身也不能变。","text_tokens":["怎么","可变","的","保证","上面","b","2","不可","改成","发现","但是","y","说","内容","有时","定义","开始","print","]","永远","创建","0","即","那","一旦","没有","tuple","list","，"," ","本身","中","c","一","“","一个","”","\"","又","。","一种","也","后","原始","每个","指向","对象","=","'","x","只是","(","元素","修改",",","！","是","不能","变","[","并","了","所谓","？","不变","但","a","必须","其实","就","改变","我们","呢","其他","所以","过","别的","前面","要",")","每","这个","会","1","："],"title":"Tuple的陷阱——“可变的”Tuple","title_tokens":["陷阱","tuple","”","可变","的","“","—"]},{"location":"Python基础/2.5.Tuple.html#tuple_1","text":"因为Tuple是一个不可变的列表，所以Tuple对象的方法很少。 d = ( 0 , 1 , 2 , 3 , 4 , 4 ) dir ( d ) ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index']","text_tokens":["_","sizeof","init","tuple","对象","subclasshook","3","的","class","delattr","getitem","count","=","，"," ","contains","len","'","reduce","getnewargs","2","不可","ge","hash","add","(","gt","mul","str","dir","repr","getattribute",",","是","一个","变","很少","[","__","所以","d","。","doc","format","iter","setattr","]","le","subclass","eq","rmul",")","因为","ne","4","方法","0","lt","new","1","index","列表","ex"],"title":"Tuple的方法","title_tokens":["的","方法","tuple"]},{"location":"Python基础/2.5.Tuple.html#_1","text":"d . count ( 4 ) 2","text_tokens":[".","2",")","4","d","count","("," "],"title":"统计元素出现的次数","title_tokens":["统计","次数","的","出现","元素"]},{"location":"Python基础/2.5.Tuple.html#_2","text":"d . index ( 4 ) 4","text_tokens":[".",")","4","d","index","("," "],"title":"得到某个值第一次出现时对应的索引值","title_tokens":["索引","时","得到","第一次","第一","值","对应","的","出现","某个","一次"]},{"location":"Python基础/2.6.Dict.html","text":"# -*- coding: utf-8 -*- Dict siwing 2019.08.10 Dict 虽然字典和列表有多个相同之处，但也有一些重要的不同之处。 自动添加。 dict可以给不存在的项赋值，即是字典中原本没有的键，也可以给它赋值。而如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值。 成员资格。 表达式k in d (其中d是一个字典）査找的是键而不是值；而表达式v in 1 (其中1是一个列表）查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自然。毕竟如果字典包含指定的键，检查相应的值就很容易。 Dict的方法 clear 删除所有的字典项 要注意的是，clear是清除了一个字典对象，而不是解除了名称与字典对象的绑定。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a a . clear () # 可以看到，a、b都变成了字典 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {} b的值: {} copy 浅拷贝 a = { \"a\" : 1 , \"b\" : 2 , \"c\" :[ 1 , 2 ]} b = a . copy () b [ \"c\" ][ 0 ] = 10 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {'a': 1, 'b': 2, 'c': [10, 2]} b的值: {'a': 1, 'b': 2, 'c': [10, 2]} fromkeys 方法 fromkeys 创建一个新字典，其中包含指定的键，且每个键对应的值都是None，也可以指定值， dict . fromkeys ( key , value ) dict . fromkeys ([ \"a\" , \"b\" ]) {'a': None, 'b': None} dict . fromkeys ([ \"a\" , \"b\" ], 10 ) {'a': 10, 'b': 10} get 方法 get 为访问字典项提供了宽松的环境。通常，如果你试图访问字典中没有的项，将引发错误。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a [ \"d\" ] ---------------------------------------------------------------------------KeyError Traceback (most recent call last)<ipython-input-1-b0ca58477f0c> in <module> 1 a = {\"a\":1,\"b\": 2,\"c\":3} ----> 2 a[\"d\"] KeyError: 'd' 而使用 get 不会这样 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . get ( \"d\" ) # 默认返回None，也可以指定返回值 a . get ( \"d\" , \"N/A\" ) 'N/A' items 方法 items 返回一个包含所有字典项的列表，其中每个元素都为 (key, value) 的形式。字典项在列表中的排列顺序不确定。返回值属于一种名为字典视图的特殊类型。字典视图可用于迭代。另外，你还可确定其长度以及对其执行成员资格检查。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . items () dict_items([('a', 1), ('b', 2), ('c', 3)]) # dict_items类型 type ( a . items ()) dict_items # 迭代 for i in a . items (): print ( i ) # 迭代 for i , j in a . items (): print ( i , end = \" \" ) print ( j ) # 检查成员资格 ( \"a\" , 1 ) in a . items () ('a', 1) ('b', 2) ('c', 3) a 1 b 2 c 3 True keys 和 values 方法 keys 返回一个字典视图，其中包含字典中的键。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . keys () dict_keys(['a', 'b', 'c']) 方法 values 返回一个字典视图，其中包含字典中的键。 a . values () dict_values([1, 2, 3]) pop 方法pop可用于获取与指定键相关联的值，并将该键-值对从字典中删除。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a . pop ( \"a\" ) print ( \"b的值\" , b ) print ( \"a的值\" , a ) b的值 1 a的值 {'b': 2, 'c': 3} popitem 方法 popitem 类似于 list.pop ，但 list.pop 弹出列表中的最后一个元素，而 popitem 随机地弹出一个字典项，因为字典项的顺序是不确定的，没有“最后一个元素”的概念。如果你要以高效地方式 逐个 删除并处理所有字典项，这可能很有用，因为这样无需先获取键列表。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . popitem () ('c', 3) a {'a': 1, 'b': 2} setdefault 方法 setdefault 有点像get，因为它也获取与指定键相关联的值，但除此之外，setdefault还在字典不包含指定的键时，在字典中添加指定的键-值对。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . setdefault ( \"a\" ) a a . setdefault ( \"d\" ) a {'a': 1, 'b': 2, 'c': 3, 'd': None} 如你所见，指定的键不存在时，setdefault返回指定的值并相应地更新字典。如果指定的键存在，就返回其值，并保持字典不变。与 get 一样，值是可选的，如果没有指定，默认为None。 update 方法update使用一个字典中的项来更新另一个字典。对于通过参数提供的字典，将其项添加到当前字典中。如果当前字典包含键相同的项，就替换它。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . update ({ \"d\" : 4 }) a {'a': 1, 'b': 2, 'c': 3, 'd': 4} 可像调用本章前面讨论的函数dict（类型构造函数）那样调用方法update。这意味着调用update时，可向它提供一个映射、一个由键-值对组成的序列（或其他可迭代对象）或关键字参数。 a . update ( zip ([ \"e\" , \"f\" ],[ 5 , 6 ])) a {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}","text_tokens":["序列","或","通常","相同","traceback","keys","构造函数","自然","的","随机","关键字","查找","包含","value","i","引发","（","表达式","b","和","很","2","recent","之处","不","无需","返回值","update","f","项","call","觉得","keyerror","达式","utf","最后","*","n","除此之外","査","module","保持","意味着","讨论","有","for","print","表达","]","不是","参数","宽松","你","浅","创建","因为","构造","方法","0","还","有用","相关联","）","即","毕竟","地","一致","8","没有","copy","_","而","概念","对于","给","新","可像","这样","不会","dict","对应","排列","/","list","关联","检查"," ","，","使用","zip","中","迭代","}","调用","c","确定","组成","看到","用于","出","{","fromkeys","一样","“","有点像","10","coding","都","相关","2019.08","另外","一个","pop","”","5","其中","\"","以","j","。","绑定","可选","siwing","input","所有","默认","一种","也","相同之处","名为","多个","将","形式","4","后","6","地弹","指定","容易","拷贝","ipython","类型","习惯","一些","每个","由键","其","弹","其项","对象","b0ca58477f0c","=","成员","资格","相当","#","append","'","关键",">","错误","访问","时","且","那样","相应","解除","所见","none","提供","(","元素","有点","type",".","自动",",","类似","到","是","方式","特殊","不能","不同之处","[","值","高效","e","其值","从","返回","视图","字典","函数","赋值","在","清除","不太","-","属于","并","<","了","原本","长度","values","如","通过","k","意味","、","不变","但","逐个","most","a","3","为","于","名称","当前","就","可","true","不同","以及","该键","可向","可以","in","索引","处理","get","获取","与","映射","这","setdefault","试图","items","先","其他","环境","可能","添加","更新","本章","d","删除","它","另","last","；","虽然","重要","要","项来","前面","除此","对","看似","key","v","如果",")","变成","顺序","执行","之外","找","替换","注意","end",":","会","键","popitem","1","clear","列表","存在"],"title":"2.6.Dict","title_tokens":[".","dict","2.6"]},{"location":"Python基础/2.6.Dict.html#dict","text":"虽然字典和列表有多个相同之处，但也有一些重要的不同之处。 自动添加。 dict可以给不存在的项赋值，即是字典中原本没有的键，也可以给它赋值。而如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值。 成员资格。 表达式k in d (其中d是一个字典）査找的是键而不是值；而表达式v in 1 (其中1是一个列表）查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自然。毕竟如果字典包含指定的键，检查相应的值就很容易。","text_tokens":["或","相同","自然","的","查找","包含","表达式","和","很","之处","不","项","觉得","达式","査","有","表达","不是","你","方法","）","即","毕竟","一致","没有","而","给","dict","检查","，"," ","使用","中","一个","其中","。","也","相同之处","多个","后","指定","容易","习惯","一些","成员","资格","相当","append","相应","(","元素","自动","类似","是","不能","不同之处","值","字典","赋值","不太","原本","k","但","就","不同","可以","in","索引","这","其他","添加","d","它","；","重要","虽然","看似","v","如果","找","会","键","1","列表","存在"],"title":"Dict","title_tokens":["dict"]},{"location":"Python基础/2.6.Dict.html#dict_1","text":"","text_tokens":[],"title":"Dict的方法","title_tokens":["的","方法","dict"]},{"location":"Python基础/2.6.Dict.html#clear","text":"要注意的是，clear是清除了一个字典对象，而不是解除了名称与字典对象的绑定。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a a . clear () # 可以看到，a、b都变成了字典 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {} b的值: {}","text_tokens":["、","而","对象","a","3","的","名称","，"," ","=","#","b","2","可以","}","解除","c","看到","{","与","(",".",",","都","是","一个","\"","值","。","绑定","print","要","字典","不是",")","变成","清除","注意","了",":","1","clear"],"title":"clear删除所有的字典项","title_tokens":["字典","项","的","删除","所有","clear"]},{"location":"Python基础/2.6.Dict.html#copy","text":"a = { \"a\" : 1 , \"b\" : 2 , \"c\" :[ 1 , 2 ]} b = a . copy () b [ \"c\" ][ 0 ] = 10 print ( \"a的值:\" , a ) print ( \"b的值:\" , a ) a的值: {'a': 1, 'b': 2, 'c': [10, 2]} b的值: {'a': 1, 'b': 2, 'c': [10, 2]}","text_tokens":["copy","a","的","="," ","'","b","2","}","c","{","(",".","10",",","\"","[","值","print","]",")","0",":","1"],"title":"copy浅拷贝","title_tokens":["copy","拷贝","浅"]},{"location":"Python基础/2.6.Dict.html#fromkeys","text":"方法 fromkeys 创建一个新字典，其中包含指定的键，且每个键对应的值都是None，也可以指定值， dict . fromkeys ( key , value ) dict . fromkeys ([ \"a\" , \"b\" ]) {'a': None, 'b': None} dict . fromkeys ([ \"a\" , \"b\" ], 10 ) {'a': 10, 'b': 10}","text_tokens":["每个","新","dict","对应","a","的","value","包含","，"," ","'","可以","b","且","}","none","fromkeys","{","(",".","10",",","都","是","一个","其中","\"","[","值","]","也","字典","key",")","创建","方法",":","键","指定"],"title":"fromkeys","title_tokens":["fromkeys"]},{"location":"Python基础/2.6.Dict.html#get","text":"方法 get 为访问字典项提供了宽松的环境。通常，如果你试图访问字典中没有的项，将引发错误。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a [ \"d\" ] ---------------------------------------------------------------------------KeyError Traceback (most recent call last)<ipython-input-1-b0ca58477f0c> in <module> 1 a = {\"a\":1,\"b\": 2,\"c\":3} ----> 2 a[\"d\"] KeyError: 'd' 而使用 get 不会这样 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . get ( \"d\" ) # 默认返回None，也可以指定返回值 a . get ( \"d\" , \"N/A\" ) 'N/A'","text_tokens":["没有","而","通常","这样","most","不会","traceback","a","为","的","3","b0ca58477f0c","可以","/","，"," ","引发","=","'","#","b","2",">","错误","访问","中","recent","get","}","c","in","项","call","none","返回值","提供","{","keyerror","(","试图","n",".",",","module","使用","环境","\"","[","d","。","last","]","input","返回","默认","也","字典","如果","宽松","你",")","将","-","方法","<","了",":","指定","1","ipython"],"title":"get","title_tokens":["get"]},{"location":"Python基础/2.6.Dict.html#items","text":"方法 items 返回一个包含所有字典项的列表，其中每个元素都为 (key, value) 的形式。字典项在列表中的排列顺序不确定。返回值属于一种名为字典视图的特殊类型。字典视图可用于迭代。另外，你还可确定其长度以及对其执行成员资格检查。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . items () dict_items([('a', 1), ('b', 2), ('c', 3)]) # dict_items类型 type ( a . items ()) dict_items # 迭代 for i in a . items (): print ( i ) # 迭代 for i , j in a . items (): print ( i , end = \" \" ) print ( j ) # 检查成员资格 ( \"a\" , 1 ) in a . items () ('a', 1) ('b', 2) ('c', 3) a 1 b 2 c 3 True","text_tokens":["的","value","包含","i","b","2","不","返回值","项","for","print","]","你","方法","还","_","dict","排列","检查","，"," ","中","迭代","}","c","确定","用于","列表","{","都","另外","一个","其中","\"","j","。","所有","一种","名为","形式","类型","每个","其","=","成员","资格","'","#","(","元素","type",".",",","特殊","[","返回","视图","字典","在","属于","长度","a","为","3","可","true","以及","in","items","key","顺序",")","执行","end",":","1","对"],"title":"items","title_tokens":["items"]},{"location":"Python基础/2.6.Dict.html#keysvalues","text":"方法 keys 返回一个字典视图，其中包含字典中的键。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . keys () dict_keys(['a', 'b', 'c']) 方法 values 返回一个字典视图，其中包含字典中的键。 a . values () dict_values([1, 2, 3])","text_tokens":["_","dict","keys","a","3","的","包含","=","，"," ","'","b","2","中","}","c","{","(",".",",","一个","其中","\"","[","。","]","返回","视图","字典",")","方法",":","values","键","1"],"title":"keys和values","title_tokens":["values","和","keys"]},{"location":"Python基础/2.6.Dict.html#pop","text":"方法pop可用于获取与指定键相关联的值，并将该键-值对从字典中删除。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } b = a . pop ( \"a\" ) print ( \"b的值\" , b ) print ( \"a的值\" , a ) b的值 1 a的值 {'b': 2, 'c': 3}","text_tokens":["a","3","的","关联","可","，"," ","=","该键","'","b","2","中","}","c","获取","用于","{","与","(",".",",","相关","pop","\"","值","删除","。","print","从","字典",")","将","并","-","方法","相关联",":","键","指定","1","对"],"title":"pop","title_tokens":["pop"]},{"location":"Python基础/2.6.Dict.html#popitem","text":"方法 popitem 类似于 list.pop ，但 list.pop 弹出列表中的最后一个元素，而 popitem 随机地弹出一个字典项，因为字典项的顺序是不确定的，没有“最后一个元素”的概念。如果你要以高效地方式 逐个 删除并处理所有字典项，这可能很有用，因为这样无需先获取键列表。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . popitem () ('c', 3) a {'a': 1, 'b': 2}","text_tokens":["没有","而","概念","弹","但","逐个","这样","a","于","list","的","随机","3","，"," ","=","'","无需","很","b","2","中","不","处理","}","c","确定","项","获取","出","{","这","元素","(","最后","“",".",",","类似","是","pop","一个","”","方式","可能","先","\"","高效","以","。","删除","要","所有","字典","顺序","如果",")","你","因为","并","方法","有用","popitem","地弹","键",":","1","列表","地"],"title":"popitem","title_tokens":["popitem"]},{"location":"Python基础/2.6.Dict.html#setdefault","text":"方法 setdefault 有点像get，因为它也获取与指定键相关联的值，但除此之外，setdefault还在字典不包含指定的键时，在字典中添加指定的键-值对。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . setdefault ( \"a\" ) a a . setdefault ( \"d\" ) a {'a': 1, 'b': 2, 'c': 3, 'd': None} 如你所见，指定的键不存在时，setdefault返回指定的值并相应地更新字典。如果指定的键存在，就返回其值，并保持字典不变。与 get 一样，值是可选的，如果没有指定，默认为None。","text_tokens":["没有","不变","但","a","3","的","为","关联","包含","就","，"," ","=","'","b","2","时","中","不","get","}","c","获取","所见","none","相应","{","与","一样","(","有点","setdefault","除此之外","有点像",".",",","相关","是","保持","更新","添加","\"","值","d","。","它","其值","可选","返回","默认","除此","也","字典","之外","如果","在",")","你","因为","-","并","方法","还","相关联",":","键","如","指定","1","地","对","存在"],"title":"setdefault","title_tokens":["setdefault"]},{"location":"Python基础/2.6.Dict.html#update","text":"方法update使用一个字典中的项来更新另一个字典。对于通过参数提供的字典，将其项添加到当前字典中。如果当前字典包含键相同的项，就替换它。 a = { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } a . update ({ \"d\" : 4 }) a {'a': 1, 'b': 2, 'c': 3, 'd': 4} 可像调用本章前面讨论的函数dict（类型构造函数）那样调用方法update。这意味着调用update时，可向它提供一个映射、一个由键-值对组成的序列（或其他可迭代对象）或关键字参数。 a . update ( zip ([ \"e\" , \"f\" ],[ 5 , 6 ])) a {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}","text_tokens":["序列","或","相同","关键字","构造函数","的","包含","（","b","2","f","update","项","意味着","讨论","]","参数","构造","方法","）","对于","可像","dict","，"," ","使用","zip","中","调用","}","迭代","c","组成","{","一个","5","\"","。","将","4","6","类型","由键","其项","对象","=","'","关键","那样","时","提供","(",".",",","到","[","值","e","字典","函数","-","通过","意味","、","a","3","当前","就","可","可向","映射","这","其他","更新","添加","本章","d","另","它","前面","项来","如果",")","替换",":","键","1","对"],"title":"update","title_tokens":["update"]},{"location":"Python基础/3.1.异常.html","text":"# -*- coding: utf-8 -*- 异常 siwing 2019.08.18 异常 异常处理机制 异常处理无外乎几件事: 断言(assert)和抛错(raise), 检查(try), 捕获(except), 处理(except,else,finally)。 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。当Python脚本发生异常时，异常会从发生异常的位置向程序上层传播。例如异常从函数向外传播到调用函数的地方，如果在这里没有被捕获，则继续向上传播，如果一直都没有被捕获，则传播到程序的最顶层，即主程序（全局作用域）。如果在主程序中也没有处理异常的程序，python将调用默认的异常处理程序，自动匹配异常的类型，然后中止程序并显示栈跟踪信息。 # 在cause_error函数中抛出异常 def cause_error (): raise Exception ( \"Somrthing is wrong\" ) # 在call_cause_error函数中调用cause_error函数 def call_cause_error (): cause_error () def deal_error (): try : cause_error () except : print ( \"Exception handled\" ) call_cause_error () ---------------------------------------------------------------------------Exception Traceback (most recent call last)<ipython-input-1-eb81f11bf5d9> in <module> ----> 1 call_cause_error() <ipython-input-1-ec5e029839e0> in call_cause_error() 1 def call_cause_error(): ----> 2 cause_error() 3 <ipython-input-1-11326a099618> in cause_error() 1 def cause_error(): ----> 2 raise Exception(\"Somrthing is wrong\") 3 Exception: Somrthing is wrong deal_error () Exception handled 如你所见，cause_error中引发的异常依次从cause_error和call_cause_error向外传播，最终导致显示一条栈跟踪信息。调用deal_error时，异常在传播到deal_error时被捕获，并被这里的try/except语句处理。 异常是Python对象，表示一个错误。异常可以作为类被定义, 也可以人为引发异常。 异常处理语句 try : < statement > #' try语句中代码首先被运行 except ： < statement > #' 捕获任何在try中引发的异常 except < name > ： < statement > #' 捕获在try中引发的<name>异常 except < name > ， < data > : < statement > #' 如果引发了'name'异常，获得附加的数据 except ( < name1 > , < name2 >... ): < statement > #' 捕获列出的多个异常 else : < statement > #' 如果没有异常发生 finally : < statement > #' 退出try时总会执行 raise #' 人为引发错误 assert < judgement > #' 断言,判断一定要返回True否则会引发AssertionError raise语句 使用raise...from...语句来提供自己的异常上下文，也可以使用None来禁止上下文。 # 默认输出异常上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 1 try: ----> 2 1/0 3 except ZeroDivisionError: ZeroDivisionError: division by zero During handling of the above exception, another exception occurred: ValueError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError 5 ValueError: # 自定义上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from ZeroDivisionError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)ZeroDivisionError: The above exception was the direct cause of the following exception: ValueError Traceback (most recent call last)<ipython-input-1-00ed5b67ecd8> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from ZeroDivisionError 5 ValueError: # 禁止上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from None ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-d9388897f61c> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from None ValueError: 内置异常 | 异常名称 | 描述 || ------------------------- | -------------------------------------------------- || BaseException | 所有异常的基类 || SystemExit | 解释器请求退出 || KeyboardInterrupt | 用户中断执行(通常是输入^C) || Exception | 常规错误的基类 || StopIteration | 迭代器没有更多的值 || GeneratorExit | 生成器(generator)发生异常来通知退出 || StandardError | 所有的内建标准异常的基类 || ArithmeticError | 所有数值计算错误的基类 || FloatingPointError | 浮点计算错误 || OverflowError | 数值运算超出最大限制 || ZeroDivisionError | 除(或取模)零 (所有数据类型) || AssertionError | 断言语句失败 || AttributeError | 对象没有这个属性 || EOFError | 没有内建输入,到达EOF 标记 || EnvironmentError | 操作系统错误的基类 || IOError | 输入/输出操作失败 || OSError | 操作系统错误 || WindowsError | 系统调用失败 || ImportError | 导入模块/对象失败 || LookupError | 无效数据查询的基类 || IndexError | 序列中没有此索引(index) || KeyError | 映射中没有这个键 || MemoryError | 内存溢出错误(对于Python 解释器不是致命的) || NameError | 未声明/初始化对象 (没有属性) || UnboundLocalError | 访问未初始化的本地变量 || ReferenceError | 弱引用(Weak reference)试图访问已经垃圾回收了的对象 || RuntimeError | 一般的运行时错误 || NotImplementedError | 尚未实现的方法 || SyntaxError | Python 语法错误 || IndentationError | 缩进错误 || TabError | Tab 和空格混用 || SystemError | 一般的解释器系统错误 || TypeError | 对类型无效的操作 || ValueError | 传入无效的参数 || UnicodeError | Unicode 相关的错误 || UnicodeDecodeError | Unicode 解码时的错误 || UnicodeEncodeError | Unicode 编码时错误 || UnicodeTranslateError | Unicode 转换时错误 || Warning | 警告的基类 || DeprecationWarning | 关于被弃用的特征的警告 || FutureWarning | 关于构造将来语义会有改变的警告 || OverflowWarning | 旧的关于自动提升为长整型(long)的警告 || PendingDeprecationWarning | 关于特性将会被废弃的警告 || RuntimeWarning | 可疑的运行时行为(runtime behavior)的警告 || SyntaxWarning | 可疑的语法的警告 || UserWarning | 用户代码生成的警告 | 参考 Python异常处理 python在异常捕获里抛出异常 异常处理","text_tokens":["程序执行","during","旧","特征","垃圾","11326a099618","代码生成","下文","warning","2","调用函数","futurewarning","*","the","定义","浮点","print","构造","传播","即","8","/","上下文","unicodeencodeerror","检查","，","运行","警告","tab","zerodivisionerror","迭代","否则","direct","coding","默认","一般","多个","无效","中断","最大","statement","zero","自定","is","runtimewarning","raise","'",">","时","里","judgement","自动","可疑","引用","语句","查询","systemexit","了","首先","溢出","致命","index","unicodeerror","作用域","following","3","用","生成器","更","这里","要","数值","任何","error","无法","主程序","内建","会","键","1","位置","类","上下","recent","除","name2","keyerror","utf","attributeerror","module","来","finally","有","回收","taberror","缩进","异常","导入","pendingdeprecationwarning","数据","）","系统","def","environmenterror","unicodetranslateerror"," ","算错","使用","中","18","行为","of","eb81f11bf5d9","中止","...","正常","systemerror","也","exception","无外乎","常规","ipython","类型","above","顶层","语法","跟踪","python","匹配","整型","unicode","内置","none","was","(","成器","人为","取模","overflowerror","long","计算","函数","上层","在","并","<","occurred","解释器","|","此","最","division","00ed5b67ecd8","释器","事件","声明","most","处理程序","true","改变","计算错误","可以","处理","已经","列出","程序","eoferror","总会","机制","该","捕获","内","runtime","信息","超出","通知","或","栈","地方","traceback","nameerror","引发","（","将会","和","memoryerror","内存","typeerror","转换","assert","keyboardinterrupt","unicodedecodeerror","generator","限制","56b5a2b441f0","你","0","全局","_","发生","关于","例如","几件事","下","deal","向上","为长","调用","generatorexit","standarderror","assertionerror","属性","相关","一个","\"","编码","。","input","notimplementederror","wrong","基类","运算","未","断言","arithmeticerror","继续","访问","name1","提供","runtimeerror","到达","弱","生成","值","else","从","返回","ec5e029839e0","somrthing","-","作用","ioerror","referenceerror","获得","影响","by","如","except","一定","废弃","名称","描述","就","判断","windowserror","传入","依次","映射","试图","语义","当","过程","last","初始化","d9388897f61c",")","执行","another","cause","这个","valueerror","对","序列","通常","标记","禁止","的","几件","stopiteration","实现","抛错","call","语法错误","特性","零","初始","附加","unboundlocalerror","尚未","不是","模块","参数","方法","lookuperror","没有","behavior","对于","handling","一直","deprecationwarning","c","userwarning","try","importerror","提升","都","2019.08","向外","5","建","name","siwing","失败","所有","导致","则","参考","将","4","多","data","最终","未声明","请求","输出","作为","表示","输入","解释","weak","对象","混用","#","解码","错误","overflowwarning","所见","操作","抛出","情况",".","向",",","到","是","本地","syntaxwarning","被","数据类型","自定义","操作系统","代码","一条","用户","退出","显示","将来","然后","脚本","floatingpointerror","indexerror","baseexception","handled","自己","器","eof","oserror","reference","in","索引","被弃","变量","空格","from","indentationerror","如果","syntaxerror","^",":","标准","："],"title":"3.1.异常","title_tokens":[".","3.1","异常"]},{"location":"Python基础/3.1.异常.html#_1","text":"","text_tokens":[],"title":"异常","title_tokens":["异常"]},{"location":"Python基础/3.1.异常.html#_2","text":"异常处理无外乎几件事: 断言(assert)和抛错(raise), 检查(try), 捕获(except), 处理(except,else,finally)。 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。当Python脚本发生异常时，异常会从发生异常的位置向程序上层传播。例如异常从函数向外传播到调用函数的地方，如果在这里没有被捕获，则继续向上传播，如果一直都没有被捕获，则传播到程序的最顶层，即主程序（全局作用域）。如果在主程序中也没有处理异常的程序，python将调用默认的异常处理程序，自动匹配异常的类型，然后中止程序并显示栈跟踪信息。 # 在cause_error函数中抛出异常 def cause_error (): raise Exception ( \"Somrthing is wrong\" ) # 在call_cause_error函数中调用cause_error函数 def call_cause_error (): cause_error () def deal_error (): try : cause_error () except : print ( \"Exception handled\" ) call_cause_error () ---------------------------------------------------------------------------Exception Traceback (most recent call last)<ipython-input-1-eb81f11bf5d9> in <module> ----> 1 call_cause_error() <ipython-input-1-ec5e029839e0> in call_cause_error() 1 def call_cause_error(): ----> 2 cause_error() 3 <ipython-input-1-11326a099618> in cause_error() 1 def cause_error(): ----> 2 raise Exception(\"Somrthing is wrong\") 3 Exception: Somrthing is wrong deal_error () Exception handled 如你所见，cause_error中引发的异常依次从cause_error和call_cause_error向外传播，最终导致显示一条栈跟踪信息。调用deal_error时，异常在传播到deal_error时被捕获，并被这里的try/except语句处理。 异常是Python对象，表示一个错误。异常可以作为类被定义, 也可以人为引发异常。","text_tokens":["程序执行","栈","位置","地方","traceback","类","的","几件","引发","抛错","（","11326a099618","和","2","recent","调用函数","call","assert","定义","module","finally","print","异常","你","传播","即","）","全局","没有","_","发生","def","例如","几件事","下","deal","/","检查","一直"," ","，","向上","中","调用","try","eb81f11bf5d9","都","中止","一个","向外","\"","正常","。","input","wrong","默认","导致","一般","也","则","exception","将","无外乎","最终","ipython","类型","作为","表示","顶层","对象","断言","跟踪","is","继续","raise","#","python","匹配",">","错误","时","所见","抛出","(","情况","向","自动",",","到","是","人为","语句","else","从","被","ec5e029839e0","函数","上层","在","somrthing","作用","并","-","<","影响","了","一条","如","except","显示","最","然后","脚本","作用域","事件","most","处理程序","handled","3","就","可以","in","处理","依次","这里","程序","当","过程","该","捕获","last","error","无法","如果",")","执行","主程序","cause","信息",":","会","1"],"title":"异常处理机制","title_tokens":["机制","处理","异常"]},{"location":"Python基础/3.1.异常.html#_3","text":"try : < statement > #' try语句中代码首先被运行 except ： < statement > #' 捕获任何在try中引发的异常 except < name > ： < statement > #' 捕获在try中引发的<name>异常 except < name > ， < data > : < statement > #' 如果引发了'name'异常，获得附加的数据 except ( < name1 > , < name2 >... ): < statement > #' 捕获列出的多个异常 else : < statement > #' 如果没有异常发生 finally : < statement > #' 退出try时总会执行 raise #' 人为引发错误 assert < judgement > #' 断言,判断一定要返回True否则会引发AssertionError","text_tokens":["没有","一定","发生","statement","断言","的","true","判断"," ","，","引发","'","#","raise","运行",">","错误","中","时","name2","name1","try","否则","judgement","(","assertionerror","列出","assert","总会",",","...","人为","附加","finally","语句","捕获","else","name","要","返回","被","任何","异常","在","如果",")","多个","执行","数据","<","代码","了","获得",":","首先","data","会","except","退出","："],"title":"异常处理语句","title_tokens":["处理","语句","异常"]},{"location":"Python基础/3.1.异常.html#raise","text":"使用raise...from...语句来提供自己的异常上下文，也可以使用None来禁止上下文。 # 默认输出异常上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 1 try: ----> 2 1/0 3 except ZeroDivisionError: ZeroDivisionError: division by zero During handling of the above exception, another exception occurred: ValueError Traceback (most recent call last)<ipython-input-1-56b5a2b441f0> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError 5 ValueError: # 自定义上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from ZeroDivisionError ---------------------------------------------------------------------------ZeroDivisionError Traceback (most recent call last)ZeroDivisionError: The above exception was the direct cause of the following exception: ValueError Traceback (most recent call last)<ipython-input-1-00ed5b67ecd8> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from ZeroDivisionError 5 ValueError: # 禁止上下文 try : 1 / 0 except ZeroDivisionError : raise ValueError from None ---------------------------------------------------------------------------ValueError Traceback (most recent call last)<ipython-input-1-d9388897f61c> in <module> 2 1/0 3 except ZeroDivisionError: ----> 4 raise ValueError from None ValueError:","text_tokens":["division","above","during","00ed5b67ecd8","输出","禁止","zero","following","most","自定","traceback","3","自己","的","上下文","/","handling","上下","，"," ","raise","#","下文","使用","可以",">","recent","zerodivisionerror","in","2","none","call","was","提供","try","(","direct","of","the","定义",",","module","...","5","来","from","语句","。","last","input","默认","d9388897f61c","也","56b5a2b441f0","异常",")","exception","-","another","4","0","<","occurred","自定义","cause",":","by","valueerror","except","1","ipython"],"title":"raise语句","title_tokens":["raise","语句"]},{"location":"Python基础/3.1.异常.html#_4","text":"| 异常名称 | 描述 || ------------------------- | -------------------------------------------------- || BaseException | 所有异常的基类 || SystemExit | 解释器请求退出 || KeyboardInterrupt | 用户中断执行(通常是输入^C) || Exception | 常规错误的基类 || StopIteration | 迭代器没有更多的值 || GeneratorExit | 生成器(generator)发生异常来通知退出 || StandardError | 所有的内建标准异常的基类 || ArithmeticError | 所有数值计算错误的基类 || FloatingPointError | 浮点计算错误 || OverflowError | 数值运算超出最大限制 || ZeroDivisionError | 除(或取模)零 (所有数据类型) || AssertionError | 断言语句失败 || AttributeError | 对象没有这个属性 || EOFError | 没有内建输入,到达EOF 标记 || EnvironmentError | 操作系统错误的基类 || IOError | 输入/输出操作失败 || OSError | 操作系统错误 || WindowsError | 系统调用失败 || ImportError | 导入模块/对象失败 || LookupError | 无效数据查询的基类 || IndexError | 序列中没有此索引(index) || KeyError | 映射中没有这个键 || MemoryError | 内存溢出错误(对于Python 解释器不是致命的) || NameError | 未声明/初始化对象 (没有属性) || UnboundLocalError | 访问未初始化的本地变量 || ReferenceError | 弱引用(Weak reference)试图访问已经垃圾回收了的对象 || RuntimeError | 一般的运行时错误 || NotImplementedError | 尚未实现的方法 || SyntaxError | Python 语法错误 || IndentationError | 缩进错误 || TabError | Tab 和空格混用 || SystemError | 一般的解释器系统错误 || TypeError | 对类型无效的操作 || ValueError | 传入无效的参数 || UnicodeError | Unicode 相关的错误 || UnicodeDecodeError | Unicode 解码时的错误 || UnicodeEncodeError | Unicode 编码时错误 || UnicodeTranslateError | Unicode 转换时错误 || Warning | 警告的基类 || DeprecationWarning | 关于被弃用的特征的警告 || FutureWarning | 关于构造将来语义会有改变的警告 || OverflowWarning | 旧的关于自动提升为长整型(long)的警告 || PendingDeprecationWarning | 关于特性将会被废弃的警告 || RuntimeWarning | 可疑的运行时行为(runtime behavior)的警告 || SyntaxWarning | 可疑的语法的警告 || UserWarning | 用户代码生成的警告 |","text_tokens":["序列","或","通常","标记","旧","nameerror","特征","垃圾","的","stopiteration","实现","代码生成","warning","将会","memoryerror","内存","和","typeerror","除","转换","keyerror","futurewarning","语法错误","attributeerror","特性","零","初始","unboundlocalerror","浮点","来","keyboardinterrupt","unicodedecodeerror","generator","限制","回收","尚未","taberror","有","缩进","不是","异常","模块","参数","导入","构造","pendingdeprecationwarning","数据","方法","lookuperror","没有","behavior","系统","发生","environmenterror","对于","关于","unicodetranslateerror","/","unicodeencodeerror"," ","为长","算错","运行","deprecationwarning","警告","tab","zerodivisionerror","中","迭代","generatorexit","调用","c","userwarning","standarderror","assertionerror","行为","属性","importerror","提升","相关","编码","建","失败","所有","notimplementederror","systemerror","基类","一般","exception","多","常规","无效","运算","未声明","中断","类型","请求","输出","最大","输入","解释","weak","对象","断言","未","语法","混用","arithmeticerror","runtimewarning","python","解码","整型","错误","访问","时","unicode","overflowwarning","操作","runtimeerror","(","到达","成器","弱","自动",",","生成","是","可疑","值","引用","取模","语句","本地","overflowerror","long","syntaxwarning","被","计算","数据类型","查询","-","ioerror","referenceerror","操作系统","systemexit","了","代码","解释器","|","用户","此","溢出","致命","退出","index","将来","释器","unicodeerror","floatingpointerror","声明","indexerror","废弃","baseexception","器","名称","描述","eof","改变","计算错误","oserror","windowserror","reference","用","索引","生成器","更","已经","传入","被弃","变量","映射","空格","试图","语义","eoferror","indentationerror","内","初始化","runtime","数值",")","执行","内建","syntaxerror","^","这个","会","键","标准","valueerror","超出","通知","对"],"title":"内置异常","title_tokens":["内置","异常"]},{"location":"Python基础/3.1.异常.html#_5","text":"Python异常处理 python在异常捕获里抛出异常 异常处理","text_tokens":["python","异常","在","处理","里","抛出","捕获"," "],"title":"参考","title_tokens":["参考"]},{"location":"Python基础/3.2.浅拷贝和深拷贝.html","text":"name与value 引用（reference） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。 一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。 因此，引用亦常被称为该资料的指标或位址。 name是value的引用。 在python里面，一个变量保存的值是某个对象的引用。Python赋值语句将左侧的符号名称与右侧的值 相关联 。在Python中，我们说名称引用值，或者名称是对值的引用 下次我们使用这个名称时，便得到与名称相关联的值。 多个name可以引用同一个value。 x = 23 y = x x 和 y 具有相同的状态：每个都以完全相同的方式引用该值。 名称是独立于其他名称重新分配的。 如果两个名称引用相同的值，则不会链接这两个名称。重新分配其中一个不会导致另一个也被重新分配： x = 23 y = x x = 12 值一直存在，直到没有名称引用它 Python会跟踪每个值有多少引用，并自动清除没有引用的值。这被称为“垃圾收集”，意味着你不必清楚值，当它们不再需要时它们会自行消失。 Assignment assignment永远不会复制数据。 当值具有多个名称时，很容易混淆并将其视为两个名称和两个值： x = 23 y = x 但是给名称分配值永远不会复制数据，它永远不会创建新值。分配只是使左侧的名称引用右侧的值。在这种情况下，我们只有一个23，x和y都引用它，就像我们在上图中看到的那样。 分配只是使左侧的名称引用右侧的值。这句话是什么意思呢？ x = 23 y = x 当python执行上面的代码，assignment的过程如下图所示： 我们查看x和y的内存地址，可以看到x和y的内存地址一样，这也说明了该过程并没有创建新值。 print ( \"x的内存地址是：\" + str ( id ( x ))) print ( \"y的内存地址是：\" + str ( id ( y ))) x的内存地址是：140728107374080 y的内存地址是：140728107374080 同样地，如果我们这样赋值，也不会创建新值。 x = 23 y = 23 print ( \"x的内存地址是：\" + str ( id ( x ))) print ( \"y的内存地址是：\" + str ( id ( y ))) x的内存地址是：140728107374080 y的内存地址是：140728107374080 当我们有更复杂的值时，事情变得更有趣，比如列表： x = [ 1 , 2 , 3 ] y = [ 1 , 2 , 3 ] print ( \"x的内存地址是：\" + str ( id ( x ))) print ( \"y的内存地址是：\" + str ( id ( y ))) x的内存地址是：2275072084616 y的内存地址是：2275073247240 虽然我们给x和y都赋值了相同的list，但是可以看到x和y绑定了不同的对象，因为它们的内存地址并不一样。为什么会这样呢？ 原因在于 23 是 int 类型的对象，而 int 类型在python中属于 immutable 的类型；list 则属于 mutable 的类型。当然，mutable、immutable只是python语言的一个规定。 因为 int 是immutable的，所以如果给x重新赋值，无论怎么样都不会影响到y。 x = 23 y = x x = 12 y x = 23 y = 23 x = 12 y 23 但是 mutable 类型的值则不一样，如果x和y存储的是同一个引用，则给其中一个名称赋值时，会影响另一个名称。 x = [ 1 , 2 , 3 ] y = x print ( \"x的内存地址是：\" + str ( id ( x ))) print ( \"y的内存地址是：\" + str ( id ( y ))) # 给x重新赋值 x [ 0 ] = 0 y x的内存地址是：2275068173704 y的内存地址是：2275068173704 [0, 2, 3] 所以，为了避免混乱，当我们直接把一个相同的值赋值给不同的名称时，python会新建对象。 x = [ 1 , 2 , 3 ] y = [ 1 , 2 , 3 ] print ( \"x的内存地址是：\" + str ( id ( x ))) print ( \"y的内存地址是：\" + str ( id ( y ))) # 给x重新赋值 x [ 0 ] = 0 y x的内存地址是：2275073185800 y的内存地址是：2275073246792 [1, 2, 3] 通过上面的示例代码，我们可以知道： 通过一个对象的所有名称可以看到值的变化。 一个对象的所有名字是什么意思？例如下面的代码，x和y都是同一个对象的名字，因为x和y储存的引用是相同的。 x = [ 1 , 2 , 3 ] y = x print ( \"x的内存地址是：\" + str ( id ( x ))) print ( \"y的内存地址是：\" + str ( id ( y ))) x的内存地址是：2275073466632 y的内存地址是：2275073466632 Assignment陷阱——mutable 和immutable 神话：Python以不同的方式分配可变和不可变的值。 因为mutable对象是不可更改的，immutable对象则可以更改，人们可能会觉得mutable对象和immutable对象的值分配方式不一样。但事实上，mutable对象和immutable对象所有的赋值的方式都是一样的。 Assignment陷阱——浅拷贝和深拷贝 神话：值是有范围的。 在python中存在作用域这样的概念，人们可能会觉得作用域指的是值（对象）的作用范围，但事实上， 值是没有范围的，作用域指的是名称的作用范围。 也就是说，在上层作用域，不能使用下层作用域的名称来使用值。 我们可以定义一个简单的函数与验证这点。 def check_name_space_range ( x ): print ( \"x的内存地址是：\" + str ( id ( x ))) # 先在最外层的作用域赋值，并打印地址 a = 10 print ( \"a的内存地址是：\" + str ( id ( a ))) check_name_space_range ( a ) a的内存地址是：140728107373664 x的内存地址是：140728107373664 很明显，在内外层作用域的值都是同一个。 因为值没有范围，这就可能出现一些惊喜。 def variable_change ( x ): x [ 0 ] = 10 return x a = [ 1 , 2 , 3 ] a_other = variable_change ( a ) print ( a ) print ( a_other ) [10, 2, 3] [10, 2, 3] 可以看到，a、a_other都被改变了，实际上a、a_other都是同一个对象。 print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) a的内存地址是：2275072212872 a_other的内存地址是：2275072212872 因此，如果要在函数里面更改参数的值，最好复制一个副本。 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ] = 10 else : pass return x a = [ 1 , 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [1, 2, 3] [10, 2, 3] a的内存地址是：2275073247560 a_other的内存地址是：2275073166216 a的值并没有改变，上面的结果看似是没问题的，但还是会有新的惊喜。 我们来修改一下variable_change_shallow函数 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ][ 0 ] = 10 else : pass return x a = [[ 1 , 2 ], 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [[10, 2], 2, 3] [[10, 2], 2, 3] a的内存地址是：2275073245384 a_other的内存地址是：2275072212872 惊喜就是a的值也改变了。因为 x.copy() 只是浅拷贝。 在python里面有三种方式去引用某个值：1. 引用另一个变量2. 浅拷贝3. 深拷贝 这三种方式是有区别的。 import copy a = [ 1 , 2 ,[ 1 , 2 ]] a_reference = a a_shallow = copy . copy ( a ) a_deep_copy = copy . deepcopy ( a ) 变量a和a_reference都是同一个对象的名称。 浅拷贝得到变量a_shallow，它是一个新对象，但a_shallow的第三个元素a_shallow[2]却是一个已经存在的对象，这和a、a_reference一样。 深拷贝得到变量a_deep_copy，它是一个新对象，并且它的每一个元素也是新的对象。 如果浅拷贝的对象包含了mutable对象，则mutable对象不会拷贝；而深拷贝则会完整拷贝对象。 Assignment陷阱——引用不仅仅是名称 以上所有示例都使用名称作为值的引用，但引用也可以是其他东西。 Python有许多复合数据结构，每个结构都包含对值的引用：列表元素，字典键和值，对象属性等。 其中每一个都可以在赋值符号的左侧使用，以上所有细节都适用于它们。 任何可以出现在赋值语句左侧的内容都是引用 ，在本文中说“名称”的任何地方都可以用“引用”替换。 在上面的示意图中，数字被显示为元素，但实际上，每个元素都是对数字的引用，因此它应该像这样绘制： nums = [ 1 , 2 , 3 ] 但这很快变得复杂，所以上面的绘图用了视觉速记： 如果你有列表元素引用其他可变值，例如子列表，请务必记住列表元素只是对值的引用。 这是一些其他assignment。这些左侧中的每一个都是引用（reference）： my_obj . attr = 23 my_dict [ key ] = 24 my_list [ index ] = 25 my_obj . attr [ key ][ index ] . attr = \"etc, etc\" 注意的是 i = x 指定了名称 i ，但 i[0] = x 并不是指定名称 i ，而是指定了 i 的值的第一个元素。 很多东西都是Assignment 正如上面所说，许多东西都可以作为引用，python里面有很多东西可以作为assignments。 这些行中的每一行都是名称X的赋值： X = ... for X in ... [ ... for X in ... ] ( ... for X in ... ) { ... for X in ... } class X ( ... ): def X ( ... ): def fn ( X ): ... ; fn ( 12 ) with ... as X : except ... as X : import X from ... import X import ... as X from ... import ... as X 注意，我并不是说这些语句像assignments，我的意思是这些语句都是赋值。它们都使名称X引用某个值。上面所说的关于赋值的所有内容都适用于所有这些赋值。 在大多数情况下，这些语句将X定义在与语句相同的作用域内。Python 2和Python 3之间的细节略有不同。但它们都是真正的赋值，而且每个事实都是关于赋值适用于所有这些。 Python通过赋值来传递函数参数。 让我们来看看这些上面assignment列表中最有趣的一个：调用一个函数。当我定义一个函数时，我将其参数命名为： def my_func ( x , y ): return x + y 这里x和y是函数my_func的参数。当我调用my_func时，我提供了实际值作为函数的参数。这些值分配给 参数名称 ，就像使用了赋值语句一样： def my_func ( x , y ): return x + y print ( my_func ( 8 , 9 )) 17 调用my_func时，8被赋值给名称x，9被赋值给名称y。该赋值与我们一直在讨论的简单赋值语句完全相同。名称x和y是函数的本地名称（local），因此当函数返回时，这些名称就会消失。但是，如果它们引用的值仍然被其他名称引用，则值仍然存在。 就像所有其他赋值一样，可变值可以传递给函数，并且通过其所有名称可以看到对值的更改。这在 中已经提到。 名称和值的一些细节 任何名称都可以随时引用任何值。 Python是动态类型的，这意味着名称没有类型。任何名称都可以随时引用任何值。名称可以引用整数，然后引用字符串，然后引用函数，然后引用模块。当然，这可能是一个非常混乱的程序，你不应该这样做，但Python语言不会介意。 名称没有类型，值没有范围。 正如名称没有类型一样，值也没有范围。当我们说一个函数有一个局部变量时，我们的意思是该名称的作用域是函数：你不能在函数外部使用该名称，当函数返回时，名称将被销毁。但是正如我们所看到的，如果名称的值具有其他引用，它将继续在函数调用之外。它是本地名称，而不是本地值。 值不能删除，只有名称可以删除。 Python的内存管理对其行为至关重要，你不仅不必删除值，而且无法删除值。 nums = [ 1 , 2 , 3 ] del nums 这不会删除值nums，它会删除名称nums。该名称将从其范围中删除，然后通常的引用计数开始执行：如果nums的值只有一个引用，则将回收该值。但如果它有其他引用，那么它不会被回收。 神话：Python没有变量。 有些人喜欢说，“Python没有变量，它有名字。”这个口号具有误导性。事实是Python有变量，它们的工作方式与C中的变量不同。 名称是Python的变量：它们引用值，并且这些值可以在程序的过程中发生变化（变化）。仅仅因为另一种语言（尽管是一种重要的语言）表现不同，没有理由将Python描述为没有变量。 参考 Facts and myths about Python names and values","text_tokens":["口号","assignment","一行","适用","本文","说明","相同","指","垃圾","它们","value","数据结构","i","结构","很","2","不可","至关","不","myths","说","理由","觉得","人","略有","消失","定义","外部","或者","讨论","也就是说","print","原因","一般而言","随时","存储","相关联","外层","传递函数","8","copy","还是","给","dict","变得复杂","，","space","视为","range","细节","attr","管理","话","那么","值有","问题","实体","储存","其中","正如","状态","2275073466632","不仅","一般","多个","两个","很多","而言","左侧","每个","一些","facts","略有不同","这点","不仅仅","具有","特定","这是","17","只是","时","shallow","许多","并打印","assignments","某个","销毁","自动","方式","名字","间接","引用","语句","字典","mutable","我","属于","实际上","了","return","值时","记忆体","独立","values","通过","index","同一个","？","中说","作用域","但","动态","3","如下","不同","表现","用","about","更","if","符号","喜欢","与","这","最好","这里","复制","其他","完全相同","却是","保存","规定","；","虽然","要","重要","局部变量","新值","常","任何","无法","24","尽管","下层","会","做","示意","1","with","存在","资料","23","怎么","可变","2275073247240","使","上面","混乱","下面","字符串","而是","y","应该","check","大多","数字","immutable","来","意味着","有","回收","]","创建","复合","数据","范围","）","分配","三个","而","概念","def","新","没","list","语言","仍然","and"," ","使用","中","事实","看到","{","names","地址","行为","“","2275073246792","对值","...","意思","绘制","fn","变得","也","复杂","类型","2275073166216","大多数","所","其","这些","class","跟踪","该值","把","至关重要","python","在内","my","去","(","事实上","修改","etc","12","键和值","位址","函数","上层","在","9","并","最","意味","实际","为","更改","改变","事情","可以","字符","已经","打印","我们","程式","：","str","程序","验证","该","亦","内","重新","让","int","pass","替换","陷阱","介意","或","什么","140728107373664","地方","包含","（","和","内存","内容","深","开始","所说","而且","for","2275072212872","知道","同一","你","0","在于","怎么样","2275073245384","很快",";","图","因此","_","发生","东西","关于","id","例如","下","关联","重新分配","之间","发生变化","调用","完整","一样","出现","属性","中一","记忆","示意图","清楚","计数","other","相关","请","一个","”","明显","便","\"","以","。","人们","收集","直接","为什么","所示","区别","容易","多少","绘图","局部","isinstance","完全","示例","2275073185800","继续","那样","第三个","提供","元素","避免","第三","速记","变","意图","值","else","从","它会","返回","提到","清除","非常","作用","真正","影响","variable","工作","以上","except","直到","、","右侧","电脑","a","名称","obj","就","描述","不再","2275073247560","函数调用","呢","—","查看","先","当","惊喜","过程","删除","它","看似","之外","为了",")","执行","就是","每","注意","第一","这个","del","对","通常","记住","装置","的","里面","变化","行中","无论","但是","神话","称为","就是说","2275068173704","永远","不是","参数","模块","浅","因为","有趣","比如","没有","视觉","140728107374080","这样","不会","并且","25","仅仅","一直","deep","链接","当然","}","c","等","下次","10","整数","都","2275072084616","绑定","name","所有","当值","一种","导致","deepcopy","则","参考","将","local","指标","简单","指定","拷贝","内存地址","命名","作为","import","对象","结果","as","=","子","#","x","这种","混淆","有些","上","误导","情况","这句",".",",","到","是","不能","不必","[","本地","务必","传递","change","被","存取","看看","像","赋值","自行","三种","代码","同样","显示","nums","然后","多数","于","副本","reference","+","新建","in","只有","变量","一下","第一个","需要","可能","得到","from","所以","另","误导性","生变","func","key","如果",":","列表","地"],"title":"3.2.浅拷贝和深拷贝","title_tokens":[".","深","和","浅","3.2","拷贝"]},{"location":"Python基础/3.2.浅拷贝和深拷贝.html#namevalue","text":"引用（reference） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。 一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。 因此，引用亦常被称为该资料的指标或位址。 name是value的引用。 在python里面，一个变量保存的值是某个对象的引用。Python赋值语句将左侧的符号名称与右侧的值 相关联 。在Python中，我们说名称引用值，或者名称是对值的引用 下次我们使用这个名称时，便得到与名称相关联的值。 多个name可以引用同一个value。 x = 23 y = x x 和 y 具有相同的状态：每个都以完全相同的方式引用该值。 名称是独立于其他名称重新分配的。 如果两个名称引用相同的值，则不会链接这两个名称。重新分配其中一个不会导致另一个也被重新分配： x = 23 y = x x = 12 值一直存在，直到没有名称引用它 Python会跟踪每个值有多少引用，并自动清除没有引用的值。这被称为“垃圾收集”，意味着你不必清楚值，当它们不再需要时它们会自行消失。","text_tokens":["资料","23","或","相同","垃圾","装置","的","里面","它们","value","（","和","y","说","消失","称为","或者","意味着","一般而言","同一","你","相关联","）","分配","因此","没有","不会","关联","重新分配","一直"," ","，","使用","中","链接","下次","值有","“","中一","记忆","实体","清楚","相关","对值","储存","都","一个","”","存在","其中","便","以","状态","。","name","收集","导致","一般","也","则","将","多个","两个","而言","指标","左侧","多少","每个","对象","具有","完全","跟踪","该值","特定","=","python","x","时","某个","自动","是","方式","间接","不必","引用","值","语句","12","位址","被","存取","在","赋值","清除","自行","并","记忆体","独立","同一个","意味","直到","右侧","电脑","于","名称","reference","可以","不再","符号","变量","与","我们","这","程式","需要","当","其他","得到","该","完全相同","亦","保存","另","它","重新","常","让","如果","这个","会","："],"title":"name与value","title_tokens":["value","与","name"]},{"location":"Python基础/3.2.浅拷贝和深拷贝.html#assignment","text":"assignment永远不会复制数据。 当值具有多个名称时，很容易混淆并将其视为两个名称和两个值： x = 23 y = x 但是给名称分配值永远不会复制数据，它永远不会创建新值。分配只是使左侧的名称引用右侧的值。在这种情况下，我们只有一个23，x和y都引用它，就像我们在上图中看到的那样。 分配只是使左侧的名称引用右侧的值。这句话是什么意思呢？ x = 23 y = x 当python执行上面的代码，assignment的过程如下图所示： 我们查看x和y的内存地址，可以看到x和y的内存地址一样，这也说明了该过程并没有创建新值。 print ( \"x的内存地址是：\" + str ( id ( x ))) print ( \"y的内存地址是：\" + str ( id ( y ))) x的内存地址是：140728107374080 y的内存地址是：140728107374080 同样地，如果我们这样赋值，也不会创建新值。 x = 23 y = 23 print ( \"x的内存地址是：\" + str ( id ( x ))) print ( \"y的内存地址是：\" + str ( id ( y ))) x的内存地址是：140728107374080 y的内存地址是：140728107374080 当我们有更复杂的值时，事情变得更有趣，比如列表： x = [ 1 , 2 , 3 ] y = [ 1 , 2 , 3 ] print ( \"x的内存地址是：\" + str ( id ( x ))) print ( \"y的内存地址是：\" + str ( id ( y ))) x的内存地址是：2275072084616 y的内存地址是：2275073247240 虽然我们给x和y都赋值了相同的list，但是可以看到x和y绑定了不同的对象，因为它们的内存地址并不一样。为什么会这样呢？ 原因在于 23 是 int 类型的对象，而 int 类型在python中属于 immutable 的类型；list 则属于 mutable 的类型。当然，mutable、immutable只是python语言的一个规定。 因为 int 是immutable的，所以如果给x重新赋值，无论怎么样都不会影响到y。 x = 23 y = x x = 12 y x = 23 y = 23 x = 12 y 23 但是 mutable 类型的值则不一样，如果x和y存储的是同一个引用，则给其中一个名称赋值时，会影响另一个名称。 x = [ 1 , 2 , 3 ] y = x print ( \"x的内存地址是：\" + str ( id ( x ))) print ( \"y的内存地址是：\" + str ( id ( y ))) # 给x重新赋值 x [ 0 ] = 0 y x的内存地址是：2275068173704 y的内存地址是：2275068173704 [0, 2, 3] 所以，为了避免混乱，当我们直接把一个相同的值赋值给不同的名称时，python会新建对象。 x = [ 1 , 2 , 3 ] y = [ 1 , 2 , 3 ] print ( \"x的内存地址是：\" + str ( id ( x ))) print ( \"y的内存地址是：\" + str ( id ( y ))) # 给x重新赋值 x [ 0 ] = 0 y x的内存地址是：2275073185800 y的内存地址是：2275073246792 [1, 2, 3] 通过上面的示例代码，我们可以知道： 通过一个对象的所有名称可以看到值的变化。 一个对象的所有名字是什么意思？例如下面的代码，x和y都是同一个对象的名字，因为x和y储存的引用是相同的。 x = [ 1 , 2 , 3 ] y = x print ( \"x的内存地址是：\" + str ( id ( x ))) print ( \"y的内存地址是：\" + str ( id ( y ))) x的内存地址是：2275073466632 y的内存地址是：2275073466632","text_tokens":["assignment","23","说明","怎么","什么","相同","2275073247240","的","使","它们","上面","混乱","变化","下面","很","内存","和","2","不","无论","但是","y","immutable","有","print","]","原因","2275068173704","永远","知道","同一","创建","因为","存储","数据","有趣","0","在于","怎么样","地","分配","比如","图","没有","而","给","id","140728107374080","这样","不会","例如","下","list","语言","，"," ","中","视为","当然","看到","一样","话","地址","都","2275073246792","储存","一个","意思","其中","2275072084616","\"","。","绑定","2275073466632","直接","变得","所有","当值","也","为什么","则","多个","将","所示","两个","复杂","左侧","容易","内存地址","类型","其","对象","具有","示例","2275073185800","=","把","#","python","x","只是","混淆","时","这种","那样","上","(","避免","情况","这句",",","到","是","名字","[","值","引用","12","像","mutable","在","赋值","属于","并","代码","了","影响","同样","值时","通过","同一个","？","、","右侧","3","名称","如下","就","不同","事情","+","可以","新建","更","只有","我们","这","呢","复制","str","查看","当","过程","该","所以","它","规定","另","；","虽然","重新","新值","如果",")","执行","int","为了","会","1","列表","："],"title":"Assignment","title_tokens":["assignment"]},{"location":"Python基础/3.2.浅拷贝和深拷贝.html#assignmentmutable-immutable","text":"神话：Python以不同的方式分配可变和不可变的值。 因为mutable对象是不可更改的，immutable对象则可以更改，人们可能会觉得mutable对象和immutable对象的值分配方式不一样。但事实上，mutable对象和immutable对象所有的赋值的方式都是一样的。","text_tokens":["但","可变","对象","的"," ","更改","不同","，","python","可以","和","不可","不","事实","觉得","一样","事实上","神话","都","方式","是","immutable","可能","变","值","以","。","人们","所有","mutable","赋值","则","因为","会","分配","："],"title":"Assignment陷阱——mutable 和immutable","title_tokens":["assignment","陷阱","mutable","和","immutable"," ","—"]},{"location":"Python基础/3.2.浅拷贝和深拷贝.html#assignment_1","text":"神话：值是有范围的。 在python中存在作用域这样的概念，人们可能会觉得作用域指的是值（对象）的作用范围，但事实上， 值是没有范围的，作用域指的是名称的作用范围。 也就是说，在上层作用域，不能使用下层作用域的名称来使用值。 我们可以定义一个简单的函数与验证这点。 def check_name_space_range ( x ): print ( \"x的内存地址是：\" + str ( id ( x ))) # 先在最外层的作用域赋值，并打印地址 a = 10 print ( \"a的内存地址是：\" + str ( id ( a ))) check_name_space_range ( a ) a的内存地址是：140728107373664 x的内存地址是：140728107373664 很明显，在内外层作用域的值都是同一个。 因为值没有范围，这就可能出现一些惊喜。 def variable_change ( x ): x [ 0 ] = 10 return x a = [ 1 , 2 , 3 ] a_other = variable_change ( a ) print ( a ) print ( a_other ) [10, 2, 3] [10, 2, 3] 可以看到，a、a_other都被改变了，实际上a、a_other都是同一个对象。 print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) a的内存地址是：2275072212872 a_other的内存地址是：2275072212872 因此，如果要在函数里面更改参数的值，最好复制一个副本。 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ] = 10 else : pass return x a = [ 1 , 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [1, 2, 3] [10, 2, 3] a的内存地址是：2275073247560 a_other的内存地址是：2275073166216 a的值并没有改变，上面的结果看似是没问题的，但还是会有新的惊喜。 我们来修改一下variable_change_shallow函数 def variable_change_shallow ( x ): if isinstance ( x , list ): x = x . copy () x [ 0 ][ 0 ] = 10 else : pass return x a = [[ 1 , 2 ], 2 , 3 ] a_other = variable_change_shallow ( a ) print ( a ) print ( a_other ) print ( \"a的内存地址是：\" + str ( id ( a ))) print ( \"a_other的内存地址是：\" + str ( id ( a_other ))) [[10, 2], 2, 3] [[10, 2], 2, 3] a的内存地址是：2275073245384 a_other的内存地址是：2275072212872 惊喜就是a的值也改变了。因为 x.copy() 只是浅拷贝。 在python里面有三种方式去引用某个值：1. 引用另一个变量2. 浅拷贝3. 深拷贝 这三种方式是有区别的。 import copy a = [ 1 , 2 ,[ 1 , 2 ]] a_reference = a a_shallow = copy . copy ( a ) a_deep_copy = copy . deepcopy ( a ) 变量a和a_reference都是同一个对象的名称。 浅拷贝得到变量a_shallow，它是一个新对象，但a_shallow的第三个元素a_shallow[2]却是一个已经存在的对象，这和a、a_reference一样。 深拷贝得到变量a_deep_copy，它是一个新对象，并且它的每一个元素也是新的对象。 如果浅拷贝的对象包含了mutable对象，则mutable对象不会拷贝；而深拷贝则会完整拷贝对象。","text_tokens":["140728107373664","指","的","里面","包含","上面","（","很","内存","2","和","觉得","check","神话","深","定义","来","有","也就是说","print","2275072212872","]","就是说","同一","参数","浅","因为","范围","0","2275073245384","）","外层","没有","_","因此","概念","def","copy","还是","新","id","三个","而","这样","不会","没","并且","list","deep","，"," ","使用","中","space","事实","range","看到","完整","出现","一样","地址","问题","10","都","other","一个","明显","存在","\"","。","人们","name","也","deepcopy","则","区别","简单","拷贝","内存地址","2275073166216","一些","这点","import","对象","isinstance","结果","=","#","python","x","在内","只是","shallow","第三个","去","(","并打印","元素","某个","事实上","修改",".",",","是","方式","第三","不能","[","值","引用","else","change","被","函数","上层","在","赋值","mutable","作用","并","实际上","三种","了","return","variable","同一个","最","、","作用域","但","实际","a","3","名称","就","更改","改变","副本","reference","+","可以","已经","打印","if","变量","与","2275073247560","我们","这","最好","复制","一下","str","验证","先","可能","得到","惊喜","却是","另","它","要","；","看似","如果",")","就是","pass","每","下层","会",":","1","："],"title":"Assignment陷阱——浅拷贝和深拷贝","title_tokens":["深","assignment","陷阱","和","浅","拷贝","—"]},{"location":"Python基础/3.2.浅拷贝和深拷贝.html#assignment_2","text":"以上所有示例都使用名称作为值的引用，但引用也可以是其他东西。 Python有许多复合数据结构，每个结构都包含对值的引用：列表元素，字典键和值，对象属性等。 其中每一个都可以在赋值符号的左侧使用，以上所有细节都适用于它们。 任何可以出现在赋值语句左侧的内容都是引用 ，在本文中说“名称”的任何地方都可以用“引用”替换。 在上面的示意图中，数字被显示为元素，但实际上，每个元素都是对数字的引用，因此它应该像这样绘制： nums = [ 1 , 2 , 3 ] 但这很快变得复杂，所以上面的绘图用了视觉速记： 如果你有列表元素引用其他可变值，例如子列表，请务必记住列表元素只是对值的引用。 这是一些其他assignment。这些左侧中的每一个都是引用（reference）： my_obj . attr = 23 my_dict [ key ] = 24 my_list [ index ] = 25 my_obj . attr [ key ][ index ] . attr = \"etc, etc\" 注意的是 i = x 指定了名称 i ，但 i[0] = x 并不是指定名称 i ，而是指定了 i 的值的第一个元素。 很多东西都是Assignment 正如上面所说，许多东西都可以作为引用，python里面有很多东西可以作为assignments。 这些行中的每一行都是名称X的赋值： X = ... for X in ... [ ... for X in ... ] ( ... for X in ... ) { ... for X in ... } class X ( ... ): def X ( ... ): def fn ( X ): ... ; fn ( 12 ) with ... as X : except ... as X : import X from ... import X import ... as X from ... import ... as X 注意，我并不是说这些语句像assignments，我的意思是这些语句都是赋值。它们都使名称X引用某个值。上面所说的关于赋值的所有内容都适用于所有这些赋值。 在大多数情况下，这些语句将X定义在与语句相同的作用域内。Python 2和Python 3之间的细节略有不同。但它们都是真正的赋值，而且每个事实都是关于赋值适用于所有这些。 Python通过赋值来传递函数参数。 让我们来看看这些上面assignment列表中最有趣的一个：调用一个函数。当我定义一个函数时，我将其参数命名为： def my_func ( x , y ): return x + y 这里x和y是函数my_func的参数。当我调用my_func时，我提供了实际值作为函数的参数。这些值分配给 参数名称 ，就像使用了赋值语句一样： def my_func ( x , y ): return x + y print ( my_func ( 8 , 9 )) 17 调用my_func时，8被赋值给名称x，9被赋值给名称y。该赋值与我们一直在讨论的简单赋值语句完全相同。名称x和y是函数的本地名称（local），因此当函数返回时，这些名称就会消失。但是，如果它们引用的值仍然被其他名称引用，则值仍然存在。 就像所有其他赋值一样，可变值可以传递给函数，并且通过其所有名称可以看到对值的更改。这在 中已经提到。","text_tokens":["assignment","一行","适用","本文","23","记住","地方","可变","相同","的","里面","它们","使","数据结构","包含","上面","i","行中","（","结构","2","和","而是","但是","y","说","内容","应该","大多","略有","消失","定义","所说","而且","数字","来","讨论","有","for","print","]","不是","参数","你","复合","数据","0","有趣","很快","）",";","分配","传递函数","8","因此","_","视觉","东西","def","关于","给","这样","例如","dict","25","并且","下","list","变得复杂","一直","仍然","，"," ","之间","使用","中","调用","}","事实","细节","看到","等","列表","attr","{","出现","一样","属性","“","示意图","都","对值","请","...","一个","”","绘制","其中","正如","\"","fn","意思","存在","。","所有","变得","也","则","将","很多","local","复杂","左侧","指定","简单","每个","一些","大多数","命名","略有不同","绘图","作为","其","import","对象","这些","class","完全","as","示例","=","这是","子","17","python","x","只是","时","许多","my","提供","(","元素","assignments","某个","情况",".",",","是","速记","意图","[","值","引用","语句","etc","本地","务必","12","传递","返回","键和值","提到","被","看看","字典","像","函数","在","赋值","我","9","并","作用","实际上","真正","了","return","以上","except","通过","index","显示","最","中说","nums","作用域","但","实际","多数","于","为","3","名称","obj","就","更改","不同","reference","+","可以","用","in","已经","符号","与","这","我们","这里","第一个","当","其他","from","所以","该","完全相同","它","内","任何","func","key","让","如果","24","替换",")","每","注意","第一",":","会","示意","1","with","对","："],"title":"Assignment陷阱——引用不仅仅是名称","title_tokens":["assignment","陷阱","是","不仅仅","引用","仅仅","不仅","名称","—"]},{"location":"Python基础/3.2.浅拷贝和深拷贝.html#_1","text":"任何名称都可以随时引用任何值。 Python是动态类型的，这意味着名称没有类型。任何名称都可以随时引用任何值。名称可以引用整数，然后引用字符串，然后引用函数，然后引用模块。当然，这可能是一个非常混乱的程序，你不应该这样做，但Python语言不会介意。 名称没有类型，值没有范围。 正如名称没有类型一样，值也没有范围。当我们说一个函数有一个局部变量时，我们的意思是该名称的作用域是函数：你不能在函数外部使用该名称，当函数返回时，名称将被销毁。但是正如我们所看到的，如果名称的值具有其他引用，它将继续在函数调用之外。它是本地名称，而不是本地值。 值不能删除，只有名称可以删除。 Python的内存管理对其行为至关重要，你不仅不必删除值，而且无法删除值。 nums = [ 1 , 2 , 3 ] del nums 这不会删除值nums，它会删除名称nums。该名称将从其范围中删除，然后通常的引用计数开始执行：如果nums的值只有一个引用，则将回收该值。但如果它有其他引用，那么它不会被回收。 神话：Python没有变量。 有些人喜欢说，“Python没有变量，它有名字。”这个口号具有误导性。事实是Python有变量，它们的工作方式与C中的变量不同。 名称是Python的变量：它们引用值，并且这些值可以在程序的过程中发生变化（变化）。仅仅因为另一种语言（尽管是一种重要的语言）表现不同，没有理由将Python描述为没有变量。","text_tokens":["口号","介意","通常","的","它们","混乱","变化","（","字符串","2","内存","至关","不","但是","说","理由","应该","人","神话","开始","而且","外部","意味着","有","回收","]","不是","模块","随时","你","因为","范围","）","没有","而","发生","这样","不会","并且","仅仅","语言","，"," ","使用","发生变化","中","调用","当然","事实","c","看到","一样","管理","那么","行为","“","计数","整数","都","一个","”","意思","正如","。","不仅","一种","也","则","将","类型","所","其","局部","这些","具有","该值","继续","=","至关重要","python","时","有些","误导","销毁",",","是","方式","名字","不能","不必","[","引用","值","本地","从","它会","返回","被","函数","在","非常","作用","工作","意味","nums","然后","作用域","动态","但","3","为","名称","描述","不同","表现","可以","字符","只有","喜欢","变量","与","函数调用","这","我们","程序","当","其他","可能","过程","该","删除","它","另","重要","误导性","局部变量","生变","任何","之外","如果","无法","执行","尽管","del","这个","做","1","对","："],"title":"名称和值的一些细节","title_tokens":["一些","和","细节","值","的","名称"]},{"location":"Python基础/3.2.浅拷贝和深拷贝.html#_2","text":"Facts and myths about Python names and values","text_tokens":["facts","python","about","myths","values","names","and"," "],"title":"参考","title_tokens":["参考"]},{"location":"Python基础/4.1.类.html","text":"#' 类提供了一种组合数据和功能的方法。 File \"<ipython-input-1-fe4e9713f159>\", line 1 ﻿#' 类提供了一种组合数据和功能的方法。 ^ SyntaxError: invalid character in identifier 类通常是由函数（称为方法，method）、变量（称为类变量，class variable）和计算出的属性（称为特性，property）组成的集合。创建一个新类意味着创建一个新类型的对象，从而允许创建一个该类型的新实例。每个类的实例可以拥有保存自己状态的属性。 Python 的类提供了面向对象编程的所有标准特性：类继承机制允许多个基类，派生类可以覆盖它基类的任何方法，一个方法可以调用基类中相同名称的的方法。对象可以包含任意数量和类型的数据。和模块一样，类也拥有 Python 天然的动态特性：它们在运行时创建，可以在创建后修改。 在Python中，约定使用单数并将首字母大写。 类中定义的函数称为 实例方法 。实例方法是一种在类的实例上进行操作的函数，类实例作为第一个参数传递。根据约定，这个参数称为self，尽管所有合法的标识符都可以使用。 self 参数指向对象本身。 self 很有用，甚至必不可少。如果没有它，所有的方法都无法访问对象本身（要操作的属性所属的对象）。 类变量 是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。 类实例 类的实例是以函数形式调用类对象来创建的。这种方法将创建一个新实例，然后将该实例传递给类的 __init__() 方法。 __init__() 方法的参数包括新创建的实例 self 和在调用类对象时提供的参数。 在 __init__() 内，通过将属性分配给 self 来将其保存到实例中。例如， self.name = name 表示将 name 属性保存在实例中。其中，点 . 运算符用于属性绑定。在新创建的实例返回到用户之后，使用点 . 运算符即可访问这些属性以及类的属性。 访问属性时，结果值可能来自多个不同的地方。可能来自实例独有的属性，也可能来自类的属性。访问属性时，Python 首先会检查实例，如果不知道该属性的任何信息，则会对实例的类进行搜索。这是类与其所有实例共享其属性的底层机制。 继承 继承是一种创建新类的机制，目的是使用或修改现有类的行为。原始类称为 基类 或 超类 。新类称为 派生类 或 子类 。 通过继承创建类时，所创建的类将“继承”其基类定义的属性。==但是，==派生类可以重新定义任何这些属性并添加自己的新属性。 在class语句中用以逗号分隔的基类名称列表来指定继承。如果没有有效的基类，类将继承object。object是所有Python对象的根类，提供了一些常见方法（如 __str__() ，它可创建供打印函数使用的字符串）的默认实现。 继承通常用于重新定义现有方法的行为。 继承是用功能稍微增强的点 . 运算符实现的。具体来讲，如果搜索一个属性时未在实例或实例的类中找到匹配项，将会继续搜索基类。这个过程会一直继续下去，直到没有更多的基类可供搜索为止。 派生类重定义 __init__() 时，不会自动调用基类的 __init__() 方法。因此，如果派生类想重定义 __init__() ，还想调用基类的 __init__() 方法，那么要由派生类调用基类的 __init__() 方法来对它们进行恰当的初始化。如果基类未定义 __init__() ，就可以忽略这一步。如果不知道基类是否定义了 __init__() ，可在不提供任何参数的情况下调用它，因为始终存在一个不执行任何操作的默认 __init__() 实现。 # 定义一个人类 class Person : def __init__ ( self , name , age ): self . name = name self . age = age def get_name ( self ): return self . name def get_age ( self ): return self . age # 定义一个美国人类 ## 现在想给美国人在初始化的时候加上 性别 的属性 class American ( Person ): # 重新定义__init__()会覆盖Person的__init__()方法 def __init__ ( self , name , age , gender ): Person . __init__ ( self , name , age ) self . gender = gender def get_gender ( self ): return self . gender jackson = American ( name = \"Cesar T. Mauck\" , age = 14 , gender = \"male\" ) jackson . get_age () 14 jackson . get_gender () 'male' # 有时，派生类将重新实现方法，但是还想调用原始的实现。 为此，有一种方法可以显式地调用基类中的原始方法，将实例 self 作为第一个参数传递即可，如下所示： # 定义一个华盛顿人类 class Washington ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 age = American . get_age () age += 1 self . age = age print ( \"Washington people grow up one year old\" ) 这个例子的微妙之处在于，American这个类其实没有实现 get_age() 方法。该方法是在Person类中实现的。尽管这段代码能够运行，但它可能会引起一些混淆（例如，American是否应该实现 get_age() ? ）。因此，替代解决方案是用 super() 函数，如下所示： # 定义一个加利福尼亚人类 class California ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 ## 实际上，因为get_age()方法在Person中定义 ## 这里可以传入Person的任何一个派生类 age = super ( California , self ) . get_age () age += 1 self . age = age print ( \"Californians grow up one year old\" ) Terri = California ( \"Terri H. Booth\" , 25 , \"female\" ) Terri . growing_up () Californians grow up one year old super(cls, instance) 会返回一个特殊对象，该对象支持在基类上执行属性查找。如果使用该函数，Python将使用本来应该在基类上使用的正常搜索规则来搜索属性。有了这种方式，就无需写死方法位置，并且能更清晰地陈述你的意图（即你希望调用以前的实现，无论它是哪个基类定义的）。然而， super() 的语法尚有不足之处。如果使用Python 3，可以使用简化的语句 super().get_age() 来执行上面示例中的计算。 多重继承 Python支持多重继承。通过让一个类列出多个基类即可指定多重继承。例如，下面给出了一个类集合： # 定义一个圣拉蒙人类 class San_Ramon ( American , California , Washington ): def growing_up ( self ): pass Edwin = San_Ramon ( \"Edwin A. Marcotte\" , 37 , \"male\" ) Edwin . get_age () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-6c60ffbe4e5a> in <module> 1 # 定义一个圣拉蒙人类 ----> 2 class San_Ramon(American, California, Washington): 3 def growing_up(self): 4 pass 5 TypeError: Cannot create a consistent method resolution order (MRO) for bases American, California, Washington 使用多重继承时，属性的解析会变得非常复杂，因为可以使用很多搜索路径来绑定属性。 在查找使用了多重继承的属性时，会将所有基类按从“最特殊”的类到“最不特殊”的类这种顺序进行排列。然后在搜索属性时，就会按这个顺序搜索，直至找到该属性的第一个定义。对于任何给定的类，通过打印它的 mro 属性即可查看基类的顺序，例如： 在大多数情况下，这个列表基于“有意义”的规则排列得出。也就是说，始终先检查派生类，然后再检查其基类，如果一个类具有多个父类，那么始终按类定义中列出的父类顺序检查这些父类。但是，基类的准确顺序实际上非常复杂，不是基于任何“简单的”算法，如深度优先或广度优先搜索。实际上，基类的顺序由 C3 线性化算法确定，可以在论文“A Monotonic Superclass Linearization for Dylan”（K. Barrett 等，发表于 OOPSLA’96）中找到该算法的介绍。该算法的一个需要注意的地方是，某些类层次结构将被 Python 拒绝并会抛出 TypeError 错误，例如： 一般来说，在大多数程序中最好避免使用多重继承。但是，多重继承有时可用于定义所谓的混合（mixin）类。混合类通常定义了要“混合到”其他类中的一组方法，目的是添加更多的功能（这与宏很类似）。通常，混合类中的方法将假定其他方法存在，并将以这些方法为基础构建。 多态动态绑定和鸭子类型 动态绑定（在继承背景下使用时，有时也称为多态性）是指在不考虑实例类型的情况下使用实例只要以 obj.attr 的形式访问属性，就会按照一定的顺序搜索并定位 attr ： 首先是实例本身，接着是实例的类定义，然后是基类。 查找过程会返回第一个匹配项。 这种绑定过程的关键在于，它不受对象 obj 的类型影响。因此，如果执行像 obj.name 这样的查找，对所有拥有 name 属性的 obj 都是适用的。这种行为有时被称为“鸭子类型”（duck typing），这个名称来源于一句谚语：“如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子。” Python 程序员经常编写利用这种行为的程序。例如，如果想编写现有对象的自定义版本，可以继承该对象，也可以创建一个外观和行为像它但与它无任何关系的全新对象。后一种方法通常用于保持程序组件的松散耦合。例如，可以编写代码来处理任何种类的对象，只要该对象拥有特定的方法集。最常见的例子就是利用标准库中定义的各种“类似文件”的对象。尽管这些对象的工作方式像文件，但它们并不是继承自内置文件对象的。 静态方法和类方法 静态方法 在类定义中，所有函数都被假定在实例上操作，该实例总是作为第一个参数 self 传递。但是，还可以定义两种常见的方法。 静态方法是一种普通函数，只不过它们正好位于类定义的命名空间中。 它不会对任何实例类型进行操作 。要定义静态方法，可使用 @staticmethod 装饰器，如下所示： class Foo ( object ): 　　 @staticmethod 　　 def add ( x , y ): 　　　　 return x + y 要调用静态方法，只需用类名作为它的前缀。无需向它传递任何其他信息，例如： x = Foo . add ( 3 , 4 ) 　　 # x = 7 如果在编写类时需要采用很多不同的方式来创建新实例，则常常使用静态方法。因为类中只能有一个 __init__() 函数，所以替代的创建函数通常按如下方式定义： class Date ( object ): 　　 def __init__ ( self , year , month , day ): 　　　　 self . year = year 　　　　 self . month = month 　　　　 self . day = day 　　 @staticmethod 　　 def now (): 　　　　 t = time . localtime () 　　　　 return Date ( t . tm_year , t . tm_mon , t . tm_day ) 　　 @staticmethod 　　 def tomorrow (): 　　　　 t = time . localtime ( time . time () + 86400 ) 　　　　 return Date ( t . tm_year , t . tm_mon , t . tm_day ) # 创建日期的示例 a = Date ( 1967 , 4 , 9 ) b = Date . now () 　　　　 # 调用静态方法now() c = Date . tomorrow () 　　 # 调用静态方法tomorrow() 类方法 类方法是将类本身作为对象进行操作的方法。类方法使用 @classmethod 装饰器定义，与实例方法不同，因为根据约定，类是作为第一个参数（名为 cls ）传递的，例如： class Times ( object ): 　　 factor = 1 　　 @classmethod 　　 def mul ( cls , x ): 　　　　 return cls . factor * x class TwoTimes ( Times ): 　　 factor = 2 x = TwoTimes . mul ( 4 ) 　　 # 调用Times.mul(TwoTimes, 4) -> 8 在这个例子中，请注意类 TwoTimes 是如何作为对象传递给 mul() 的。尽管这个例子有些深奥，但类方法还有一些实用且巧妙的用法。例如，你定义了一个类，它继承自前面给出的 Date 类并对其略加定制： class EuroDate ( Date ): 　　 # 修改字符串转换，以使用欧洲日期格式 　　 def __str__ ( self ): 　　　　 return \" %02d / %02d / %4d \" % ( self . day , self . month , self . year ) 由于该类继承自 Date，所以它拥有 Date 的所有特性。但是 now() 和 tomorrow() 方法稍微有点不同。例如，如果调用 EuroDate.now()，则会返回 Date 对象，而不是 EuroDate 对象。类方法可以解决该问题： class Date ( object ): 　　 ... 　　 @classmethod 　　 def now ( cls ): 　　　　 t = time . localtime () 　　　　 # 创建具有合适类型的对象 　　　　 return cls ( t . tm_year , t . tm_month , t . tm_day ) class EuroDate ( Date ): 　　 ... a = Date . now () 　　　　 # 调用Date.now(Date)并返回Date b = EuroDate . now () 　　 # 调用Date.now(EuroDate)并返回EuroDate 关于静态方法和类方法需要注意的一点是，Python 不会在与实例方法独立的命名空间中管理它们。因此，可以在实例上调用它们。例如： a = Date ( 1967 , 4 , 9 ) b = d . now () 　　　　　 # 调用Date.now(Date) 这可能很容易引起混淆，因为对 d.now() 的调用与实例d没有任何关系。这种行为是 Python 对象系统与其他面向对象语言（如 Smalltalk 和 Ruby）对象系统的区别之一。在这些语言中，类方法与实例方法是严格分开的。 特性 @property ——把方法变为属性 通常，访问实例或类的属性时，返回的会是所存储的相关值。特性（property）是一种特殊的属性，访问它时会计算它的值。下面是一个简单的例子： import math class Circle ( object ): def __init__ ( self , radius ): self . radius = radius # Circle的一些附加特性 @property def area ( self ): return math . pi * self . radius ** 2 @property def preimeter ( self ): return 2 * math . pi * self . radius 得到的Circle对象的行为如下： c = Circle ( 4.0 ) c . radius 4.0 c . area 50.26548245743669 c . perimeter ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-9874f48d40e6> in <module> ----> 1 c.perimeter AttributeError: 'Circle' object has no attribute 'perimeter' c . area = 2 ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-0dac39a0c579> in <module> ----> 1 c.area = 2 AttributeError: can't set attribute 在这个例子中，Circle 实例存储了一个实例变量 c.radius 。 c.area 和 c.perimeter 是根据该值计算得来的。 @property 装饰器支持以简单属性的形式访问后面的方法，无需像平常一样添加额外的 () 来调用该方法。对象的使用者很难发现正在计算一个属性，除非在试图重新定义该属性时生成了错误消息（如上面的 AttributeError 异常所示）。 ==这种特性使用方式遵循所谓的统一访问原则。==实际上，如果定义一个类，尽可能保持编程接口的统一总是不错的。如果没有特性，将会以简单属性（如 c.radius ）的形式访问对象的某些属性，而其他属性将以方法（如 c.area() ）的形式访问。费力去了解何时添加额外的 () 会带来不必要的混淆。特性可以解决该问题。 Python 程序员很少认识到，方法本身是被隐式地作为一类特性处理的。考虑下面这个类： class Foo ( object ): def __init__ ( self , name ): self . name = name def spam ( self , x ): print ( \" %s , %s \" % ( self . name , x ) File \"<ipython-input-1-3579cdb072a7>\", line 5 print(\"%s, %s\" % (self.name, x) ^ SyntaxError: unexpected EOF while parsing 用户创建 f = Foo(\"Guido\") 这样的实例然后访问 f.spam 时，不会返回原始函数对象 spam ，而是会得到所谓的绑定方法（bound method），绑定方法是一个对象，代表将在对象上调用 () 运算符时执行的方法调用。绑定方法有点类似于已部分计算的函数，其中的self参数已经填入，但其他参数仍然需要在使用 () 调用该函数时提供。这种绑定方法对象是由在后台执行的特性函数静默地创建的。使用 @staticmethod 和 @classmethod 定义静态方法和类方法时，实际上就指定了使用不同的特性函数，以不同的方式处理对这些方法的访问。例如， @staticmethod 仅“按原样”返回方法函数，不会进行任何特殊的包装或处理。 特性还可以截获操作权，以设置和删除属性。这是通过向特性附加其他 setter 和 deleter 方法来实现的，如下所示： class Foo ( object ): def __init__ ( self , name ): self . __name = name @property def name ( self ): return self . __name @name . setter def name ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value @name . deleter def name ( self ): raise TypeError ( \"Can't delete name\" ) f = Foo ( \"Guido\" ) n = f . name # 调用f.name() – get函数 f . name = \"Monty\" # 调用setter name(f,\"Monty\") f . name = 45 # 调用setter name(f,45) -> TypeError del f . name # 调用deleter name(f) -> TypeError ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-a48ffb0076e6> in <module> 17 n = f.name # 调用f.name() – get函数 18 f.name = \"Monty\" # 调用setter name(f,\"Monty\") ---> 19 f.name = 45 # 调用setter name(f,45) -> TypeError 20 del f.name # 调用deleter name(f) -> TypeError <ipython-input-1-a48ffb0076e6> in name(self, value) 8 def name(self,value): 9 if not isinstance(value,str): ---> 10 raise TypeError(\"Must be a string!\") 11 self.__name = value 12 @name.deleter TypeError: Must be a string! 在这个例子中，首先使用 @property 装饰器和相关方法将属性 name 定义为只读特性。后面的 @name.setter 和 @name.deleter 装饰器将其他方法与 name 属性上的设置和删除操作相关联。这些方法的名称必须与原始特性的名称完全匹配。在这些方法中，请注意实际的名称值存储在属性 __name 中。所存储属性的名称无需遵循任何约定，但它必须与特性名称不同，以便将它与特性的名称区分开。 在以前的代码中，通常会看到用 property(getf=None, setf=None, delf=None, doc=None) 函数来定义特性，往其中传入一组名称不同的方法，用于执行相关操作。例如： class Foo ( object ): def getname ( self ): return self . __name def setname ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value def delname ( self ): raise TypeError ( \"Can't delete name\" ) name = property ( getname , setname , delname ) 这种老方法仍然可以使用，但装饰器版本会让类看起来更整洁。例如，如果使用装饰器，get、 set 和 delete 函数将不会显示为方法。 数据封装和私有属性 默认情况下，类的所有属性和方法都是“公共的”。这意味着对它们的访问没有任何限制。这还暗示着，在基类中定义的所有内容都会被派生类继承，并可从派生类内进行访问。在面向对象的应用程序中，通常我们不希望发生这种行为，因为它会暴露对象的内部实现，可能导致在派生类中定义的对象与在基类中定义的对象之间发生命名空间冲突。 为了解决该问题，==类中所有以双下划线开头的名称（如 __Foo ）都会自动变形，形成具有 _Classname__Foo 形式的新名称。==这提供了一种在类中添加私有属性和方法的有效方式，因为派生类中使用的私有名称不会与基类中使用的相同私有名称发生冲突，如下所示： class A ( object ): def __init__ ( self ): self . __X = 3 # 变形为self._A__X def __spam ( self ): # 变形为_A__spam() pass def bar ( self ): self . __spam () # 只调用A.__spam() class B ( A ): def __init__ ( self ): A . __init__ ( self ) self . __X = 37 # 变形为self._B__X def __spam ( self ): # 变形为_B__spam() pass 尽管这种方案似乎隐藏了数据，但并没有严格的机制来实际阻止对类的“私有”属性进行访问。特别是如果已知类名称和相应私有属性的名称，则可以使用变形后的名称来访问它们。通过重定义 dir() 方法，类可以降低这些属性的可见性， dir() 方法提供了检查对象的 dir() 函数所返回的名称列表。 尽管这种名称变形似乎是一个额外的处理步骤，但变形过程实际上只在定义类时发生一次。它不会在方法执行期间发生，也不会为程序的执行添加额外的开销。而且要知道，名称变形不会在 getattr() 、 hasattr() 、 setattr() 或 delattr() 等函数中发生，在这些函数中，属性名被指定为字符串。对于这些函数，需要显式使用变形名称（如 __Classname__name ）来访问属性。 建议在定义可变属性时，通过特性来使用私有属性。这样，就可鼓励用户使用特性名称，而无需直接访问底层实例数据（如果你在实例开头添加了一个特性，可能不想采用这种访问方式）。 ==通过为方法提供私有名称，超类可以阻止派生类重新定义和更改方法的实现。==例如，示例中的 A.bar() 方法只调用 A.__spam() ，无论 self 具有何种类型，或者派生类中是否存在不同的 __spam() 方法都是如此。 最后，不要混淆私有类属性的命名和模块中“私有”定义的命名。一个常见的错误是，在定义类时，在属性名上使用单个前导下划线来隐藏属性值（如 _name ）。==在模块中，这种命名约定可以阻止通过 from module import * 语句导出名称。==但是在类中，这种命名约定既不能隐藏属性，在某个类继承该类并使用相同名称定义一个新属性或方法时，也不能阻止出现名称冲突。 对象表示和属性绑定 从内部实现上看，实例是使用字典来实现的，可以通过实例的 __dict__ 属性访问该字典。这个字典包含的数据对每个实例而言都是唯一的，如下所示： >>> a = Account ( 'Guido' , 1100.0 ) >>> a . __dict__ { 'balance' : 1100.0 , 'name' : 'Guido' } 可以在任何时候向实例添加新属性，例如： a . number = 123456 　　 #' 将属性'number'添加到 a.__dict__ 对实例的修改始终会反映到局部 __dict__ 属性中。同样，如果直接对 __dict__ 进行修改，所做的修改也会反映在实例的属性中。 实例通过特殊属性 __class__ 链接回它们的类。类本身也只是对字典的浅层包装，你可以在实例的 __dict__ 属性中找到这个字典。可以在类字典中找到各种方法。例如： >>> a . __class__ < class ' __main__ . Account '> >>> Account . __dict__ . keys () [ '__dict__' , '__module__' , 'inquiry' , 'deposit' , 'withdraw' , '__del__' , 'num_accounts' , '__weakref__' , '__doc__' , '__init__' ] 最后，通过特殊属性 __bases__ 中将类链接到它们的基类，该属性是一个基类元组。这种底层结构是获取、设置和删除对象属性的所有操作的基础。 只要使用 obj.name = value 设置了属性，特殊方法 obj.__setattr__(\"name\", value) 就会被调用。如果使用 del obj.name 删除了一个属性，就会调用特殊方法 obj.__delattr__(\"name\") 。这些方法的默认行为是修改或删除 obj 的局部 __dict__ 的值，除非请求的属性正好是一个特性或描述符。在这种情况下，设置和删除操作将由与该特性相关联的设置和删除函数执行。 在查找属性（如 obj.name ）时，将调用特殊方法 obj.__getattrribute__(\"name\") 。该方法执行搜索来查找该属性，这通常涉及检查特性、查找局部 __dict__ 属性、检查类字典以及搜索基类。如果搜索过程失败，最终会尝试调用类的 __getattr__() 方法（如果已定义）来查找该属性。如果这也失败，就会抛出 AttributeError 异常。 如果有必要，用户定义的类可以实现其自己的属性访问函数。例如： class Circle ( object ): def __init__ ( self , radius ): self . radius = radius def __getattr__ ( self , name ): if name == 'area' : return math . pi * self . radius ** 2 elif name == 'perimeter' : return 2 * math . pi * self . radius else : return object . __getattr__ ( self , name ) def setattr__ ( self , name , value ): if name in [ 'area' , 'perimeter' ]: raise TypeError ( \" %s is readonly\" % name ) object . __setattr__ ( self , name , value ) 重新实现这些方法的类应该可以依靠 object 中的默认实现来执行实际的工作。这是因为默认实现能够处理类的更高级特性，如描述符和特性。 一般来讲，类很少重新定义属性访问运算符。但是，在编写通用的包装器和现有对象的代理时，通常会使用属性访问运算符。通过重新定义 __getattr__() 、 __setattr__() 和 __delattr__() ，代理可以捕获属性访问操作，并透明地将这些操作转发给另一个对象。 __slots__ 通过定义特殊变量 slots ，类可以限制对合法实例属性名称的设置，如下所示： class Account ( object ): 　　 __slots__ = ( 'name' , 'balance' ) 　　　 ... 定义 __slots__ 时，可以将实例上分配的属性名称限制为指定的名称，否则将引发 AttributeError 异常。这种限制可以阻止其他人向现有实例添加新属性，即便用户将属性名称写错，也不会创建出新的属性来。 在实际使用中， __slots__ 从未被当作一种安全的特性来实现。它实际上是对内存和执行速度的一种性能优化。 使用 __slots__ 的类的实例不再使用字典来存储实例数据，转而采用一种基于数组的更加紧凑的数据结构。在会创建大量对象的程序中，使用 __slots__ 可以显著减少减少内存占用和执行时间。 注意， __slots__ 与继承的配合使用需要一定的技巧。如果类继承自使用 __slots__ 的基类，那么它也需要定义 __slots__ 来存储自己的属性（即使它不会添加任何属性也是如此），这样才能利用 __slots__ 提供的优势。如果忘记了这一点，派生类的运行速度将更慢，占用的内存也更多，比完全不使用 __slots__ 时情况更糟。 __slots__ 的使用还会破坏期望实例具有底层 __dict__ 属性的代码。尽管这一点通常不适用于用户代码，但对于支持对象的实用库和其他工具，其代码可能要依靠 __dict__ 来调试、序列化对象以及执行其他操作。 最后，如果类中重新定义了 __getattribute__() 、 __getattr__() 和 __setattr__() 等方法， __slots__ 的存在不会对它们的调用产生任何影响。但是，这些方法的默认行为将考虑到 __slots__ 。此外应该强调一点，没有必要向 __slots__ 添加方法或特性名称，因为它们存储在类中，而不是存储在每个实例中。","text_tokens":["适用","相同","keys","段","指","它们","一般来说","female","value","之","供","数据结构","前缀","产生","转发","大量","优先","结构","很","不可","f","2","之处","不","鸭子","首字母","降低","层次","组件","层次结构","多态","edwin","*","人","定义","目的","得出","深度","名上","保持","定制","线性","或者","按类","单独","也就是说","print","浅层","考虑","californians","year","区分","具体来讲","稍微","通用","拉蒙","存储","相关联","尚有","即","地","male","num","8","定位","american","得来","给","单数","封装","减少","强调","dict","foo","从未","合适","/","检查","，","再","super","circle","96","运行","ruby","3579cdb072a7","导出","guido","一类","派生类","背景","attr","管理","否则","那么","未定义","eurodate","本来","twotimes","问题","1967","暗示","其中","staticmethod","状态","形成","整洁","全新","–","能","默认","setname","一般","打印函数","尝试","多个","形式","外观","隐藏","很多","而言","accounts","构建","破坏","允许","每个","一些","不足","面向","忽略","阻止","自定","factor","按","bound","具有","tomorrow","must","中将","时未","两种","9874f48d40e6","is","marcotte","特定","这是","'","raise","17",">","只是","时","美国","perimeter","某个","涉及","自动","类似","高级","之后","方式","特殊","忘记","deposit","语句","不适","booth","解析","washington","字典","实例","微妙","setf","实际上","必不可少","希望","了","return","首先","独立","通过","one","普通","子类","tm","即可","动态","标识","但","now","还有","1100.0","3","底层","如下","setter","走起路来","何种","不同","准确","下划线","用","线性化","inquiry","更","if","加利福尼亚","解决方案","’","与","这","这里","最好","add","发表","cls","往","readonly","getattrribute","parsing","其他","19","步骤","保存","想","要","方案","前面","期间","任何","仅","无法","约定","深奥","尽管","while","会","截获","做","发给","转发给","1","?","用法","平常","暗示着","存在","years","37","位置","delname","可变","从而","如此","类","即使","上面","下面","后面","字符串","介绍","根类","recent","而是","y","应该","有时","最后","唯一","大多","attributeerror","程序员","property","module","age","例子","空间","来","意味着","!","公共","逗号","有","doc","规则","需用","采用","]","静默","覆盖","异常","华盛","50.26548245743669","重","创建","数据","华盛顿","只要","86400","应用","typing","not","）","统一","格式","分配","ramon","系统","def","广度","init","点","character","新","而","数量","并会","san","版本","语言","透明","仍然"," ","圣","部分","people","何时","使用","中","如何","确定","组成","看到","出","用于","{","下划","18","行为","“","额外","...","参数传递","他人","正常","但类","前导","dylan","其他人","变得","一般来讲","也","福尼亚","old","名为","算法","关键在于","不错","给定","复杂","4.0","ipython","string","类型","来讲","getattr","期望","大多数","指向","smalltalk","所","组合","其","直至","论文","time","变为","装饰","这些","语法","class","该值","linearization","死","把","消息","delf","显著","python","匹配","人类","有效","关键","内置","none","去","(","object","order","mul","修改","以便","开销","不受","似乎","尽可","由于","已","陈述","12","setattr","mauck","计算","函数","只读","在","t","9","并","<","balance","集合","位于","getf","up","原则","最","classname","意味","加利","delete","巧妙","看起","与其","现在","实际","most","开","day","为","02d","必须","单个","可","month","更改","gender","account","可以","字符","处理","已经","严格","或类","打印","withdraw","我们","为止","str","列出","程序","包括","老","实用","回","机制","该","该类","捕获","加利福","﻿","内","日期","新创","暴露","重新","让","pass","barrett","支持","走起","开头","之一","信息","认识","起来","必要","看起来","grow","是否","person","或","数组","任意","地方","traceback","对类","写错","叫声","包含","引发","（","将会","和","运算符","按照","typeerror","带来","私有","内存","未定","转换","内容","radius","时候","bases","哪个","weakref","getattribute","而且","首字","共享","line","for","限制","性","代表","集","知道","分开","你","性别","还","在于","派生","接口","elif","鼓励","因此","_","合法","发生","123456","关于","例如","has","下","排列","关联","monty","之间","调用","一样","出现","继续下去","属性","为此","相关","请","一个","”","种类","6c60ffbe4e5a","\"","s","分隔","设置","以","spam","。","来源于","input","be","直接","算符","fe4e9713f159","耦合","基类","应用程序","oopsla","invalid","所示","区别","后","根据","容易","运算","instance","才能","一次","无法访问","不必要","使用者","遵循","多态性","局部","isinstance","此外","完全","优势","示例","不过","继续","依靠","字母","用者","增强","访问","且","%","set","以双","提供","超类","resolution","反映","各种","有点","area","避免","terri","dir","能够","生成","意图","值","找到","else","从","源于","它会","独有","返回","路径","self","由","非常","-","7","用以","具体","影响","variable","所谓","如","工作","配合","然而","、","直到","一定","hasattr","mixin","14","a","preimeter","identifier","名称","宏","就","obj","描述","还会","以及","紧凑","不再","拒绝","传入","来说","monotonic","尽可能","变形","试图","—","始终","查看","发生冲突","先","superclass","添加","过程","很少","现有","冲突","d","删除","它","main","last","可见","原样","初始化","总是","混合","为了",")","就是","执行","pi","常常","性能","静态方法","第一","注意","这个","del","只不过","对","growing","序列","特别","正好","通常","只","顺序搜索","的","delattr","实现","查找","库中","元组","建议","无需","b","即便","slots","时间","处","无论","发现","但是","a48ffb0076e6","项","call","文件","面向对象编程","当作","欧洲","11","n","特性","安全","初始","附加","甚至","除非","功能","称为","类时","简化","number","调试","jackson","就是说","库","不是","想重","模块","参数","h","因为","california","@","方法","所属","有用","权","填入","__","编程","描述符","多重","没有","对于","标识符","这样","不会","25","并且","松散","代理","一直","接着","了解","包装","本身","更慢","时会","链接","}","duck","大写","替代","下去","等","c","10","都","父类","5","deleter","bar","不要","can","绑定","是因为","name","date","失败","所有","经常","一种","很难","导致","则","将","4","费力","序列化","后台","原始","多","简单","指定","谚语","times","最终","no","优化","localtime","命名","请求","0dac39a0c579","作为","表示","数传","名","关系","对象","结果","只能","import","略加","常见","=","#","math","x","看","这种","混淆","错误","写","有些","相应","上","操作","c3","抛出","继承","create","20","更加","拥有","天然","给出","静态","情况","来自",".","向",",","到","是","新类","编写","占用","mon","classmethod","隐式","不必","unexpected","不能","[","内部","正在","传递","无","被","解决","._","类中","像","45","既","自定义","自","代码","cannot","假定","一句","cesar","用户","意义","同样","k","恰当","尼亚","非常复杂","　","显示","工具","然后","利用","基于","类名","某些","多数","于","自己","新创建","其实","器","面向对象","eof","method","+","以前","来源","in","##","consistent","4d","get","显式","获取","变量","转而","第一个","需要","attribute","引起","不想","可能","得到","不足之处","from","加上","所以","技巧","另","进行","基础","搜索",".__","getname","mro","出新","比","顺序","一步","如果","一组","已知","syntaxerror","速度","更糟","划线","^","清晰","一点",":","标准","列表","file","："],"title":"4.1.类","title_tokens":[".","类","4.1"]},{"location":"Python基础/4.1.类.html#_1","text":"类的实例是以函数形式调用类对象来创建的。这种方法将创建一个新实例，然后将该实例传递给类的 __init__() 方法。 __init__() 方法的参数包括新创建的实例 self 和在调用类对象时提供的参数。 在 __init__() 内，通过将属性分配给 self 来将其保存到实例中。例如， self.name = name 表示将 name 属性保存在实例中。其中，点 . 运算符用于属性绑定。在新创建的实例返回到用户之后，使用点 . 运算符即可访问这些属性以及类的属性。 访问属性时，结果值可能来自多个不同的地方。可能来自实例独有的属性，也可能来自类的属性。访问属性时，Python 首先会检查实例，如果不知道该属性的任何信息，则会对实例的类进行搜索。这是类与其所有实例共享其属性的底层机制。","text_tokens":["地方","类","的","和","运算符","不","来","共享","知道","参数","创建","方法","__","分配","init","给","新","点","例如","检查","，"," ","使用","中","调用","用于","属性","一个","其中","以","。","绑定","name","所有","算符","也","则","形式","将","多个","运算","表示","其","对象","这些","结果","=","python","这种","时","访问","提供","(","来自",".","到","是","之后","值","传递","独有","返回","函数","self","实例","在","首先","用户","通过","然后","即可","与其","新创建","底层","不同","以及","这","包括","机制","可能","该","保存","进行","内","搜索","新创","任何","如果",")","信息","会","对"],"title":"类实例","title_tokens":["类","实例"]},{"location":"Python基础/4.1.类.html#_2","text":"继承是一种创建新类的机制，目的是使用或修改现有类的行为。原始类称为 基类 或 超类 。新类称为 派生类 或 子类 。 通过继承创建类时，所创建的类将“继承”其基类定义的属性。==但是，==派生类可以重新定义任何这些属性并添加自己的新属性。 在class语句中用以逗号分隔的基类名称列表来指定继承。如果没有有效的基类，类将继承object。object是所有Python对象的根类，提供了一些常见方法（如 __str__() ，它可创建供打印函数使用的字符串）的默认实现。 继承通常用于重新定义现有方法的行为。 继承是用功能稍微增强的点 . 运算符实现的。具体来讲，如果搜索一个属性时未在实例或实例的类中找到匹配项，将会继续搜索基类。这个过程会一直继续下去，直到没有更多的基类可供搜索为止。 派生类重定义 __init__() 时，不会自动调用基类的 __init__() 方法。因此，如果派生类想重定义 __init__() ，还想调用基类的 __init__() 方法，那么要由派生类调用基类的 __init__() 方法来对它们进行恰当的初始化。如果基类未定义 __init__() ，就可以忽略这一步。如果不知道基类是否定义了 __init__() ，可在不提供任何参数的情况下调用它，因为始终存在一个不执行任何操作的默认 __init__() 实现。 # 定义一个人类 class Person : def __init__ ( self , name , age ): self . name = name self . age = age def get_name ( self ): return self . name def get_age ( self ): return self . age # 定义一个美国人类 ## 现在想给美国人在初始化的时候加上 性别 的属性 class American ( Person ): # 重新定义__init__()会覆盖Person的__init__()方法 def __init__ ( self , name , age , gender ): Person . __init__ ( self , name , age ) self . gender = gender def get_gender ( self ): return self . gender jackson = American ( name = \"Cesar T. Mauck\" , age = 14 , gender = \"male\" ) jackson . get_age () 14 jackson . get_gender () 'male' # 有时，派生类将重新实现方法，但是还想调用原始的实现。 为此，有一种方法可以显式地调用基类中的原始方法，将实例 self 作为第一个参数传递即可，如下所示： # 定义一个华盛顿人类 class Washington ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 age = American . get_age () age += 1 self . age = age print ( \"Washington people grow up one year old\" ) 这个例子的微妙之处在于，American这个类其实没有实现 get_age() 方法。该方法是在Person类中实现的。尽管这段代码能够运行，但它可能会引起一些混淆（例如，American是否应该实现 get_age() ? ）。因此，替代解决方案是用 super() 函数，如下所示： # 定义一个加利福尼亚人类 class California ( American ): def get_age ( self ): return f \" {self.age} years old\" def growing_up ( self ): # 显式地调用基类中的原始方法 ## 实际上，因为get_age()方法在Person中定义 ## 这里可以传入Person的任何一个派生类 age = super ( California , self ) . get_age () age += 1 self . age = age print ( \"Californians grow up one year old\" ) Terri = California ( \"Terri H. Booth\" , 25 , \"female\" ) Terri . growing_up () Californians grow up one year old super(cls, instance) 会返回一个特殊对象，该对象支持在基类上执行属性查找。如果使用该函数，Python将使用本来应该在基类上使用的正常搜索规则来搜索属性。有了这种方式，就无需写死方法位置，并且能更清晰地陈述你的意图（即你希望调用以前的实现，无论它是哪个基类定义的）。然而， super() 的语法尚有不足之处。如果使用Python 3，可以使用简化的语句 super().get_age() 来执行上面示例中的计算。","text_tokens":["growing","是否","person","或","通常","位置","段","类","的","它们","实现","查找","female","之","供","上面","（","字符串","运算符","将会","根类","f","无需","不","处","无论","但是","未定","项","之处","应该","有时","时候","人","哪个","定义","目的","初始","age","例子","来","称为","功能","类时","grow","逗号","有","简化","jackson","print","规则","覆盖","知道","想重","californians","参数","华盛","具体来讲","稍微","创建","重","因为","性别","方法","还","华盛顿","在于","?","california","派生","尚有","）","__","即","地","male","没有","因此","_","def","american","点","init","新","给","years","不会","例如","25","并且","下","一直","，"," ","people","super","运行","使用","中","调用","}","派生类","替代","下去","用于","h","{","那么","未定义","行为","继续下去","“","属性","本来","为此","一个","”","\"","参数传递","分隔","正常","。","name","所有","算符","默认","能","基类","一种","打印函数","福尼亚","old","将","所示","原始","多","指定","运算","instance","来讲","一些","不足","所","忽略","作为","其","数传","对象","这些","语法","class","时未","常见","示例","=","继续","死","'","#","python","增强","匹配","有效","人类","混淆","时","这种","写","上","操作","继承","超类","提供","object","(","美国","terri","情况","修改",".","自动",",","能够","是","新类","方式","特殊","意图","语句","找到","booth","陈述","传递","mauck","返回","washington","解决","计算","函数","self","在","实例","由","t","并","微妙","类中","实际上","你","希望","用以","了","具体","return","cesar","如","代码","通过","up","one","然而","恰当","尼亚","子类","直到","加利","即可","现在","但","实际","14","3","自己","其实","名称","如下","可","就","gender","+","可以","用","以前","##","字符","更","get","传入","显式","打印","加利福尼亚","解决方案","这","这里","第一个","为止","str","：","year","cls","始终","引起","机制","可能","添加","过程","不足之处","现有","加上","该","它","想","进行","搜索","要","方案","初始化","加利福","重新","任何","对","一步","如果",")","执行","支持","尽管","第一","清晰","这个","会",":","1","列表","存在"],"title":"继承","title_tokens":["继承"]},{"location":"Python基础/4.1.类.html#_3","text":"Python支持多重继承。通过让一个类列出多个基类即可指定多重继承。例如，下面给出了一个类集合： # 定义一个圣拉蒙人类 class San_Ramon ( American , California , Washington ): def growing_up ( self ): pass Edwin = San_Ramon ( \"Edwin A. Marcotte\" , 37 , \"male\" ) Edwin . get_age () ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-6c60ffbe4e5a> in <module> 1 # 定义一个圣拉蒙人类 ----> 2 class San_Ramon(American, California, Washington): 3 def growing_up(self): 4 pass 5 TypeError: Cannot create a consistent method resolution order (MRO) for bases American, California, Washington 使用多重继承时，属性的解析会变得非常复杂，因为可以使用很多搜索路径来绑定属性。 在查找使用了多重继承的属性时，会将所有基类按从“最特殊”的类到“最不特殊”的类这种顺序进行排列。然后在搜索属性时，就会按这个顺序搜索，直至找到该属性的第一个定义。对于任何给定的类，通过打印它的 mro 属性即可查看基类的顺序，例如： 在大多数情况下，这个列表基于“有意义”的规则排列得出。也就是说，始终先检查派生类，然后再检查其基类，如果一个类具有多个父类，那么始终按类定义中列出的父类顺序检查这些父类。但是，基类的准确顺序实际上非常复杂，不是基于任何“简单的”算法，如深度优先或广度优先搜索。实际上，基类的顺序由 C3 线性化算法确定，可以在论文“A Monotonic Superclass Linearization for Dylan”（K. Barrett 等，发表于 OOPSLA’96）中找到该算法的介绍。该算法的一个需要注意的地方是，某些类层次结构将被 Python 拒绝并会抛出 TypeError 错误，例如： 一般来说，在大多数程序中最好避免使用多重继承。但是，多重继承有时可用于定义所谓的混合（mixin）类。混合类通常定义了要“混合到”其他类中的一组方法，目的是添加更多的功能（这与宏很类似）。通常，混合类中的方法将假定其他方法存在，并将以这些方法为基础构建。","text_tokens":["growing","37","或","通常","地方","traceback","类","顺序搜索","的","查找","一般来说","下面","（","优先","介绍","2","结构","recent","typeerror","很","不","但是","层次","call","层次结构","有时","edwin","bases","大多","定义","得出","module","深度","目的","age","线性","来","功能","按类","for","有","也就是说","规则","就是说","不是","因为","california","拉蒙","方法","派生","）","ramon","male","多重","_","对于","american","def","广度","并会","例如","san","排列","下","检查","，"," ","圣","再","96","使用","中","派生类","确定","等","用于","那么","属性","“","父类","一个","5","”","存在","6c60ffbe4e5a","\"","以","。","绑定","dylan","input","变得","所有","基类","oopsla","一般","多个","将","4","算法","多","很多","给定","复杂","简单","指定","构建","ipython","大多数","直至","其","论文","按","这些","class","具有","linearization","marcotte","=","#","python","人类",">","这种","时","错误","c3","抛出","继承","create","resolution","(","给出","order","避免","情况",".",",","类似","到","是","特殊","找到","解析","从","路径","washington","被","类中","self","在","由","非常","-","并","实际上","<","cannot","了","假定","意义","集合","如","所谓","up","通过","k","非常复杂","最","即可","然后","基于","实际","某些","most","多数","mixin","a","3","于","为","宏","就","可","准确","method","可以","in","consistent","线性化","拒绝","get","更","打印","来说","monotonic","与","’","最好","这","第一个","发表","列出","需要","程序","始终","查看","先","superclass","其他","添加","该","它","进行","last","搜索","要","基础","mro","任何","让","顺序","如果",")","pass","就是","支持","barrett","混合","一组","第一","注意","这个",":","会","1","列表","："],"title":"多重继承","title_tokens":["继承","多重"]},{"location":"Python基础/4.1.类.html#_4","text":"动态绑定（在继承背景下使用时，有时也称为多态性）是指在不考虑实例类型的情况下使用实例只要以 obj.attr 的形式访问属性，就会按照一定的顺序搜索并定位 attr ： 首先是实例本身，接着是实例的类定义，然后是基类。 查找过程会返回第一个匹配项。 这种绑定过程的关键在于，它不受对象 obj 的类型影响。因此，如果执行像 obj.name 这样的查找，对所有拥有 name 属性的 obj 都是适用的。这种行为有时被称为“鸭子类型”（duck typing），这个名称来源于一句谚语：“如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子。” Python 程序员经常编写利用这种行为的程序。例如，如果想编写现有对象的自定义版本，可以继承该对象，也可以创建一个外观和行为像它但与它无任何关系的全新对象。后一种方法通常用于保持程序组件的松散耦合。例如，可以编写代码来处理任何种类的对象，只要该对象拥有特定的方法集。最常见的例子就是利用标准库中定义的各种“类似文件”的对象。尽管这些对象的工作方式像文件，但它们并不是继承自内置文件对象的。","text_tokens":["适用","通常","指","类","顺序搜索","的","叫声","它们","查找","库中","（","和","鸭子","按照","不","项","组件","文件","有时","多态","定义","而且","程序员","保持","例子","来","称为","考虑","集","不是","创建","方法","只要","在于","typing","）","因此","定位","这样","例如","松散","版本","下","，"," ","接着","本身","使用","duck","背景","attr","用于","那么","行为","属性","“","都","一个","”","种类","以","。","绑定","来源于","name","全新","所有","经常","耦合","基类","一种","也","形式","外观","后","关键在于","谚语","类型","多态性","自定","关系","对象","这些","常见","特定","匹配","关键","python","这种","时","访问","内置","继承","拥有","各种","情况",".","类似","编写","是","方式","不受","源于","返回","无","被","像","在","实例","并","自定义","自","代码","影响","一句","首先","工作","最","、","然后","一定","利用","看起","动态","但","obj","名称","就","走起路来","来源","可以","处理","与","第一个","程序","过程","现有","该","它","想","搜索","任何","顺序","如果","执行","走起","就是","尽管","第一","这个","会","起来","标准","看起来","对","："],"title":"多态动态绑定和鸭子类型","title_tokens":["和","鸭子","动态","绑定","多态","类型"]},{"location":"Python基础/4.1.类.html#_5","text":"","text_tokens":[],"title":"静态方法和类方法","title_tokens":["和","方法","静态方法","类","静态"]},{"location":"Python基础/4.1.类.html#_6","text":"在类定义中，所有函数都被假定在实例上操作，该实例总是作为第一个参数 self 传递。但是，还可以定义两种常见的方法。 静态方法是一种普通函数，只不过它们正好位于类定义的命名空间中。 它不会对任何实例类型进行操作 。要定义静态方法，可使用 @staticmethod 装饰器，如下所示： class Foo ( object ): 　　 @staticmethod 　　 def add ( x , y ): 　　　　 return x + y 要调用静态方法，只需用类名作为它的前缀。无需向它传递任何其他信息，例如： x = Foo . add ( 3 , 4 ) 　　 # x = 7 如果在编写类时需要采用很多不同的方式来创建新实例，则常常使用静态方法。因为类中只能有一个 __init__() 函数，所以替代的创建函数通常按如下方式定义： class Date ( object ): 　　 def __init__ ( self , year , month , day ): 　　　　 self . year = year 　　　　 self . month = month 　　　　 self . day = day 　　 @staticmethod 　　 def now (): 　　　　 t = time . localtime () 　　　　 return Date ( t . tm_year , t . tm_mon , t . tm_day ) 　　 @staticmethod 　　 def tomorrow (): 　　　　 t = time . localtime ( time . time () + 86400 ) 　　　　 return Date ( t . tm_year , t . tm_mon , t . tm_day ) # 创建日期的示例 a = Date ( 1967 , 4 , 9 ) b = Date . now () 　　　　 # 调用静态方法now() c = Date . tomorrow () 　　 # 调用静态方法tomorrow()","text_tokens":["正好","通常","只","类","的","它们","前缀","无需","b","但是","y","定义","空间","来","类时","有","需用","采用","参数","year","创建","@","因为","方法","还","86400","__","_","def","init","新","不会","例如","foo","，"," ","使用","中","调用","c","替代","都","1967","一个","staticmethod","。","date","所有","一种","则","所示","4","很多","类型","localtime","命名","作为","time","装饰","只能","按","class","tomorrow","两种","常见","不过","示例","=","#","x","上","操作","(","object","静态","向",".",",","编写","是","方式","mon","传递","被","函数","self","在","实例","类中","t","9","7","假定","return","位于","　","普通","tm","类名","now","day","a","3","器","如下","可","month","不同","+","可以","add","第一个","需要","其他","该","所以","它","进行","日期","要","总是","任何","如果",")","常常","静态方法","第一","信息",":","只不过","对","："],"title":"静态方法","title_tokens":["静态","方法","静态方法"]},{"location":"Python基础/4.1.类.html#_7","text":"类方法是将类本身作为对象进行操作的方法。类方法使用 @classmethod 装饰器定义，与实例方法不同，因为根据约定，类是作为第一个参数（名为 cls ）传递的，例如： class Times ( object ): 　　 factor = 1 　　 @classmethod 　　 def mul ( cls , x ): 　　　　 return cls . factor * x class TwoTimes ( Times ): 　　 factor = 2 x = TwoTimes . mul ( 4 ) 　　 # 调用Times.mul(TwoTimes, 4) -> 8 在这个例子中，请注意类 TwoTimes 是如何作为对象传递给 mul() 的。尽管这个例子有些深奥，但类方法还有一些实用且巧妙的用法。例如，你定义了一个类，它继承自前面给出的 Date 类并对其略加定制： class EuroDate ( Date ): 　　 # 修改字符串转换，以使用欧洲日期格式 　　 def __str__ ( self ): 　　　　 return \" %02d / %02d / %4d \" % ( self . day , self . month , self . year ) 由于该类继承自 Date，所以它拥有 Date 的所有特性。但是 now() 和 tomorrow() 方法稍微有点不同。例如，如果调用 EuroDate.now()，则会返回 Date 对象，而不是 EuroDate 对象。类方法可以解决该问题： class Date ( object ): 　　 ... 　　 @classmethod 　　 def now ( cls ): 　　　　 t = time . localtime () 　　　　 # 创建具有合适类型的对象 　　　　 return cls ( t . tm_year , t . tm_month , t . tm_day ) class EuroDate ( Date ): 　　 ... a = Date . now () 　　　　 # 调用Date.now(Date)并返回Date b = EuroDate . now () 　　 # 调用Date.now(EuroDate)并返回EuroDate 关于静态方法和类方法需要注意的一点是，Python 不会在与实例方法独立的命名空间中管理它们。因此，可以在实例上调用它们。例如： a = Date ( 1967 , 4 , 9 ) b = d . now () 　　　　　 # 调用Date.now(Date) 这可能很容易引起混淆，因为对 d.now() 的调用与实例d没有任何关系。这种行为是 Python 对象系统与其他面向对象语言（如 Smalltalk 和 Ruby）对象系统的区别之一。在这些语言中，类方法与实例方法是严格分开的。","text_tokens":["类","的","它们","（","字符串","2","和","b","很","但是","转换","欧洲","*","特性","定义","例子","定制","空间","不是","分开","参数","year","你","稍微","因为","@","创建","方法","）","__","格式","8","因此","_","没有","def","而","关于","给","系统","例如","不会","合适","/","语言","，"," ","本身","使用","ruby","中","如何","调用","管理","eurodate","行为","问题","twotimes","请","...","一个","1967","\"","以","。","但类","date","所有","则","名为","将","4","区别","根据","容易","times","类型","一些","localtime","命名","smalltalk","面向","作为","其","time","关系","对象","装饰","factor","class","tomorrow","具有","略加","这些","=","#","python","x",">","混淆","这种","且","%","有些","上","操作","继承","(","object","mul","给出","拥有","有点","静态","修改",".",",","是","classmethod","由于","传递","返回","解决","self","在","实例","t","9","-","并","自","了","return","独立","如","　","tm","巧妙","now","还有","day","a","02d","器","面向对象","month","不同","4d","可以","字符","严格","与","这","第一个","cls","str","需要","实用","引起","可能","其他","该类","所以","该","它","进行","日期","d","前面","任何","如果","约定",")","深奥","尽管","静态方法","之一","第一","注意","这个",":","会","一点","1","用法","对","："],"title":"类方法","title_tokens":["类","方法"]},{"location":"Python基础/4.1.类.html#_8","text":"@property ——把方法变为属性 通常，访问实例或类的属性时，返回的会是所存储的相关值。特性（property）是一种特殊的属性，访问它时会计算它的值。下面是一个简单的例子： import math class Circle ( object ): def __init__ ( self , radius ): self . radius = radius # Circle的一些附加特性 @property def area ( self ): return math . pi * self . radius ** 2 @property def preimeter ( self ): return 2 * math . pi * self . radius 得到的Circle对象的行为如下： c = Circle ( 4.0 ) c . radius 4.0 c . area 50.26548245743669 c . perimeter ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-9874f48d40e6> in <module> ----> 1 c.perimeter AttributeError: 'Circle' object has no attribute 'perimeter' c . area = 2 ---------------------------------------------------------------------------AttributeError Traceback (most recent call last)<ipython-input-1-0dac39a0c579> in <module> ----> 1 c.area = 2 AttributeError: can't set attribute 在这个例子中，Circle 实例存储了一个实例变量 c.radius 。 c.area 和 c.perimeter 是根据该值计算得来的。 @property 装饰器支持以简单属性的形式访问后面的方法，无需像平常一样添加额外的 () 来调用该方法。对象的使用者很难发现正在计算一个属性，除非在试图重新定义该属性时生成了错误消息（如上面的 AttributeError 异常所示）。 ==这种特性使用方式遵循所谓的统一访问原则。==实际上，如果定义一个类，尽可能保持编程接口的统一总是不错的。如果没有特性，将会以简单属性（如 c.radius ）的形式访问对象的某些属性，而其他属性将以方法（如 c.area() ）的形式访问。费力去了解何时添加额外的 () 会带来不必要的混淆。特性可以解决该问题。 Python 程序员很少认识到，方法本身是被隐式地作为一类特性处理的。考虑下面这个类： class Foo ( object ): def __init__ ( self , name ): self . name = name def spam ( self , x ): print ( \" %s , %s \" % ( self . name , x ) File \"<ipython-input-1-3579cdb072a7>\", line 5 print(\"%s, %s\" % (self.name, x) ^ SyntaxError: unexpected EOF while parsing 用户创建 f = Foo(\"Guido\") 这样的实例然后访问 f.spam 时，不会返回原始函数对象 spam ，而是会得到所谓的绑定方法（bound method），绑定方法是一个对象，代表将在对象上调用 () 运算符时执行的方法调用。绑定方法有点类似于已部分计算的函数，其中的self参数已经填入，但其他参数仍然需要在使用 () 调用该函数时提供。这种绑定方法对象是由在后台执行的特性函数静默地创建的。使用 @staticmethod 和 @classmethod 定义静态方法和类方法时，实际上就指定了使用不同的特性函数，以不同的方式处理对这些方法的访问。例如， @staticmethod 仅“按原样”返回方法函数，不会进行任何特殊的包装或处理。 特性还可以截获操作权，以设置和删除属性。这是通过向特性附加其他 setter 和 deleter 方法来实现的，如下所示： class Foo ( object ): def __init__ ( self , name ): self . __name = name @property def name ( self ): return self . __name @name . setter def name ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value @name . deleter def name ( self ): raise TypeError ( \"Can't delete name\" ) f = Foo ( \"Guido\" ) n = f . name # 调用f.name() – get函数 f . name = \"Monty\" # 调用setter name(f,\"Monty\") f . name = 45 # 调用setter name(f,45) -> TypeError del f . name # 调用deleter name(f) -> TypeError ---------------------------------------------------------------------------TypeError Traceback (most recent call last)<ipython-input-1-a48ffb0076e6> in <module> 17 n = f.name # 调用f.name() – get函数 18 f.name = \"Monty\" # 调用setter name(f,\"Monty\") ---> 19 f.name = 45 # 调用setter name(f,45) -> TypeError 20 del f.name # 调用deleter name(f) -> TypeError <ipython-input-1-a48ffb0076e6> in name(self, value) 8 def name(self,value): 9 if not isinstance(value,str): ---> 10 raise TypeError(\"Must be a string!\") 11 self.__name = value 12 @name.deleter TypeError: Must be a string! 在这个例子中，首先使用 @property 装饰器和相关方法将属性 name 定义为只读特性。后面的 @name.setter 和 @name.deleter 装饰器将其他方法与 name 属性上的设置和删除操作相关联。这些方法的名称必须与原始特性的名称完全匹配。在这些方法中，请注意实际的名称值存储在属性 __name 中。所存储属性的名称无需遵循任何约定，但它必须与特性名称不同，以便将它与特性的名称区分开。 在以前的代码中，通常会看到用 property(getf=None, setf=None, delf=None, doc=None) 函数来定义特性，往其中传入一组名称不同的方法，用于执行相关操作。例如： class Foo ( object ): def getname ( self ): return self . __name def setname ( self , value ): if not isinstance ( value , str ): raise TypeError ( \"Must be a string!\" ) self . __name = value def delname ( self ): raise TypeError ( \"Can't delete name\" ) name = property ( getname , setname , delname ) 这种老方法仍然可以使用，但装饰器版本会让类看起来更整洁。例如，如果使用装饰器，get、 set 和 delete 函数将不会显示为方法。","text_tokens":["value","2","f","*","定义","保持","print","考虑","区分","存储","相关联","8","得来","foo","，","circle","3579cdb072a7","guido","一类","问题","其中","staticmethod","整洁","–","setname","形式","一些","按","bound","must","9874f48d40e6","这是","'","raise","17",">","时","perimeter","类似","方式","特殊","实例","setf","实际上","了","return","首先","通过","但","如下","setter","不同","用","更","if","与","往","parsing","其他","19","任何","仅","约定","while","会","截获","1","平常","delname","类","上面","下面","后面","recent","而是","attributeerror","程序员","property","module","例子","!","来","doc","静默","异常","50.26548245743669","创建","not","）","统一","def","而","init","版本","仍然"," ","部分","何时","使用","中","看到","用于","18","行为","“","额外","不错","4.0","ipython","string","所","变为","装饰","这些","class","该值","把","消息","delf","python","匹配","none","去","(","object","以便","尽可","已","12","计算","只读","函数","在","t","9","<","getf","原则","delete","看起","实际","开","most","为","必须","可以","处理","已经","或类","：","str","程序","老","该","重新","让","支持","认识","起来","必要","看起来","或","traceback","（","将会","和","带来","运算符","typeerror","radius","line","代表","还","接口","例如","has","关联","monty","调用","一样","属性","相关","请","一个","”","s","\"","设置","以","spam","。","input","be","算符","所示","根据","运算","不必要","使用者","遵循","isinstance","完全","用者","访问","%","set","提供","area","有点","生成","值","返回","self","由","-","所谓","如","、","a","preimeter","名称","就","传入","尽可能","试图","—","添加","很少","删除","它","last","原样","总是",")","pi","执行","静态方法","注意","del","这个","对","通常","的","实现","无需","发现","a48ffb0076e6","call","11","n","特性","附加","除非","参数","@","方法","权","填入","__","编程","没有","这样","不会","了解","包装","本身","时会","c","10","5","deleter","can","绑定","name","一种","很难","将","费力","后台","原始","简单","指定","no","0dac39a0c579","作为","import","对象","=","math","#","x","这种","错误","混淆","上","操作","20","静态",".","向",",","到","是","隐式","unexpected","不必","classmethod","正在","被","解决","像","45","代码","用户","显示","然后","某些","于","器","eof","method","以前","in","get","变量","需要","attribute","可能","得到","进行",".__","getname","如果","一组","syntaxerror","^",":","file","地"],"title":"特性","title_tokens":["特性"]},{"location":"Python基础/4.1.类.html#_9","text":"默认情况下，类的所有属性和方法都是“公共的”。这意味着对它们的访问没有任何限制。这还暗示着，在基类中定义的所有内容都会被派生类继承，并可从派生类内进行访问。在面向对象的应用程序中，通常我们不希望发生这种行为，因为它会暴露对象的内部实现，可能导致在派生类中定义的对象与在基类中定义的对象之间发生命名空间冲突。 为了解决该问题，==类中所有以双下划线开头的名称（如 __Foo ）都会自动变形，形成具有 _Classname__Foo 形式的新名称。==这提供了一种在类中添加私有属性和方法的有效方式，因为派生类中使用的私有名称不会与基类中使用的相同私有名称发生冲突，如下所示： class A ( object ): def __init__ ( self ): self . __X = 3 # 变形为self._A__X def __spam ( self ): # 变形为_A__spam() pass def bar ( self ): self . __spam () # 只调用A.__spam() class B ( A ): def __init__ ( self ): A . __init__ ( self ) self . __X = 37 # 变形为self._B__X def __spam ( self ): # 变形为_B__spam() pass 尽管这种方案似乎隐藏了数据，但并没有严格的机制来实际阻止对类的“私有”属性进行访问。特别是如果已知类名称和相应私有属性的名称，则可以使用变形后的名称来访问它们。通过重定义 dir() 方法，类可以降低这些属性的可见性， dir() 方法提供了检查对象的 dir() 函数所返回的名称列表。 尽管这种名称变形似乎是一个额外的处理步骤，但变形过程实际上只在定义类时发生一次。它不会在方法执行期间发生，也不会为程序的执行添加额外的开销。而且要知道，名称变形不会在 getattr() 、 hasattr() 、 setattr() 或 delattr() 等函数中发生，在这些函数中，属性名被指定为字符串。对于这些函数，需要显式使用变形名称（如 __Classname__name ）来访问属性。 建议在定义可变属性时，通过特性来使用私有属性。这样，就可鼓励用户使用特性名称，而无需直接访问底层实例数据（如果你在实例开头添加了一个特性，可能不想采用这种访问方式）。 ==通过为方法提供私有名称，超类可以阻止派生类重新定义和更改方法的实现。==例如，示例中的 A.bar() 方法只调用 A.__spam() ，无论 self 具有何种类型，或者派生类中是否存在不同的 __spam() 方法都是如此。 最后，不要混淆私有类属性的命名和模块中“私有”定义的命名。一个常见的错误是，在定义类时，在属性名上使用单个前导下划线来隐藏属性值（如 _name ）。==在模块中，这种命名约定可以阻止通过 from module import * 语句导出名称。==但是在类中，这种命名约定既不能隐藏属性，在某个类继承该类并使用相同名称定义一个新属性或方法时，也不能阻止出现名称冲突。","text_tokens":["是否","37","特别","通常","或","只","相同","可变","如此","对类","类","的","它们","实现","delattr","（","建议","b","和","私有","字符串","无需","不","无论","降低","但是","内容","最后","*","特性","定义","而且","module","名上","空间","来","意味着","公共","类时","或者","限制","性","采用","知道","模块","你","重","因为","方法","还","应用","数据","派生","）","__","鼓励","没有","_","对于","发生","def","init","而","新","这样","不会","例如","foo","下","检查","，"," ","之间","使用","中","导出","调用","派生类","列表","等","下划","出现","行为","问题","“","属性","额外","都","一个","”","暗示","bar","存在","不要","spam","。","形成","前导","name","直接","所有","默认","应用程序","基类","一种","导致","也","则","形式","所示","隐藏","后","指定","getattr","一次","类型","命名","面向","所","阻止","名","import","对象","这些","具有","class","示例","常见","=","#","x","有效","这种","混淆","访问","时","错误","相应","以双","继承","提供","超类","(","object","某个","情况","dir",".","自动","是","方式","开销","似乎","不能","值","语句","内部","从","它会","setattr","返回","被","解决","._","类中","self","在","函数","实例","并","既","实际上","希望","了","如","用户","通过","classname","意味","、","hasattr","但","实际","a","3","为","单个","底层","名称","面向对象","可","如下","就","更改","何种","下划线","不同","可以","字符","处理","严格","显式","与","变形","这","我们","需要","程序","发生冲突","机制","可能","不想","添加","冲突","过程","from","该","该类","步骤","它","进行","内","可见","方案","暴露",".__","期间","要","重新","任何","为了",")","pass","如果","已知","执行","划线","尽管","开头","约定","会",":","暗示着","对","："],"title":"数据封装和私有属性","title_tokens":["和","私有","封装","数据","属性"]},{"location":"Python基础/4.1.类.html#_10","text":"从内部实现上看，实例是使用字典来实现的，可以通过实例的 __dict__ 属性访问该字典。这个字典包含的数据对每个实例而言都是唯一的，如下所示： >>> a = Account ( 'Guido' , 1100.0 ) >>> a . __dict__ { 'balance' : 1100.0 , 'name' : 'Guido' } 可以在任何时候向实例添加新属性，例如： a . number = 123456 　　 #' 将属性'number'添加到 a.__dict__ 对实例的修改始终会反映到局部 __dict__ 属性中。同样，如果直接对 __dict__ 进行修改，所做的修改也会反映在实例的属性中。 实例通过特殊属性 __class__ 链接回它们的类。类本身也只是对字典的浅层包装，你可以在实例的 __dict__ 属性中找到这个字典。可以在类字典中找到各种方法。例如： >>> a . __class__ < class ' __main__ . Account '> >>> Account . __dict__ . keys () [ '__dict__' , '__module__' , 'inquiry' , 'deposit' , 'withdraw' , '__del__' , 'num_accounts' , '__weakref__' , '__doc__' , '__init__' ] 最后，通过特殊属性 __bases__ 中将类链接到它们的基类，该属性是一个基类元组。这种底层结构是获取、设置和删除对象属性的所有操作的基础。 只要使用 obj.name = value 设置了属性，特殊方法 obj.__setattr__(\"name\", value) 就会被调用。如果使用 del obj.name 删除了一个属性，就会调用特殊方法 obj.__delattr__(\"name\") 。这些方法的默认行为是修改或删除 obj 的局部 __dict__ 的值，除非请求的属性正好是一个特性或描述符。在这种情况下，设置和删除操作将由与该特性相关联的设置和删除函数执行。 在查找属性（如 obj.name ）时，将调用特殊方法 obj.__getattrribute__(\"name\") 。该方法执行搜索来查找该属性，这通常涉及检查特性、查找局部 __dict__ 属性、检查类字典以及搜索基类。如果搜索过程失败，最终会尝试调用类的 __getattr__() 方法（如果已定义）来查找该属性。如果这也失败，就会抛出 AttributeError 异常。 如果有必要，用户定义的类可以实现其自己的属性访问函数。例如： class Circle ( object ): def __init__ ( self , radius ): self . radius = radius def __getattr__ ( self , name ): if name == 'area' : return math . pi * self . radius ** 2 elif name == 'perimeter' : return 2 * math . pi * self . radius else : return object . __getattr__ ( self , name ) def setattr__ ( self , name , value ): if name in [ 'area' , 'perimeter' ]: raise TypeError ( \" %s is readonly\" % name ) object . __setattr__ ( self , name , value ) 重新实现这些方法的类应该可以依靠 object 中的默认实现来执行实际的工作。这是因为默认实现能够处理类的更高级特性，如描述符和特性。 一般来讲，类很少重新定义属性访问运算符。但是，在编写通用的包装器和现有对象的代理时，通常会使用属性访问运算符。通过重新定义 __getattr__() 、 __setattr__() 和 __delattr__() ，代理可以捕获属性访问操作，并透明地将这些操作转发给另一个对象。","text_tokens":["或","正好","通常","keys","类","的","它们","实现","value","包含","delattr","查找","转发","（","元组","结构","和","2","运算符","typeerror","但是","应该","radius","时候","唯一","最后","bases","特性","attributeerror","weakref","定义","*","module","来","除非","number","doc","有","]","浅层","异常","你","通用","因为","数据","方法","只要","相关联","elif","）","__","描述符","地","num","_","123456","def","init","新","代理","例如","dict","下","透明","关联","检查","，"," ","包装","本身","circle","使用","中","guido","链接","}","调用","{","行为","属性","都","相关","一个","s","\"","设置","。","是因为","name","直接","失败","所有","一般来讲","默认","算符","基类","也","一般","尝试","将","所示","而言","accounts","最终","运算","getattr","来讲","每个","请求","所","其","局部","对象","这些","class","中将","is","=","依靠","'","#","math","raise","看",">","只是","访问","这种","时","%","上","操作","抛出","反映","(","各种","object","area","涉及","perimeter","情况","修改",".","向",",","能够","到","是","高级","编写","特殊","deposit","[","值","内部","找到","已","从","setattr","else","被","字典","函数","self","实例","在","由","并","<","了","return","同样","balance","如","用户","工作","通过","　","、","实际","a","1100.0","自己","底层","obj","如下","就","描述","器","以及","account","可以","in","inquiry","处理","withdraw","更","获取","if","与","这","readonly","始终","getattrribute","回","添加","过程","很少","现有","该","捕获","删除","main","进行","基础","搜索","另",".__","重新","任何","如果",")","执行","pi","del","这个",":","会","做","发给","转发给","必要","对","："],"title":"对象表示和属性绑定","title_tokens":["和","表示","对象","绑定","属性"]},{"location":"Python基础/4.1.类.html#__slots__","text":"通过定义特殊变量 slots ，类可以限制对合法实例属性名称的设置，如下所示： class Account ( object ): 　　 __slots__ = ( 'name' , 'balance' ) 　　　 ... 定义 __slots__ 时，可以将实例上分配的属性名称限制为指定的名称，否则将引发 AttributeError 异常。这种限制可以阻止其他人向现有实例添加新属性，即便用户将属性名称写错，也不会创建出新的属性来。 在实际使用中， __slots__ 从未被当作一种安全的特性来实现。它实际上是对内存和执行速度的一种性能优化。 使用 __slots__ 的类的实例不再使用字典来存储实例数据，转而采用一种基于数组的更加紧凑的数据结构。在会创建大量对象的程序中，使用 __slots__ 可以显著减少减少内存占用和执行时间。 注意， __slots__ 与继承的配合使用需要一定的技巧。如果类继承自使用 __slots__ 的基类，那么它也需要定义 __slots__ 来存储自己的属性（即使它不会添加任何属性也是如此），这样才能利用 __slots__ 提供的优势。如果忘记了这一点，派生类的运行速度将更慢，占用的内存也更多，比完全不使用 __slots__ 时情况更糟。 __slots__ 的使用还会破坏期望实例具有底层 __dict__ 属性的代码。尽管这一点通常不适用于用户代码，但对于支持对象的实用库和其他工具，其代码可能要依靠 __dict__ 来调试、序列化对象以及执行其他操作。 最后，如果类中重新定义了 __getattribute__() 、 __getattr__() 和 __setattr__() 等方法， __slots__ 的存在不会对它们的调用产生任何影响。但是，这些方法的默认行为将考虑到 __slots__ 。此外应该强调一点，没有必要向 __slots__ 添加方法或特性名称，因为它们存储在类中，而不是存储在每个实例中。","text_tokens":["序列","或","通常","数组","如此","类","写错","的","它们","实现","数据结构","即使","引发","产生","大量","（","结构","和","即便","内存","slots","时间","不","但是","当作","应该","最后","attributeerror","安全","特性","定义","getattribute","来","调试","限制","采用","考虑","库","不是","异常","创建","因为","存储","数据","方法","派生","）","__","分配","没有","合法","对于","而","新","减少","这样","不会","dict","强调","从未","，"," ","更慢","运行","使用","中","调用","派生类","用于","等","否则","那么","行为","属性","...","存在","设置","他人","。","其他人","name","默认","基类","一种","也","将","所示","序列化","多","指定","破坏","才能","getattr","优化","期望","每个","其","阻止","对象","这些","此外","class","完全","具有","优势","=","依靠","'","显著","这种","时","上","操作","继承","提供","更加","(","object","情况","向",",","到","是","占用","特殊","忘记","不适","setattr","被","字典","类中","实例","在","实际上","自","代码","了","配合","影响","balance","用户","通过","　","工具","、","一定","利用","基于","实际","但","为","自己","底层","名称","如下","还会","以及","account","紧凑","可以","不再","更","变量","转而","与","这","需要","程序","实用","其他","可能","添加","现有","技巧","它","要","重新","任何","出新","比","如果",")","执行","速度","性能","更糟","支持","尽管","注意","一点",":","会","必要","对","："],"title":"__slots__","title_tokens":["slots","__"]},{"location":"Python基础/4.2.模块.html","text":"为什么需要模块 如果你想要编写一些更大的程序，肯定不想定义重复的函数、类，想让代码可以重复使用。随着程序变得越来越大，你可能想要将它分割成几个更易于维护的文件。为了满足这些需要，Python 提供了一个方法可以从文件中获取定义，在脚本或者解释器的一个交互式实例中使用。这样的文件被称为模块。 模块搜索路径 Python 怎样知道从何处找到模块文件？ 如果你熟悉命令行，那么这个问题对你来说就不难理解。在命令行中执行的任何命令，实际上背后都对应了一个可执行文件。命令行解释器（比如 cmd, bash）会从一个全局的环境变量 PATH 中读取一个有序的列表。这个列表包含了一系列的路径，而命令行解释器，会依次在这些路径里，搜索需要的可执行文件。 Python 搜寻模块文件，也遵循了类似的思路。比如，用户在 Python 中尝试导入 import foobar，那么 首先，Python 会在内建模块中搜寻 foobar； 若未找到，则 Python 会在当前工作路径（当前脚本所在路径，或者执行 Python 解释器的路径）中搜寻 foobar； 若仍未找到，则 Python 会在环境变量 PYTHONPATH 中指示的路径中搜寻 foobar； 若依旧未能找到，则 Python 会在安装时指定的路径中搜寻 foobar； 若仍旧失败，则 Python 会报错，提示找不到 foobar 这个模块。 添加搜索路径 当我们使用import加载自己编写的py代码时，必须放在python的默认路径下才可以import。 添加临时路径—— sys.path.append 在python中引入 sys ， sys 中的 path 是一个列表类型的对象，内容就是路径的列表，我们将sys引入后查看就可以清楚的知道了： import sys print ( type ( sys . path )) sys . path <class 'list'> ['G:\\\\1.User\\\\Desktop 2\\\\Wiki\\\\04.Python', 'C:\\\\Users\\\\Android\\\\Desktop', 'G:\\\\Installed\\\\Anaconda3\\\\python37.zip', 'G:\\\\Installed\\\\Anaconda3\\\\DLLs', 'G:\\\\Installed\\\\Anaconda3\\\\lib', 'G:\\\\Installed\\\\Anaconda3', 'C:\\\\Users\\\\Android\\\\AppData\\\\Roaming\\\\Python\\\\Python37\\\\site- packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32\\\\lib', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\Pythonwin', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\IPython\\\\extensions'] 既然是list对象，那么使用append可以向列表添加新的元素，假设我们要添加的路径是r\"C:\\Users\\Android\\Desktop\"： import sys sys . path . append ( r \"C:\\Users\\Android\\Desktop\" ) 但这只是临时添加路径，如果重启编译器，添加的路径就会消失。 修改环境变量 在Windows10中，选择 ->控制面板\\系统和安全\\系统->高级系统设置->环境变量 ， # 找到path后选择编辑，添加新的路径。 但这种方法不能适用所有python的功能，因为这种方法并未将要查找的路径添加到python的Path系统环境中，在sys.path的列表中找不到相关路径的元素。也就是说这样做并没有将路径添加到python的搜索路径中。 添加永久搜索路径——增加.pth文件 在site-packages文件夹添加path文件，可以实现搜索路径的永久添加。方法如下： 先编辑一个扩展名为 .pth 的文本文件，在这个文本文件里面写上要添加的path就可以了，例如： 文本文件的文件名是：test.pth test.pth 文件的内容是： C:\\Users\\Android\\Desktop 接着获取python的site-packages文件夹的路径： import site site . getsitepackages () ['G:\\\\Installed\\\\Anaconda3', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site- packages'] 然后将 test.pth 文件放进 G:\\Installed\\Anaconda3\\lib\\site-packages 里面即可。 模块的导入 在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块(module)导入: 例如，我们要使用使用 sys 模块，那么首先要导入该模块： import sys 导入 sys 模块后，我们就有了 变量 sys 指向该模块，利用 sys 这个变量，就可以访问 sys 模块的所有功能。 也就是说导入整个模块的做法会导致命名空间的修改。 也可以一次性导入多个module： import os , sys , time 通过 as 关键字，可以在导入module的时候，给module定义别名： import sys as system 从某个模块中导入函数： 从某个模块中导入某个函数 from somemodule import somefunction 从某个模块中导入多个函数 from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入 from somemodule import * 一般而言，除了实验、排查，不推荐导入模块内的所有公开符号（没有前缀 _ 的那些）。因为导入模块会修改namespace，而通常你不知道模块定义了哪些符号、是否与当前的namespace有重名的符号。一旦有重名，那么，就会覆盖掉当前namespace的值。从而造成难以排查的错误 注意 出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果修改了的模块，需要重启解释器； 或者，如果你就是想交互式的测试这么一个模块，可以用 imp.reload() 重新加载，例如 import imp imp . reload ( modulename ) 。 模块的识别 和 Python 中的其它对象一样，Python 也为模块定义了一些形如 __foo__ 的变量。对于模块来说，最重要的就是它的名字 __name__ 了。每当 Python 执行脚本，它就会为该脚本赋予一个名字。对于「主程序」来说，这一脚本的 __name__ 被定义为 \"__main__\" ；对于被 import 进主程序的模块来说，这一脚本的 __name__ 被定义为脚本的文件名（base filename）。因此，我们可以用 if __name__ == \"__main__\": 在模块代码中定义一些测试代码。 例如：当我们在命令行运行 hello 模块文件时，Python解释器把一个特殊变量 __name__ 置为 __main__ ，而如果在其他地方导入该 hello 模块时， if 判断将失败。因此，这种 if 测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试，例如下面的示例脚本。 参考：(Python 中的黑暗角落（三）：模块与包)[https://liam0205.me/2017/07/23/modules-and-packages-of-python/] #!/usr/bin/env python3 - - coding: utf-8 - - ' a test module ' __author__ = 'Michael Liao' import sys def test (): args = sys . argv if len ( args ) == 1 : print ( 'Hello, world!' ) elif len ( args ) == 2 : print ( 'Hello, %s !' % args [ 1 ]) else : print ( 'Too many arguments!' ) if __name__ == '__main__' : test () Hello, world! 作用域 在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用，在Python中，是通过 _ 前缀来实现的。 正常的函数和变量名是公开的（public），可以被直接引用，比如： abc ， x123 ， PI 等； 类似 __xxx__ 这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的 __author__ ， __name__ 就是特殊变量， hello 模块定义的文档注释也可以用特殊变量 __doc__ 访问，我们自己的变量一般不要用这种变量名； 类似 _xxx 和 __xxx 这样的函数或变量就是非公开的（private），不应该被直接引用，比如 _abc ， __abc 等； 之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。 private函数或变量不应该被别人引用，那它们有什么用呢？请看例子 def _private_1 ( name ): return 'Hello, %s ' % name def _private_2 ( name ): return 'Hi, %s ' % name def greeting ( name ): if len ( name ) > 3 : return _private_1 ( name ) else : return _private_2 ( name ) 我们在模块里公开 greeting() 函数，而把内部逻辑用private函数隐藏起来了，这样，调用 greeting() 函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即： 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。 作为脚本来执行模块 当你使用以下方式运行 Python 模块时，模块中的代码便会被执行: python fibo.py <arguments> 模块中的代码会被执行，就像导入它一样，不过 此时 __name__ 被设置为 \"__main__\" 。 这相当于，如果你在模块后加入如下代码: if __name__ == \"__main__\" : import sys fib ( int ( sys . argv [ 1 ])) 就可以让此文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为 “main” 文件执行时才被调用: $ python fibo . py 50 1 1 2 3 5 8 13 21 34 如果模块被导入，不会执行这段代码: >>> import fibo >>> 这通常用来为模块提供一个便于测试的用户接口（将模块作为脚本执行测试需求）。 “编译的” Python 文件—— pyc 文件 和 LaTeX 中遇到的问题一样：装载大量文本文件（ .py 文件）是很慢的。因此 Python 也采用了类似 LaTeX 的解决方案：将模块编译成容易装载的文件，并在 __pycache__ 目录下以 module.*version*.pyc 名字缓存这些文件。（相当于 LaTeX 中的 dump 格式文件 .fmt ）。 这里的版本编制了编译后文件的格式。它通常会包含 Python 的版本号。例如，在 CPython 3.3 版中，spam.py 编译后的版本将缓存为 __pycache__/spam.cpython-33.pyc 。这种命名约定允许由不同发布和不同版本的 Python 编译的模块同时存在。 当 Python 编译好模块之后，下次载入时，Python 就会读取相应的 .pyc 文件，而不是 .py 文件。而装载 .pyc 文件会比装载 .py 文件更快。 Python 会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。 这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。 Python 不检查在两个不同环境中的缓存。首先，它会永远重新编译而且不会存储直接从命令行加载的模块。其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源文件的模块。 部分高级技巧: 为了减少一个编译模块的大小，你可以在 Python 命令行中使用 -O 或者 -OO 。 -O 参数删除了断言语句， -OO 参数删除了断言语句和 doc 字符串。 因为某些程序依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。“优化的” 模块有一个 .pyo 后缀而不是 .pyc 后缀。未来的版本可能会改变优化的效果。 来自 .pyc 文件或 .pyo 文件中的程序不会比来自 .py 文件的运行更快； .pyc 或 .pyo 文件只是在它们加载的时候更快一些。 compileall 模块可以为指定目录中的所有模块创建 .pyc 文件（或者使用 -O 参数创建 .pyo 文件）。 在 PEP 3147 中有很多关这一部分内容的细节，并且包含了一个决策流程。","text_tokens":["适用","从文件","本文","全部","07","args","放进","段","34","它们","前缀","大量","译成","2","很","不","永久","bash","说","并未","*","消失","定义","引入","abc","外部","快","或者","imp","既然","也就是说","print","考虑","一般而言","当于","进","存储","架构","site","那","即","一旦","8","给","封装","减少","extensions","version","foo","慢","/","检查","，","appdata","运行","zip","细节","难以","那么","问题","reload","分割","别人","coding","pyo","filename","需求","user","默认","一般","尝试","多个","发布","隐藏","dump","两个","很多","而言","仍","允许","一系列","一些","每个","compileall","pycache","越来","这是","'",">","只是","时","版本号","里","3.3","置","报错","某个","其次","自动","类似","高级","方式","之后","wiki","名字","特殊","同时","引用","语句","抽象","交互式","greeting","实例","源","实际上","希望","了","return","首先","通过","便于","同一个","？","即可","这一","作用域","但","3","识别","usr","如下","不同","用","下才","packages","fib","更","if","符号","dlls","可用性","与","解决方案","一系","这","这里","lib","liam0205","未来","若","其他","roaming","me","选项","想","；","要","重要","方案","任何","arguments","系列","主程序","越来越","约定","foobar","可执行文件","假设","会","做","关","1","存在","23","2017","会话","自动化","从而","平台","类","决策","不用","上面","liao","易于","下面","格式文件","字符串","用途","交互","https","应该","utf","公开","module","例子","空间","来","!","「","文件夹","有","doc","]","采用","secondfunc","覆盖","更大","读取","导入","创建","）","格式","系统","而","def","新","编辑","控制面板","版本","list","and"," ","那些","部分","使用","latex","中","确定","一次性","xxx","“","of","下以","额外","...","不难","test","正常","windows10","变得","也","可用","临时","名为","33","ipython","命令行","类型","缓存","指向","time","21","关心","这些","class","不到","依赖于","实验","把","getsitepackages","python","关键","编译成","在内","重复","三","hello","一部","(","sys","修改","整个","用来","」","函数","在","背后","并","<","环境变量","private","解释器","此","依赖","最","释器","base","实际","必须","为","版中","当前","argv","未找到","改变","面板","len","可以","pythonpath","50","字符","每当","加载","cpython","我们","程序","包","desktop","该","日期","内","重新","让","增加","int","支持","源文件","起来","这么","排查","载入","是否","或","py","modulename","bin","many","什么","地方","关键字","包含","角落","（","和","目录","过期","内容","时候","版","而且","大小","共享","限制","知道","同一","你","文本","出于","elif","接口","全局","加入","因此","_","例如","对应","下","编译","控制","michael","之间","逻辑","调用","哪些","是非","所在","一样","放在","重名","清楚","env","相关","推荐","请","一个","”","s","\"","public","设置","以","spam","。","重启","直接","为什么","文件名","后","编制","容易","cmd","注释","一次","习惯","安装","遵循","源目录","somefunction","断言","完全","示例","不过","users","熟悉","相当","访问","os","%","后缀","除了","提供","元素","变量名","type","win32","值","仍旧","找到","成","else","从","它会","路径","维护","重复使用","由","非常","-","作用","几个","x123","android","工作","如","、","13","a","思路","测试","造成","就","判断","此时","跨平台","python37","黑暗","来说","依次","3147","呢","—","指示","查看","先","当","环境","做法","system","添加","时才","过程","删除","它","main","装载","赖于","为了",")","执行","就是","性能","pi","找","注意","这个","形","path","对","o","通常","只","的","里面","pep","实现","查找","才","将要","一遍","但是","文件","其它","件夹","想要","安全","$","somemodule","称为","功能","便会","别名","就是说","环境变","namespace","库","永远","不是","模块","firstfunc","参数","因为","g","too","方法","之所以","有用","python3","__","编程","比如","没有","对于","world","这样","不会","并且","仅仅","流程","接着","测试代码","理解","场合","效果","c","oo","行文","等","下次","肯定","r","都","5","选择","无误","不要","\\","是因为","建","name","失败","所有","一种","导致","则","参考","将","以下","04","thirdfunc","有序","指定","pyc","命令","优化","命名","作为","解释","import","对象","提示","编译器","fibo","as","常见","=","pth","append","#","看","这种","错误","赋予","写","相应","上","installed","搜寻","好","来自",".","向",",","编写","大","是","到","不能","掉","[","满足","依旧","modules","内部","当前工作","hi","被","解决","像","代码","用户","相当于","不难理解","然后","随着","利用","脚本","某些","怎样","自己","未能","pythonwin","fmt","获取","只有","变量","遇到","中有","需要","不想","可能","from","所以","一部分","技巧","搜索","比","文档","扩展","author","如果","anaconda3","制面","文本文件",":","何处","列表","："],"title":"4.2.模块","title_tokens":[".","模块","4.2"]},{"location":"Python基础/4.2.模块.html#_1","text":"如果你想要编写一些更大的程序，肯定不想定义重复的函数、类，想让代码可以重复使用。随着程序变得越来越大，你可能想要将它分割成几个更易于维护的文件。为了满足这些需要，Python 提供了一个方法可以从文件中获取定义，在脚本或者解释器的一个交互式实例中使用。这样的文件被称为模块。","text_tokens":["一些","、","随着","释器","从文件","脚本","这样","解释","这些","类","的","越来","，"," ","被","易于","python","可以","使用","中","重复","更","获取","文件","提供","交互","肯定","想要","需要","程序","分割","定义","编写","大","一个","不想","可能","称为","或者","。","想","它","成","满足","变得","维护","重复使用","交互式","更大","让","函数","如果","越来越","你","为了","将","在","实例","几个","方法","模块","代码","了","解释器"],"title":"为什么需要模块","title_tokens":["模块","什么","为什么","需要"]},{"location":"Python基础/4.2.模块.html#_2","text":"Python 怎样知道从何处找到模块文件？ 如果你熟悉命令行，那么这个问题对你来说就不难理解。在命令行中执行的任何命令，实际上背后都对应了一个可执行文件。命令行解释器（比如 cmd, bash）会从一个全局的环境变量 PATH 中读取一个有序的列表。这个列表包含了一系列的路径，而命令行解释器，会依次在这些路径里，搜索需要的可执行文件。 Python 搜寻模块文件，也遵循了类似的思路。比如，用户在 Python 中尝试导入 import foobar，那么 首先，Python 会在内建模块中搜寻 foobar； 若未找到，则 Python 会在当前工作路径（当前脚本所在路径，或者执行 Python 解释器的路径）中搜寻 foobar； 若仍未找到，则 Python 会在环境变量 PYTHONPATH 中指示的路径中搜寻 foobar； 若依旧未能找到，则 Python 会在安装时指定的路径中搜寻 foobar； 若仍旧失败，则 Python 会报错，提示找不到 foobar 这个模块。","text_tokens":["的","包含","（","文件","bash","或者","环境变","知道","模块","读取","你","导入","）","全局","比如","而","对应","，"," ","理解","中","所在","行文","那么","问题","都","不难","一个","。","建","失败","也","尝试","则","有序","仍","指定","cmd","命令行","命令","一系列","安装","遵循","解释","import","这些","提示","不到","熟悉","python","在内","时","里","搜寻","报错",",","类似","仍旧","找到","依旧","从","当前工作","路径","在","背后","实际上","环境变量","了","首先","解释器","用户","工作","不难理解","？","释器","脚本","实际","怎样","思路","未能","当前","就","未找到","pythonpath","来说","依次","变量","一系","需要","指示","若","环境","搜索","；","任何","对","系列","如果","执行","foobar","可执行文件","找","这个","会","path","何处","列表"],"title":"模块搜索路径","title_tokens":["搜索","路径","模块"]},{"location":"Python基础/4.2.模块.html#_3","text":"当我们使用import加载自己编写的py代码时，必须放在python的默认路径下才可以import。","text_tokens":["py","import","必须","自己","的","，","python","使用","可以","时","下才","加载","放在","我们","编写","当","。","路径","默认","代码"],"title":"添加搜索路径","title_tokens":["搜索","路径","添加"]},{"location":"Python基础/4.2.模块.html#syspathappend","text":"在python中引入 sys ， sys 中的 path 是一个列表类型的对象，内容就是路径的列表，我们将sys引入后查看就可以清楚的知道了： import sys print ( type ( sys . path )) sys . path <class 'list'> ['G:\\\\1.User\\\\Desktop 2\\\\Wiki\\\\04.Python', 'C:\\\\Users\\\\Android\\\\Desktop', 'G:\\\\Installed\\\\Anaconda3\\\\python37.zip', 'G:\\\\Installed\\\\Anaconda3\\\\DLLs', 'G:\\\\Installed\\\\Anaconda3\\\\lib', 'G:\\\\Installed\\\\Anaconda3', 'C:\\\\Users\\\\Android\\\\AppData\\\\Roaming\\\\Python\\\\Python37\\\\site- packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\win32\\\\lib', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\Pythonwin', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site-packages\\\\IPython\\\\extensions'] 既然是list对象，那么使用append可以向列表添加新的元素，假设我们要添加的路径是r\"C:\\Users\\Android\\Desktop\"： import sys sys . path . append ( r \"C:\\Users\\Android\\Desktop\" ) 但这只是临时添加路径，如果重启编译器，添加的路径就会消失。","text_tokens":["的","2","内容","消失","引入","既然","print","]","知道","g","site","新","extensions","list","编译","，"," ","appdata","使用","zip","中","c","列表","那么","r","清楚","一个","\"","user","\\","。","重启","临时","将","后","04","ipython","类型","import","对象","class","编译器","users","'","append","python",">","只是","installed","(","元素","type","sys",".","向",",","win32","是","wiki","[","路径","在","-","<","了","但","就","pythonwin","可以","packages","python37","dlls","我们","这","lib","查看","desktop","roaming","添加","要","anaconda3",")","就是","如果","假设",":","会","1","path","android","："],"title":"添加临时路径——sys.path.append","title_tokens":[".","append","临时","—","添加","path","路径","sys"]},{"location":"Python基础/4.2.模块.html#_4","text":"在Windows10中，选择 ->控制面板\\系统和安全\\系统->高级系统设置->环境变量 ， # 找到path后选择编辑，添加新的路径。 但这种方法不能适用所有python的功能，因为这种方法并未将要查找的路径添加到python的Path系统环境中，在sys.path的列表中找不到相关路径的元素。也就是说这样做并没有将路径添加到python的搜索路径中。","text_tokens":["没有","系统","适用","新","但","这样","编辑","控制面板","的","不到","查找","控制","，"," ","面板","将要","#","python","和",">","这种","中","变量","元素","并未","安全","sys",".","相关","高级","到","选择","环境","不能","添加","功能","\\","设置","windows10","找到","。","也就是说","搜索","路径","所有","就是说","环境变","在","就是","因为","-","找","并","后","制面","方法","环境变量","将","做","path","列表"],"title":"修改环境变量","title_tokens":["环境","环境变量","变量","环境变","修改"]},{"location":"Python基础/4.2.模块.html#pth","text":"在site-packages文件夹添加path文件，可以实现搜索路径的永久添加。方法如下： 先编辑一个扩展名为 .pth 的文本文件，在这个文本文件里面写上要添加的path就可以了，例如： 文本文件的文件名是：test.pth test.pth 文件的内容是： C:\\Users\\Android\\Desktop 接着获取python的site-packages文件夹的路径： import site site . getsitepackages () ['G:\\\\Installed\\\\Anaconda3', 'G:\\\\Installed\\\\Anaconda3\\\\lib\\\\site- packages'] 然后将 test.pth 文件放进 G:\\Installed\\Anaconda3\\lib\\site-packages 里面即可。","text_tokens":["然后","即可","本文","例如","编辑","import","放进","的","里面","实现","如下","就","users","，"," ","接着","getsitepackages","pth","'","python","可以","packages","写","c","获取","上","永久","文件","installed","内容","件夹","(","lib",".",",","是","一个","先","desktop","test","添加","\\","[","文件夹","。","搜索","要","路径","]","扩展","anaconda3","在",")","名为","文件名","-","文本","g","方法","将","文本文件","了","这个",":","site","path","android","："],"title":"添加永久搜索路径——增加.pth文件","title_tokens":[".","增加","添加","永久","文件","pth","搜索","路径","—"]},{"location":"Python基础/4.2.模块.html#_5","text":"在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块(module)导入: 例如，我们要使用使用 sys 模块，那么首先要导入该模块： import sys 导入 sys 模块后，我们就有了 变量 sys 指向该模块，利用 sys 这个变量，就可以访问 sys 模块的所有功能。 也就是说导入整个模块的做法会导致命名空间的修改。 也可以一次性导入多个module： import os , sys , time 通过 as 关键字，可以在导入module的时候，给module定义别名： import sys as system 从某个模块中导入函数： 从某个模块中导入某个函数 from somemodule import somefunction 从某个模块中导入多个函数 from somemodule import firstfunc , secondfunc , thirdfunc 将某个模块中的全部函数导入 from somemodule import * 一般而言，除了实验、排查，不推荐导入模块内的所有公开符号（没有前缀 _ 的那些）。因为导入模块会修改namespace，而通常你不知道模块定义了哪些符号、是否与当前的namespace有重名的符号。一旦有重名，那么，就会覆盖掉当前namespace的值。从而造成难以排查的错误","text_tokens":["是否","全部","通常","关键字","从而","的","前缀","（","不","时候","*","公开","定义","module","somemodule","空间","来","功能","或者","有","也就是说","别名","就是说","secondfunc","排查","一般而言","namespace","覆盖","知道","模块","firstfunc","你","导入","因为","）","一旦","没有","_","而","给","例如"," ","，","那些","使用","中","哪些","难以","一次性","那么","重名","推荐","...","。","所有","导致","也","一般","将","多个","后","而言","thirdfunc","一次","命名","指向","time","somefunction","import","as","实验","python","关键","错误","访问","os","相应","除了","(","某个","sys","修改",",","整个","掉","值","从","函数","在","了","首先","通过","、","利用","造成","当前","就","用","可以","符号","变量","与","我们","system","做法","from","该","内","要",")","就是","这个",":","会","："],"title":"模块的导入","title_tokens":["导入","的","模块"]},{"location":"Python基础/4.2.模块.html#_6","text":"出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果修改了的模块，需要重启解释器； 或者，如果你就是想交互式的测试这么一个模块，可以用 imp.reload() 重新加载，例如 import imp imp . reload ( modulename ) 。","text_tokens":["每个","因此","释器","会话","只","modulename","解释","例如","import","的","测试","，"," ","可以","用","中","一遍","加载","交互","(","需要","reload","修改",".","一个","或者","imp","。","想","重启","；","考虑","重新","交互式","模块","在","如果","性能","导入","你","就是","出于",")","了","解释器","这么"],"title":"注意","title_tokens":["注意"]},{"location":"Python基础/4.2.模块.html#_7","text":"和 Python 中的其它对象一样，Python 也为模块定义了一些形如 __foo__ 的变量。对于模块来说，最重要的就是它的名字 __name__ 了。每当 Python 执行脚本，它就会为该脚本赋予一个名字。对于「主程序」来说，这一脚本的 __name__ 被定义为 \"__main__\" ；对于被 import 进主程序的模块来说，这一脚本的 __name__ 被定义为脚本的文件名（base filename）。因此，我们可以用 if __name__ == \"__main__\": 在模块代码中定义一些测试代码。 例如：当我们在命令行运行 hello 模块文件时，Python解释器把一个特殊变量 __name__ 置为 __main__ ，而如果在其他地方导入该 hello 模块时， if 判断将失败。因此，这种 if 测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试，例如下面的示例脚本。 参考：(Python 中的黑暗角落（三）：模块与包)[https://liam0205.me/2017/07/23/modules-and-packages-of-python/] #!/usr/bin/env python3 - - coding: utf-8 - - ' a test module ' __author__ = 'Michael Liao' import sys def test (): args = sys . argv if len ( args ) == 1 : print ( 'Hello, world!' ) elif len ( args ) == 2 : print ( 'Hello, %s !' % args [ 1 ]) else : print ( 'Too many arguments!' ) if __name__ == '__main__' : test () Hello, world!","text_tokens":["23","2017","bin","many","07","地方","args","的","liao","下面","角落","（","和","2","其它","文件","https","utf","定义","module","!","「","print","]","进","模块","导入","too","elif","python3","）","__","8","因此","对于","而","def","world","例如","foo","/","and","，"," ","测试代码","michael","运行","中","一样","of","额外","env","coding","一个","filename","test","\"","s","。","name","失败","也","参考","文件名","将","命令行","命令","一些","解释","import","对象","常见","示例","=","把","'","#","python","这种","赋予","时","三","%","hello","置","(","sys",".",",","名字","特殊","[","else","modules","」","被","在","-","代码","了","解释器","如","通过","最","这一","base","脚本","释器","a","为","测试","usr","argv","就","判断","len","可以","用","packages","每当","黑暗","来说","if","变量","与","我们","程序","liam0205","包","当","其他","me","该","它","main","；","重要","arguments","让","author","主程序","如果","就是","执行",")","会",":","形","1","："],"title":"模块的识别","title_tokens":["的","模块","识别"]},{"location":"Python基础/4.2.模块.html#_8","text":"在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用，在Python中，是通过 _ 前缀来实现的。 正常的函数和变量名是公开的（public），可以被直接引用，比如： abc ， x123 ， PI 等； 类似 __xxx__ 这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的 __author__ ， __name__ 就是特殊变量， hello 模块定义的文档注释也可以用特殊变量 __doc__ 访问，我们自己的变量一般不要用这种变量名； 类似 _xxx 和 __xxx 这样的函数或变量就是非公开的（private），不应该被直接引用，比如 _abc ， __abc 等； 之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。 private函数或变量不应该被别人引用，那它们有什么用呢？请看例子 def _private_1 ( name ): return 'Hello, %s ' % name def _private_2 ( name ): return 'Hi, %s ' % name def greeting ( name ): if len ( name ) > 3 : return _private_1 ( name ) else : return _private_2 ( name ) 我们在模块里公开 greeting() 函数，而把内部逻辑用private函数隐藏起来了，这样，调用 greeting() 函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即： 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。","text_tokens":["全部","或","什么","的","它们","实现","不用","才","上面","前缀","（","和","2","用途","不","但是","说","应该","公开","定义","例子","abc","来","外部","有","doc","限制","不是","模块","因为","之所以","方法","有用","）","__","那","编程","即","比如","没有","_","而","def","给","封装","这样","仅仅","，"," ","使用","逻辑","中","调用","是非","细节","等","xxx","“","别人","请","一个","”","public","s","不要","正常","。","是因为","name","直接","一种","也","一般","隐藏","很多","注释","习惯","关心","完全","把","'","python","看","这种",">","访问","%","hello","里","上","(","变量名",",","类似","是","特殊","不能","引用","内部","else","抽象","从","成","hi","被","greeting","函数","在","非常","x123","并","希望","private","了","return","代码","通过","？","但","3","自己","为","就","len","可以","用","只有","if","变量","我们","这","呢","需要","可能","所以","；","文档","author","pi","就是",")","会",":","起来","1","："],"title":"作用域","title_tokens":["作用域","作用"]},{"location":"Python基础/4.2.模块.html#_9","text":"当你使用以下方式运行 Python 模块时，模块中的代码便会被执行: python fibo.py <arguments> 模块中的代码会被执行，就像导入它一样，不过 此时 __name__ 被设置为 \"__main__\" 。 这相当于，如果你在模块后加入如下代码: if __name__ == \"__main__\" : import sys fib ( int ( sys . argv [ 1 ])) 就可以让此文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为 “main” 文件执行时才被调用: $ python fibo . py 50 1 1 2 3 5 8 13 21 34 如果模块被导入，不会执行这段代码: >>> import fibo >>> 这通常用来为模块提供一个便于测试的用户接口（将模块作为脚本执行测试需求）。","text_tokens":["py","通常","段","的","34","（","2","文件","$","便会","]","当于","模块","你","导入","接口","）","__","加入","8","不会","，"," ","运行","使用","中","调用","一样","“","5","”","一个","需求","\"","设置","。","name","将","以下","后","作为","21","import","fibo","不过","=","相当","python",">","时","提供","(","sys",".","方式","用来","[","被","像","在","<","代码","用户","此","相当于","便于","脚本","13","为","3","测试","如下","就","argv","此时","可以","50","fib","只有","if","这","当","时才","它","main","arguments","让","如果","int","执行",")",":","会","1"],"title":"作为脚本来执行模块","title_tokens":["模块","脚本","执行","作为","来"]},{"location":"Python基础/4.2.模块.html#python-pyc","text":"和 LaTeX 中遇到的问题一样：装载大量文本文件（ .py 文件）是很慢的。因此 Python 也采用了类似 LaTeX 的解决方案：将模块编译成容易装载的文件，并在 __pycache__ 目录下以 module.*version*.pyc 名字缓存这些文件。（相当于 LaTeX 中的 dump 格式文件 .fmt ）。 这里的版本编制了编译后文件的格式。它通常会包含 Python 的版本号。例如，在 CPython 3.3 版中，spam.py 编译后的版本将缓存为 __pycache__/spam.cpython-33.pyc 。这种命名约定允许由不同发布和不同版本的 Python 编译的模块同时存在。 当 Python 编译好模块之后，下次载入时，Python 就会读取相应的 .pyc 文件，而不是 .py 文件。而装载 .pyc 文件会比装载 .py 文件更快。 Python 会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。 这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。 Python 不检查在两个不同环境中的缓存。首先，它会永远重新编译而且不会存储直接从命令行加载的模块。其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源文件的模块。 部分高级技巧: 为了减少一个编译模块的大小，你可以在 Python 命令行中使用 -O 或者 -OO 。 -O 参数删除了断言语句， -OO 参数删除了断言语句和 doc 字符串。 因为某些程序依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。“优化的” 模块有一个 .pyo 后缀而不是 .pyc 后缀。未来的版本可能会改变优化的效果。 来自 .pyc 文件或 .pyo 文件中的程序不会比来自 .py 文件的运行更快； .pyc 或 .pyo 文件只是在它们加载的时候更快一些。 compileall 模块可以为指定目录中的所有模块创建 .pyc 文件（或者使用 -O 参数创建 .pyo 文件）。 在 PEP 3147 中有很多关这一部分内容的细节，并且包含了一个决策流程。","text_tokens":["载入","是否","o","本文","py","通常","只","自动化","或","决策","平台","的","它们","pep","包含","大量","格式文件","（","译成","字符串","和","很","目录","不","过期","文件","内容","应该","版","*","时候","而且","module","大小","快","共享","或者","doc","有","采用","当于","库","永远","不是","同一","模块","读取","你","参数","因为","文本","创建","存储","架构","）","__","格式","因此","没有","系统","而","减少","version","例如","慢","不会","版本","下","/","编译","并且","流程","检查"," ","，","部分","之间","场合","效果","使用","运行","latex","中","oo","确定","细节","下次","一样","问题","“","下以","一个","”","pyo","存在","无误","以","spam","。","直接","所有","也","可用","将","发布","dump","33","编制","后","两个","很多","容易","指定","命令行","缓存","pyc","允许","命令","优化","一些","命名","compileall","源目录","这些","断言","完全","pycache","依赖于","相当","这是","python","编译成","这种","只是","时","版本号","后缀","相应","一部","3.3","好","修改",".","其次","自动","来自","类似","高级","是","之后","名字","同时","语句","从","它会","解决","在","由","源","并","-","了","首先","依赖","相当于","同一个","这一","某些","为","必须","版中","就","改变","不同","跨平台","fmt","可以","字符","更","cpython","加载","只有","可用性","变量","解决方案","与","3147","这里","遇到","这","中有","需要","程序","未来","当","环境","若","可能","过程","选项","所以","一部分","技巧","它","删除","日期","要","方案","；","装载","重新","赖于","比","如果","约定","为了","支持","文本文件","源文件","会",":","关","："],"title":"“编译的” Python 文件——pyc 文件","title_tokens":["python","pyc","”","文件","的","编译"," ","“","—"]},{"location":"numpy笔记/5.1.创建数组.html","text":"import numpy as np 共同的参数 这里有几个共同的参数： a ：一个 array-like 类型的实例，它不一定是数组，可以为 list 、 tuple 、 list of tuple 、 list of list 、 tuple of list 、 tuple of tuple 等等。 dtype ：数组的值类型，默认为 float 。你可以指定Python的标准数值类型，也可以使用 numpy 的数值类型如： numpy.int32 或者 numpy.float64 等等。 order ：指定存储多维数据的方式。 - 'C' ，表示按行优先存储（C风格）； - 'F' ，表示按列优先存储（Fortran风格）。 - 对于 **_like() 函数， order 可以为： 'C' ， 'F' ， 'A' （表示结果的order与a相同）， 'K' （表示结果的 order 与 a 尽可能相似） subok ： bool 值。如果为 True 则：如果 a 为 ndarray 的子类（如 matrix 类），则结果类型与 a 类型相同。如果为 False 则：结果类型始终为 ndarray 。默认为True。 从现有的数据创建 np.array(object[, dtype, copy, order, subok, ndmin]) :从 object 创建。 - object 可以是一个 ndarray ，也可以是一个 array_like 的对象，也可以是一个含有返回一个序列或者 ndarray 的 __array__ 方法的对象，或者一个序列。 copy ：默认为 True ，表示拷贝对象 order 可以为 'C'、'F'、'A' 。默认为 'K' 。 subok 默认为 False ndmin ：指定结果 ndarray 最少有多少个维度。 np.asarray(a[, dtype, order]) ：将 a 转换成一个 ndarray 。其中 a 是 array_like 的对象， 可以是 list 、 list of tuple 、 tuple 、 tuple of list 、 ndarray 类型。 order 默认为 C 。 np.asanyarray(a[, dtype, order]) ：将 a 转换成 ndarray 。 np.ascontiguousarray(a[, dtype]) ：返回C风格的连续 ndarray 。 np.copy(a[, order]) ：返回 ndarray 的一份深拷贝。 以上5个方法实际上都是调用了 array() 的接口。 np . asarray () # array(a, dtype, copy=False, order=order) np . asanyarray () # array(a, dtype, copy=False, order=order, subok=True) np . ascontiguousarray () # array(a, dtype, copy=False, order='C', ndmin=1) np . copy () # array(a, order=order, copy=True) np.asmatrix(data[, dtype]) ：返回 matrix 。 np.frombuffer(buffer[, dtype, count, offset]) ：从输入数据中返回一维 ndarray 。 count 指定读取的数量， -1 表示全部读取； offset 指定从哪里开始读取，默认为0。 创建的数组与 buffer 共享内存。 buffer 是一个提供了 buffer 接口的对象（ 内置的 bytes/bytearray/array.array 类型提供了该接口 ）。 from array import array # array.array 提供了类似list对象的内存机制 a = array ( \"d\" , [ 1 , 2 , 3 , 4 ]) # 创建一个array数组 na = np . frombuffer ( a , dtype = np . float ) # 通过np.frombuffer()创建一个和a共享内存的NumPy数组 print ( \"a:\" , a ) print ( \"na:\" , na ) na [ 1 ] = 20 # 修改NumPy数组中的第一个元素 a # array数组中的第一个元素也同时改变 a : array ( 'd' , [ 1.0 , 2.0 , 3.0 , 4.0 ]) na : [ 1 . 2 . 3 . 4 .] array('d', [1.0, 20.0, 3.0, 4.0]) np.fromfile(file[, dtype, count, sep]) ：从二进制文件或者文本文件中读取数据返回 ndarray 。 sep ：当从文本文件中读取时，数值之间的分隔字符串，如果 sep 是空字符串则表示文件应该作为二进制文件读取；如果 sep 为 \" \" 表示可以匹配0个或者多个空白字符。 np.fromfunction(function, shape, \\**kwargs) ：返回一个 ndarray 。function会获取每一个坐标点的数据，作为输入参数。假设 shape 的维度为N，那么 function 带有 N 个参数， fn(x1,x2,...x_N) ，其返回值就是该坐标点的值。 def fun ( x , y ): return x + y np . fromfunction ( fun , shape = ( 3 , 3 )) array([[0., 1., 2.], [1., 2., 3.], [2., 3., 4.]]) np.fromiter(iterable, dtype[, count]) ：从可迭代对象中迭代获取数据创建一维 ndarray 。 np . fromiter ( \"123\" , dtype = \"int64\" ) array([1, 2, 3], dtype=int64) np.fromstring(string[, dtype, count, sep]) ：从字符串或者 raw binary 中创建一维 ndarray 。如果 sep 为空字符串则 string 将按照二进制数据解释（即每个字符作为 ASCII 码值对待）。创建的数组有自己的数据存储区。 a = \"abcdefg\" a = np . fromstring ( a , dtype = np . int8 ) # 将每个字符的ASCII编码解释为整数 print ( a ) a = \"1;2;3;4;5\" a = np . fromstring ( a , dtype = np . int8 , sep = \";\" ) print ( a ) [ 97 98 99 100 101 102 103] [1 2 3 4 5] .\\setup.py:2: DeprecationWarning: The binary mode of fromstring is deprecated, as it behaves surprisingly on unicode inputs. Use frombuffer instead \"\"\" np.loadtxt(fname[, dtype, comments, delimiter, ...]) :从文本文件中加载数据创建 ndarray ，要求文本文件每一行都有相同数量的数值。 comments ：指示注释行的起始字符，可以为单个字符或者字符列表（默认为 # ）。 delimiter :指定数值之间的分隔字符串，默认为空白符。 converters ：将指定列号(0,1,2...)的列数据执行转换，是一个 map ，如 {0:func1} 表示对第一列数据执行 func1(val_0) 。 skiprows ：指定跳过开头的多少行。 usecols ：指定读取那些列（0表示第一列）。 从数值区间创建 np.arange([start,] stop[, step,][, dtype]) :返回均匀间隔的值组成的一维 ndarray 。区间是半闭半开的 [start,stop) ，其采样行为类似Python的 range 函数。 start 为开始点， stop 为终止点， step 为步长，默认为1。这几个数可以为整数可以为浮点数。 注意如果 step 为浮点数，则结果可能有误差，因为浮点数相等比较不准确（计算机精度有限）。 np.linspace(start, stop[, num, endpoint, ...]) ：返回 num 个均匀采样的数值组成的一维 ndarray （默认为50）。区间是闭区间 [start,stop] 。 endpoint 为布尔值，如果为真则表示 stop 是最后采样的值（默认为 True ），否则结果不包含 stop 。 retstep 如果为 True 则返回结果包含采样步长 step ，默认为 True 。 np.logspace(start, stop[, num, endpoint, base, ...]) ：返回对数级别上均匀采样的数值组成的一维 ndarray 。采样点开始于 base^start ，结束于 base^stop 。 base 为对数的基，默认为 10。 它逻辑上相当于先执行 arange 获取数组 array ，然后再执行 base^array[i] 获取采样点 - 它没有 retstep 关键字参数 以填充的方式创建 np.empty(shape[,dtype,order]) ：返回一个新的 ndarray ，指定了 shape 和 dtype ，但是没有初始化元素。因此其内容是随机的。 np.empty_like(a[,dtype,order,subok]) ：返回一个新的 ndarray ， shape 与 a 相同，但是没有初始化元素。因此其内容是随机的。 # 内存未初始化 a = np . empty (( 3 , 2 ), order = \"C\" ) # 内存未初始化 np . empty_like ( a ) array([[0., 0.], [0., 0.], [0., 0.]]) np.eye(N[, M, k, dtype]) ：返回一个==二维数组==，对角线元素为1，其余元素为0。 M 默认等于 N 。 k 默认为0表示对角线元素为1，如为正数则表示对角线上方一格的元素为1，如为负数表示对角线下方一格的元素为1。 np.identity(n[, dtype]) ：返回一个单位矩阵。 np . eye ( N = 2 , M = 3 ) np . eye ( N = 2 , M = 3 , k = 0 ) # 参数k是可以超出范围的 np . eye ( N = 2 , M = 3 , k = 1 ) # 返回n阶单位矩阵 np . identity ( n = 4 ) array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) np.ones(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为1. np.ones_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为1。 np.zeros(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为0. np.zeros_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a （另一个数组）相同，每个元素初始化为0。 9 np.full(shape, fill_value[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为 fill_value 。 np.full_like(a, fill_value[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为 fill_value 。 np . full (( 2 , 3 ), fill_value = 2 ) array([[2, 2, 2], [2, 2, 2]])","text_tokens":["一行","全部","本文","float","相同","float64","count","随机","iterable","value","i","优先","fromfunction","闭","f","2","不","返回值","fortran","*","the","区间","na","shape","浮点","或者","print","当于","半闭","浮点数","均匀","存储","即","num","copy","布尔值","tuple","/","fun","，","再","use","迭代","range","填充","否则","那么","哪里","空","fromiter","subok","其中","默认","多个","每个","正数","setup","is","'","布尔","bytes","按行","时","m","102","bool","类似","方式","同时","等于","列号","实例","实际上","了","return","通过","子类","2.0","算机","linspace","3","arange","准确","identity","个","与","这里","行","这","usecols","start","；","数值","假设","会","计算机","其余","1","103","inputs","98","精度","类","x1","字符串","间隔","y","应该","最后","级别","kwargs","logspace","有","]","误差","读取","创建","数据","要求","范围","对数","）","retstep","def","点","新","数量","区","list","fname"," ","那些","使用","一份","中","组成","abcdefg","{","终止","行为","eye","of","...","fn","int64","full","也","x2","一列","4.0","string","类型","其","99","风格","123","python","匹配","关键","unicode","内置","获取数据","100","endpoint","(","object","order","修改","尽可","对待","采样","计算","函数","带有","9","int32","base","实际","loadtxt","为","单个","可","true","改变","可以","50","字符","加载","数","单位","机制","该","on","101","第一列","开头","阶","超出","py","数组","关键字","delimiter","包含","进制","（","offset","和","内存","按照","转换","内容","深","开始","有限","共享","相等","dtype","你","文本","0","一格","接口","对角",";","因此","_","ndarray","numpy","ones","converters","1.0","之间","共享内存","function","逻辑","多维","调用","val","一个","\"","buffer","分隔","raw","编码","。","起始","以","二维","ascii","bytearray","注释","多少","步长","未","维度","为空","sep","负数","相当","跳过","提供","元素","step","type","false","值","从","返回","func1","-","几个","如","以上","surprisingly","空白符","、","一定","zeros","二进制","a","换成","列","fill","mode","结束","20.0","like","尽可能","3.0","超出范围","始终","指示","先","当","按列","现有","d","它","初始化",")","就是","执行","每","第一","注意","empty","对","序列","矩阵","asarray","的","坐标","码值","但是","文件","n","初始","读取数据","fromstring","stop","参数","因为","方法","behaves","__","没有","对于","skiprows","等等","array","含有","转换成","deprecationwarning","}","c","上方","it","整数","都","10","如为","5","空白","\\","下方","相似","frombuffer","ndmin","则","最少","将","4","data","指定","int8","拷贝","作为","表示","输入","解释","import","对象","结果","真则","as","共同","=","连续","#","x","单位矩阵","基","上","20",".",",","是","对角线","[","比较","97","map","ascontiguousarray","相当于","k","一维","然后","于","自己","instead","deprecated","+","获取","fromfile","binary","第一个","半开","可能","from","另","如果","asmatrix","comments","matrix","^","文本文件","点数",":","asanyarray","标准","np","列表","file","："],"title":"5.1.创建数组","title_tokens":[".","创建","5.1","数组"]},{"location":"numpy笔记/5.1.创建数组.html#_1","text":"这里有几个共同的参数： a ：一个 array-like 类型的实例，它不一定是数组，可以为 list 、 tuple 、 list of tuple 、 list of list 、 tuple of list 、 tuple of tuple 等等。 dtype ：数组的值类型，默认为 float 。你可以指定Python的标准数值类型，也可以使用 numpy 的数值类型如： numpy.int32 或者 numpy.float64 等等。 order ：指定存储多维数据的方式。 - 'C' ，表示按行优先存储（C风格）； - 'F' ，表示按列优先存储（Fortran风格）。 - 对于 **_like() 函数， order 可以为： 'C' ， 'F' ， 'A' （表示结果的order与a相同）， 'K' （表示结果的 order 与 a 尽可能相似） subok ： bool 值。如果为 True 则：如果 a 为 ndarray 的子类（如 matrix 类），则结果类型与 a 类型相同。如果为 False 则：结果类型始终为 ndarray 。默认为True。","text_tokens":["数组","float","相同","float64","类","的","（","优先","f","不","fortran","*","或者","有","参数","dtype","你","存储","数据","）","_","对于","tuple","ndarray","等等","numpy","list","array","，"," ","使用","多维","c","of","一个","subok","。","默认","相似","也","则","指定","类型","表示","结果","风格","共同","'","python","按行","(","order","bool",".","是","方式","false","尽可","值","函数","实例","-","几个","如","k","子类","、","一定","int32","a","为","true","可以","like","尽可能","与","这里","始终","可能","按列","它","；","数值","如果",")","matrix","标准","："],"title":"共同的参数","title_tokens":["共同","的","参数"]},{"location":"numpy笔记/5.1.创建数组.html#_2","text":"np.array(object[, dtype, copy, order, subok, ndmin]) :从 object 创建。 - object 可以是一个 ndarray ，也可以是一个 array_like 的对象，也可以是一个含有返回一个序列或者 ndarray 的 __array__ 方法的对象，或者一个序列。 copy ：默认为 True ，表示拷贝对象 order 可以为 'C'、'F'、'A' 。默认为 'K' 。 subok 默认为 False ndmin ：指定结果 ndarray 最少有多少个维度。 np.asarray(a[, dtype, order]) ：将 a 转换成一个 ndarray 。其中 a 是 array_like 的对象， 可以是 list 、 list of tuple 、 tuple 、 tuple of list 、 ndarray 类型。 order 默认为 C 。 np.asanyarray(a[, dtype, order]) ：将 a 转换成 ndarray 。 np.ascontiguousarray(a[, dtype]) ：返回C风格的连续 ndarray 。 np.copy(a[, order]) ：返回 ndarray 的一份深拷贝。 以上5个方法实际上都是调用了 array() 的接口。 np . asarray () # array(a, dtype, copy=False, order=order) np . asanyarray () # array(a, dtype, copy=False, order=order, subok=True) np . ascontiguousarray () # array(a, dtype, copy=False, order='C', ndmin=1) np . copy () # array(a, order=order, copy=True) np.asmatrix(data[, dtype]) ：返回 matrix 。 np.frombuffer(buffer[, dtype, count, offset]) ：从输入数据中返回一维 ndarray 。 count 指定读取的数量， -1 表示全部读取； offset 指定从哪里开始读取，默认为0。 创建的数组与 buffer 共享内存。 buffer 是一个提供了 buffer 接口的对象（ 内置的 bytes/bytearray/array.array 类型提供了该接口 ）。 from array import array # array.array 提供了类似list对象的内存机制 a = array ( \"d\" , [ 1 , 2 , 3 , 4 ]) # 创建一个array数组 na = np . frombuffer ( a , dtype = np . float ) # 通过np.frombuffer()创建一个和a共享内存的NumPy数组 print ( \"a:\" , a ) print ( \"na:\" , na ) na [ 1 ] = 20 # 修改NumPy数组中的第一个元素 a # array数组中的第一个元素也同时改变 a : array ( 'd' , [ 1.0 , 2.0 , 3.0 , 4.0 ]) na : [ 1 . 2 . 3 . 4 .] array('d', [1.0, 20.0, 3.0, 4.0]) np.fromfile(file[, dtype, count, sep]) ：从二进制文件或者文本文件中读取数据返回 ndarray 。 sep ：当从文本文件中读取时，数值之间的分隔字符串，如果 sep 是空字符串则表示文件应该作为二进制文件读取；如果 sep 为 \" \" 表示可以匹配0个或者多个空白字符。 np.fromfunction(function, shape, \\**kwargs) ：返回一个 ndarray 。function会获取每一个坐标点的数据，作为输入参数。假设 shape 的维度为N，那么 function 带有 N 个参数， fn(x1,x2,...x_N) ，其返回值就是该坐标点的值。 def fun ( x , y ): return x + y np . fromfunction ( fun , shape = ( 3 , 3 )) array([[0., 1., 2.], [1., 2., 3.], [2., 3., 4.]]) np.fromiter(iterable, dtype[, count]) ：从可迭代对象中迭代获取数据创建一维 ndarray 。 np . fromiter ( \"123\" , dtype = \"int64\" ) array([1, 2, 3], dtype=int64) np.fromstring(string[, dtype, count, sep]) ：从字符串或者 raw binary 中创建一维 ndarray 。如果 sep 为空字符串则 string 将按照二进制数据解释（即每个字符作为 ASCII 码值对待）。创建的数组有自己的数据存储区。 a = \"abcdefg\" a = np . fromstring ( a , dtype = np . int8 ) # 将每个字符的ASCII编码解释为整数 print ( a ) a = \"1;2;3;4;5\" a = np . fromstring ( a , dtype = np . int8 , sep = \";\" ) print ( a ) [ 97 98 99 100 101 102 103] [1 2 3 4 5] .\\setup.py:2: DeprecationWarning: The binary mode of fromstring is deprecated, as it behaves surprisingly on unicode inputs. Use frombuffer instead \"\"\" np.loadtxt(fname[, dtype, comments, delimiter, ...]) :从文本文件中加载数据创建 ndarray ，要求文本文件每一行都有相同数量的数值。 comments ：指示注释行的起始字符，可以为单个字符或者字符列表（默认为 # ）。 delimiter :指定数值之间的分隔字符串，默认为空白符。 converters ：将指定列号(0,1,2...)的列数据执行转换，是一个 map ，如 {0:func1} 表示对第一列数据执行 func1(val_0) 。 skiprows ：指定跳过开头的多少行。 usecols ：指定读取那些列（0表示第一列）。","text_tokens":["序列","一行","全部","本文","py","数组","float","inputs","asarray","98","相同","的","count","delimiter","iterable","进制","坐标","（","fromfunction","x1","offset","f","内存","2","和","字符串","按照","码值","返回值","y","转换","文件","应该","*","n","the","深","开始","na","kwargs","shape","共享","或者","读取数据","fromstring","有","print","]","读取","dtype","参数","创建","文本","存储","方法","数据","0","behaves","要求","接口","）","__","即",";","copy","_","def","skiprows","点","ndarray","tuple","数量","numpy","区","converters","list","/","fun","fname","array"," ","，","含有","1.0","之间","共享内存","function","那些","转换成","deprecationwarning","一份","中","调用","迭代","use","c","}","abcdefg","列表","{","那么","val","of","it","整数","都","哪里","...","一个","5","subok","空","其中","空白","\"","fn","buffer","分隔","\\","raw","。","编码","起始","int64","默认","也","x2","frombuffer","ascii","ndmin","则","最少","将","4","多个","一列","fromiter","data","指定","bytearray","4.0","拷贝","string","类型","多少","int8","注释","每个","作为","表示","其","99","输入","解释","import","对象","结果","setup","维度","as","风格","为空","is","=","连续","sep","'","#","匹配","123","x","unicode","bytes","时","内置","获取数据","100","20","102","提供","跳过","object","(","order","元素","修改",".",",","类似","是","false","同时","对待","[","值","从","返回","97","map","列号","ascontiguousarray","带有","func1","-","实际上","了","return","如","以上","surprisingly","通过","k","空白符","、","一维","2.0","实际","loadtxt","二进制","a","为","3","自己","单个","instead","可","true","deprecated","改变","换成","列","+","可以","mode","字符","获取","加载","个","20.0","like","3.0","与","binary","行","第一个","指示","机制","当","usecols","from","该","d","on","；","数值","101","对","第一列","如果",")","asmatrix","就是","comments","执行","matrix","每","假设","开头","第一","文本文件",":","会","asanyarray","np","1","103","fromfile","file","："],"title":"从现有的数据创建","title_tokens":["创建","数据","现有","的","从"]},{"location":"numpy笔记/5.1.创建数组.html#_3","text":"np.arange([start,] stop[, step,][, dtype]) :返回均匀间隔的值组成的一维 ndarray 。区间是半闭半开的 [start,stop) ，其采样行为类似Python的 range 函数。 start 为开始点， stop 为终止点， step 为步长，默认为1。这几个数可以为整数可以为浮点数。 注意如果 step 为浮点数，则结果可能有误差，因为浮点数相等比较不准确（计算机精度有限）。 np.linspace(start, stop[, num, endpoint, ...]) ：返回 num 个均匀采样的数值组成的一维 ndarray （默认为50）。区间是闭区间 [start,stop] 。 endpoint 为布尔值，如果为真则表示 stop 是最后采样的值（默认为 True ），否则结果不包含 stop 。 retstep 如果为 True 则返回结果包含采样步长 step ，默认为 True 。 np.logspace(start, stop[, num, endpoint, base, ...]) ：返回对数级别上均匀采样的数值组成的一维 ndarray 。采样点开始于 base^start ，结束于 base^stop 。 base 为对数的基，默认为 10。 它逻辑上相当于先执行 arange 获取数组 array ，然后再执行 base^array[i] 获取采样点 - 它没有 retstep 关键字参数","text_tokens":["数组","精度","关键字","的","包含","i","（","闭","间隔","不","最后","级别","区间","开始","有限","logspace","浮点","有","]","当于","stop","误差","半闭","浮点数","相等","均匀","dtype","参数","因为","对数","）","retstep","num","没有","布尔值","点","ndarray","array"," ","，","再","逻辑","range","组成","否则","终止","行为","10","整数","...","。","默认","则","步长","表示","其","结果","真则","相当","布尔","python","关键","基","上","endpoint","(","step",".",",","类似","是","[","值","采样","比较","返回","计算","函数","-","几个","相当于","一维","然后","base","算机","linspace","为","于","true","arange","准确","可以","50","结束","获取","个","这","数","半开","先","可能","start","它","数值","如果",")","执行","^","注意","点数",":","计算机","np","1","："],"title":"从数值区间创建","title_tokens":["区间","创建","数值","从"]},{"location":"numpy笔记/5.1.创建数组.html#_4","text":"np.empty(shape[,dtype,order]) ：返回一个新的 ndarray ，指定了 shape 和 dtype ，但是没有初始化元素。因此其内容是随机的。 np.empty_like(a[,dtype,order,subok]) ：返回一个新的 ndarray ， shape 与 a 相同，但是没有初始化元素。因此其内容是随机的。 # 内存未初始化 a = np . empty (( 3 , 2 ), order = \"C\" ) # 内存未初始化 np . empty_like ( a ) array([[0., 0.], [0., 0.], [0., 0.]]) np.eye(N[, M, k, dtype]) ：返回一个==二维数组==，对角线元素为1，其余元素为0。 M 默认等于 N 。 k 默认为0表示对角线元素为1，如为正数则表示对角线上方一格的元素为1，如为负数表示对角线下方一格的元素为1。 np.identity(n[, dtype]) ：返回一个单位矩阵。 np . eye ( N = 2 , M = 3 ) np . eye ( N = 2 , M = 3 , k = 0 ) # 参数k是可以超出范围的 np . eye ( N = 2 , M = 3 , k = 1 ) # 返回n阶单位矩阵 np . identity ( n = 4 ) array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) np.ones(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为1. np.ones_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为1。 np.zeros(shape[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为0. np.zeros_like(a[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a （另一个数组）相同，每个元素初始化为0。 9 np.full(shape, fill_value[, dtype, order]) ：返回一个新的 ndarray ，指定了 shape 和 type ，每个元素初始化为 fill_value 。 np.full_like(a, fill_value[, dtype, order, subok]) ：返回一个新的 ndarray ， shape 与 a 相同，每个元素初始化为 fill_value 。 np . full (( 2 , 3 ), fill_value = 2 ) array([[2, 2, 2], [2, 2, 2]])","text_tokens":["矩阵","数组","相同","的","随机","value","（","和","内存","2","但是","内容","n","shape","初始","]","参数","dtype","0","范围","一格","对角","）","没有","因此","_","ndarray","新","ones","array","，"," ","c","上方","eye","如为","一个","subok","\"","。","下方","默认","二维","full","则","4","指定","每个","表示","其","未","正数","=","负数","#","单位矩阵","m","(","元素","order","type",".",",","是","对角线","等于","[","返回","9","了","k","zeros","a","3","为","identity","fill","可以","like","与","超出范围","单位","另","初始化",")","其余","阶","np","1","超出","empty","："],"title":"以填充的方式创建","title_tokens":["方式","创建","以","的","填充"]},{"location":"numpy笔记/5.2.索引.html","text":"import numpy as np import copy ndarrays 可以使用标准 Python x[obj] 语法对其进行索引 ，其中 x 是数组， obj 是索引。有三种可用的索引：字段访问，基本切片，高级索引。哪一个发生取决于 obj 。 在 Python 中， x[(exp1，exp2，.，EXPN)] 等同于 x[exp1，exp2，.，EXPN] 。后者只是前者的语法糖。 # 创建一个一维数组 a = np . arange ( 100 ) # 创建一个二维数组 b = copy . deepcopy ( np . reshape ( a , ( 20 , 5 ))) # 创建一个三维数组 c = copy . deepcopy ( np . arange ( 90 ) . reshape (( 10 , 3 , 3 ))) 一维数组的索引 一维数组的索引和列表相同。假设 a1 是一维数组，那么有以下5种使用索引的情况： 可以指定一个 整数 i 作为索引下标，如 a1[i] 。 可以指定一个 切片 作为索引下标，如 a1[i:j] ，等价于 a1[slice(j,j)] 。 可以指定一个 整数list 对数组进行存取，如 a1[[i1,i2,i3]] 。此时会将列表中的每个整数作为下标 (i1/i2/i3) ，使用列表作为下标得到的数组为 np.array([a1[i1],a1[i2],a1[i3]]) ，它不和原始数组共享内存。 可以指定一个 整数数组 作为数组下标，如 a1[a2] 此时会得到一个形状和下标数组 a2 相同的新数组。新数组的每个元素都是下标数组中对应位置的值作为下标从原始数组中获得的值。新数组不和原始数组共享数据。 可以指定一个 布尔数组 作为数组下标，如a1[b]。此时将获得数组a1中与数组b中的True对应的元素。新数组不和原始数组共享数据。 # 指定一个整数 a [ 1 ] # OWNDATA : True ## 等价于 a [( 1 )] # OWNDATA : True # 指定切片 a [ 0 : 20 : 2 ] # 返回视图 a [ slice ( 0 , 20 , 2 )] # 返回视图 # 指定一个整数列表 a [[ 1 , 2 , 3 , 4 ]] # OWNDATA : True # 指定一个整数数组 ## index是一维数组 index = np . array ([ 0 , 1 , 2 , 3 , 4 ]) a [ index ] # OWNDATA : True ## index是二维数组 index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) a [ index ] # OWNDATA : True # 指定一个布尔数组 ## 布尔数组的ndim需要和原数组相同 bool_a = a > 50 bool_a = list ( bool_a ) 多维数组的索引 多维数组使用 元组 作为数组的下标，如 a[1,2] ，当然你也可以添加圆括号为 a[(1,2)] 。实际上，一维数组也是如此，只是一维数组只有第 0 轴。 下标元组 中每个元素和数组的每个轴对应。下标元组的第 0 个元素对应数组第 0 轴，第 1 个元素对应数组第 1 轴，第 2 个元素对应数组第 2 轴··· 多维数组的下标必须是一个长度和数组的维度ndim相等的元组。 如果下标元组的长度大于数组的维度ndim，则IndexError 如果下标元组的长度小于数组的维度ndim，则自动在元组的后面补 : ，使得下标元组的长度等于数组维度ndim。 如果下标对象不是元组，则Numpy会首先将其转换为元组。 有以下7种使用索引的情况： 整数元组 切片 整数元组搭配切片 整数list 整数数组 布尔数组 整数数组、切片、整数元组混搭 # 指定一个整数元组 b [( 1 , 2 )] # OWNDATA : Trues ## 等价于 b [ 1 , 2 ] # OWNDATA : Trues ## 元组的维度超过多维数组的维度:IndexError ''' b[(1,2,3)] ''' ## 元组的维度超少于维数组的维度 b [ 1 ] # 返回视图 等价于 b[1,:] # 切片 b [ 0 , 0 : 5 : 2 ] # 返回视图 b [ 0 , 0 :: 2 ] # 返回视图 b [ 0 , slice ( 0 , None , 2 )] # 返回视图 ## SyntaxError b[0,slice(0,,2)] b [ 0 : 10 : 2 , 0 : 5 : 2 ] # 返回视图 ## 第二列 b [:, 1 ] # 返回视图 b [ ... , 1 ] # 返回视图 ## IndexError: an index can only have a single ellipsis ('...') ''' b[...,...] IndexError ''' b [ ... ,:] # 返回视图 b [:,:] # 返回视图 # 整数数组 ## arrays used as indices must be of integer (or boolean) type index = np . array ([ 0 , 1 , 2 , 3 ]) b [ index ] # OWNDATA : True index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) b [ index ] # OWNDATA : True ## 如果下标整数数组的维度不一致，会进行广播 rows = np . array ([[ 0 , 1 , 2 ]]) columns = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 4 ]]) index = ( rows , columns ) b [ index ] array([[ 0, 6, 12], [ 3, 9, 14]]) 多维数组的下标是布尔数组或者下标元组中包含了布尔数组，则相当于将布尔数组通过 np.nonzero() 将布尔数组转换成一个整数数组的元组，然后使用整数数组进行下标运行。 np.nonzero(a) 返回数组 a 中，值非零的元素的 下标 。它返回值是一个长度为 a.ndim 的元组，元组的每个元素都是一个一维的整数数组，其值为非零元素的下标在对应轴上的值。如：第 0 个元素为a中的非零值元素在0轴的下标、第 1 个元素为a中的非零值元素在1轴的下标... np . nonzero ( bool_a ) (array([51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], dtype=int64),) 进阶说明 使用切片返回视图的原因： 当下标使用切片时，所取得的数据在数据存储区域中是等间隔分布的。因为只需要修改数组的ndim/shape/strides等属性以及指向数据存储区域的data指针就能够实现整数和切片下标的索引。所以新数组和原始数组能够共享数据存储区域。 当使用整数数组（整数元组，整数列表页转换成整数数组），布尔数组时，不能保证所取得的数据在数据存储区中是等间隔的，因此无法和原始数组共享数据，只能对数据进行复制。 通过整数元组获取的数组元素的类型为数组的dtype类型 。如果你想获取标准python类型，可以使用数组的item()方法。 索引的维度变换 索引的下标元组中： 如果下标元组都是切片，则索引结果的数组与原始数组的维度相同（轴的数量相等） 每多一个整数下标，则索引结果的数组就少一个维度（少一个轴） 如果所有的下标都是整数，则索引结果的维度为 0 如果下标元组中存在数组，则还需要考虑该下标数组广播后的维度 多维数组的下标必须是一个长度和数组的维度 ndim 相等的元组。但是如果下标中包含None，则可以突破这一限制。每多一个None，则索引结构维度升 1 。 当数组的下标元组的长度小于等于数组的维度ndim时，元组中出现的None等价于切片: 当数组的下标元组的长度大于数组的维度ndim时，元组中哪里出现None，索引结果就在哪里创建一个新轴，该轴长度为 1。 b [ 1 , 2 ] b [ 1 , 2 , None ] b [ 1 , 2 , np . newaxis ] array([7])","text_tokens":["说明","相同","an","段","exp1","i","结构","2","不","轴上","返回值","arrays","值非","shape","或者","当于","原因","考虑","expn","87","58","存储","一个二维","非","copy","/","，","取决于","96","运行","指针","74","那么","64","哪里","其中","维","圆括号","每个","must","83","i3","布尔","'","只是",">","时","bool","自动","trues","高级","等于","94","实际上","混","了","首先","ndim","通过","index","当下","这一","3","columns","arange","62","个","与","59","复制","57","想","·","无法","哪","假设","会","少于","1","51","存在","小于","位置","98","如此","超过","后面","间隔","80","nonzero","92","52","等同","63","有","]","基本","前者","创建","数据","exp2","）","85","新","数量","71","list","区域","have"," ","使用","中","72","of","...","owndata","int64","也","可用","76","括号","类型","指向","所","81","其","99","语法","python","a1","100","none","搭","68","77","(","切片","原","修改","used","其值","12","91","视图","在","ellipsis","9","82","第","实际","为","必须","true","可以","50","only","该","非零值","区中","95","70","69","二列","数组","中是","新轴","包含","保证","字","（","等同于","和","内存","变换","同于","boolean","indices","转换","single","页","共享","限制","相等","dtype","你","等价","进阶","0","还","因此","_","发生","numpy","55","integer","对应","item","下","共享内存","多维","补","65","后者","出现","newaxis","属性","一个","。","be","二维","后","6","维度","分布","相当","访问","标","形状","糖","元素","超","type","取得","能够","值","60","从","返回","第二","54","7","获得","长度","如","slice","、","a2","每多","a","14","66","obj","就","此时","strides","换成","以及","rows","reshape","当","添加","它",")","88","突破","对","只","78","的","实现","元组","b","但是","61","使得","零","种","不是","因为","方法","一致","array","标的","转换成","当然","c","等","三维","10","整数","都","5","j","can","所有","deepcopy","取决","则","将","86","4","93","以下","原始","data","指定","56","90","作为","少","import","对象","只能","结果","as","=","84","#","x","20","第二列","广播","情况",".",",","是","53","大于","不能","轴","[","97","存取","79","i2","搭配","三种","i1","67","一个三维","相当于","一维","然后","or","indexerror","于","ndarrays","索引","##","升","获取","只有","75","需要","得到","所以","下标","73","进行","如果","syntaxerror","89",":","标准","np","列表","："],"title":"5.2.索引","title_tokens":[".","5.2","索引"]},{"location":"numpy笔记/5.2.索引.html#_1","text":"一维数组的索引和列表相同。假设 a1 是一维数组，那么有以下5种使用索引的情况： 可以指定一个 整数 i 作为索引下标，如 a1[i] 。 可以指定一个 切片 作为索引下标，如 a1[i:j] ，等价于 a1[slice(j,j)] 。 可以指定一个 整数list 对数组进行存取，如 a1[[i1,i2,i3]] 。此时会将列表中的每个整数作为下标 (i1/i2/i3) ，使用列表作为下标得到的数组为 np.array([a1[i1],a1[i2],a1[i3]]) ，它不和原始数组共享内存。 可以指定一个 整数数组 作为数组下标，如 a1[a2] 此时会得到一个形状和下标数组 a2 相同的新数组。新数组的每个元素都是下标数组中对应位置的值作为下标从原始数组中获得的值。新数组不和原始数组共享数据。 可以指定一个 布尔数组 作为数组下标，如a1[b]。此时将获得数组a1中与数组b中的True对应的元素。新数组不和原始数组共享数据。 # 指定一个整数 a [ 1 ] # OWNDATA : True ## 等价于 a [( 1 )] # OWNDATA : True # 指定切片 a [ 0 : 20 : 2 ] # 返回视图 a [ slice ( 0 , 20 , 2 )] # 返回视图 # 指定一个整数列表 a [[ 1 , 2 , 3 , 4 ]] # OWNDATA : True # 指定一个整数数组 ## index是一维数组 index = np . array ([ 0 , 1 , 2 , 3 , 4 ]) a [ index ] # OWNDATA : True ## index是二维数组 index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) a [ index ] # OWNDATA : True # 指定一个布尔数组 ## 布尔数组的ndim需要和原数组相同 bool_a = a > 50 bool_a = list ( bool_a )","text_tokens":["数组","位置","相同","的","i","b","和","内存","2","不","共享","有","]","种","等价","数据","0","_","新","对应","list","/","array","，"," ","共享内存","使用","中","列表","那么","整数","都","5","一个","owndata","j","。","二维","将","4","以下","原始","指定","每个","作为","=","i3","布尔","#","a1",">","20","形状","(","元素","切片","原","情况","bool",".",",","是","[","值","从","返回","存取","视图","i2","i1","获得","如","ndim","index","slice","一维","a2","a","于","为","3","true","此时","可以","50","索引","##","与","需要","得到","下标","它","进行",")","假设",":","会","np","1","对","："],"title":"一维数组的索引","title_tokens":["索引","一维","的","数组"]},{"location":"numpy笔记/5.2.索引.html#_2","text":"多维数组使用 元组 作为数组的下标，如 a[1,2] ，当然你也可以添加圆括号为 a[(1,2)] 。实际上，一维数组也是如此，只是一维数组只有第 0 轴。 下标元组 中每个元素和数组的每个轴对应。下标元组的第 0 个元素对应数组第 0 轴，第 1 个元素对应数组第 1 轴，第 2 个元素对应数组第 2 轴··· 多维数组的下标必须是一个长度和数组的维度ndim相等的元组。 如果下标元组的长度大于数组的维度ndim，则IndexError 如果下标元组的长度小于数组的维度ndim，则自动在元组的后面补 : ，使得下标元组的长度等于数组维度ndim。 如果下标对象不是元组，则Numpy会首先将其转换为元组。 有以下7种使用索引的情况： 整数元组 切片 整数元组搭配切片 整数list 整数数组 布尔数组 整数数组、切片、整数元组混搭 # 指定一个整数元组 b [( 1 , 2 )] # OWNDATA : Trues ## 等价于 b [ 1 , 2 ] # OWNDATA : Trues ## 元组的维度超过多维数组的维度:IndexError ''' b[(1,2,3)] ''' ## 元组的维度超少于维数组的维度 b [ 1 ] # 返回视图 等价于 b[1,:] # 切片 b [ 0 , 0 : 5 : 2 ] # 返回视图 b [ 0 , 0 :: 2 ] # 返回视图 b [ 0 , slice ( 0 , None , 2 )] # 返回视图 ## SyntaxError b[0,slice(0,,2)] b [ 0 : 10 : 2 , 0 : 5 : 2 ] # 返回视图 ## 第二列 b [:, 1 ] # 返回视图 b [ ... , 1 ] # 返回视图 ## IndexError: an index can only have a single ellipsis ('...') ''' b[...,...] IndexError ''' b [ ... ,:] # 返回视图 b [:,:] # 返回视图 # 整数数组 ## arrays used as indices must be of integer (or boolean) type index = np . array ([ 0 , 1 , 2 , 3 ]) b [ index ] # OWNDATA : True index = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 5 ]]) b [ index ] # OWNDATA : True ## 如果下标整数数组的维度不一致，会进行广播 rows = np . array ([[ 0 , 1 , 2 ]]) columns = np . array ([[ 0 , 1 , 2 ],[ 3 , 4 , 4 ]]) index = ( rows , columns ) b [ index ] array([[ 0, 6, 12], [ 3, 9, 14]]) 多维数组的下标是布尔数组或者下标元组中包含了布尔数组，则相当于将布尔数组通过 np.nonzero() 将布尔数组转换成一个整数数组的元组，然后使用整数数组进行下标运行。 np.nonzero(a) 返回数组 a 中，值非零的元素的 下标 。它返回值是一个长度为 a.ndim 的元组，元组的每个元素都是一个一维的整数数组，其值为非零元素的下标在对应轴上的值。如：第 0 个元素为a中的非零值元素在0轴的下标、第 1 个元素为a中的非零值元素在1轴的下标... np . nonzero ( bool_a ) (array([51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], dtype=int64),)","text_tokens":["69","小于","二列","数组","an","98","如此","78","的","超过","包含","元组","后面","b","2","和","80","不","boolean","返回值","轴上","indices","转换","nonzero","single","92","arrays","61","值非","52","使得","63","零","或者","有","]","当于","相等","种","不是","58","87","dtype","你","等价","0","非","一致","_","85","numpy","55","integer","对应","71","list","have","array","，"," ","96","运行","使用","转换成","多维","74","中","补","当然","65","72","of","64","10","整数","都","...","一个","owndata","5","。","can","be","int64","也","则","将","维","4","76","以下","86","93","6","括号","圆括号","指定","56","90","每个","81","作为","其","99","对象","must","维度","as","83","=","84","相当","布尔","#","'","只是","none","搭","68","77","第二列","(","元素","广播","切片","超","95","情况","type",".","bool","自动",",","trues","是","53","大于","轴","等于","[","值","60","used","其值","12","返回","91","第二","54","97","视图","94","79","在","ellipsis","9","搭配","7","实际上","混","了","首先","长度","如","ndim","67","相当于","通过","82","index","slice","、","一维","然后","第","or","实际","indexerror","a","为","必须","于","3","columns","14","66","true","62","换成","可以","索引","##","只有","个","only","rows","59","75","57","添加","下标","它","进行","73","·","非零值","如果",")","syntaxerror","89",":","会","少于","88","np","1","51","70","："],"title":"多维数组的索引","title_tokens":["索引","的","多维","数组"]},{"location":"numpy笔记/5.2.索引.html#_3","text":"使用切片返回视图的原因： 当下标使用切片时，所取得的数据在数据存储区域中是等间隔分布的。因为只需要修改数组的ndim/shape/strides等属性以及指向数据存储区域的data指针就能够实现整数和切片下标的索引。所以新数组和原始数组能够共享数据存储区域。 当使用整数数组（整数元组，整数列表页转换成整数数组），布尔数组时，不能保证所取得的数据在数据存储区中是等间隔的，因此无法和原始数组共享数据，只能对数据进行复制。 通过整数元组获取的数组元素的类型为数组的dtype类型 。如果你想获取标准python类型，可以使用数组的item()方法。","text_tokens":["数组","只","的","中是","实现","保证","（","元组","间隔","和","转换","shape","页","共享","原因","dtype","你","因为","存储","数据","方法","）","因此","新","item","下","/","区域"," ","，","标的","使用","指针","转换成","等","列表","属性","整数","。","原始","data","类型","指向","所","只能","分布","布尔","python","时","标","(","元素","切片","修改","取得","能够","是","不能","返回","视图","在","ndim","通过","当下","为","就","以及","strides","换成","可以","索引","获取","复制","需要","当","所以","想","进行","无法","如果",")","区中","标准","对","："],"title":"进阶说明","title_tokens":["进阶","说明"]},{"location":"numpy笔记/5.2.索引.html#_4","text":"索引的下标元组中： 如果下标元组都是切片，则索引结果的数组与原始数组的维度相同（轴的数量相等） 每多一个整数下标，则索引结果的数组就少一个维度（少一个轴） 如果所有的下标都是整数，则索引结果的维度为 0 如果下标元组中存在数组，则还需要考虑该下标数组广播后的维度 多维数组的下标必须是一个长度和数组的维度 ndim 相等的元组。但是如果下标中包含None，则可以突破这一限制。每多一个None，则索引结构维度升 1 。 当数组的下标元组的长度小于等于数组的维度ndim时，元组中出现的None等价于切片: 当数组的下标元组的长度大于数组的维度ndim时，元组中哪里出现None，索引结果就在哪里创建一个新轴，该轴长度为 1。 b [ 1 , 2 ] b [ 1 , 2 , None ] b [ 1 , 2 , np . newaxis ] array([7])","text_tokens":["小于","数组","相同","的","新轴","包含","（","元组","结构","和","b","2","但是","限制","]","考虑","相等","等价","创建","0","还","）","数量","array","，"," ","多维","中","出现","newaxis","整数","都","哪里","一个","。","所有","则","后","原始","少","结果","维度","时","none","广播","(","切片",".",",","是","大于","轴","等于","[","在","7","长度","ndim","这一","每多","为","必须","于","就","可以","索引","升","与","：","需要","当","该","下标","如果",")",":","突破","np","1","存在"],"title":"索引的维度变换","title_tokens":["变换","维度","的","索引"]},{"location":"numpy笔记/5.3.属性.html","text":"import numpy as np import copy 数组属性 内存布局 以下属性包含有关数组内存布局的信息： a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) # 以下属性包含有关数组内存布局的信息： # 元素类型 a . dtype # 轴的个数（维度的个数） a . ndim # 各个轴的大小 a . shape # 指向数组的数据的存储区 a . data # 一个数组元素的长度，以字节为单位 a . itemsize # 数组元素占据的总字节数 a . nbytes # 如果内存来自其他对象，则以此为基础对象 a . base # 有关数组内存布局的信息 a . flags # 它是一个整数的元组，每个元素保存着每个轴上相邻两个元素的地址差。 # 即当某个轴的下标增加1 时，数据存储区中的指针增加的字节数 a . strides (20, 4) 可以通过 ndarray.view() 方法，从同一块数据区创建不同的dtype数组。即使用不同的数值类型查看同一段内存中的二进制数据。 它们使用的是同一块内存。 a_view = a . view ( np . float32 ) # a_view 是视图 a_view . flags # 如果我们直接修改原始数组的`dtype`，会达到同样的效果，==但此时直接修改原始数组。== a . dtype = np . float32 # 可以直接修改ndarray对象的strides属性。此时修改的是原始数组。 a . strides = ( 8 , 4 ) 数组方法 # 将数组作为a.ndim-levels深层嵌套的Python标量列表返回 a . tolist () # 构造包含数组中原始数据字节的Python字节。 a . tostring () # 构造包含数组中原始数据字节的Python字节。 a . tobytes () b'\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\t\\x00\\x00\\x00\\n\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\t\\x00\\x00\\x00\\n\\x00\\x00\\x00\\x0b\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\n\\x00\\x00\\x00\\x0b\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\r\\x00\\x00\\x00\\x0e\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\r\\x00\\x00\\x00\\x0e\\x00\\x00\\x00\\x0f\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x0e\\x00\\x00\\x00\\x0f\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x11\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x11\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x14\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x14\\x00\\x00\\x00\\x15\\x00\\x00\\x00\\x16\\x00\\x00\\x00'","text_tokens":["数组","的","flags","它们","包含","进制","tobytes","（","元组","b","达到","内存","轴上","n","float32","x02","x0b","大小","shape","同一","dtype","创建","构造","存储","数据","方法","x06","）","即","从同","x11","8","深层","copy","_","有关","ndarray","numpy","区"," ","，","效果","指针","使用","x13","中","itemsize","一块","节数","tolist","地址","属性","x04","x00","r","10","整数","5","一个","x16","\\","以","。","直接","字节数","deepcopy","x0e","则","将","4","两个","以下","view","`","原始","总","data","原始数据","类型","每个","levels","指向","作为","即当","import","对象","一段","维度","as","=","'","#","python","时","x0f","20","x15","(","元素","某个","来自",".","修改",",","是","x12","轴","tostring","返回","视图","t","-","同样","长度","ndim","通过","nbytes","base","但","以此","二进制","a","各个","为","x07","arange","不同","此时","strides","x14","占据","x0c","可以","50","差","同","标量","个数","着","我们","reshape","查看","单位","其他","下标","它","基础","保存","相邻","数值","增加","如果",")","块内存","x08","x05","布局","x10","区中","信息","字节","x03","会","x01","np","1","嵌套","列表","："],"title":"5.3.属性","title_tokens":[".","属性","5.3"]},{"location":"numpy笔记/5.3.属性.html#_1","text":"","text_tokens":[],"title":"数组属性","title_tokens":["属性","数组"]},{"location":"numpy笔记/5.3.属性.html#_2","text":"以下属性包含有关数组内存布局的信息： a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) # 以下属性包含有关数组内存布局的信息： # 元素类型 a . dtype # 轴的个数（维度的个数） a . ndim # 各个轴的大小 a . shape # 指向数组的数据的存储区 a . data # 一个数组元素的长度，以字节为单位 a . itemsize # 数组元素占据的总字节数 a . nbytes # 如果内存来自其他对象，则以此为基础对象 a . base # 有关数组内存布局的信息 a . flags # 它是一个整数的元组，每个元素保存着每个轴上相邻两个元素的地址差。 # 即当某个轴的下标增加1 时，数据存储区中的指针增加的字节数 a . strides (20, 4) 可以通过 ndarray.view() 方法，从同一块数据区创建不同的dtype数组。即使用不同的数值类型查看同一段内存中的二进制数据。 它们使用的是同一块内存。 a_view = a . view ( np . float32 ) # a_view 是视图 a_view . flags # 如果我们直接修改原始数组的`dtype`，会达到同样的效果，==但此时直接修改原始数组。== a . dtype = np . float32 # 可以直接修改ndarray对象的strides属性。此时修改的是原始数组。 a . strides = ( 8 , 4 )","text_tokens":["数组","的","flags","它们","包含","进制","（","元组","达到","内存","轴上","float32","大小","shape","同一","dtype","创建","存储","数据","方法","）","即","从同","8","copy","_","有关","ndarray","区"," ","，","效果","指针","使用","中","itemsize","一块","节数","地址","属性","10","整数","5","一个","以","。","直接","字节数","deepcopy","则","4","两个","以下","view","`","原始","总","data","类型","每个","指向","即当","一段","对象","维度","=","#","时","20","(","元素","某个","来自",".","修改",",","是","轴","视图","同样","长度","ndim","通过","nbytes","base","但","以此","二进制","a","各个","为","arange","不同","此时","strides","占据","可以","50","差","同","个数","着","我们","reshape","查看","单位","其他","下标","它","基础","保存","相邻","数值","增加","如果",")","块内存","布局","区中","信息","字节","会","np","1","："],"title":"内存布局","title_tokens":["布局","内存"]},{"location":"numpy笔记/5.3.属性.html#_3","text":"# 将数组作为a.ndim-levels深层嵌套的Python标量列表返回 a . tolist () # 构造包含数组中原始数据字节的Python字节。 a . tostring () # 构造包含数组中原始数据字节的Python字节。 a . tobytes () b'\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\t\\x00\\x00\\x00\\n\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\t\\x00\\x00\\x00\\n\\x00\\x00\\x00\\x0b\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\n\\x00\\x00\\x00\\x0b\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\r\\x00\\x00\\x00\\x0e\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\r\\x00\\x00\\x00\\x0e\\x00\\x00\\x00\\x0f\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x0e\\x00\\x00\\x00\\x0f\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x11\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x11\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x14\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x14\\x00\\x00\\x00\\x15\\x00\\x00\\x00\\x16\\x00\\x00\\x00'","text_tokens":["深层","levels","作为","数组","a","x07","的","包含"," ","tobytes","'","#","python","x0c","b","x14","x13","中","x0f","标量","x15","tolist","(","n","x02","x00",".","x04","r","x0b","x12","x16","\\","。","tostring","返回","x0e",")","x08","t","将","-","构造","x05","数据","x10","原始","字节","x03","x01","ndim","原始数据","x06","嵌套","x11","列表"],"title":"数组方法","title_tokens":["方法","数组"]},{"location":"numpy笔记/5.4.广播.html","text":"广播 当使用ufunc函数对两个数组进行计算时，ufunc函数会对这两个数组的对应元素进行计算。这要求这两个数组的形状相同。如果这两个数组的形状不同，就通过广播broadcasting进行处理： 首先让所有输入数组都向其中维度最高的数组看齐。看齐方式为：在shape属性的左侧插入数字1 最后输出数组的shape属性是输入数组的shape属性的各轴上的最大值 如果输入数组的某个轴的长度为 1，或者与输出数组的各对应轴的长度相同，该数组能正确广播。否则计算出错 当输入数组的某个轴的长度为 1时，沿着此轴运算时都用此轴上的第一组值。 \"\"\" numpy.broadcast_arrays() 查看广播之后的数组 np.broadcast_to(array, shape, subok=False) 将array广播为指定的shape，如果指定的shape不满足广播要求，则报错 ndarray.repeat(repeats, axis=None) 重复某个轴上的值. repeats为重复次数 axis指定被重复的轴，即沿着哪一轴重复。如果未指定，则将数组展平然后重复。返回的也是一个展平的数组 \"\"\" a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = np . arange ( 5 ) c = b [:, None ] d = np . ones (( 5 , 3 )) np . broadcast_arrays ( d , c ) [array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]), array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]])] np . broadcast_to ( b [:, None ], ( 5 , 2 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) a . repeat ( 3 , axis = 1 ) array([[0, 0, 0, 1, 1, 1], [2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5], [6, 6, 6, 7, 7, 7], [8, 8, 8, 9, 9, 9]]) 广播示意图 The code to produce the figures is part of the AstroML book","text_tokens":["astroml","数组","book","相同","的","第一组","b","2","不","轴上","arrays","最后","the","shape","数字","或者","插入","]","code","要求","0","即","8","_","copy","part","ndarray","numpy","ones","对应","各轴上","array","，"," ","repeat","使用","哪一轴","c","broadcasting","否则","各","属性","沿着","of","示意图","10","都","produce","一个","5","大值","subok","其中","\"","。","此轴","所有","能","也","deepcopy","则","将","4","两个","6","此轴上","左侧","指定","运算","repeats","输出","最大","未指定","ufunc","输入","维度","is","=","时","重复","次数","none","形状","广播","(","元素","报错","某个","向",".",",","看齐","方式","是","之后","false","轴","意图","[","值","满足","broadcast","返回","被","计算","函数","在","9","7","最大值","首先","长度","通过","然后","a","为","3","就","不同","arange","figures","用","处理","展平","与","这","出错","reshape","查看","当","该","to","d","进行","正确","axis","最高","让","如果","一组",")","第一","会",":","示意","np","1","对","："],"title":"5.4.广播","title_tokens":[".","5.4","广播"]},{"location":"numpy笔记/5.4.广播.html#_1","text":"当使用ufunc函数对两个数组进行计算时，ufunc函数会对这两个数组的对应元素进行计算。这要求这两个数组的形状相同。如果这两个数组的形状不同，就通过广播broadcasting进行处理： 首先让所有输入数组都向其中维度最高的数组看齐。看齐方式为：在shape属性的左侧插入数字1 最后输出数组的shape属性是输入数组的shape属性的各轴上的最大值 如果输入数组的某个轴的长度为 1，或者与输出数组的各对应轴的长度相同，该数组能正确广播。否则计算出错 当输入数组的某个轴的长度为 1时，沿着此轴运算时都用此轴上的第一组值。 \"\"\" numpy.broadcast_arrays() 查看广播之后的数组 np.broadcast_to(array, shape, subok=False) 将array广播为指定的shape，如果指定的shape不满足广播要求，则报错 ndarray.repeat(repeats, axis=None) 重复某个轴上的值. repeats为重复次数 axis指定被重复的轴，即沿着哪一轴重复。如果未指定，则将数组展平然后重复。返回的也是一个展平的数组 \"\"\" a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = np . arange ( 5 ) c = b [:, None ] d = np . ones (( 5 , 3 )) np . broadcast_arrays ( d , c ) [array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]), array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]])] np . broadcast_to ( b [:, None ], ( 5 , 2 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) a . repeat ( 3 , axis = 1 ) array([[0, 0, 0, 1, 1, 1], [2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5], [6, 6, 6, 7, 7, 7], [8, 8, 8, 9, 9, 9]])","text_tokens":["数组","相同","的","第一组","b","2","不","轴上","arrays","最后","shape","数字","或者","插入","]","要求","0","即","8","_","copy","ndarray","numpy","ones","对应","各轴上","array","，"," ","repeat","使用","哪一轴","c","broadcasting","否则","各","属性","沿着","10","都","一个","5","大值","subok","其中","\"","。","此轴","所有","能","也","deepcopy","则","将","4","两个","6","此轴上","左侧","指定","运算","repeats","输出","最大","未指定","ufunc","输入","维度","=","时","重复","次数","none","形状","广播","(","元素","报错","某个","向",".",",","看齐","方式","是","之后","false","轴","[","值","满足","broadcast","返回","被","计算","函数","在","9","7","最大值","首先","长度","通过","然后","a","为","3","就","不同","arange","用","处理","展平","与","这","出错","reshape","查看","当","该","to","d","进行","正确","axis","最高","让","如果","一组",")","第一","会",":","np","1","对","："],"title":"广播","title_tokens":["广播"]},{"location":"numpy笔记/5.4.广播.html#_2","text":"The code to produce the figures is part of the AstroML book","text_tokens":["figures","part","produce","code","astroml","book","to","is"," ","of","the"],"title":"广播示意图","title_tokens":["示意图","意图","示意","广播"]},{"location":"numpy笔记/5.5.常量.html","text":"import numpy as np NumPy定义了几个常量（都是IEEE 754 浮点表示）： （正）无穷大 # 使用`inf`是因为`Inf`、`Infinity`、`PINF`和`infty`是`inf`的别名。 np . inf np . Infinity np . PINF np . Inf np . infty inf 负无穷大 np . NINF -inf 非数字 NaN # `NaN`和`NAN`是`nan`的等价定义。请使用`nan而不是`NAN`。 np . nan np . NAN np . NaN nan 负零 np . NZERO -0.0 正零 np . PZERO 0.0 自然对数的基础，纳皮尔的常数 np . e 2.718281828459045 欧拉常数 γ = 0.5772156649015328606065120900824024310421... 参考 np . euler_gamma 0.5772156649015329 None的便捷别名 对索引数组很有用 np . newaxis 圆周率 np . pi 3.141592653589793","text_tokens":["纳皮尔","数组","自然","的","（","和","很","0.5772156649015328606065120900824024310421","定义","infty","数字","浮点","inf","0.0","别名","不是","等价","因为","对数","有用","非","nzero","）","_","而","pzero","numpy","常数","圆周"," ","，","使用","newaxis","无穷大","都","请","...","。","是因为","负零","参考","自然对数","`","正零","表示","import","as","ieee","754","=","#","欧拉","none","infinity",".","euler","是","圆周率","e","便捷","-","gamma","几个","2.718281828459045","了","、","无穷","pinf","ninf","索引","正","常量","3.141592653589793","负","nan","基础","γ","pi","0.5772156649015329","np","对","："],"title":"5.5.常量","title_tokens":[".","常量","5.5"]},{"location":"numpy笔记/5.6.打印数组.html","text":"import numpy import numpy as np 打印数组 当打印ndarray时，numpy按照Python的嵌套list的格式打印输出，但是按照以下顺序打印： 最底层的axis按照从左到右的顺序输出 次底层的axis按照从上到下的顺序输出 其他层的axis也是按照从上到下的顺序输出，但是每个slice中间间隔一条空行 如： 一维的ndarray按行打印；二维的ndarray按照矩阵打印；三维的ndarray按照矩阵的list打印 如果ndarray太大，那么numpy默认跳过中间部分的数据而只是输出四个角落的数据。 要想任何时候都打印全部数据，可以在print(array)之前设置选项 numpy . set_printoptions ( threshold = None ) 这样后续的打印ndarray就不会省略中间数据。 np . set_printoptions ( threshold = 5 ) np . arange ( 200 ) array([ 0, 1, 2, ..., 197, 198, 199])","text_tokens":["矩阵","全部","数组","层","的","之前","角落","间隔","2","按照","上到","但是","空行","时候","print","]","最底层","数据","0","199","太大","格式","_","而","ndarray","中间","numpy","这样","不会","list","从上到下","array","，"," ","部分","threshold","198","三维","那么","197","都","...","5","设置","次","。","打印输出","默认","二维","也","后续","以下","每个","输出","import","printoptions","as","=","python","只是","时","按行","set","none","跳过","(",".",",","是","从左到右","[","省略","在","一条","如","四个","slice","一维","底层","就","arange","可以","200","打印","当","其他","选项","想","；","要","任何","顺序","如果",")","np","1","嵌套","axis","："],"title":"5.6.打印数组","title_tokens":[".","5.6","数组","打印"]},{"location":"numpy笔记/5.6.打印数组.html#_1","text":"当打印ndarray时，numpy按照Python的嵌套list的格式打印输出，但是按照以下顺序打印： 最底层的axis按照从左到右的顺序输出 次底层的axis按照从上到下的顺序输出 其他层的axis也是按照从上到下的顺序输出，但是每个slice中间间隔一条空行 如： 一维的ndarray按行打印；二维的ndarray按照矩阵打印；三维的ndarray按照矩阵的list打印 如果ndarray太大，那么numpy默认跳过中间部分的数据而只是输出四个角落的数据。 要想任何时候都打印全部数据，可以在print(array)之前设置选项 numpy . set_printoptions ( threshold = None ) 这样后续的打印ndarray就不会省略中间数据。 np . set_printoptions ( threshold = 5 ) np . arange ( 200 ) array([ 0, 1, 2, ..., 197, 198, 199])","text_tokens":["矩阵","全部","层","的","之前","角落","间隔","2","按照","上到","但是","空行","时候","print","]","最底层","数据","0","199","太大","格式","_","而","ndarray","中间","numpy","这样","不会","list","从上到下","array"," ","，","部分","threshold","198","三维","那么","197","都","...","5","设置","次","。","打印输出","默认","二维","也","后续","以下","每个","输出","printoptions","=","python","只是","时","按行","set","none","跳过","(",".",",","是","从左到右","[","省略","在","一条","如","四个","slice","一维","底层","就","arange","可以","200","打印","当","其他","选项","想","；","要","任何","顺序","如果",")","np","1","嵌套","axis","："],"title":"打印数组","title_tokens":["数组","打印"]},{"location":"numpy笔记/5.7.形状操纵.html","text":"import numpy as np import copy 形状操作( shape ) # 创建示例数据 a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) # 会直接修改原始数组 a . shape = ( 5 , 10 ) a . flags # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . shape = ( 25 , - 1 ) # 不会直接修改原始数组 a . reshape ( 5 , 10 ) # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . reshape ( 5 , - 1 ) # 会直接修改原始数组 a . resize (( 25 , 2 )) # reshape resize 区别 ## reshape不会修改原数据 ## resize会修改原数据 形状操作( ndim ) \"\"\" numpy.transpose(a, axes=None) 重置轴序。如果axes=None，则默认重置为逆序的轴序，如原来的shape=(1,2,3)，逆序之后为(3,2,1)） 如果axes!=None，则要给出重置后的轴序。它获得的是原数组的视图。 numpy.swapaxes(a, axis1, axis2) 交换指定的两个轴axis1/axis2。它获得是原数组的视图。 \"\"\" # 多维数组转为一维数组 a . flatten () # 返回副本 a . ravel () # 一般返回视图 ## flatten ravel 区别 ## ravel()：如果没有必要，不会产生源数据的副本 ## flatten()：返回源数据的副本 b = np . arange ( 10 ) # 创建示例数据 b . flatten () . flags [ \"OWNDATA\" ] True b . ravel () . flags [ \"OWNDATA\" ] False a . ravel ( order = \"F\" ) . flags [ \"OWNDATA\" ] True # 对维数为1的维度降维,返回副本 b = copy . deepcopy ( np . arange ( 20 ) . reshape ( 20 , 1 )) b [: 6 ] array([[0], [1], [2], [3], [4], [5]]) b . squeeze ( 1 ) array([ 0, 1, 2, ..., 17, 18, 19]) # 返回数组的视图，其中axis1和axis2互换。 ## ndarray.swapaxes(axis1, axis2) a = copy . deepcopy ( np . arange ( 20 ) . reshape ( 10 , 2 )) a . swapaxes ( 0 , 1 ) # 视图 array([[ 0, 2, 4, ..., 14, 16, 18], [ 1, 3, 5, ..., 15, 17, 19]]) # 返回轴转置的数组视图。 b = copy . deepcopy ( np . arange ( 60 ) . reshape ( 3 , 2 , 10 )) b . transpose () array ([[[ 0 , 20 , 40 ], [ 10 , 30 , 50 ]], [[ 1 , 21 , 41 ], [ 11 , 31 , 51 ]], [[ 2 , 22 , 42 ], [ 12 , 32 , 52 ]], ..., [[ 7 , 27 , 47 ], [ 17 , 37 , 57 ]], [[ 8 , 28 , 48 ], [ 18 , 38 , 58 ]], [[ 9 , 29 , 49 ], [ 19 , 39 , 59 ]]]) 数组拼接 \"\"\" numpy.concatenate((a1, a2, ...), axis=0) 连接多个数组。其中(a1,a2,...)为数组的序列，给出了待连接的数组，它们沿着axis指定的轴连接。 所有的这些数组的形状，除了axis轴之外都相同 numpy.vstack(tup) 等价于numpy.concatenate((a1, a2, ...), axis=0)。 沿0轴拼接（垂直拼接），增加行 numpy.hstack(tup) 等价于numpy.concatenate((a1, a2, ...), axis=1)。 沿1轴拼接（水平拼接），增加列 numpy.column_stack(tup) 类似于hstack，但是如果被拼接的数组是一维的，则将其形状修改为二维的(N,1)。 numpy.c_对象的[]方法也可以用于按列连接数组。 但是如果被拼接的数组是一维的，则将其形状修改为二维的(N,1)。 沿列方向拼接，增加列 \"\"\" a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) # 横向拼接、拼接 1 轴（第二个轴，即列） np . concatenate (( a , b ), axis = 1 ) np . hstack (( a , b )) np . c_ [ a , b ] array([[0, 1, 0, 1], [2, 3, 2, 3], [4, 5, 4, 5], [6, 7, 6, 7], [8, 9, 8, 9]]) # column_stack hstack np.c_区别 a1 = np . arange ( 5 ) np . column_stack (( a1 , a1 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) np . hstack (( a1 , a1 )) array([0, 1, 2, ..., 2, 3, 4]) np . c_ [ a1 , a1 ] array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) 数组拆分 \"\"\" numpy.split(ary, indices_or_sections, axis=0) 用于沿着指定的轴拆分数组ary。indices_or_sections指定了拆分点： 如果为整数N，则表示平均拆分成N份。如果不能平均拆分，则报错 如果为序列，则该序列指定了划分区间（无需指定最开始的0起点和终点）。如[1,3]指定了区间：[0,1],[1,3],[3:] 而numpy.array_split(ary, indices_or_sections, axis=0)的作用也是类似。 唯一的区别在于：当indices_or_sections为整数，且无法平均拆分时，并不报错，而是尽可能的维持平均拆分。 \"\"\" a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) np . split ( a , 2 , axis = 0 ) [array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]]), array([[25, 26, 27, 28, 29], [30, 31, 32, 33, 34], [35, 36, 37, 38, 39], [40, 41, 42, 43, 44], [45, 46, 47, 48, 49]])] # [0,1) [1,3) [3:] np . split ( a ,[ 1 , 3 ], axis = 1 ) [array([[ 0], [ 5], [10], ..., [35], [40], [45]]), array([[ 1, 2], [ 6, 7], [11, 12], ..., [36, 37], [41, 42], [46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], ..., [38, 39], [43, 44], [48, 49]])] np . array_split ( a , 2 , axis = 1 ) [array([[ 0, 1, 2], [ 5, 6, 7], [10, 11, 12], ..., [35, 36, 37], [40, 41, 42], [45, 46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], ..., [38, 39], [43, 44], [48, 49]])]","text_tokens":["序列","原来","37","23","数组","44","相同","flags","的","它们","stack","40","34","产生","（","36","轴序","2","b","f","和","split","无需","不","而是","但是","indices","份","待","11","n","唯一","52","区间","沿","开始","shape","!","连接","终点","32","]","沿列","58","16","等价","创建","维持","数据","0","29","方法","30","27","在于","）","42","即列","8","没有","copy","_","横向","而","点","ndarray","numpy","25","不会","tup","/","对维数","水平","array"," ","，","46","squeeze","多维","c","resize","用于","18","48","沿着","转置","10","整数","都","swapaxes","...","5","owndata","拼接","ary","其中","平均","\"","设置","。","直接","所有","默认","二维","一般","deepcopy","flatten","也","则","多个","将","区别","两个","后","4","拆分","原始","转为","6","sections","33","28","指定","15","其","表示","21","35","import","对象","交换","这些","维度","22","vstack","as","示例","concatenate","=","#","transpose","17","a1","第二个","时","且","除了","垂直","操作","none","20","形状","hstack","(","拆","给出","某个","原","order","axis2","修改",".","41","自动",",","重置","类似","之后","是","false","不能","轴","尽可","[","60","12","返回","43","第二","被","视图","计算","在","9","源","45","-","7","作用","并","获得","了","长度","ndim","如","降维","最","、","一维","方向","or","a2","起点","13","a","为","3","14","38","于","true","39","arange","副本","此时","49","列","报错","可以","50","划分","##","互换","尽可能","axis1","31","二个","分成","行","59","reshape","逆序","当","可能","57","按列","该","axes","19","它","要","ravel","axis","column","之外","如果",")","47","增加","无法","24","26","会",":","np","1","必要","51","："],"title":"5.7.形状操纵","title_tokens":[".","形状","5.7","操纵"]},{"location":"numpy笔记/5.7.形状操纵.html#shape","text":"# 创建示例数据 a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) # 会直接修改原始数组 a . shape = ( 5 , 10 ) a . flags # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . shape = ( 25 , - 1 ) # 不会直接修改原始数组 a . reshape ( 5 , 10 ) # 可以在某个维度设置其长度为 -1，此时该维度的长度会被自动计算 a . reshape ( 5 , - 1 ) # 会直接修改原始数组 a . resize (( 25 , 2 )) # reshape resize 区别 ## reshape不会修改原数据 ## resize会修改原数据","text_tokens":["copy","数组","其","25","不会","a","维度","flags","为","的","示例","="," ","arange","，","此时","#","可以","50","2","##","resize","(","某个","原","修改",".","reshape","10",",","自动","shape","5","设置","该","直接","被","deepcopy","计算",")","在","创建","-","区别","数据","原始","会","长度","np","1"],"title":"形状操作(shape)","title_tokens":[")","shape","操作","形状","("]},{"location":"numpy笔记/5.7.形状操纵.html#ndim","text":"\"\"\" numpy.transpose(a, axes=None) 重置轴序。如果axes=None，则默认重置为逆序的轴序，如原来的shape=(1,2,3)，逆序之后为(3,2,1)） 如果axes!=None，则要给出重置后的轴序。它获得的是原数组的视图。 numpy.swapaxes(a, axis1, axis2) 交换指定的两个轴axis1/axis2。它获得是原数组的视图。 \"\"\" # 多维数组转为一维数组 a . flatten () # 返回副本 a . ravel () # 一般返回视图 ## flatten ravel 区别 ## ravel()：如果没有必要，不会产生源数据的副本 ## flatten()：返回源数据的副本 b = np . arange ( 10 ) # 创建示例数据 b . flatten () . flags [ \"OWNDATA\" ] True b . ravel () . flags [ \"OWNDATA\" ] False a . ravel ( order = \"F\" ) . flags [ \"OWNDATA\" ] True # 对维数为1的维度降维,返回副本 b = copy . deepcopy ( np . arange ( 20 ) . reshape ( 20 , 1 )) b [: 6 ] array([[0], [1], [2], [3], [4], [5]]) b . squeeze ( 1 ) array([ 0, 1, 2, ..., 17, 18, 19]) # 返回数组的视图，其中axis1和axis2互换。 ## ndarray.swapaxes(axis1, axis2) a = copy . deepcopy ( np . arange ( 20 ) . reshape ( 10 , 2 )) a . swapaxes ( 0 , 1 ) # 视图 array([[ 0, 2, 4, ..., 14, 16, 18], [ 1, 3, 5, ..., 15, 17, 19]]) # 返回轴转置的数组视图。 b = copy . deepcopy ( np . arange ( 60 ) . reshape ( 3 , 2 , 10 )) b . transpose () array ([[[ 0 , 20 , 40 ], [ 10 , 30 , 50 ]], [[ 1 , 21 , 41 ], [ 11 , 31 , 51 ]], [[ 2 , 22 , 42 ], [ 12 , 32 , 52 ]], ..., [[ 7 , 27 , 47 ], [ 17 , 37 , 57 ]], [[ 8 , 28 , 48 ], [ 18 , 38 , 58 ]], [[ 9 , 29 , 49 ], [ 19 , 39 , 59 ]]])","text_tokens":["原来","37","数组","的","flags","40","产生","轴序","2","b","f","和","11","52","shape","!","32","]","58","16","创建","数据","0","29","30","27","）","42","8","没有","copy","ndarray","numpy","不会","/","对维数","array","，"," ","squeeze","多维","18","48","转置","10","swapaxes","...","5","owndata","其中","\"","。","默认","一般","flatten","deepcopy","则","区别","两个","后","4","转为","6","28","指定","15","21","交换","维度","22","示例","=","transpose","#","17","none","20","(","给出","原","order","41","axis2",".",",","重置","之后","是","false","轴","[","60","12","返回","视图","9","源","7","获得","如","降维","一维","a","为","3","14","38","true","39","副本","arange","49","50","##","互换","axis1","31","59","reshape","逆序","57","axes","19","它","要","ravel","如果",")","47",":","np","1","必要","51","："],"title":"形状操作(ndim)","title_tokens":[")","操作","形状","ndim","("]},{"location":"numpy笔记/5.7.形状操纵.html#_1","text":"\"\"\" numpy.concatenate((a1, a2, ...), axis=0) 连接多个数组。其中(a1,a2,...)为数组的序列，给出了待连接的数组，它们沿着axis指定的轴连接。 所有的这些数组的形状，除了axis轴之外都相同 numpy.vstack(tup) 等价于numpy.concatenate((a1, a2, ...), axis=0)。 沿0轴拼接（垂直拼接），增加行 numpy.hstack(tup) 等价于numpy.concatenate((a1, a2, ...), axis=1)。 沿1轴拼接（水平拼接），增加列 numpy.column_stack(tup) 类似于hstack，但是如果被拼接的数组是一维的，则将其形状修改为二维的(N,1)。 numpy.c_对象的[]方法也可以用于按列连接数组。 但是如果被拼接的数组是一维的，则将其形状修改为二维的(N,1)。 沿列方向拼接，增加列 \"\"\" a = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) b = copy . deepcopy ( np . arange ( 10 ) . reshape ( 5 , 2 )) # 横向拼接、拼接 1 轴（第二个轴，即列） np . concatenate (( a , b ), axis = 1 ) np . hstack (( a , b )) np . c_ [ a , b ] array([[0, 1, 0, 1], [2, 3, 2, 3], [4, 5, 4, 5], [6, 7, 6, 7], [8, 9, 8, 9]]) # column_stack hstack np.c_区别 a1 = np . arange ( 5 ) np . column_stack (( a1 , a1 )) array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]) np . hstack (( a1 , a1 )) array([0, 1, 2, ..., 2, 3, 4]) np . c_ [ a1 , a1 ] array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]])","text_tokens":["序列","数组","相同","的","stack","它们","（","b","2","但是","待","n","沿","连接","]","沿列","等价","0","方法","）","即列","8","横向","_","copy","numpy","tup","水平","array"," ","，","c","用于","沿着","10","都","...","5","拼接","其中","\"","。","所有","二维","也","deepcopy","则","多个","将","4","区别","6","指定","其","对象","这些","vstack","concatenate","=","#","a1","第二个","除了","垂直","hstack","形状","(","给出","修改",".",",","类似","是","轴","[","第二","被","9","7","了","、","一维","方向","a2","a","为","于","3","arange","列","可以","二个","行","reshape","按列","column","之外","增加",")","如果","np","1","axis"],"title":"数组拼接","title_tokens":["拼接","数组"]},{"location":"numpy笔记/5.7.形状操纵.html#_2","text":"\"\"\" numpy.split(ary, indices_or_sections, axis=0) 用于沿着指定的轴拆分数组ary。indices_or_sections指定了拆分点： 如果为整数N，则表示平均拆分成N份。如果不能平均拆分，则报错 如果为序列，则该序列指定了划分区间（无需指定最开始的0起点和终点）。如[1,3]指定了区间：[0,1],[1,3],[3:] 而numpy.array_split(ary, indices_or_sections, axis=0)的作用也是类似。 唯一的区别在于：当indices_or_sections为整数，且无法平均拆分时，并不报错，而是尽可能的维持平均拆分。 \"\"\" a = copy . deepcopy ( np . arange ( 50 ) . reshape ( 10 , 5 )) np . split ( a , 2 , axis = 0 ) [array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]]), array([[25, 26, 27, 28, 29], [30, 31, 32, 33, 34], [35, 36, 37, 38, 39], [40, 41, 42, 43, 44], [45, 46, 47, 48, 49]])] # [0,1) [1,3) [3:] np . split ( a ,[ 1 , 3 ], axis = 1 ) [array([[ 0], [ 5], [10], ..., [35], [40], [45]]), array([[ 1, 2], [ 6, 7], [11, 12], ..., [36, 37], [41, 42], [46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], ..., [38, 39], [43, 44], [48, 49]])] np . array_split ( a , 2 , axis = 1 ) [array([[ 0, 1, 2], [ 5, 6, 7], [10, 11, 12], ..., [35, 36, 37], [40, 41, 42], [45, 46, 47]]), array([[ 3, 4], [ 8, 9], [13, 14], ..., [38, 39], [43, 44], [48, 49]])]","text_tokens":["序列","23","37","数组","44","的","34","40","（","36","split","无需","和","2","不","而是","indices","份","11","n","唯一","区间","开始","终点","32","]","16","维持","0","29","在于","27","30","）","42","8","_","copy","而","点","numpy","25","array"," ","，","46","用于","18","48","沿着","10","整数","...","平均","5","ary","\"","。","也","deepcopy","则","拆分","区别","4","33","6","28","指定","表示","15","21","35","22","=","17","#","时","且","20","(","拆","报错","sections","41",".",",","类似","是","不能","轴","尽可","[","12","43","9","45","作用","并","7","了","如","最","or","起点","13","a","为","3","14","38","39","arange","49","划分","50","尽可能","分成","31","reshape","当","可能","该","19","无法","如果",")","24","26","47",":","np","1","axis","："],"title":"数组拆分","title_tokens":["拆分","数组"]},{"location":"numpy笔记/5.8.ufunc函数.html","text":"import numpy as np np . set_printoptions ( threshold = 40 ) 四则运算 a = np . arange ( 1 , 6 ) # 表达式形式 a + a a - a a * a a / a # ufunc函数形式 np . add ( a , a ) np . subtract ( a , a ) np . multiply ( a , a ) np . true_divide ( a , a ) array([1., 1., 1., 1., 1.]) 比较运算 a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 表达式形式 a == b a != b a < b a <= b a > b a >= b # ufunc函数形式 np . equal ( a , b ) np . not_equal ( a , b ) np . less ( a , b ) np . less_equal ( a , b ) np . greater ( a , b ) np . greater_equal ( a , b ) array([[False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False]]) 逻辑运算 a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 与 np . logical_and ( a , b ) # 或 np . logical_or ( a , b ) # 非 np . logical_not ( a , b ) # 异或 np . logical_xor ( a , b ) # 任意一个元素 np . any ( a ) # 全部元素 np . all ( a ) False 位运算 a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) a & b a | b ~ a a ^ b # 按位与 np . bitwise_and ( a , b ) # 按位或 np . bitwise_or ( a , b ) # 按位取反 np . bitwise_not ( a ) # 按位异或 np . bitwise_xor ( a , b ) array([[10, 10, 14, 14, 10, 10, 22, 22, 26, 26], [30, 30, 26, 26, 22, 22, 10, 10, 14, 14]], dtype=int32) 自定义 ufunc 函数 可以通过 frompyfunc() 将计算单个元素的函数转换成ufunc函数。调用格式为如下： numpy . frompyfunc ( func , nin , nout ) # func：计算单个元素的函数 # nin：func的输入参数的个数 The number of input # nout：func返回值的个数 The number of output def my_add ( x , y ): z = x + y + 1 return z myufunc = np . frompyfunc ( my_add , 2 , 1 ) a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) myufunc ( a , b ) array([6, 8, 10, 12, 14], dtype=object) 也可以通过 vectorize() 函数来实现 frompyfunc() 的功能。 np . vectorize ( func , otypes = '' , doc = None , excluded = None ) 。 # func：计算单个元素的函数 # otypes：可以是一个表示结果数组元素类型的字符串，也可以是一个类型列表。如果使用类型列表，可以描述多个返回数组的元素类型 # doc：函数的描述字符串。若未给定，则使用func.__doc__ # excluded：指定func中哪些参数未被向量化。你可以指定一个字符串和整数的集合，其中字符串代表关键字参数，整数代表位置参数。 a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) def my_add ( x , num ): z = x + num return z myufunc = np . vectorize ( my_add , doc = \"每一个元素加上一个指定的数\" ) print ( myufunc . __doc__ ) myufunc ( a , 1 ) 每一个元素加上一个指定的数 array([1, 2, 3, 4, 5]) def my_add ( x , y , list_num ): z = x + y for i in list_num : z = z + i return z myufunc = np . vectorize ( my_add , excluded = [ 2 ]) myufunc ( a , b , [ 1 , 2 , 3 ]) # list_num 作为一个list，而不是向量化成一个个元素 array([11, 13, 15, 17, 19]) def my_add ( x , num ): z = x + num return z , z myufunc = np . vectorize ( my_add , otypes = [ np . float , int ]) myufunc ( a , 1 ) (array([1., 2., 3., 4., 5.]), array([1, 2, 3, 4, 5])) ufunc 对象的方法 ufunc函数对象本身还有一些方法。 这些方法只对于两个输入、一个输出的ufunc函数函数有效。对于其他的ufunc函数对象调用这些方法时，会抛出 ValueError 异常。 ufunc.reduce() ufunc.reduce 方法：类似于Python的 reduce 函数，它==沿着== axis 参数指定的轴，对数组进行操作。经过一次reduce，结果数组的维度降低一维。 假设 <op> 是一个ufunc函数， ufunc.reduce 用法如下： < op >. reduce ( array , axis = 0 , dtype = None ) a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . reduce ( a , axis = 1 ) # 沿着 列方向 array([ 6, 22, 38, 54, 70]) np . add . reduce ( a , axis = 0 ) # 沿着 行方向 array([40, 45, 50, 55]) 相当于将 运算符插入到沿着axis轴的所有元素之间： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) def fun ( a , b ): z = a + b + 1 return z fun2 = np . frompyfunc ( fun , 2 , 1 ) fun2 . reduce ( a , axis = 1 ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] array([9, 25, 41, 57, 73], dtype=object) ufunc.accumulate() ufunc.accumulate 方法：它类似于reduce()的计算过程，但是它会保存所有的中间计算结果，从而使得返回数组的形状和输入数组的形状相同： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . accumulate ( a , axis = 1 ) array([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38], [12, 25, 39, 54], [16, 33, 51, 70]], dtype=int32) ufunc.outer() ufunc.outer 方法：相当于将 运算符对输入数组A和输入数组B的每一对元素对(a,b)起作用。设A的shape=(4,5)，B的shape为(4,)，则结果数组的shape=(4,5,4) 一维数组和一维数组的outer操作为二维数组 a = np . arange ( 1 , 6 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array([[2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7], [5, 6, 7, 8], [6, 7, 8, 9]]) 多维数组的outer拆分成各自的一维操作 a = np . arange ( 1 , 7 ) . reshape ( 2 , 3 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array ([[[ 2 , 3 , 4 , 5 ], [ 3 , 4 , 5 , 6 ], [ 4 , 5 , 6 , 7 ]], [[ 5 , 6 , 7 , 8 ], [ 6 , 7 , 8 , 9 ], [ 7 , 8 , 9 , 10 ]]]) 数学函数 下面是一元的数学函数： abs/fabs ：计算整数、浮点数或者复数的绝对值。对于非复数值，可以使用更快的fabs sqrt ：计算平方根，相当于$a^{0.5}$ square ：计算平方，相当于$a^2$ exp ：计算指数$e^x$ log/log10/log2/log1p ：分别为$log_{e}(a), log_{10}(a), log_2(a), log_e(1+x)$ sign ：计算$sign(a)$ ceil ：计算各元素的ceiling值：大于等于该值的最小整数 floor ：计算个元素的floor值：小于等于该值的最大整数 rint ：将各元素四舍五入到最接近的整数，保留 dtype modf ：将数组的小数和整数部分以两个独立数组的形式返回 cos/cosh/sin/sinh/tan/tanh ：普通和双曲型三角函数 arccos/arcsosh/arcsin/arcsinh/arctan/arctanh :反三角函数 isnan ：返回一个布尔数组，该数组指示那些是 NaN isfinite/isinf ：返回一个布尔数组，该数组指示哪些是有限的/无限数","text_tokens":["全部","float","相同","ceiling","tan","i","2","返回值","降低","*","the","定义","shape","浮点","或者","isfinite","插入","print","当于","浮点数","16","非","绝对","各自","num","8","/","fun","，","log2","其中","形式","多个","两个","方根","一些","最大","15","四舍五入","自定","22","printoptions","'","17","布尔",">","时","otypes","类似","等于","一对","return","独立","通过","普通","还有","3","38","如下","arange","reduce","个","rint","add","与","行","一元","output","square","若","其他","57","nan","19","保存","floor","数值","假设","会","1","用法","exp","51","小于","位置","从而","~","isinf","greater","下面","字符串","y","一个个","达式","!","来","doc","]","异常","按位","27","not","格式","bitwise","def","而","型","list","and"," ","部分","那些","使用","中","less","{","各","18","of","也","33","三角函数","给定","类型","这些","该值","arctan","python","关键","有效","ceil","my","none","计算结果","三角","(","object","arcsin","e","12","非复","计算","函数","9","accumulate","最小","<","|","集合","最","方向","int32","multiply","单个","为","true","可以","50","字符","绝对值","分成","数","该","any","int","指数","70","或","数组","任意","关键字","sin","保留","表达式","和","运算符","转换","有限","for","表达","代表","逻辑运算","dtype","你","0","_","numpy","55","位","threshold","之间","sinh","逻辑","多维","调用","哪些","log","vectorize","一个","\"","以","。","input","平方","算符","二维","6","0.5","nout","运算","一次","未","化成","维度","相当","取反","set","起","形状","元素","拆","41","outer","更快","false","值","cosh","它会","返回","54","-","7","作用","无限","、","13","a","14","描述","换成","列","equal","量化","reshape","excluded","双曲","指示","fun2","过程","它","logical","sqrt",")","每","op","nin","valueerror","axis","对","myufunc","arctanh","只","divide","复数","的","实现","40","b","&","但是","11","使得","$","功能","平方根","number","不是","参数","方法","30","sign","__","对于","abs","中间","25","tanh","接近","四则运算","array","本身","转换成","isnan","}","反","沿着","分别","10","整数","5","modf","xor","所有","fabs","则","将","4","指定","输出","作为","表示","arccos","ufunc","输入","cos","import","对象","结果","四则","as","=","#","数学","x","subtract","操作","20","抛出","frompyfunc",".","向",",","到","是","大于","轴","[","arcsinh","比较","被","45","自定义","设","相当于","向量","个个","一维","or","arcsosh","z","小数","log10","于","经过","all","39","异或","+","in","个数","log1p","加上","73","进行",".__","func","如果","26","^","点数",":","np","列表","："],"title":"5.8.ufunc函数","title_tokens":[".","ufunc","函数","5.8"]},{"location":"numpy笔记/5.8.ufunc函数.html#_1","text":"a = np . arange ( 1 , 6 ) # 表达式形式 a + a a - a a * a a / a # ufunc函数形式 np . add ( a , a ) np . subtract ( a , a ) np . multiply ( a , a ) np . true_divide ( a , a ) array([1., 1., 1., 1., 1.])","text_tokens":["_","ufunc","divide","multiply","a","/","array","true","="," ","arange","#","表达式","+","subtract","add","达式","(","*",".",",","[","表达","]","函数",")","形式","-","6","np","1"],"title":"四则运算","title_tokens":["运算","四则运算","四则"]},{"location":"numpy笔记/5.8.ufunc函数.html#_2","text":"a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 表达式形式 a == b a != b a < b a <= b a > b a >= b # ufunc函数形式 np . equal ( a , b ) np . not_equal ( a , b ) np . less ( a , b ) np . less_equal ( a , b ) np . greater ( a , b ) np . greater_equal ( a , b ) array([[False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False]])","text_tokens":["_","ufunc","a","array","="," ","arange","greater","#","表达式","b","2",">","equal","20","less","达式","(",".","reshape",",","10","false","!","[","表达","]","函数",")","形式","<","30","not","np"],"title":"比较运算","title_tokens":["运算","比较"]},{"location":"numpy笔记/5.8.ufunc函数.html#_3","text":"a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) # 与 np . logical_and ( a , b ) # 或 np . logical_or ( a , b ) # 非 np . logical_not ( a , b ) # 异或 np . logical_xor ( a , b ) # 任意一个元素 np . any ( a ) # 全部元素 np . all ( a ) False","text_tokens":["_","全部","或","or","任意","a","and","all","="," ","arange","异或","#","b","2","20","与","(","元素",".","reshape",",","10","一个","false","logical","xor","any",")","30","not","非","np"],"title":"逻辑运算","title_tokens":["运算","逻辑运算","逻辑"]},{"location":"numpy笔记/5.8.ufunc函数.html#_4","text":"a = np . arange ( 20 ) . reshape ( 2 , 10 ) b = np . arange ( 10 , 30 ) . reshape ( 2 , 10 ) a & b a | b ~ a a ^ b # 按位与 np . bitwise_and ( a , b ) # 按位或 np . bitwise_or ( a , b ) # 按位取反 np . bitwise_not ( a ) # 按位异或 np . bitwise_xor ( a , b ) array([[10, 10, 14, 14, 10, 10, 22, 22, 26, 26], [30, 30, 26, 26, 22, 22, 10, 10, 14, 14]], dtype=int32)","text_tokens":["bitwise","_","int32","或","or","a","14","22","~","array","and","="," ","arange","异或","#","b","2","取反","&","20","与","(",".","reshape",",","10","[","]","xor",")","26","dtype","^","按位","30","not","|","np"],"title":"位运算","title_tokens":["位","运算"]},{"location":"numpy笔记/5.8.ufunc函数.html#ufunc","text":"可以通过 frompyfunc() 将计算单个元素的函数转换成ufunc函数。调用格式为如下： numpy . frompyfunc ( func , nin , nout ) # func：计算单个元素的函数 # nin：func的输入参数的个数 The number of input # nout：func返回值的个数 The number of output def my_add ( x , y ): z = x + y + 1 return z myufunc = np . frompyfunc ( my_add , 2 , 1 ) a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) myufunc ( a , b ) array([6, 8, 10, 12, 14], dtype=object) 也可以通过 vectorize() 函数来实现 frompyfunc() 的功能。 np . vectorize ( func , otypes = '' , doc = None , excluded = None ) 。 # func：计算单个元素的函数 # otypes：可以是一个表示结果数组元素类型的字符串，也可以是一个类型列表。如果使用类型列表，可以描述多个返回数组的元素类型 # doc：函数的描述字符串。若未给定，则使用func.__doc__ # excluded：指定func中哪些参数未被向量化。你可以指定一个字符串和整数的集合，其中字符串代表关键字参数，整数代表位置参数。 a = np . arange ( 5 ) b = np . arange ( 5 , 10 ) def my_add ( x , num ): z = x + num return z myufunc = np . vectorize ( my_add , doc = \"每一个元素加上一个指定的数\" ) print ( myufunc . __doc__ ) myufunc ( a , 1 ) 每一个元素加上一个指定的数 array([1, 2, 3, 4, 5]) def my_add ( x , y , list_num ): z = x + y for i in list_num : z = z + i return z myufunc = np . vectorize ( my_add , excluded = [ 2 ]) myufunc ( a , b , [ 1 , 2 , 3 ]) # list_num 作为一个list，而不是向量化成一个个元素 array([11, 13, 15, 17, 19]) def my_add ( x , num ): z = x + num return z , z myufunc = np . vectorize ( my_add , otypes = [ np . float , int ]) myufunc ( a , 1 ) (array([1., 2., 3., 4., 5.]), array([1, 2, 3, 4, 5]))","text_tokens":["myufunc","数组","float","位置","关键字","的","实现","i","b","2","字符串","和","返回值","y","转换","一个个","11","the","来","功能","number","doc","for","print","]","代表","不是","参数","dtype","你","__","格式","num","8","_","def","而","numpy","list","array"," ","，","转换成","使用","中","调用","哪些","of","10","整数","vectorize","5","一个","其中","\"","。","input","也","则","将","多个","4","6","nout","给定","指定","类型","作为","表示","15","ufunc","输入","未","结果","化成","=","'","#","17","关键","x","my","none","frompyfunc","(","元素","object","otypes",".","向",",","是","[","12","返回","被","计算","函数","return","集合","通过","向量","个个","z","13","a","单个","为","14","3","如下","描述","arange","换成","+","可以","in","字符","量化","个数","add","数","output","excluded","若","加上","19",".__","func","如果",")","int","每",":","nin","np","1","列表","："],"title":"自定义 ufunc 函数","title_tokens":["定义","函数","ufunc","自定义","自定"," "]},{"location":"numpy笔记/5.8.ufunc函数.html#ufunc_1","text":"ufunc函数对象本身还有一些方法。 这些方法只对于两个输入、一个输出的ufunc函数函数有效。对于其他的ufunc函数对象调用这些方法时，会抛出 ValueError 异常。","text_tokens":["一些","、","对于","输出","只","ufunc","输入","还有","对象","这些","的"," ","，","本身","有效","时","调用","抛出","一个","其他","。","函数","异常","两个","方法","会","valueerror"],"title":"ufunc 对象的方法","title_tokens":["ufunc","方法","对象","的"," "]},{"location":"numpy笔记/5.8.ufunc函数.html#ufuncreduce","text":"ufunc.reduce 方法：类似于Python的 reduce 函数，它==沿着== axis 参数指定的轴，对数组进行操作。经过一次reduce，结果数组的维度降低一维。 假设 <op> 是一个ufunc函数， ufunc.reduce 用法如下： < op >. reduce ( array , axis = 0 , dtype = None ) a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . reduce ( a , axis = 1 ) # 沿着 列方向 array([ 6, 22, 38, 54, 70]) np . add . reduce ( a , axis = 0 ) # 沿着 行方向 array([40, 45, 50, 55]) 相当于将 运算符插入到沿着axis轴的所有元素之间： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) def fun ( a , b ): z = a + b + 1 return z fun2 = np . frompyfunc ( fun , 2 , 1 ) fun2 . reduce ( a , axis = 1 ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] array([9, 25, 41, 57, 73], dtype=object)","text_tokens":["数组","的","40","b","2","运算符","降低","11","插入","print","]","当于","参数","dtype","16","方法","0","8","def","55","25","fun","array","，"," ","之间","18","沿着","10","一个","5","。","所有","算符","将","4","6","指定","运算","一次","15","ufunc","结果","维度","22","=","相当","17","python","#",">","操作","none","20","frompyfunc","(","元素","object","41",".",",","类似","到","是","轴","[","12","54","函数","9","45","7","<","return","相当于","一维","方向","z","13","a","于","经过","3","14","38","如下","arange","reduce","列","+","50","add","行","reshape","fun2","57","19","它","进行","73","axis",")","假设","op",":","np","1","用法","对","70","："],"title":"ufunc.reduce()","title_tokens":[".",")","ufunc","(","reduce"]},{"location":"numpy笔记/5.8.ufunc函数.html#ufuncaccumulate","text":"ufunc.accumulate 方法：它类似于reduce()的计算过程，但是它会保存所有的中间计算结果，从而使得返回数组的形状和输入数组的形状相同： a = np . arange ( 20 ) . reshape ( 5 , 4 ) print ( a ) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] np . add . accumulate ( a , axis = 1 ) array([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38], [12, 25, 39, 54], [16, 33, 51, 70]], dtype=int32)","text_tokens":["8","int32","数组","15","中间","ufunc","输入","相同","25","从而","结果","a","于","的","3","13","14","22","array","38","39","，"," ","=","arange","reduce","17","和","2","但是","20","计算结果","形状","add","(","18","11","使得",".","51","reshape",",","类似","10","5","过程","[","19","它","保存","print","它会","]","所有","返回","12","54","计算","16","accumulate",")","9","dtype","4","7","方法","0","33","6","27","np","1","axis","70","："],"title":"ufunc.accumulate()","title_tokens":[".",")","accumulate","ufunc","("]},{"location":"numpy笔记/5.8.ufunc函数.html#ufuncouter","text":"ufunc.outer 方法：相当于将 运算符对输入数组A和输入数组B的每一对元素对(a,b)起作用。设A的shape=(4,5)，B的shape为(4,)，则结果数组的shape=(4,5,4) 一维数组和一维数组的outer操作为二维数组 a = np . arange ( 1 , 6 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array([[2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7], [5, 6, 7, 8], [6, 7, 8, 9]]) 多维数组的outer拆分成各自的一维操作 a = np . arange ( 1 , 7 ) . reshape ( 2 , 3 ) b = np . arange ( 1 , 5 ) np . add . outer ( a , b ) array ([[[ 2 , 3 , 4 , 5 ], [ 3 , 4 , 5 , 6 ], [ 4 , 5 , 6 , 7 ]], [[ 5 , 6 , 7 , 8 ], [ 6 , 7 , 8 , 9 ], [ 7 , 8 , 9 , 10 ]]])","text_tokens":["8","一维","数组","ufunc","输入","结果","a","为","的","相当于","3","np","array"," ","=","，","arange","相当","各自","b","运算符","和","2","多维","起","操作","分成","add","(","元素","拆","outer",".","reshape",",","10","shape","5","[","。","一对","]","算符","当于","二维",")","则","9","将","作用","4","每","方法","7","设","6","运算","1","对","："],"title":"ufunc.outer()","title_tokens":[".",")","ufunc","(","outer"]},{"location":"numpy笔记/5.8.ufunc函数.html#_5","text":"下面是一元的数学函数： abs/fabs ：计算整数、浮点数或者复数的绝对值。对于非复数值，可以使用更快的fabs sqrt ：计算平方根，相当于$a^{0.5}$ square ：计算平方，相当于$a^2$ exp ：计算指数$e^x$ log/log10/log2/log1p ：分别为$log_{e}(a), log_{10}(a), log_2(a), log_e(1+x)$ sign ：计算$sign(a)$ ceil ：计算各元素的ceiling值：大于等于该值的最小整数 floor ：计算个元素的floor值：小于等于该值的最大整数 rint ：将各元素四舍五入到最接近的整数，保留 dtype modf ：将数组的小数和整数部分以两个独立数组的形式返回 cos/cosh/sin/sinh/tan/tanh ：普通和双曲型三角函数 arccos/arcsosh/arcsin/arcsinh/arctan/arctanh :反三角函数 isnan ：返回一个布尔数组，该数组指示那些是 NaN isfinite/isinf ：返回一个布尔数组，该数组指示哪些是有限的/无限数","text_tokens":["小于","arctanh","数组","复数","的","保留","sin","ceiling","tan","isinf","下面","2","和","$","有限","浮点","平方根","或者","isfinite","当于","浮点数","dtype","sign","绝对","_","对于","abs","型","tanh","接近","/"," ","，","部分","那些","sinh","使用","isnan","}","哪些","反","{","各","log","分别","10","整数","一个","log2","以","。","modf","平方","fabs","将","形式","两个","0.5","三角函数","方根","最大","arccos","四舍五入","cos","该值","arctan","相当","布尔","数学","x","ceil","三角","(","元素","arcsin","更快",",","到","是","大于","等于","e","值","cosh","arcsinh","返回","非复","计算","函数","最小","无限","独立","相当于","最","普通","、","arcsosh","小数","log10","a","为","+","可以","绝对值","个","rint","数","一元","双曲","log1p","指示","square","该","nan","floor","sqrt","数值",")","^","点数",":","1","指数","exp","："],"title":"数学函数","title_tokens":["数学","函数"]},{"location":"numpy笔记/5.9.函数库.html","text":"import numpy as np 随机数库","text_tokens":["库","随机数","numpy","import","随机","as","np","机数"," "],"title":"5.9.函数库","title_tokens":[".","函数","5.9","函数库"]},{"location":"numpy笔记/5.9.函数库.html#_1","text":"","text_tokens":[],"title":"随机数库","title_tokens":["随机数","机数","随机","库"]},{"location":"计算机基础/1.1.计算机与程序结构.html","text":"CPU 计算机的工作过程就是计算机执行程序的过程。程序是一个指令序列，这个序列明确告诉计算机应该执行什么操作，在什么地方能够找到用来操作的数据。 一旦把程序装入主存储器，计算机就可以自动执行取出指令和执行指令的任务。 专门用来完成此项工作的计算机部件称为中央处理器（Central Processing Unit，CPU） ，做成单片集成电路的CPU通常又称为微处理器（Microprocessor），在一个集成电路中集成了两个 CPU 芯片，称之为双核（dual core）微处理器。现代的个人计算机一般都是使用微处理器作为CPU。 注意：CPU不是指一个特定的某一类东西，而是具有某种功能的部件的总称。所以，不管是何种形态、设计、原理的部件，只要它能具有取出指令、执行指令的功能，它就是CPU。 简而言之， CPU 是用来表示计算机内部元件功能的术语。 下图为陶瓷PGA封装的Intel 80486 DX2 CPU： 计算机工业从1960年代早期开始使用CPU这个术语。迄今为止，CPU从形态、设计到实现都已发生了巨大的变化，但是其基本工作原理却一直没有大的变化。 早期的CPU通常是为大型、特定的应用而定制的。目前，这种为特定应用而设计定制CPU的昂贵方法，在很大程度上已经让位于可大规模生产的通用处理器。这种标准化趋势，诞生于分立晶体管大型计算机（Mainframe）和小型计算机（Minicomputer）年代，并且随着集成电路（IC）的普及而大大加速。 现代的CPU使用集成电路制作，集成电路可以把日益复杂的CPU设计制造在很小的空间里。CPU的小型化和标准化，大大增加了这些数字器件在现代生活中的应用范围，远远超出了专用运算机器这一有限的应用。现代微处理器已经随处可见，从汽车到手机，甚至儿童玩具。 ​ ——参考于 英特尔文档：CPU的功能和组成 CPU和内存由数字集成电路（数字芯片）构成，集成电路通常称为IC（Integrated Circuit），它由晶体管组成，每一个晶体管具有ON/OFF两个状态。 从功能方面来看 ，CPU的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。 寄存器可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有20～100 个寄存器。 控制器负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。 运算器负责运算从内存读入寄存器的数据。 时钟负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。 寄存器的主要种类和功能 根据功能的不同，我们可以将寄存器大致划分为八类。可以看出，==寄存器中存储的内容既可以是指令也可以是数据。其中，数据分为“用于运算的数值”和“表示内存地址的数值”两种。==数据种类不同，存储该数值的寄存器也不同。CPU 中每个寄存器的功能都是不同的。 种类 功能 累加寄存器 accumulator 存储执行运算的数据和运算后的数据 标志寄存器 flag register 存储运算处理后的 CPU 的状态 程序计数器 program counter 存储下一条指令所在内存的地址 基址寄存器 base register 存储数据内存的起始地址 变址寄存器 index register 存储基址寄存器的相对地址 通用寄存器 general purpose register 存储任意数据 指令寄存器 instruction register 存储指令。CPU 内部使用，程序员无法通过程序对该寄存器进行读写操作 栈寄存器 stack register 存储栈区域的起始地址 寄存器对程序员来说比较特殊，因为寄存器是编程中的一个对象，例如在汇编语言中： # 汇编语言编写的程序示例 mov eax, dword ptr [ebp-8] …把数值从内存复制到 eax add eax, dword ptr [ebp-0Ch] …exa 的数值和内存的数值相加 mov dword ptr [ebp-4], eax …把 exa 的数值（上一步的相加结果）存储在内存中 eax 和 ebp 是 CPU 内部的寄存器的名称。内存的存储场所通过地址编号来区分，而寄存器的种类则通过名字来区分。 main memory 通常所说的内存指的是计算机的主存储器（main memory），简称主存。 主存通过控制芯片等与 CPU 相连， 主要负责存储指令和数据。 主存由可读写的元素构成，每个字节（1 Byte = 8 bit ）都带有一个地址编号。 CPU 可以通过该地址读取主存中的指令和数据，以及写入数据。 如何通过内存索引数据？ 内存的构成单位是一个字节（8位），每一个字节都有一个地址编号，这个地址编号是它的逻辑地址。 CPU中的寄存器（基址寄存器、变址寄存器）会储存中被运算的数据的编号地址。CPU寄存器的空间大小决定了CPU能识别多大的内存。 比如说，一个32位的寄存器，它能表示的最大数为$2^{32}-1=4294967295$（十进制数，从0开始；换成16进制数就是FFFFFFFF）。也就是说它能表示$2^{32}=4294967296$种状态。而4g的内存一共有$4\\times1024\\times1024\\times1024=4294967296$个byte，也就是说一个具有32位的寄存器的CPU最多能识别4g的内存。 通过基址寄存器和变址寄存器，我们可以对主内存上特定的内存区域进行划分。首先，我们用十六进制数 将计算机内存上 00000000～FFFFFFFF的地址划分出来。那么，凡是该范围的内存区域，只要有一个 32 位的 寄存器，即可查看全部的内存地址。 CPU所生成的地址通常称为逻辑地址(logical address)，而内存单元所看到的地址（即加载到内存地址寄存器(memory-address register)中的地址）通常称为物理地址(physical address) 。 逻辑地址与物理地址的对应关系并不是固定不变的，这取决于执行的地址绑定方案。因此，逻辑地址又称为虚拟地址。虚拟地址通过 映射 与物理地址对应起来。完成这种映射的硬件设备是 内存管理单元 (memory-management unit, MMU)，完成映射的方法有多种，也就是地址绑定方案有多种。程序无法访问物理地址，只能基于虚拟地址进行操作。","text_tokens":["虚拟地址","全部","program","指","integrated","陶瓷","cpu","2","儿童","做成","普及","定制","外部","4g","晶体管","也就是说","区分","16","dual","通用","存储","小型化","即","一旦","8","部件","不管","封装","最多能","general","/","大大增加","，","取决于","元件","玩具","特尔","一类","芯片","中央处理器","管理","那么","ic","十进制","储存","大型","其中","又","状态","能","读写操作","一般","两个","而言","早期","每个","最大","累加","exa","具有","两种","特定","现代","目前","里","大规","自动","比如说","名字","汇编","特殊","处理器","明确","物理","完成","了","首先","主存储器","通过","八类","index","？","即可","这一","指令和数据","算机","电路","memory","识别","何种","不同","用","出来","个","总称","add","与","这","复制","装入","此项","机器","执行程序","虚拟","形态","；","方案","十六进制","多大","数值","算器","无法","迄今","会","日益","计算机","1","最多","简称","设备","…","运算器","大数","而是","相加","应该","程度","程序员","数字","空间","来","手机","32","有","复制到","mainframe","]","基本","读取","硬件","存储器","数据","只要","应用","范围","最大数","）","单片","​","而","计时","core","迄今为止","语言","工业","区域"," ","部分","大大","使用","中","如何","组成","看到","用于","{","各","地址","儿童玩具","随处","“","集成","告诉","任务","专门","简而言之","也","可用","某种","复杂","相对","构成","读写","所","1960","其","相互","加速","寄存器","这些","把","原理","决定","标准化","100","(","中央","整个","用来","0ch","已","方面","连通","暂存","计算","在","带有","并","processing","位于","四个","address","base","physical","电流","为","可","可以","划分","处理","已经","加载","术语","我们","为止","程序","数","此项工作","单位","制作","规模","指令寄存器","该","称之为","mmu","on","让","增加","bit","生活","起来","超出","栈","任意","什么","地方","很大","stack","register","进制","存储栈","（","和","个人","内存","相连","内容","开始","所说","大小","有限","小型","0","flag","eax","因此","发生","东西","例如","对应","下","ptr","控制","位","之间","逻辑","变址","双核","所在","instruction","计数","一个","dx2","”","种类","写入","理器","purpose","。","起始","远远","大增","后","根据","运算","无法访问","制造","英特尔","不过","示例","访问","凡是","标志","元素","能够","生成","ffffffff","汽车","times1024","找到","从","由","-","工作","分为","、","不变","十六","设计","～","名称","就","负责","以及","换成","central","场所","来说","映射","management","指令","—","计数器","固定","基址","查看","80486","行程","过程","它","main","logical","可见","时钟","随处可见",")","就是","执行","很小","每","注意","字节","这个","对","单元","序列","通常","4294967296","4294967295","的","实现","变化","取出","但是","通用寄存器","信号","$","专用","主要","甚至","称为","功能","就是说","种","不是","pga","因为","方法","编程","趋势","比如","没有","并且","一直","却","microprocessor","}","等","intel","都","accumulator","\\","绑定","一种","取决","参考","则","控制器","将","4","00000000","之为","下图","内存地址","发出","作为","表示","对主","关系","对象","结果","大致","只能","英特","=","#","unit","这种","晶体","有些","上","操作","20","某","器件","ebp",",","集成电路","是","到","大","年代","编写","[","内部","比较","看作","circuit","被","物理地址","既","一条","读入","微处理器","巨大","随着","基于","汇编语言","byte","于","mov","昂贵","minicomputer","编号","分立","off","dword","索引","主存","一共","所以","看出","进行","来看","大规模","诞生","文档","counter","一步","成电","^","多种","寄存","标准","生产","："],"title":"1.1.计算机与程序结构","title_tokens":[".","计算","结构","算机","1.1","与","计算机","程序结构","程序"]},{"location":"计算机基础/1.1.计算机与程序结构.html#cpu","text":"计算机的工作过程就是计算机执行程序的过程。程序是一个指令序列，这个序列明确告诉计算机应该执行什么操作，在什么地方能够找到用来操作的数据。 一旦把程序装入主存储器，计算机就可以自动执行取出指令和执行指令的任务。 专门用来完成此项工作的计算机部件称为中央处理器（Central Processing Unit，CPU） ，做成单片集成电路的CPU通常又称为微处理器（Microprocessor），在一个集成电路中集成了两个 CPU 芯片，称之为双核（dual core）微处理器。现代的个人计算机一般都是使用微处理器作为CPU。 注意：CPU不是指一个特定的某一类东西，而是具有某种功能的部件的总称。所以，不管是何种形态、设计、原理的部件，只要它能具有取出指令、执行指令的功能，它就是CPU。 简而言之， CPU 是用来表示计算机内部元件功能的术语。 下图为陶瓷PGA封装的Intel 80486 DX2 CPU： 计算机工业从1960年代早期开始使用CPU这个术语。迄今为止，CPU从形态、设计到实现都已发生了巨大的变化，但是其基本工作原理却一直没有大的变化。 早期的CPU通常是为大型、特定的应用而定制的。目前，这种为特定应用而设计定制CPU的昂贵方法，在很大程度上已经让位于可大规模生产的通用处理器。这种标准化趋势，诞生于分立晶体管大型计算机（Mainframe）和小型计算机（Minicomputer）年代，并且随着集成电路（IC）的普及而大大加速。 现代的CPU使用集成电路制作，集成电路可以把日益复杂的CPU设计制造在很小的空间里。CPU的小型化和标准化，大大增加了这些数字器件在现代生活中的应用范围，远远超出了专用运算机器这一有限的应用。现代微处理器已经随处可见，从汽车到手机，甚至儿童玩具。 ​ ——参考于 英特尔文档：CPU的功能和组成 CPU和内存由数字集成电路（数字芯片）构成，集成电路通常称为IC（Integrated Circuit），它由晶体管组成，每一个晶体管具有ON/OFF两个状态。 从功能方面来看 ，CPU的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。 寄存器可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有20～100 个寄存器。 控制器负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。 运算器负责运算从内存读入寄存器的数据。 时钟负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。","text_tokens":["序列","通常","什么","地方","很大","指","integrated","的","实现","陶瓷","变化","（","cpu","运算器","和","个人","儿童","内存","取出","而是","但是","应该","程度","信号","做成","普及","开始","定制","数字","专用","有限","空间","甚至","称为","功能","手机","来","外部","有","晶体管","mainframe","基本","不是","pga","小型","dual","通用","存储器","存储","数据","只要","应用","方法","范围","小型化","）","一旦","单片","趋势","没有","​","部件","发生","东西","而","计时","不管","封装","并且","core","迄今为止","/","工业","一直","大大增加","控制","，"," ","部分","之间","大大","元件","microprocessor","使用","却","玩具","中","特尔","一类","组成","芯片","双核","等","中央处理器","各","ic","儿童玩具","随处","集成","告诉","intel","都","一个","dx2","种类","大型","任务","专门","理器","又","状态","。","远远","能","简而言之","一种","一般","也","可用","大增","参考","控制器","将","两个","某种","之为","而言","复杂","根据","运算","下图","构成","早期","发出","作为","表示","1960","其","加速","相互","制造","寄存器","这些","对象","具有","结果","英特尔","英特","不过","特定","把","现代","目前","unit","原理","这种","晶体","有些","标准化","里","上","操作","20","100","大规","某","器件","中央","自动","能够","集成电路","是","到","大","年代","整个","用来","汽车","处理器","找到","内部","已","明确","从","方面","连通","暂存","看作","circuit","计算","在","由","并","processing","完成","了","工作","主存储器","位于","读入","四个","、","微处理器","巨大","随着","算机","电路","这一","电流","为","于","设计","～","何种","就","昂贵","可","minicomputer","负责","不同","分立","off","可以","central","处理","已经","主存","个","总称","术语","指令","为止","程序","装入","—","此项工作","此项","80486","行程","规模","制作","过程","机器","所以","称之为","执行程序","它","形态","on","来看","可见","时钟","大规模","诞生","随处可见","文档","让","增加","算器","就是","执行","成电","很小","生活","每","迄今","注意","寄存","这个","会","日益","计算机","标准","生产","超出","："],"title":"CPU","title_tokens":["cpu"]},{"location":"计算机基础/1.1.计算机与程序结构.html#_1","text":"根据功能的不同，我们可以将寄存器大致划分为八类。可以看出，==寄存器中存储的内容既可以是指令也可以是数据。其中，数据分为“用于运算的数值”和“表示内存地址的数值”两种。==数据种类不同，存储该数值的寄存器也不同。CPU 中每个寄存器的功能都是不同的。 种类 功能 累加寄存器 accumulator 存储执行运算的数据和运算后的数据 标志寄存器 flag register 存储运算处理后的 CPU 的状态 程序计数器 program counter 存储下一条指令所在内存的地址 基址寄存器 base register 存储数据内存的起始地址 变址寄存器 index register 存储基址寄存器的相对地址 通用寄存器 general purpose register 存储任意数据 指令寄存器 instruction register 存储指令。CPU 内部使用，程序员无法通过程序对该寄存器进行读写操作 栈寄存器 stack register 存储栈区域的起始地址 寄存器对程序员来说比较特殊，因为寄存器是编程中的一个对象，例如在汇编语言中： # 汇编语言编写的程序示例 mov eax, dword ptr [ebp-8] …把数值从内存复制到 eax add eax, dword ptr [ebp-0Ch] …exa 的数值和内存的数值相加 mov dword ptr [ebp-4], eax …把 exa 的数值（上一步的相加结果）存储在内存中 eax 和 ebp 是 CPU 内部的寄存器的名称。内存的存储场所通过地址编号来区分，而寄存器的种类则通过名字来区分。","text_tokens":["栈","任意","program","的","stack","…","register","存储栈","（","cpu","和","内存","相加","内容","通用寄存器","程序员","来","功能","复制到","]","区分","通用","因为","存储","数据","flag","）","编程","eax","8","而","例如","general","下","语言","区域","ptr","，"," ","使用","中","变址","所在","用于","地址","“","instruction","计数","都","accumulator","一个","”","种类","其中","purpose","状态","。","起始","读写操作","也","则","将","4","后","根据","相对","运算","内存地址","读写","每个","累加","表示","exa","寄存器","大致","对象","结果","两种","示例","=","把","#","上","操作","标志","ebp",",","编写","是","名字","汇编","特殊","0ch","[","内部","比较","从","在","-","既","一条","通过","八类","index","分为","base","汇编语言","为","mov","名称","编号","不同","dword","可以","划分","处理","场所","来说","add","我们","复制","指令","程序","计数器","基址","指令寄存器","该","看出","进行","数值","counter","无法","一步","执行","寄存","对","："],"title":"寄存器的主要种类和功能","title_tokens":["和","主要","种类","寄存器","功能","寄存","的"]},{"location":"计算机基础/1.1.计算机与程序结构.html#main-memory","text":"通常所说的内存指的是计算机的主存储器（main memory），简称主存。 主存通过控制芯片等与 CPU 相连， 主要负责存储指令和数据。 主存由可读写的元素构成，每个字节（1 Byte = 8 bit ）都带有一个地址编号。 CPU 可以通过该地址读取主存中的指令和数据，以及写入数据。","text_tokens":["每个","8","指令和数据","通常","算机","memory","指","byte","的","控制","可","，"," ","负责","=","编号","以及","（","cpu","通过","可以","内存","中","主存","芯片","等","相连","与","地址","元素","指令","所说","都","是","一个","主要","写入","读写","该","。","main","计算","读取","带有","由","存储器","bit","存储","数据","字节","主存储器","计算机","）","1","构成","简称"],"title":"main memory","title_tokens":["memory"," ","main"]},{"location":"计算机基础/1.1.计算机与程序结构.html#_2","text":"内存的构成单位是一个字节（8位），每一个字节都有一个地址编号，这个地址编号是它的逻辑地址。 CPU中的寄存器（基址寄存器、变址寄存器）会储存中被运算的数据的编号地址。CPU寄存器的空间大小决定了CPU能识别多大的内存。 比如说，一个32位的寄存器，它能表示的最大数为$2^{32}-1=4294967295$（十进制数，从0开始；换成16进制数就是FFFFFFFF）。也就是说它能表示$2^{32}=4294967296$种状态。而4g的内存一共有$4\\times1024\\times1024\\times1024=4294967296$个byte，也就是说一个具有32位的寄存器的CPU最多能识别4g的内存。 通过基址寄存器和变址寄存器，我们可以对主内存上特定的内存区域进行划分。首先，我们用十六进制数 将计算机内存上 00000000～FFFFFFFF的地址划分出来。那么，凡是该范围的内存区域，只要有一个 32 位的 寄存器，即可查看全部的内存地址。 CPU所生成的地址通常称为逻辑地址(logical address)，而内存单元所看到的地址（即加载到内存地址寄存器(memory-address register)中的地址）通常称为物理地址(physical address) 。 逻辑地址与物理地址的对应关系并不是固定不变的，这取决于执行的地址绑定方案。因此，逻辑地址又称为虚拟地址。虚拟地址通过 映射 与物理地址对应起来。完成这种映射的硬件设备是 内存管理单元 (memory-management unit, MMU)，完成映射的方法有多种，也就是地址绑定方案有多种。程序无法访问物理地址，只能基于虚拟地址进行操作。","text_tokens":["虚拟地址","全部","设备","通常","4294967296","4294967295","的","register","进制","（","cpu","2","内存","和","大数","开始","大小","$","空间","称为","32","4g","有","也就是说","就是说","种","不是","16","硬件","数据","最大数","0","范围","只要","方法","）","即","比如","8","因此","而","最多能","对应","区域","位","，"," ","取决于","逻辑","中","}","变址","看到","{","管理","那么","地址","十进制","都","储存","一个","\\","又","状态","。","绑定","能","也","取决","将","00000000","4","运算","内存地址","构成","无法访问","所","最大","表示","对主","寄存器","关系","只能","具有","特定","=","unit","决定","这种","访问","凡是","上","操作","(",",","生成","到","是","ffffffff","比如说","times1024","从","物理","被","物理地址","计算","-","并","完成","了","首先","通过","、","即可","address","算机","physical","不变","基于","memory","byte","十六","为","识别","～","编号","换成","可以","划分","用","出来","加载","个","与","映射","我们","这","management","一共","数","程序","固定","基址","单位","查看","该","mmu","它","进行","虚拟","logical","；","方案","十六进制","多大","无法",")","就是","执行","每","^","多种","字节","寄存","这个","会","起来","计算机","1","最多","单元"],"title":"如何通过内存索引数据？","title_tokens":["内存","索引","如何","数据","通过","？"]},{"location":"计算机基础/1.2.基本概念.html","text":"程序和编程语言 程序（Program） 告诉计算机应如何完成一个计算任务，这里的计算可以是数学运算，比如解方程，也可以是符号运算，比如查找和替换文档中的某个单词。从根本上说，==计算机是由数字电路组成的运算机器，只能对数字做运算，程序之所以能做符号运算，是因为符号在计算机内部也是用数字表示的。==此外，程序还可以处理声音和图像，声音和图像在计算机内部必然也是用数字表示的，这些数字经过专门的硬件设备转换成人可以听到、看到的声音和图像。 程序由一系列 指令（Instruction） 组成，指令是指示计算机做某种运算的命令，通常包括以下几类： 输入（Input）：从键盘、文件或者其它设备获取数据。 输出（Output）：把数据显示到屏幕，或者存入一个文件，或者发送到其它设备。 基本运算：执行最基本的数学运算（加减乘除）和数据存取。 测试和分支：测试某个条件，然后根据不同的测试结果执行不同的后续指令。 循环：重复执行一系列操作。 对于程序来说，有上面这几类指令就足够了。你曾用过的任何一个程序，不管它有多么复杂，都是由这几类指令组成的。程序是那么的复杂，而编写程序可以用的指令却只有这么简单的几种，这中间巨大的落差就要由程序员去填了，所以编写程序理应是一件相当复杂的工作。 编写程序可以说就是这样一个过程：把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。 编程语言 ：编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。 机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，==语句是计算机指令的抽象表示。==举个例子，同样一个语句用C语言、汇编语言和机器语言分别表示如下： 低级编程语言使用计算机指令编写程序； 高级编程语言使用语句编写程序。 计算机只能对数字做运算，符号、声音、图像在计算机内部都要用数字表示，指令也不例外，上表中的机器语言完全由十六进制数字组成。最早的程序员都是直接用机器语言编程，但是很麻烦，需要查大量的表格来确定每个数字表示什么意思，编写出来的程序很不直观，而且容易出错，于是有了==汇编语言，把机器语言中一组一组的数字用助记符（Mnemonic）表示，直接用这些助记符写出汇编程序，然后让汇编器（Assembler）去查表把助记符替换成数字，也就把汇编语言翻译成了机器语言。== 从上面的例子可以看出， 汇编语言和机器语言的指令是一一对应的，汇编语言有三条指令，机器语言也有三条指令，汇编器就是做一个简单的替换工作 ，例如在第一条指令中，把 movl ?,%eax 这种格式的指令替换成机器码 a1 ? ，?表示一个地址，在汇编指令中是 0x804a01c ，转换成机器码之后是 1c a0 04 08 （这是指令中的十六进制数的小端表示，小端表示将在 第 5.1 节 “目标文件” 介绍）。 从上面的例子还可以看出，==高级语言的语句和低级语言的指令之间不是简单的一一对应关系，==一条 a=b+1; 语句要翻译成三条汇编或机器指令，这个过程称为 编译（Compile） ，由编译器（Compiler）来完成，显然编译器的功能比汇编器要复杂得多。用高级语言编写的程序必须经过编译转成机器指令才能被计算机执行，编译需要花一些时间，这是用高级语言编程的一个缺点，然而更多的是优点。首先，用高级语言编程更容易，写出来的代码更紧凑，可读性更强，出了错也更容易改正。其次，高级语言是可移植的（Portable）或者称为平台无关的（Platform Independent）。 平台 这个词有很多种解释，可以指计算机体系结构（Architecture），也可以指操作系统（Operating System），也可以指开发平台（编译器、链接器等）。不同的计算机体系结构有不同的指令集（Instruction Set），可以识别的机器指令格式是不同的，直接用某种体系结构的汇编或机器指令写出来的程序只能在这种体系结构的计算机上运行，然而各种体系结构的计算机都有各自的C编译器，可以把C程序编译成各种不同体系结构的机器指令，这意味着用C语言写的程序只需稍加修改甚至不用修改就可以在各种不同的计算机上编译运行。各种高级语言都具有C语言的这些优点，所以绝大部分程序是用高级语言编写的，只有和硬件关系密切的少数程序（例如驱动程序）才会用到低级语言。还要注意一点，即使在相同的体系结构和操作系统下，用不同的C编译器（或者同一个C编译器的不同版本）编译同一个程序得到的结果也有可能不同，C语言有些语法特性在C标准中并没有明确规定，各编译器有不同的实现，编译出来的指令的行为特性也会不同，应该尽量避免使用不可移植的语法特性。 总结一下编译执行的过程，首先你用文本编辑器写一个C程序，然后保存成一个文件，例如 program.c （通常C程序的文件名后缀是 .c ），这称为源代码（Source Code）或源文件，然后运行编译器对它进行编译，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，再加上一些描述信息，生成一个新的文件，例如 a.out ，这称为可执行文件，可执行文件可以被操作系统加载运行，计算机执行该文件中由编译器生成的指令，如下图所示： 有些高级语言以解释（Interpret）的方式执行，解释执行过程和C语言的编译执行过程很不一样。例如编写一个Shell脚本 script.sh ，内容如下： #! /bin/sh VAR = 1 VAR = $(( $VAR + 1 )) echo $VAR 定义Shell变量 VAR 的初始值是1，然后自增1，然后打印 VAR 的值。用Shell程序 /bin/sh 解释执行这个脚本，结果如下： $ / bin / sh script . sh 2 这里的 /bin/sh 称为解释器（Interpreter），它把脚本中的每一行当作一条命令解释执行，而不需要先生成包含机器指令的可执行文件再执行。如果把脚本中的这三行当作三条命令直接敲到Shell提示符下，也能得到同样的结果： $ VAR = 1 $ VAR = $ (( $ VAR + 1 )) $ echo $ VAR 2 编程语言仍在发展演化。以上介绍的机器语言称为第一代语言（1GL，1st Generation Programming Language），汇编语言称为第二代语言（2GL，2nd Generation Programming Language），C、C++、Java、Python等可以称为第三代语言（3GL，3rd Generation Programming Language）。目前已经有了4GL（4th Generation Programming Language）和5GL（5th Generation Programming Language）的概念。3GL的编程语言虽然是用语句编程而不直接用指令编程，但语句也分为输入、输出、基本运算、测试分支和循环等几种，和指令有直接的对应关系。而4GL以后的编程语言更多是描述要做什么（Declarative）而不描述具体一步一步怎么做（Imperative），具体一步一步怎么做完全由编译器或解释器决定，例如SQL语言（SQL，Structured Query Language，结构化查询语言）就是这样的例子。 解释执行的语言相比编译执行的语言有什么优缺点？ 这是我们的第一个思考题。本书的思考题通常要求读者系统地总结当前小节的知识，结合以前的知识，并经过一定的推理，然后作答。本书强调的是基本概念，读者应该抓住概念的定义和概念之间的关系来总结，比如本节介绍了很多概念：程序由语句或指令组成，计算机只能执行 低级语言 中的指令（汇编语言的指令要先转成机器码才能执行），高级语言要执行就必须先翻译成低级语言，翻译的方法有两种：编译和解释，虽然有这样的不便，但高级语言有一个好处是平台无关性。什么是平台？一种平台，就是一种体系结构，就是一种指令集，就是一种机器语言，这些都可看作是一一对应的，上文并没有用“一一对应”这个词，但读者应该能推理出这个结论，而高级语言和它们不是一一对应的，因此高级语言是平台无关的，概念之间像这样的数量对应关系尤其重要。那么编译和解释的过程有哪些不同？主要的不同在于什么时候翻译和什么时候执行。 现在回答这个思考题，根据编译和解释的不同原理，你能否在执行效率和平台无关性等方面做一下比较？ 程序的调试 编程是一件复杂的工作，因为是人做的事情，所以难免经常出错。据说有这样一个典故：早期的计算机体积都很大，有一次一台计算机不能正常工作，工程师们找了半天原因最后发现是一只臭虫钻进计算机中造成的。从此以后，程序中的错误被叫做臭虫（Bug），而找到这些Bug并加以纠正的过程就叫做调试（Debug）。有时候调试是一件非常复杂的工作，要求程序员概念明确、逻辑清晰、性格沉稳，还需要一点运气。调试的技能我们在后续的学习中慢慢培养，但首先我们要区分清楚程序中的Bug分为哪几类。 编译时错误 编译器只能翻译语法正确的程序，否则将导致编译失败，无法生成可执行文件。对于自然语言来说，一点语法错误不是很严重的问题，因为我们仍然可以读懂句子。而编译器就没那么宽容了，只要有哪怕一个很小的语法错误，编译器就会输出一条错误提示信息然后罢工，你就得不到你想要的结果。虽然大部分情况下编译器给出的错误提示信息就是你出错的代码行，但也有个别时候编译器给出的错误提示信息帮助不大，甚至会误导你。在开始学习编程的前几个星期，你可能会花大量的时间来纠正语法错误。等到有了一些经验之后，还是会犯这样的错误，不过会少得多，而且你能更快地发现错误原因。等到经验更丰富之后你就会觉得，语法错误是最简单最低级的错误，编译器的错误提示也就那么几种，即使错误提示是有误导的也能够立刻找出真正的错误原因是什么。相比下面两种错误，语法错误解决起来要容易得多。 运行时错误 编译器检查不出这类错误，仍然可以生成可执行文件，但在运行时会出错而导致程序崩溃。对于我们接下来的几章将编写的简单程序来说，运行时错误很少见，到了后面的章节你会遇到越来越多的运行时错误。读者在以后的学习中要时刻 注意区分编译时和运行时（Run-time）这两个概念 ，不仅在调试时需要区分这两个概念，在学习C语言的很多语法时都需要区分这两个概念，有些事情在编译时做，有些事情则在运行时做。 逻辑错误和语义错误 第三类错误是逻辑错误和语义错误。如果程序里有逻辑错误，编译和运行都会很顺利，看上去也不产生任何错误信息，但是程序没有干它该干的事情，而是干了别的事情。当然不管怎么样，计算机只会按你写的程序去做，问题在于你写的程序不是你真正想要的，这意味着程序的意思（即语义）是错的。找到逻辑错误在哪需要十分清醒的头脑，要通过观察程序的输出回过头来判断它到底在做什么。 通过本书你将掌握的最重要的技巧之一就是调试。调试的过程可能会让你感到一些沮丧，但调试也是编程中最需要动脑的、最有挑战和乐趣的部分。从某种角度看调试就像侦探工作，根据掌握的线索来推断是什么原因和过程导致了你所看到的结果。调试也像是一门实验科学，每次想到哪里可能有错，就修改程序然后再试一次。如果假设是对的，就能得到预期的正确结果，就可以接着调试下一个Bug，一步一步逼近正确的程序；如果假设错误，只好另外再找思路再做假设。“当你把不可能的全部剔除，剩下的——即使看起来再怎么不可能——就一定是事实。”（即使你没看过福尔摩斯也该看过柯南吧）。 也有一种观点认为，编程和调试是一回事，编程的过程就是逐步调试直到获得期望的结果为止。你应该总是从一个能正确运行的小规模程序开始，每做一步小的改动就立刻进行调试，这样的好处是总有一个正确的程序做参考：如果正确就继续编程，如果不正确，那么一定是刚才的小改动出了问题。例如，Linux操作系统包含了成千上万行代码，但它也不是一开始就规划好了内存管理、设备管理、文件系统、网络等等大的模块，一开始它仅仅是Linus Torvalds用来琢磨Intel 80386芯片而写的小程序。据Larry Greenfield 说，“Linus的早期工程之一是编写一个交替打印AAAA和BBBB的程序，这玩意儿后来进化成了Linux。”（引自The Linux User's Guide Beta1版）在后面的章节中会给出更多关于调试和编程实践的建议。 变量及其行为 变量（Variable）是编程语言最重要的概念之一。 变量是计算机存储器中的一块命名的空间，可以在里面存储一个值（Value），存储的值是可以随时变的，比如这次存个字符 'a' 下次存个字符 'b' ，正因为变量的值可以随时变所以才叫变量。 也就是说，变量有一个储存地址，该地址储存的值是可以改变的。或者说，变量是一种使用方便的占位符，用于引用计算机内存地址，变量创建后会占用一定的内存空间。 不要弄混变量和变量名，变量名是标识符的一种。 占位符 ：先占住一个固定的位置，等待值添加到该位置的符号。 变量的类型决定了它所占的存储空间的大小。 变量的行为一共有四种：声明、定义、初始化、赋值。 声明 ：告诉编译器/解析器有这个变量的存在，这个行为不分配内存空间。 定义 ：为变量分配内存空间。 实际上，从广义的角度来说，声明有两种： 引用性声明（defining declaration）：不需要建立储存空间的声明，例如 extern in a 中的变量 a 已经在别的文件中被定义。 定义性声明（referencing declaration）：需要建立储存空间的声明，例如 int a 在声明时就建立了 a 的储存空间。 可见从广义的角度来说，声明包含了定义，而并非所有的声明都是定义。一般的情况下我们常常这样叙述，把建立空间的声明称之为\"定义\"，而把不需要建立存储空间称之为\"声明\"。 定义和声明的本质区别就是：定义会给变量分配内存空间，而声明则不会。 初始化 ：在定义变量之后，系统为变量分配的内存空间内并没有值，此时值是不确定的。为保证程序的安全性和确定性，需要对这个内存空间进行初始化。初始化一般伴随着定义而产生。初始化是从无到有的过程。 如果变量的定义没有初始化，那这个最初分配的空间的值是随机的（空间上原来存储的值）。不经过初始化的变量可能会为程序带来不安全与不确定性。 赋值 ：赋值是变量值得刷新操作。赋值是从旧到新的过程。 基础概念（python） assignment ：Assignments do not copy data — they just bind names to objects. assignment操作不会拷贝，只是把名字和对象做一个绑定。也就是assignment语句是起一个绑定或重绑定的作用（bind or rebind）。函数调用的参数传递是传引用，不是拷贝。 引用（reference ） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。因此，引用亦常被称为==该资料==的 指标 或 位址 。 标识符（identifier，缩写为ID） ：又称为识别码，是一个用来识别不同对象的名称。 在编程语言中，标识符就是程序员自己规定的具有特定含义的词，比如函数名、方法名、类名，变量名、常量名等。 对象（object） ：是一个记忆体位址，其中拥有值，这个位址可能有标识符指向此处。台湾译作物件。对象是某个类的实例。我们将数据和对数据的操作融为一体，形成具有静态信息和动态行为的对象。 每个对象都具有一个ID、一个类型、一个值。对象一旦建立，ID便不会改变。这里所说的ID是是对象在内存中的地址，而不是identifier。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 标识符并不是对象的属性，一个对象可以指向不同的标识符。而管理这些名字（标识符）的事物就是“命名空间”。 命名空间（Namespace） ：名字（标识符）到对象的==映射==。 A namespace is a mapping from names to objects. 各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。 现今 Python 的大部分命名空间是通过字典来实现的，也即一个命名空间就是名字到对象的映射，标识符是键，对象则是值。 与命名空间相对的一个概念就是“作用域” 。 作用域（Scope） ：本质是一块文本区域，Python 通过该文本区域可以 直接访问 相应的命名空间。 直接访问 ：Python 中不加 . 的访问为直接访问，反之为属性访问。 命名空间与作用域的联系 ：作用域是 Python 的一块文本区域，即一块代码区域，需要代码区域引用名字（标识符）来访问变量，那么作用域与命名空间之间就有了联系。 名字作用域 ：名字可以影响到的代码文本区域。 命名空间的作用域 ：就是这个命名空间可以影响到的代码文本区域。 显然可以存在这样的一个代码文本区域，它可以被多个命名空间影响。 面向对象编程 ：基于对象概念来分析问题和设计解法，这就是面向对象编程（object-orientation programming，简称OOP）。通过OOP所得到的程序是一个由很多对象组成的系统，可以向对象发送消息来实现对数据的处理，全体对象通过相互协作来完成程序的数据处理功能。 面向过程编程 ：得到的程序是一组对数据进行操作的过程，通过按顺序执行这些过程来实现程序功能。 类的概念 类是类型概念的发展。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 用计算机解决问题时，首先需要明确问题中涉及哪些数据，并在程序中将这些数据用编程语言提供的数据类型表示出来，然后再去考虑需要对这些数据执行何种操作。 为了表示数据，编程语言一般提供若干 基本数据类型 （如Python的int、float、str和list等类型） ，并为这些基本类型提供相应的基本操作（如Python中对int、float、str和list都提供了+运算，尽管含义不同）。 然而，实际问题中往往涉及很复杂的数据，不能用基本数据类型直接表示。为了表示复杂数据，大体有两种办法： 一种是将复杂数据分解成若干个简单数据项，以便每个数据项可以用基本类型表示 另一种是由用户自定义新的数据类型，以便对复杂数据进行直接的、整体的表示。 例如，如果要表示一个学生的姓名，可以简单地用一个字符串数据表示；如果要表示一个学生的年龄，可以简单地用一个整数数据表示。但如果要整体表示一个“学生”，包括该学生的姓名、年龄、地址等信息，就没法用基本数据类型直接表示了。 一种解决办法是将整体的“学生”分解成姓名、年龄、地址等简单数据，并通过分别处理这些简单数据而达到处理“学生”数据的目的。但这不是好办法，因为这种表示法丢失了数据的整体性，在维护姓名、年龄、地址等数据间的联系时很麻烦。 另一种解决办法是将学生整体视为一个数据值，并为这种数据值定义新的数据类型（因为编程语言中没有现成的类型能够表示该数据）。 假设我们要为“学生“数据定义一个新的数据类型S，那么S应该是由若干更简单的数据项构成的（如学号、姓名等），我们称这些构成S的成员数据为S的属性。除了定义S类型数据的属性，还需要定义能对S数据执行什么操作（如修改姓名或年龄、读取地址等）。可以利用编程语言提供的基本类型和新类型定义机制来实现S，例如用str类型表示姓名和学号，用int类型表示年龄之类，用函数实现对S数据的操作。定义了S，就好像为编程语言添加了一个新的数据类型，应用程序就可以像使用整数、字符串等基本类型一样去使用S。 由此，我们从传统的数据类型概念发展出了“类”的概念。类（class）是广义的数据类型，能够定义复杂数据的特性，包括静态特性（即数据）和动态特性（即对数据的操作方法）。 类的值就是“对象”，也称为类的实例。 对象 vs 变量 python的入门者可能很容易把变量和对象混为一谈，实际上，可以说python中不存在变量这样的概念，所谓的变量实质上是对象的名字。 在python中，对象属于某一个类型，而变量是没有类型的。所有的变量都是内存中一个对象的“引用”，也就是说变量的值实际上是对象的地址，而不是对象本身的值。 例如： nfoo = 1 #一个指向int数据类型的nfoo（再次提醒，nfoo没有类型），在这里，具有类型的是1 lstFoo = [ 1 ] #一个指向list类型的lstFoo，这个list中包含一个整数1 可更改(mutable) vs 不可更改(immutable) 在python中，strings、tuples、numbers是不可更改(immutable)的对象，而list、dict等则是可以修改(mutable)的对象。那么，这些所谓的可改变和不可改的本质是什么呢？ mutable、immutable只是python语言的一个规定。从硬件角度说，硬件提供给用户的接口是按照规定设定好的。比如说，操作内存的方式是固定的，不存在可变和不可变。实现python的可变、不可变就是调用了不同的底层api，或者是不同底层api相互组合来实现的。python将这些规定以python语法的形式提供给用户使用，最后还是编译成0、1去让计算机执行。对于用户来说，可变和不可变对象是语言提供的一个特性，可以完成一些功能，但是对于计算机其实是没区别的。 而在python中，不可变就是对象本身无法被修改，比如对象的值无法被修改。修改不可变对象只能创建新对象，旧对象若没有引用，则会被内存回收机制销毁。而可变对象的值是可以修改的。 接下来看一个例子： nfoo = 1 nfoo = 2 lstFoo = [ 1 ] lstFoo [ 0 ] = 2 代码第2行中，内存中原始的1对象因为不能改变，于是被“抛弃”，另nfoo指向一个新的int对象，其值为2。 代码第5行中，更改list中第一个元素的值，因为list是可改变的，所以，第一个元素变更为2。其实应该说，lstFoo指向一个 列表对象 。赋值所发生的事情，lstFoo所指向的列表对象的第一个元素被替换为新的值，但是对于lstFoo本身来说，它的值（列表的地址）没有变换，只是列表对象的内容发生变化了。 如下图所示： 但有时候，即使对象被复制了，修改原对象，两个变量指向的对象都改变了，怎么回事？ def fun2 (): a = [ 1 , 2 , 3 ,[ 1 , 2 ]] b = a . copy () a [ 1 ] = a [ 3 ][ 0 ] = 10 print ( a , ' \\n ' , b ) def fun2_2 (): a = [ 1 , 2 , 3 ,[ 1 , 2 ]] b = a . copy () a [ 1 ] = a [ 3 ] = 10 print ( a , ' \\n ' , b ) 上面定义了两个函数，两个函数输出的结果会一样吗？让我们看看： fun2 ------------------- [ 1 , 10 , 3 , [ 10 , 2 ]] [ 1 , 2 , 3 , [ 10 , 2 ]] fun2_2 ------------------- [ 1 , 10 , 3 , 10 ] [ 1 , 2 , 3 , [ 1 , 2 ]] 为什么 fun2 中b的第2个元素的值不变，而第四个元素的值却被改变了，而在 fun2_2 中b的值都没变？ 因为list储存的不是值，而是对象的引用。 Python的函数参数传递：传值？引用？ python函数参数传递可以理解为就是变量传值操作，入门者可能会发现，不可变对象作为参数，看似是传引用；而可变对象作为参数，看似是传值。举一个例子： 不可变对象参数调用 def ChangeInt ( a ): a = 10 nfoo = 2 ChangeInt ( nfoo ) print nfoo #结果是2 这时发生了什么？让我们看一下 nfoo 和 a 实际的值的变化： nfoo = 2 # nfoo：对象2的地址 # 进行传参： a = nfoo # 函数参数a：对象2的地址 # 对a进行赋值 a = 10 # 函数参数a：对象10的地址；此时，nfoo的值：对象2的地址 也就是说，当 nfoo 传参给 ChangeInt() 的时候，是传递了 nfoo 的值，是 值传递 。如下图： 因为对象是不可变的，所以对b重新赋值的时候，只能创建一个新的对象10，将对象10放进新的地址，而不是将储存于1的地址的值删除，再把10放进1的地址。 但可变对象不同于不可变对象： 可变对象参数调用 def ChangeList ( a ): a [ 0 ] = 10 lstFoo = [ 2 ] ChangeList ( lstFoo ) print lstFoo #结果是[10] 这时发生了什么？让我们看一下 nfoo 和 a 实际的值的变化： lstFoo = [ 2 ] # nfoo：对象[2]的地址 # 进行传参： a = lstFoo # 函数参数a：对象[2]的地址 # 对a进行赋值 a [ 0 ] = 10 # 函数参数a：对象[2]的地址；此时，nfoo的值：对象[2]的地址 当 lstFoo 传参给 ChangeList() 的时候， 变量仍旧是“传值” ，a复制了变量 lstFoo 的值，于是 a 和 lstFoo 指向同一个对象，但是，list是可以改变的对象，对 a[0] 进行赋值，就是更改原对象的值，而 lstFoo 也指向原对象。于是，这时的 a[0] = 10 ，就是更改了 lstFoo 指向的对象的第一个元素。所以，再次输出 lstFoo 时，显示 [10] ，因此，看起来是 lstFoo 的值改变了。但实际上 lstFoo 的值还是原对象的地址， lstFoo 的值并没有改变，改变的是对象。 综上所以，python的传参，传进去的是name（变量）的值，而name的值是object的引用。也就是说，传参传的是name的值（object的引用）。传参无法把对象的值传进去。","text_tokens":["个字符","旧","存入","相同","program","运气","大量","第四","觉得","the","定义","学号","或者","script","密切","code","一门","存储","还是","不管","dict","/","丢失","一","guide","vs","其中","形成","文本编辑","多个","声音","bbbb","早期","一些","torvalds","自定","观点","按","具有","特定","操作方法","只是","整体","某个","之后","汇编","第三代","间接","抽象","明确","解析","加减乘除","译作","记忆体","弄混","普通","但","动态","如下","何种","不同","nfoo","个","一系","行","复制","其他","小节","低级","要","虽然","可执行文件","尽管","会","1","系统地","不出","解决问题","填","不用","strings","下面","independent","immutable","助记符","]","读取","就要","只要","地用","最初","三代","传值","概念","一一对","版本","list","把子","部分","中","看到","出","如学","names","各","告诉","var","半天","任务","通过观察","上万","中要","回答","现成","找出","某种","用到","复杂","一台","驱动","不到","把","足够","a1","编译成","原理","获取数据","machine","去","(","原","用来","自然语言","发送","在","并","中不加","单词","解释器","四个","意味","释器","第","声明","更改","事情","上文","出错","让","之一","发展","挑战","1c","很大","分析","转换","不确定性","开始","怎么样",";","08","eax","发生","关于","称","尽量","尽量避免","之间","明确规定","发生变化","方程","一样","汇编程序","第四个","”","若干个","文件名","刚才","所示","玩意","还要","才能","得不到","逐步","declaration","上表","沉稳","访问","后缀","各种","结构化","抛弃","举","值","仍旧","成","第二","变更","-","分支","variable","如","、","帮助","名称","现今","判断","使用方便","此时","旧到","融为一体","来说","—","指示","source","fun2","很少","可见","正确","看似",")","很小","每","崩溃","实现","行中","变化","b","但是","当作","其它","面向对象编程","oop","调试","referencing","just","portable","标识符","中间","这样","不会","吗","接着","广义","c","行文","稍加","整数","三条","是因为","提示符","name","失败","经常","programming","原始","之为","data","简单","拷贝","命令","条件","从此以后","输出","表示","引自","=","子","清醒","尤其","有些","操作","某","本质区别","误导","给出","抓住","mnemonic","机器语言","sh","代码","显示","非常复杂","然后","利用","错","成千上万","其实","编程语言","reference","+","in","提示信息","获取","体系结构","本","第一个","一共","技能","得到","角度","看出","进行","基础","没变","比","顺序","一步","此处","落差","标准","建立","aaaa","版","assignment","一行","全部","float","随机","它们","value","源代码","2","不可","会为","下来","也就是说","器写","考虑","一般而言","会犯","区分","即","给","函数参数","表示法","检查","确定性","设定","user","能否","很多","看上","每个","值得","几类","例外","越来","里","或者说","编程序","销毁","方式","整体性","引用","echo","回过头来","字典","剩下","叫","实际上","数字电路","独立","实践","一只","循环","同一个","作用域","标识","怎么回事","识别","回过","用","沮丧","个别","符号","这里","这","output","若","重要","任何","常","越来越","哪","假设","5gl","第一条","怎么","位置","学习","后面","最后","办法","程序员","千上万","来","有","绝大","创建","总结","应用","not","分配","系统","语言","事实","考题","行为","存","需","也","性格","思考题","类型","组合","相互","这些","class","消息","成员","决定","乘除","移植","一件","顺利","方面","位址","函数","星期","内存空间","难免","看起","实际","协作","为","可","词","改变","感到","处理","加载","out","掌握","str","数","过头","培养","典故","琢磨","分解成","机器码","缩写","they","替换","物件","本书","2gl","每次","什么","前","中是","若干","图像","内存","带来","变换","规划","同于","内容","反之","进化","性","会花","同一","第一代","你","文本","认为","大部分","0","开发","接口","只会","因此","定义新","提醒","加减","传参","四种","哪些","5.1","是从","instruction","清楚","另外","一个","助记","s","\"","举个","体性","。","input","不便","于是","工程师","三行","为什么","后","容易","运算","侦探","此外","完全","不过","%","查表","生成","能够","变","找到","立刻","几个","具体","所谓","分为","一定","a","思路","测试","identifier","设计","就","吧","改","映射","语义","high","固定","第三类","过程","总是","level","为了","这类","就是","常常","注意","这个","imperative","通常","只","结论","的","先生","才","建议","等到","不加","可移植","0x804a01c","小端","就是说","不是","因为","方法","改正","编程","query","没有","时刻","本身","理解","转换成","推断","numbers","传","operating","都","5","不要","交替","所有","则","多","指标","得","内存地址","解释","关系","只能","结果","提示","java","少数","写","上","拥有","情况","大","占用","structured","以后","解决","赋值","自定义","一条","键盘","类名","自己","mapping","只有","变量","遇到","解法","几章","成千","from","所以","另","生变","sql","多种","一点","节","地","体系","读懂","放进","指","姓名","有时候","很","达到","不","说","人","目的","bug","interpreter","敲到","目标","罢工","随时","误信","do","一旦","tuples","强调","，","发现错误","管理","那么","问题","实体","哪里","储存","后来","不仅","一般","两个","而言","一系列","由此","表格","发送到","两种","is","时","方便","从无到有","assignments","其次","高级","比如说","名字","叫做","extern","mutable","首先","最早","？","麻烦","混为","算机","出来","效率","体积","工程","优点","机器","一一对应","执行程序","过","别的","；","十六进制","大体","再试一次","键","?","翻译","简称","设备","原来","好处","低级语言","听到","declarative","思考","章节","字符串","可读性","应该","有时","例子","!","空间","意味着","changelist","platform","回收","观察","基本","硬件","）","而","这次","def","数量","没","区域","仍然","角度看","网络","使用","剔除","如何","组成","3rd","用于","年龄","“","台湾","严重","本质","意思","正常","显然","defining","相对","期望","指向","所","成人","词有","time","语法","python","识别码","基本概念","送到","c语言","符","计算","预期","并非","数据处理","福尔摩斯","小","已经","打印","数据表","我们","乐趣","程式","加以","机制","称之为","linux","内","数据项","重新","读者","bind","据说","一代","源文件","起来","这么","或","bin","包含","进制","保证","含义","玩意儿","orientation","间","所说","大小","到底","宽容","安全性","传参传","在于","二代","图","往往","例如","下","编译","2nd","逻辑","调用","属性","重名","便","直接","应用程序","分解","占位","根据","greenfield","好像","继续","set","除了","元素","避免","变量名","自增","大部","翻译成","维护","转成","获得","然而","融为","不变","十六","描述","机器指令","函数调用","常量","总有","先","添加","删除","想到","执行","科学","找","自然","装置","里面","查找","这时","时间","文件","三类","动脑","想要","n","语法错误","特性","据","等待","查询语言","$","功能","改动","参数","之所以","占住","先占住","看过","入门者","比如","对于","仅仅","号","lstfoo","却","时会","当然","等","全体","相比","intel","会少","10","\\","绑定","应","language","参考","将","命名","作为","数传","输入","一体","编译器","#","看","错误","相应","静态",".","向",",","到","内部","比较","被","存取","看看","数据类型","像","看上去","操作系统","初始值","巨大","基于","汇编语言","经过","于","器","一下","需要","接下","可能","实质","一组","存储空间","列表","1st","：","根本","纠正","low","臭虫","产生","译成","结构","rebind","快","print","进去","原因","compiler","可更改","逼近","数据表示","那","各自","copy","scope","再","architecture","运行","视为","推理","4gl","一一","伴随","芯片","否则","经验","占","又","能","3gl","线索","福尔","十分","形式","仍","面向","statement","中将","曾","这是","目前","'","之类","句子","层层","涉及","4th","语句","一对","没法","查询","实例","属于","完成","刷新","了","通过","objects","电路","3","底层","不同于","摩斯","changeint","更","与","着","interpret","结合","assembler","规定","保存","系列","无法","做","计算机","存在","关系密切","资料","可变","平台","从此","类","api","绝大部分","即使","上面","数字电","介绍","而是","数字","传统","run","存储器","数据","要求","格式","linus","新","编辑","多么","慢慢"," ","分配内存","解方程","确定","一块","地址","回事","参数传递","专门","事物","构成","上去","从根本上","movl","入门","花","像是","直观","larry","实验","重复","知识","object","修改","以便","最有","其值","见","最","现在","各个","查","必须","当前","定性","可以","字符","正","为止","程序","包括","规模","该","亦","int","信息","或重","看起来","错误信息","（","联系","和","按照","丰富","debug","时候","80386","而且","5th","还","缺点","哪怕","_","相互协作","id","对应","基本操作","优缺点","干","中一","记忆","们","以","a0","后续","区别","只好","一次","解决办法","相当","起","提供","c++","第三","从","文件系统","由","非常","真正","作用","写出","演化","影响","工作","以上","理应","无关","作答","柯南","没法用","直到","汇编器","指令集","混为一谈","电脑","及其","屏幕","学生","造成","换成","紧凑","呢","指令","system","行程","当","它","初始化","头脑","第一","解析器","第二代","对","小规模","替换成","发现","安全","初始","1gl","主要","甚至","称为","namespace","模块","beta1","再次","等等","必然","链接","下次","综上","分别","generation","类型定义","一种","导致","以下","04","shell","名","对象","数学","这种","几种","好","转","编写","是","不能","[","传递","看作","更强","叙述","钻进","同样","用户","assembly","脚本","or","驱动程序","以前","接下来","编写程序","可读","加上","to","技巧","compile","文档","如果","清晰",":"],"title":"1.2.基本概念","title_tokens":[".","概念","1.2","基本概念","基本"]},{"location":"计算机基础/1.2.基本概念.html#_1","text":"程序（Program） 告诉计算机应如何完成一个计算任务，这里的计算可以是数学运算，比如解方程，也可以是符号运算，比如查找和替换文档中的某个单词。从根本上说，==计算机是由数字电路组成的运算机器，只能对数字做运算，程序之所以能做符号运算，是因为符号在计算机内部也是用数字表示的。==此外，程序还可以处理声音和图像，声音和图像在计算机内部必然也是用数字表示的，这些数字经过专门的硬件设备转换成人可以听到、看到的声音和图像。 程序由一系列 指令（Instruction） 组成，指令是指示计算机做某种运算的命令，通常包括以下几类： 输入（Input）：从键盘、文件或者其它设备获取数据。 输出（Output）：把数据显示到屏幕，或者存入一个文件，或者发送到其它设备。 基本运算：执行最基本的数学运算（加减乘除）和数据存取。 测试和分支：测试某个条件，然后根据不同的测试结果执行不同的后续指令。 循环：重复执行一系列操作。 对于程序来说，有上面这几类指令就足够了。你曾用过的任何一个程序，不管它有多么复杂，都是由这几类指令组成的。程序是那么的复杂，而编写程序可以用的指令却只有这么简单的几种，这中间巨大的落差就要由程序员去填了，所以编写程序理应是一件相当复杂的工作。 编写程序可以说就是这样一个过程：把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。 编程语言 ：编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。 机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，==语句是计算机指令的抽象表示。==举个例子，同样一个语句用C语言、汇编语言和机器语言分别表示如下： 低级编程语言使用计算机指令编写程序； 高级编程语言使用语句编写程序。 计算机只能对数字做运算，符号、声音、图像在计算机内部都要用数字表示，指令也不例外，上表中的机器语言完全由十六进制数字组成。最早的程序员都是直接用机器语言编程，但是很麻烦，需要查大量的表格来确定每个数字表示什么意思，编写出来的程序很不直观，而且容易出错，于是有了==汇编语言，把机器语言中一组一组的数字用助记符（Mnemonic）表示，直接用这些助记符写出汇编程序，然后让汇编器（Assembler）去查表把助记符替换成数字，也就把汇编语言翻译成了机器语言。== 从上面的例子可以看出， 汇编语言和机器语言的指令是一一对应的，汇编语言有三条指令，机器语言也有三条指令，汇编器就是做一个简单的替换工作 ，例如在第一条指令中，把 movl ?,%eax 这种格式的指令替换成机器码 a1 ? ，?表示一个地址，在汇编指令中是 0x804a01c ，转换成机器码之后是 1c a0 04 08 （这是指令中的十六进制数的小端表示，小端表示将在 第 5.1 节 “目标文件” 介绍）。 从上面的例子还可以看出，==高级语言的语句和低级语言的指令之间不是简单的一一对应关系，==一条 a=b+1; 语句要翻译成三条汇编或机器指令，这个过程称为 编译（Compile） ，由编译器（Compiler）来完成，显然编译器的功能比汇编器要复杂得多。用高级语言编写的程序必须经过编译转成机器指令才能被计算机执行，编译需要花一些时间，这是用高级语言编程的一个缺点，然而更多的是优点。首先，用高级语言编程更容易，写出来的代码更紧凑，可读性更强，出了错也更容易改正。其次，高级语言是可移植的（Portable）或者称为平台无关的（Platform Independent）。 平台 这个词有很多种解释，可以指计算机体系结构（Architecture），也可以指操作系统（Operating System），也可以指开发平台（编译器、链接器等）。不同的计算机体系结构有不同的指令集（Instruction Set），可以识别的机器指令格式是不同的，直接用某种体系结构的汇编或机器指令写出来的程序只能在这种体系结构的计算机上运行，然而各种体系结构的计算机都有各自的C编译器，可以把C程序编译成各种不同体系结构的机器指令，这意味着用C语言写的程序只需稍加修改甚至不用修改就可以在各种不同的计算机上编译运行。各种高级语言都具有C语言的这些优点，所以绝大部分程序是用高级语言编写的，只有和硬件关系密切的少数程序（例如驱动程序）才会用到低级语言。还要注意一点，即使在相同的体系结构和操作系统下，用不同的C编译器（或者同一个C编译器的不同版本）编译同一个程序得到的结果也有可能不同，C语言有些语法特性在C标准中并没有明确规定，各编译器有不同的实现，编译出来的指令的行为特性也会不同，应该尽量避免使用不可移植的语法特性。 总结一下编译执行的过程，首先你用文本编辑器写一个C程序，然后保存成一个文件，例如 program.c （通常C程序的文件名后缀是 .c ），这称为源代码（Source Code）或源文件，然后运行编译器对它进行编译，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，再加上一些描述信息，生成一个新的文件，例如 a.out ，这称为可执行文件，可执行文件可以被操作系统加载运行，计算机执行该文件中由编译器生成的指令，如下图所示： 有些高级语言以解释（Interpret）的方式执行，解释执行过程和C语言的编译执行过程很不一样。例如编写一个Shell脚本 script.sh ，内容如下： #! /bin/sh VAR = 1 VAR = $(( $VAR + 1 )) echo $VAR 定义Shell变量 VAR 的初始值是1，然后自增1，然后打印 VAR 的值。用Shell程序 /bin/sh 解释执行这个脚本，结果如下： $ / bin / sh script . sh 2 这里的 /bin/sh 称为解释器（Interpreter），它把脚本中的每一行当作一条命令解释执行，而不需要先生成包含机器指令的可执行文件再执行。如果把脚本中的这三行当作三条命令直接敲到Shell提示符下，也能得到同样的结果： $ VAR = 1 $ VAR = $ (( $ VAR + 1 )) $ echo $ VAR 2 编程语言仍在发展演化。以上介绍的机器语言称为第一代语言（1GL，1st Generation Programming Language），汇编语言称为第二代语言（2GL，2nd Generation Programming Language），C、C++、Java、Python等可以称为第三代语言（3GL，3rd Generation Programming Language）。目前已经有了4GL（4th Generation Programming Language）和5GL（5th Generation Programming Language）的概念。3GL的编程语言虽然是用语句编程而不直接用指令编程，但语句也分为输入、输出、基本运算、测试分支和循环等几种，和指令有直接的对应关系。而4GL以后的编程语言更多是描述要做什么（Declarative）而不描述具体一步一步怎么做（Imperative），具体一步一步怎么做完全由编译器或解释器决定，例如SQL语言（SQL，Structured Query Language，结构化查询语言）就是这样的例子。","text_tokens":["一行","全部","体系","根本","存入","相同","program","low","指","源代码","大量","译成","结构","很","不可","2","不","说","定义","interpreter","敲到","或者","script","器写","密切","目标","code","compiler","各自","不管","/","，","再","architecture","运行","4gl","一一","那么","能","3gl","文本编辑","仍","声音","一系列","每个","一些","statement","表格","发送到","具有","几类","例外","曾","这是","目前","层层","某个","编程序","其次","高级","之后","方式","4th","汇编","第三代","语句","一对","抽象","明确","加减乘除","echo","查询","属于","完成","数字电路","了","首先","循环","同一个","最早","麻烦","算机","电路","但","识别","如下","不同","用","出来","更","符号","一系","这里","这","interpret","output","assembler","优点","机器","低级","一一对应","执行程序","规定","保存","过","；","要","十六进制","虽然","任何","系列","可执行文件","做","会","计算机","1","?","翻译","关系密切","5gl","设备","第一条","低级语言","怎么","听到","平台","填","declarative","不用","绝大部分","即使","上面","数字电","介绍","而是","可读性","independent","应该","最后","程序员","例子","数字","!","来","意味着","有","助记符","platform","绝大","基本","硬件","就要","总结","数据","）","格式","三代","系统","而","概念","新","编辑","一一对","版本","语言","把子","多么"," ","部分","解方程","使用","中","如何","确定","组成","看到","出","3rd","各","地址","行为","“","告诉","var","需","意思","任务","专门","显然","也","某种","用到","复杂","成人","驱动","词有","从根本上","movl","这些","语法","花","直观","把","足够","python","a1","编译成","决定","重复","获取数据","machine","去","(","乘除","移植","一件","修改","送到","c语言","计算","发送","在","并","单词","解释器","最","意味","释器","第","查","必须","可以","处理","已经","打印","加载","out","程序","数","包括","出错","分解成","该","机器码","让","替换","一代","源文件","信息","发展","2gl","这么","或","bin","1c","什么","中是","包含","进制","图像","（","和","转换","内容","而且","5th","同一","第一代","你","文本","大部分","还","开发","二代",";","缺点","08","eax","图","加减","例如","对应","尽量","下","编译","尽量避免","2nd","之间","明确规定","方程","5.1","一样","汇编程序","instruction","一个","”","助记","举个","以","。","input","直接","于是","a0","三行","分解","后续","文件名","所示","还要","根据","容易","运算","才能","此外","完全","上表","相当","%","后缀","set","查表","各种","避免","生成","c++","结构化","第三","值","自增","成","大部","从","翻译成","第二","由","-","写出","演化","具体","分支","工作","以上","理应","然而","分为","无关","、","直到","汇编器","指令集","十六","屏幕","a","测试","描述","就","机器指令","换成","紧凑","来说","high","指令","指示","system","source","行程","过程","它","level",")","执行","就是","每","第一","注意","这个","第二代","imperative","对","通常","只","的","先生","才","查找","实现","替换成","b","时间","但是","当作","文件","其它","可移植","0x804a01c","特性","查询语言","$","初始","1gl","甚至","小端","称为","功能","不是","因为","之所以","改正","编程","portable","query","比如","没有","对于","中间","这样","必然","却","转换成","链接","c","等","行文","稍加","分别","operating","都","generation","三条","是因为","提示符","应","programming","language","将","以下","04","多","简单","得","命令","条件","输出","shell","表示","输入","解释","关系","只能","结果","提示","编译器","=","子","#","java","数学","这种","少数","几种","写","有些","上","操作",".","转",",","到","是","编写","mnemonic","structured","内部","机器语言","sh","以后","被","存取","更强","操作系统","代码","一条","同样","初始值","键盘","显示","assembly","然后","巨大","脚本","汇编语言","错","经过","器","驱动程序","编程语言","+","获取","只有","体系结构","变量","一下","需要","编写程序","可读","可能","得到","所以","加上","看出","进行","compile","比","文档","sql","一步","如果","一组","落差","多种","一点","标准","节","1st","："],"title":"程序和编程语言","title_tokens":["和","语言","编程","编程语言","程序"]},{"location":"计算机基础/1.2.基本概念.html#_2","text":"这是我们的第一个思考题。本书的思考题通常要求读者系统地总结当前小节的知识，结合以前的知识，并经过一定的推理，然后作答。本书强调的是基本概念，读者应该抓住概念的定义和概念之间的关系来总结，比如本节介绍了很多概念：程序由语句或指令组成，计算机只能执行 低级语言 中的指令（汇编语言的指令要先转成机器码才能执行），高级语言要执行就必须先翻译成低级语言，翻译的方法有两种：编译和解释，虽然有这样的不便，但高级语言有一个好处是平台无关性。什么是平台？一种平台，就是一种体系结构，就是一种指令集，就是一种机器语言，这些都可看作是一一对应的，上文并没有用“一一对应”这个词，但读者应该能推理出这个结论，而高级语言和它们不是一一对应的，因此高级语言是平台无关的，概念之间像这样的数量对应关系尤其重要。那么编译和解释的过程有哪些不同？主要的不同在于什么时候翻译和什么时候执行。 现在回答这个思考题，根据编译和解释的不同原理，你能否在执行效率和平台无关性等方面做一下比较？","text_tokens":["或","通常","好处","体系","低级语言","结论","什么","平台","的","它们","思考","（","译成","介绍","和","结构","应该","时候","定义","主要","来","有","性","基本","不是","你","总结","要求","方法","在于","）","比如","没有","因此","系统","概念","而","这样","强调","数量","一一对","对应","语言","编译","，"," ","之间","中","推理","哪些","一一","组成","出","等","那么","考题","“","都","一个","”","。","能","不便","一种","回答","思考题","能否","很多","根据","才能","解释","关系","只能","这些","两种","这是","原理","基本概念","尤其","知识","抓住","高级","是","汇编","语句","一对","机器语言","方面","比较","看作","翻译成","计算","像","在","由","转成","并","了","无关","作答","？","指令集","然后","一定","算机","汇编语言","现在","但","经过","必须","当前","就","可","词","不同","以前","用","效率","上文","体系结构","本","我们","一下","第一个","指令","结合","程序","先","过程","小节","低级","机器","一一对应","要","机器码","虽然","重要","读者","执行","就是","第一","这个","做","本书","计算机","节","系统地","翻译","："],"title":"解释执行的语言相比编译执行的语言有什么优缺点？","title_tokens":["优缺点","执行","解释","什么","的","语言","编译","有","缺点","相比","？"]},{"location":"计算机基础/1.2.基本概念.html#_3","text":"编程是一件复杂的工作，因为是人做的事情，所以难免经常出错。据说有这样一个典故：早期的计算机体积都很大，有一次一台计算机不能正常工作，工程师们找了半天原因最后发现是一只臭虫钻进计算机中造成的。从此以后，程序中的错误被叫做臭虫（Bug），而找到这些Bug并加以纠正的过程就叫做调试（Debug）。有时候调试是一件非常复杂的工作，要求程序员概念明确、逻辑清晰、性格沉稳，还需要一点运气。调试的技能我们在后续的学习中慢慢培养，但首先我们要区分清楚程序中的Bug分为哪几类。 编译时错误 编译器只能翻译语法正确的程序，否则将导致编译失败，无法生成可执行文件。对于自然语言来说，一点语法错误不是很严重的问题，因为我们仍然可以读懂句子。而编译器就没那么宽容了，只要有哪怕一个很小的语法错误，编译器就会输出一条错误提示信息然后罢工，你就得不到你想要的结果。虽然大部分情况下编译器给出的错误提示信息就是你出错的代码行，但也有个别时候编译器给出的错误提示信息帮助不大，甚至会误导你。在开始学习编程的前几个星期，你可能会花大量的时间来纠正语法错误。等到有了一些经验之后，还是会犯这样的错误，不过会少得多，而且你能更快地发现错误原因。等到经验更丰富之后你就会觉得，语法错误是最简单最低级的错误，编译器的错误提示也就那么几种，即使错误提示是有误导的也能够立刻找出真正的错误原因是什么。相比下面两种错误，语法错误解决起来要容易得多。 运行时错误 编译器检查不出这类错误，仍然可以生成可执行文件，但在运行时会出错而导致程序崩溃。对于我们接下来的几章将编写的简单程序来说，运行时错误很少见，到了后面的章节你会遇到越来越多的运行时错误。读者在以后的学习中要时刻 注意区分编译时和运行时（Run-time）这两个概念 ，不仅在调试时需要区分这两个概念，在学习C语言的很多语法时都需要区分这两个概念，有些事情在编译时做，有些事情则在运行时做。 逻辑错误和语义错误 第三类错误是逻辑错误和语义错误。如果程序里有逻辑错误，编译和运行都会很顺利，看上去也不产生任何错误信息，但是程序没有干它该干的事情，而是干了别的事情。当然不管怎么样，计算机只会按你写的程序去做，问题在于你写的程序不是你真正想要的，这意味着程序的意思（即语义）是错的。找到逻辑错误在哪需要十分清醒的头脑，要通过观察程序的输出回过头来判断它到底在做什么。 通过本书你将掌握的最重要的技巧之一就是调试。调试的过程可能会让你感到一些沮丧，但调试也是编程中最需要动脑的、最有挑战和乐趣的部分。从某种角度看调试就像侦探工作，根据掌握的线索来推断是什么原因和过程导致了你所看到的结果。调试也像是一门实验科学，每次想到哪里可能有错，就修改程序然后再试一次。如果假设是对的，就能得到预期的正确结果，就可以接着调试下一个Bug，一步一步逼近正确的程序；如果假设错误，只好另外再找思路再做假设。“当你把不可能的全部剔除，剩下的——即使看起来再怎么不可能——就一定是事实。”（即使你没看过福尔摩斯也该看过柯南吧）。 也有一种观点认为，编程和调试是一回事，编程的过程就是逐步调试直到获得期望的结果为止。你应该总是从一个能正确运行的小规模程序开始，每做一步小的改动就立刻进行调试，这样的好处是总有一个正确的程序做参考：如果正确就继续编程，如果不正确，那么一定是刚才的小改动出了问题。例如，Linux操作系统包含了成千上万行代码，但它也不是一开始就规划好了内存管理、设备管理、文件系统、网络等等大的模块，一开始它仅仅是Linus Torvalds用来琢磨Intel 80386芯片而写的小程序。据Larry Greenfield 说，“Linus的早期工程之一是编写一个交替打印AAAA和BBBB的程序，这玩意儿后来进化成了Linux。”（引自The Linux User's Guide Beta1版）在后面的章节中会给出更多关于调试和编程实践的建议。","text_tokens":["全部","读懂","纠正","运气","臭虫","产生","大量","有时候","很","不","说","觉得","人","the","bug","快","下来","原因","罢工","会犯","区分","一门","逼近","误信","即","还是","不管","检查","，","发现错误","再","运行","芯片","一","否则","管理","那么","经验","问题","guide","哪里","后来","user","不仅","能","线索","福尔","十分","两个","很多","看上","bbbb","早期","一些","torvalds","观点","按","几类","两种","越来","'","句子","时","里","之后","明确","叫做","回过头来","剩下","了","首先","实践","一只","通过","算机","但","回过","摩斯","沮丧","更","个别","体积","这","行","工程","低级","别的","要","虽然","重要","；","任何","无法","越来越","哪","可执行文件","假设","再试一次","做","会","计算机","翻译","不出","设备","好处","怎么","从此","即使","学习","章节","下面","后面","而是","应该","有时","最后","程序员","千上万","来","意味着","有","观察","run","要求","只要","）","系统","而","概念","linus","没","语言","仍然","慢慢"," ","角度看","部分","网络","剔除","中","事实","看到","出","“","严重","半天","意思","回事","通过观察","上万","中要","正常","也","性格","找出","某种","复杂","一台","期望","上去","所","time","这些","语法","不到","像是","larry","实验","把","去","一件","修改","最有","用来","顺利","c语言","自然语言","计算","在","并","见","预期","星期","最","意味","福尔摩斯","难免","看起","感到","事情","可以","小","打印","掌握","我们","乐趣","：","为止","程序","加以","过头","出错","培养","典故","琢磨","规模","该","linux","读者","让","据说","之一","信息","起来","本书","看起来","每次","挑战","错误信息","很大","什么","前","包含","（","和","内存","玩意儿","丰富","规划","debug","时候","80386","版","开始","而且","进化","到底","宽容","会花","你","认为","大部分","还","在于","怎么样","只会","哪怕","关于","例如","下","编译","逻辑","干","们","清楚","另外","一个","”","s","。","工程师","后续","刚才","玩意","只好","根据","容易","一次","greenfield","得不到","侦探","逐步","不过","继续","沉稳","生成","能够","第三","找到","大部","立刻","从","成","文件系统","非常","真正","-","几个","获得","工作","分为","柯南","、","直到","一定","帮助","思路","造成","就","判断","吧","来说","语义","—","第三类","总有","当","过程","很少","它","正确","想到","总是","这类","执行","就是","很小","头脑","找","科学","每","注意","崩溃","对","自然","的","小规模","建议","时间","发现","等到","但是","文件","三类","动脑","想要","语法错误","据","甚至","调试","改动","不是","模块","因为","看过","编程","没有","对于","beta1","时刻","这样","等等","仅仅","接着","时会","推断","当然","行文","相比","intel","会少","都","交替","失败","经常","一种","导致","则","参考","将","多","简单","得","从此以后","输出","引自","只能","结果","提示","编译器","清醒","错误","几种","有些","写","操作","好","误导","给出","情况","编写","是","大","到","不能","以后","被","解决","像","看上去","钻进","操作系统","代码","一条","非常复杂","然后","错","成千上万","提示信息","接下来","遇到","需要","接下","几章","技能","成千","可能","得到","角度","所以","技巧","进行","一步","如果","清晰","一点","aaaa","地"],"title":"程序的调试","title_tokens":["的","调试","程序"]},{"location":"计算机基础/1.2.基本概念.html#_4","text":"变量（Variable）是编程语言最重要的概念之一。 变量是计算机存储器中的一块命名的空间，可以在里面存储一个值（Value），存储的值是可以随时变的，比如这次存个字符 'a' 下次存个字符 'b' ，正因为变量的值可以随时变所以才叫变量。 也就是说，变量有一个储存地址，该地址储存的值是可以改变的。或者说，变量是一种使用方便的占位符，用于引用计算机内存地址，变量创建后会占用一定的内存空间。 不要弄混变量和变量名，变量名是标识符的一种。 占位符 ：先占住一个固定的位置，等待值添加到该位置的符号。 变量的类型决定了它所占的存储空间的大小。 变量的行为一共有四种：声明、定义、初始化、赋值。 声明 ：告诉编译器/解析器有这个变量的存在，这个行为不分配内存空间。 定义 ：为变量分配内存空间。 实际上，从广义的角度来说，声明有两种： 引用性声明（defining declaration）：不需要建立储存空间的声明，例如 extern in a 中的变量 a 已经在别的文件中被定义。 定义性声明（referencing declaration）：需要建立储存空间的声明，例如 int a 在声明时就建立了 a 的储存空间。 可见从广义的角度来说，声明包含了定义，而并非所有的声明都是定义。一般的情况下我们常常这样叙述，把建立空间的声明称之为\"定义\"，而把不需要建立存储空间称之为\"声明\"。 定义和声明的本质区别就是：定义会给变量分配内存空间，而声明则不会。 初始化 ：在定义变量之后，系统为变量分配的内存空间内并没有值，此时值是不确定的。为保证程序的安全性和确定性，需要对这个内存空间进行初始化。初始化一般伴随着定义而产生。初始化是从无到有的过程。 如果变量的定义没有初始化，那这个最初分配的空间的值是随机的（空间上原来存储的值）。不经过初始化的变量可能会为程序带来不安全与不确定性。 赋值 ：赋值是变量值得刷新操作。赋值是从旧到新的过程。","text_tokens":["原来","个字符","位置","的","里面","随机","才","value","包含","保证","产生","（","b","和","内存","带来","不","文件","不确定性","安全","定义","等待","会为","大小","初始","空间","或者","有","也就是说","referencing","性","就是说","随时","安全性","因为","存储器","创建","存储","占住","先占住","）","那","编程","最初","分配","比如","没有","系统","概念","这次","标识符","而","给","新","这样","例如","不会","下","/","语言","编译"," ","，","分配内存","确定性","使用","广义","中","四种","确定","伴随","用于","一块","下次","地址","行为","占","是从","存","告诉","都","储存","一个","本质","存在","\"","不要","。","所有","一种","一般","占位","则","defining","区别","后","之为","内存地址","类型","命名","所","值得","编译器","declaration","两种","把","'","决定","时","方便","上","操作","从无到有","或者说","本质区别","变量名","情况","到","是","之后","占用","变","值","引用","解析","从","extern","符","被","计算","在","赋值","叫","叙述","并","实际上","刷新","了","variable","弄混","最","并非","、","一定","算机","内存空间","声明","实际","标识","a","为","经过","就","改变","编程语言","使用方便","此时","定性","可以","in","字符","已经","旧到","来说","符号","正","变量","与","我们","着","一共","需要","程序","固定","可能","角度","添加","过程","所以","该","称之为","它","进行","别的","可见","重要","初始化","内","如果","int","就是","常常","之一","解析器","这个","会","存储空间","计算机","建立","对","："],"title":"变量及其行为","title_tokens":["行为","变量","及其"]},{"location":"计算机基础/1.2.基本概念.html#python","text":"assignment ：Assignments do not copy data — they just bind names to objects. assignment操作不会拷贝，只是把名字和对象做一个绑定。也就是assignment语句是起一个绑定或重绑定的作用（bind or rebind）。函数调用的参数传递是传引用，不是拷贝。 引用（reference ） ：一个可以让程式间接存取于电脑记忆体或其他储存装置中一特定资料的值。一般而言，引用会是资料储存于记忆体或储存装置中的实体位址 。因此，引用亦常被称为==该资料==的 指标 或 位址 。 标识符（identifier，缩写为ID） ：又称为识别码，是一个用来识别不同对象的名称。 在编程语言中，标识符就是程序员自己规定的具有特定含义的词，比如函数名、方法名、类名，变量名、常量名等。 对象（object） ：是一个记忆体位址，其中拥有值，这个位址可能有标识符指向此处。台湾译作物件。对象是某个类的实例。我们将数据和对数据的操作融为一体，形成具有静态信息和动态行为的对象。 每个对象都具有一个ID、一个类型、一个值。对象一旦建立，ID便不会改变。这里所说的ID是是对象在内存中的地址，而不是identifier。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 标识符并不是对象的属性，一个对象可以指向不同的标识符。而管理这些名字（标识符）的事物就是“命名空间”。 命名空间（Namespace） ：名字（标识符）到对象的==映射==。 A namespace is a mapping from names to objects. 各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。 现今 Python 的大部分命名空间是通过字典来实现的，也即一个命名空间就是名字到对象的映射，标识符是键，对象则是值。 与命名空间相对的一个概念就是“作用域” 。 作用域（Scope） ：本质是一块文本区域，Python 通过该文本区域可以 直接访问 相应的命名空间。 直接访问 ：Python 中不加 . 的访问为直接访问，反之为属性访问。 命名空间与作用域的联系 ：作用域是 Python 的一块文本区域，即一块代码区域，需要代码区域引用名字（标识符）来访问变量，那么作用域与命名空间之间就有了联系。 名字作用域 ：名字可以影响到的代码文本区域。 命名空间的作用域 ：就是这个命名空间可以影响到的代码文本区域。 显然可以存在这样的一个代码文本区域，它可以被多个命名空间影响。 面向对象编程 ：基于对象概念来分析问题和设计解法，这就是面向对象编程（object-orientation programming，简称OOP）。通过OOP所得到的程序是一个由很多对象组成的系统，可以向对象发送消息来实现对数据的处理，全体对象通过相互协作来完成程序的数据处理功能。 面向过程编程 ：得到的程序是一组对数据进行操作的过程，通过按顺序执行这些过程来实现程序功能。","text_tokens":["assignment","资料","或","发送","类","的","装置","实现","含义","（","联系","和","内存","orientation","分析","不加","面向对象编程","rebind","反之","程序员","所说","oop","空间","来","称为","功能","设计","有","一般而言","namespace","不是","参数","文本","方法","数据","大部分","not","just","do","）","即","一旦","编程","比如","因此","copy","没有","而","标识符","概念","系统","相互协作","id","这样","不会","语言","区域","scope"," ","，","部分","之间","广义","中","调用","视为","组成","等","一块","全体","names","传","一样","地址","管理","行为","那么","属性","“","中一","记忆","台湾","实体","重名","问题","都","储存","一个","”","本质","存在","其中","便","参数传递","又","。","绑定","形成","直接","显然","programming","也","一般","事物","则","将","多个","某种","很多","而言","data","指标","相对","拷贝","类型","每个","命名","指向","面向","所","相互","数传","名","关系","对象","这些","按","具有","一体","is","特定","把","=","消息","python","识别码","只是","访问","相应","起","操作","object","拥有","assignments","变量名","某个","静态",".","向","到","是","名字","用来","间接","不能","引用","值","语句","大部","传递","位址","被","存取","数据类型","函数","字典","在","实例","属于","由","作用","并","-","中不加","代码","影响","了","完成","译作","记忆体","独立","通过","objects","普通","、","数据处理","融为","or","类名","基于","作用域","动态","电脑","标识","但","协作","a","于","为","自己","identifier","识别","名称","各个","现今","就","词","改变","不同","编程语言","reference","可以","处理","mapping","融为一体","变量","与","函数调用","我们","这里","映射","程式","解法","需要","程序","—","这","常量","其他","可能","得到","from","过程","to","该","亦","规定","所以","它","进行","常","缩写","任何","they","bind","让","此处","就是","一组","顺序","执行","物件","或重","信息","这个","做","会","键","建立","对","简称","："],"title":"基础概念（python）","title_tokens":["（","python","概念","基础","）"]},{"location":"计算机基础/1.2.基本概念.html#_5","text":"类是类型概念的发展。 对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。 用计算机解决问题时，首先需要明确问题中涉及哪些数据，并在程序中将这些数据用编程语言提供的数据类型表示出来，然后再去考虑需要对这些数据执行何种操作。 为了表示数据，编程语言一般提供若干 基本数据类型 （如Python的int、float、str和list等类型） ，并为这些基本类型提供相应的基本操作（如Python中对int、float、str和list都提供了+运算，尽管含义不同）。 然而，实际问题中往往涉及很复杂的数据，不能用基本数据类型直接表示。为了表示复杂数据，大体有两种办法： 一种是将复杂数据分解成若干个简单数据项，以便每个数据项可以用基本类型表示 另一种是由用户自定义新的数据类型，以便对复杂数据进行直接的、整体的表示。 例如，如果要表示一个学生的姓名，可以简单地用一个字符串数据表示；如果要表示一个学生的年龄，可以简单地用一个整数数据表示。但如果要整体表示一个“学生”，包括该学生的姓名、年龄、地址等信息，就没法用基本数据类型直接表示了。 一种解决办法是将整体的“学生”分解成姓名、年龄、地址等简单数据，并通过分别处理这些简单数据而达到处理“学生”数据的目的。但这不是好办法，因为这种表示法丢失了数据的整体性，在维护姓名、年龄、地址等数据间的联系时很麻烦。 另一种解决办法是将学生整体视为一个数据值，并为这种数据值定义新的数据类型（因为编程语言中没有现成的类型能够表示该数据）。 假设我们要为“学生“数据定义一个新的数据类型S，那么S应该是由若干更简单的数据项构成的（如学号、姓名等），我们称这些构成S的成员数据为S的属性。除了定义S类型数据的属性，还需要定义能对S数据执行什么操作（如修改姓名或年龄、读取地址等）。可以利用编程语言提供的基本类型和新类型定义机制来实现S，例如用str类型表示姓名和学号，用int类型表示年龄之类，用函数实现对S数据的操作。定义了S，就好像为编程语言添加了一个新的数据类型，应用程序就可以像使用整数、字符串等基本类型一样去使用S。 由此，我们从传统的数据类型概念发展出了“类”的概念。类（class）是广义的数据类型，能够定义复杂数据的特性，包括静态特性（即数据）和动态特性（即对数据的操作方法）。 类的值就是“对象”，也称为类的实例。","text_tokens":["或","解决问题","float","什么","类","的","实现","姓名","含义","若干","（","联系","字符串","和","很","达到","应该","间","办法","特性","定义","目的","学号","来","称为","有","考虑","基本","传统","不是","读取","因为","数据","还","应用","方法","地用","数据表示","）","即","编程","因此","定义新","没有","概念","而","往往","新","称","例如","list","语言","号","表示法","，"," ","再","基本操作","丢失","使用","广义","中","视为","哪些","等","年龄","如学","出","一样","那么","地址","问题","“","属性","分别","整数","都","一个","”","s","类型定义","体性","。","直接","能","应用程序","一种","一般","分解","若干个","也","将","现成","某种","复杂","简单","运算","类型","构成","每个","表示","自定","由此","对象","这些","解决办法","class","中将","好像","两种","成员","python","之类","操作方法","这种","时","整体","相应","除了","操作","提供","去","好","静态","涉及","修改","以便","能够","是","不能","整体性","值","明确","从","没法","维护","解决","数据类型","计算","函数","在","由","属于","像","并","实例","自定义","了","首先","如","用户","通过","然而","普通","没法用","、","麻烦","然后","利用","算机","实际","但","动态","为","学生","何种","就","编程语言","不同","+","可以","用","出来","字符","处理","更","数据表","这","我们","需要","程序","str","包括","机制","添加","分解成","该","另","进行","要","；","数据项","为了","int","执行","如果","就是","尽管","假设","大体","发展","信息","计算机","对","："],"title":"类的概念","title_tokens":["类","的","概念"]},{"location":"计算机基础/1.2.基本概念.html#vs","text":"python的入门者可能很容易把变量和对象混为一谈，实际上，可以说python中不存在变量这样的概念，所谓的变量实质上是对象的名字。 在python中，对象属于某一个类型，而变量是没有类型的。所有的变量都是内存中一个对象的“引用”，也就是说变量的值实际上是对象的地址，而不是对象本身的值。 例如： nfoo = 1 #一个指向int数据类型的nfoo（再次提醒，nfoo没有类型），在这里，具有类型的是1 lstFoo = [ 1 ] #一个指向list类型的lstFoo，这个list中包含一个整数1","text_tokens":["混为一谈","没有","指向","概念","混为","而","（","提醒","再次","实际","这样","例如","对象","入门","具有","的","list","包含","把","，"," ","=","lstfoo","本身","python","#","可以","很","和","内存","中","nfoo","不","上","说","变量","某","地址","这里","：","“","整数","都","是","一个","名字","”","可能","[","引用","值","。","也就是说","实质","]","所有","就是说","不是","数据类型","在","就是","属于","int","实际上","数据","这个","所谓","容易","）","1","入门者","类型","存在"],"title":"对象  vs  变量","title_tokens":["变量"," ","vs","对象"]},{"location":"计算机基础/1.2.基本概念.html#mutable-vs-immutable","text":"在python中，strings、tuples、numbers是不可更改(immutable)的对象，而list、dict等则是可以修改(mutable)的对象。那么，这些所谓的可改变和不可改的本质是什么呢？ mutable、immutable只是python语言的一个规定。从硬件角度说，硬件提供给用户的接口是按照规定设定好的。比如说，操作内存的方式是固定的，不存在可变和不可变。实现python的可变、不可变就是调用了不同的底层api，或者是不同底层api相互组合来实现的。python将这些规定以python语法的形式提供给用户使用，最后还是编译成0、1去让计算机执行。对于用户来说，可变和不可变对象是语言提供的一个特性，可以完成一些功能，但是对于计算机其实是没区别的。 而在python中，不可变就是对象本身无法被修改，比如对象的值无法被修改。修改不可变对象只能创建新对象，旧对象若没有引用，则会被内存回收机制销毁。而可变对象的值是可以修改的。 接下来看一个例子： nfoo = 1 nfoo = 2 lstFoo = [ 1 ] lstFoo [ 0 ] = 2 代码第2行中，内存中原始的1对象因为不能改变，于是被“抛弃”，另nfoo指向一个新的int对象，其值为2。 代码第5行中，更改list中第一个元素的值，因为list是可改变的，所以，第一个元素变更为2。其实应该说，lstFoo指向一个 列表对象 。赋值所发生的事情，lstFoo所指向的列表对象的第一个元素被替换为新的值，但是对于lstFoo本身来说，它的值（列表的地址）没有变换，只是列表对象的内容发生变化了。 如下图所示： 但有时候，即使对象被复制了，修改原对象，两个变量指向的对象都改变了，怎么回事？ def fun2 (): a = [ 1 , 2 , 3 ,[ 1 , 2 ]] b = a . copy () a [ 1 ] = a [ 3 ][ 0 ] = 10 print ( a , ' \\n ' , b ) def fun2_2 (): a = [ 1 , 2 , 3 ,[ 1 , 2 ]] b = a . copy () a [ 1 ] = a [ 3 ] = 10 print ( a , ' \\n ' , b ) 上面定义了两个函数，两个函数输出的结果会一样吗？让我们看看： fun2 ------------------- [ 1 , 10 , 3 , [ 10 , 2 ]] [ 1 , 2 , 3 , [ 10 , 2 ]] fun2_2 ------------------- [ 1 , 10 , 3 , 10 ] [ 1 , 2 , 3 , [ 1 , 2 ]] 为什么 fun2 中b的第2个元素的值不变，而第四个元素的值却被改变了，而在 fun2_2 中b的值都没变？ 因为list储存的不是值，而是对象的引用。","text_tokens":["旧","怎么","什么","可变","的","api","strings","实现","即使","上面","行中","变化","译成","（","有时候","b","和","不可","按照","内存","2","不","变换","而是","但是","说","第四","内容","应该","有时","最后","时候","n","特性","定义","例子","immutable","来","功能","或者","下来","回收","print","]","不是","硬件","创建","因为","0","接口","）","比如","图","没有","tuples","对于","而","还是","发生","给","新","def","copy","_","dict","没","吗","list","语言","编译","，"," ","lstfoo","本身","却","使用","发生变化","中","调用","numbers","等","设定","一样","那么","地址","“","第四个","10","都","储存","一个","”","本质","5","回事","\\","以","。","于是","为什么","则","将","形式","区别","所示","两个","原始","一些","指向","所","输出","组合","相互","对象","这些","语法","只能","结果","=","'","python","编译成","看","只是","操作","提供","去","好","(","元素","原","销毁","修改",".",",","是","方式","比如说","抛弃","不能","变","[","值","引用","其值","从","被","看看","计算","mutable","函数","在","赋值","变更","-","完成","代码","了","所谓","用户","四个","？","、","算机","第","不变","但","怎么回事","a","为","3","其实","底层","如下","可","更改","改变","不同","事情","可以","nfoo","接下来","改","来说","个","变量","我们","呢","：","第一个","复制","接下","固定","若","机制","fun2","角度","所以","规定","另","它","没变","生变","让","无法",")","就是","执行","int","替换","第一","会",":","计算机","1","列表","存在"],"title":"可更改(mutable)  vs  不可更改(immutable)","title_tokens":["mutable","vs",")","不可","immutable","可更改","(","更改"," "]},{"location":"计算机基础/1.2.基本概念.html#python_1","text":"python函数参数传递可以理解为就是变量传值操作，入门者可能会发现，不可变对象作为参数，看似是传引用；而可变对象作为参数，看似是传值。举一个例子： 不可变对象参数调用 def ChangeInt ( a ): a = 10 nfoo = 2 ChangeInt ( nfoo ) print nfoo #结果是2 这时发生了什么？让我们看一下 nfoo 和 a 实际的值的变化： nfoo = 2 # nfoo：对象2的地址 # 进行传参： a = nfoo # 函数参数a：对象2的地址 # 对a进行赋值 a = 10 # 函数参数a：对象10的地址；此时，nfoo的值：对象2的地址 也就是说，当 nfoo 传参给 ChangeInt() 的时候，是传递了 nfoo 的值，是 值传递 。如下图： 因为对象是不可变的，所以对b重新赋值的时候，只能创建一个新的对象10，将对象10放进新的地址，而不是将储存于1的地址的值删除，再把10放进1的地址。 但可变对象不同于不可变对象： 可变对象参数调用 def ChangeList ( a ): a [ 0 ] = 10 lstFoo = [ 2 ] ChangeList ( lstFoo ) print lstFoo #结果是[10] 这时发生了什么？让我们看一下 nfoo 和 a 实际的值的变化： lstFoo = [ 2 ] # nfoo：对象[2]的地址 # 进行传参： a = lstFoo # 函数参数a：对象[2]的地址 # 对a进行赋值 a [ 0 ] = 10 # 函数参数a：对象[2]的地址；此时，nfoo的值：对象[2]的地址 当 lstFoo 传参给 ChangeList() 的时候， 变量仍旧是“传值” ，a复制了变量 lstFoo 的值，于是 a 和 lstFoo 指向同一个对象，但是，list是可以改变的对象，对 a[0] 进行赋值，就是更改原对象的值，而 lstFoo 也指向原对象。于是，这时的 a[0] = 10 ，就是更改了 lstFoo 指向的对象的第一个元素。所以，再次输出 lstFoo 时，显示 [10] ，因此，看起来是 lstFoo 的值改变了。但实际上 lstFoo 的值还是原对象的地址， lstFoo 的值并没有改变，改变的是对象。 综上所以，python的传参，传进去的是name（变量）的值，而name的值是object的引用。也就是说，传参传的是name的值（object的引用）。传参无法把对象的值传进去。","text_tokens":["可变","什么","放进","的","变化","（","这时","b","2","不可","和","发现","同于","但是","时候","例子","changelist","也就是说","print","进去","]","就是说","不是","同一","参数","传参传","因为","创建","0","）","入门者","传值","图","因此","没有","而","def","发生","给","新","再次","还是","传参","函数参数","list","，"," ","再","lstfoo","理解","调用","传","地址","综上","“","10","储存","一个","”","参数传递","。","name","于是","也","将","指向","输出","作为","数传","对象","结果","入门","只能","=","把","#","python","看","时","操作","(","元素","object","原","是","变","举","[","引用","值","仍旧","传递","函数","赋值","并","实际上","了","同一个","显示","？","看起","实际","但","a","为","于","如下","更改","改变","不同","不同于","此时","changeint","可以","nfoo","变量","我们","一下","复制","第一个","当","可能","所以","删除","进行","；","重新","看似","让","无法",")","就是","第一","会",":","起来","1","看起来","对","："],"title":"Python的函数参数传递：传值？引用？","title_tokens":["传值","python","函数","参数","数传","参数传递","引用","的","传递","？","："]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html","text":"编译型语言和解释型语言的优缺点对比 编程语言可以分为：完全的编译型，纯粹的解释型或者两者相互混合的编程语言。实际上，大部分现有的编程语言都同时拥有其编译型和解释型版本。 编译型语言和解释型语言分别有其各自的优势和不足。下面从编译型语言开始介绍。 编译型语言： 编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%。 编译型程序比解释型程序消耗的内存更少。 不利的一面——编译器比解释器要难写得多。 编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置。 可执行的编译型代码要比相同的解释型代码大许多。例如，C/C++的.exe文件要比同样功能的Java的.class文件大很多。 编译型程序是面向特定平台的因而是平台依赖的。 编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的） 由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。 解释型语言： 解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的。 另一个优势是解释器比编译器容易实现 解释型语言最大的优势之一是其平台独立性 解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的 中间语言代码的大小比编译型可执行代码小很多 平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素。 解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存。 由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多。 解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。 原文链接： http://www.codeproject.com/Articles/1825/The-Common-Language-Runtime-CLR-and-Java-Runtime-E Pros and cons of compiled and interpreted languages Languages can be developed either as fully-compiled, pure-interpreted, or hybrid compiled-interpreted. As a matter of fact, most of the current programming languages have both a compiled and interpreted versions available. Both compiled and interpreted approaches have their advantages and disadvantages. I will start with the compiled languages. Compiled languages One of the biggest advantages of Compiled languages is their execution speed. A program written in C/C++ runs 30-70 % faster then an equivalent program written in Java. Compiled code also takes less memory as compared to an interpreted program. On the down side - a compiler is much more difficult to write than an interpreter. A compiler does not provide much help in debugging a program - how many times have you received a \"Null pointer exception\" in your C code and have spent hours trying to figure out where in your source code did the exception occurred. The executable Compiled code is much bigger in size than an equivalent interpreted code e.g. a C/C++ .exe file is much bigger than an equivalent Java .class file Compiled programs are targeted towards a particular platform and hence are platform dependent. Compiled programs do not allow security to be implemented with in the code - e.g. a compiled program can access any area of the memory, and can do whatever it wants with your PC (most of the viruses are made in compiled languages). Due to loose security and platform dependence - a compiled language is not particularly suited to be used to develop Internet or web-based applications. Interpreted languages Interpreted language provides excellent debugging support. A Java programmer only spends a few minutes fixing a \"Null pointer exception\", because Java runtime not only specifies the nature of exception but also gives the exact line number and function call sequence (the famous stack trace information) where the exception occurred. This facility is something that a compiled language can never provide. Another advantage is that Interpreters are much easier to build then a compiler. One of the biggest advantages of Interpreters is that they make platform-independence possible. Interpreted language also allow high degree of security - something badly needed for an Internet application. An intermediate language code size is much smaller than a compiled executable code. Platform independence, and tight security are the two most important factors that make an interpreted language ideally suited for Internet and web-based applications. Interpreted languages have some serious drawbacks. The interpreted applications take up more memory and CPU resources. This is because in order to run a program written in interpreted language; the corresponding interpreter must be run first. Interpreters are sophisticated, intelligent and resource hungry programs and they take up lot of CPU cycles and RAM. Due to interpreted application's decode-fetch-execute cycle; they are much slower than compiled programs. Interpreters also do lot of code-optimization, security violation checking at run-time; these extra steps take up even more resources and further slows the application down.","text_tokens":["fully","相同","program","an","行号","它们","speed","比用","i","大量","cpu","2","不","降低","never","support","the","interpreter","快","http","或者","30%","code","important","compiler","fact","do","dependence","各自","定位","好几个","病毒","equivalent","慢","loose","/","检查","，","hybrid","运行","指针","fetch","nature","because","空","security","次","不仅","developed","几分","faster","很多","approaches","因特网","依赖性","compared","一些","不足","面向","最大","null","must","is","特定","executable","这是","hence","received","'","more","时","许多","did","便利","programmer","70%","degree","同时","消耗","明确","two","steps","information","实际上","application","了","成为","首先","独立","one","性质","their","memory","资源","whatever","checking","用","更","堆栈","versions","个","targeted","程序运行","start","步骤","想","based","要","重要","；","任何","无法","wants","做","会","trying","with","存在","1825","位置","corresponding","平台","使","pointer","interpreters","下面","介绍","而是","provide","serious","几分钟","一名","联网","particularly","程序员","来","因而是","much","有","platform","execute","both","matter","run","write","异常","应用","make","not","）","不利","型","难","版本","语言","区域","have","and","独立性"," ","advantages","部分","your","advantage","使用","中","less","“","of","额外","严重","spent","extra","smaller","these","也","slows","also","exception","严密","两者","复杂","drawbacks","抓取","其","相互","allow","time","这些","class","跟踪","programs","pure","you","分钟","(","famous","order","compiled","specifies","something","lot","web","figure","resource","e","spends","c语言","由于","difficult","used","com","hours","智能","函数","好几","在","并","occurred","further","biggest","解释器","依赖","up","最","释器","实际","most","必须","可","cons","事情","可以","调试程序","小","out","only","程序","side","on","runtime","any","they","written","支持","之一","信息","70","many","因素","什么","dependent","stack","保证","cycles","intelligent","cycle","intermediate","（","和","内存","optimization","but","fixing","开始","而且","大小","到底","exact","line","for","access","takes","修复","你","安全性","slower","大部分","开发","指明","因而","excellent",";","缺点","towards","不了","current","发生","are","例如","sequence","编译","first","function","优缺点","implemented","trace","调用","周期","exe","相关","一个","”","s","\"","badly","。","be","tight","facility","build","代码优化","一面","容易","多少","interpreted","some","either","完全","优势","访问","%","提供","area","this","c++","迫切","小时","大部","bigger","从","viruses","take","disadvantages","不太","-","几个","具体","分为","execution","帮助","因特","a","violation","debugging","就","以及","函数调用","high","迫切需要","高度","—","particular","互联","source","that","环境","互联网","现有","它","needed","混合","gives","为了",")","就是","执行","another","than","independence","available","对","then","ideally","只","runs","internet","的","纯粹","实现","does","due","花费","factors","call","文件","安全","develop","pc","功能","resources","number","调试","languages","made","因为","g","even","30","编程","will","ram","few","中间","这样","并且","松散","进一步","suited","链接","provides","c","分别","it","都","sophisticated","can","理想","programming","language","多","times","得","优化","easier","少","解释","适合","著名","编译器","as","语言所","java","解码","错误","写","clr","拥有","给出",".",",","编写","大","是","占用","where","对比","www","decode","minutes","hungry","possible","代码","同样","applications","articles","基于","or","down","原文","编程语言","in","codeproject","遇到","需要","help","极佳","size","at","to","另","common","比","顺序","一步","速度","how",":","pros","file","："],"title":"1.3.编译型语言和解释型语言的优缺点对比","title_tokens":[".","1.3","优缺点","和","对比","型","解释","的","语言","编译","缺点"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#_1","text":"编程语言可以分为：完全的编译型，纯粹的解释型或者两者相互混合的编程语言。实际上，大部分现有的编程语言都同时拥有其编译型和解释型版本。 编译型语言和解释型语言分别有其各自的优势和不足。下面从编译型语言开始介绍。","text_tokens":["不足","其","相互","实际","型","解释","版本","完全","语言","的","编译","纯粹","优势","，"," ","编程语言","部分","下面","可以","和","介绍","拥有","分别","开始","都","同时","或者","现有","有","。","大部","从","混合","实际上","大部分","两者","各自","编程","分为","："],"title":"编译型语言和解释型语言的优缺点对比","title_tokens":["优缺点","和","对比","解释","型","的","语言","编译","缺点"]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#_2","text":"编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%。 编译型程序比解释型程序消耗的内存更少。 不利的一面——编译器比解释器要难写得多。 编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置。 可执行的编译型代码要比相同的解释型代码大许多。例如，C/C++的.exe文件要比同样功能的Java的.class文件大很多。 编译型程序是面向特定平台的因而是平台依赖的。 编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的） 由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。","text_tokens":["位置","相同","什么","平台","的","实现","比用","（","和","内存","而是","不","花费","文件","安全","到底","pc","快","来","功能","或者","因而是","30%","有","调试","异常","你","安全性","大部分","应用","开发","因而","）","不利","不了","好几个","病毒","型","难","例如","并且","松散","/","语言","编译","区域"," ","，","部分","运行","指针","使用","中","c","“","exe","一个","空","”","次","。","多","很多","一面","因特网","得","依赖性","多少","面向","最大","少","其","解释","class","适合","编译器","优势","特定","java","错误","时","访问","许多","写","提供","70%",".","编写","大","c++","是","web","消耗","c语言","小时","大部","明确","由于","好几","在","不太","-","几个","代码","同样","解释器","依赖","释器","基于","帮助","因特","可","事情","用","调试程序","可以","更","遇到","需要","程序","—","程序运行","它","想","要","任何","比","就是","执行","速度","支持","之一","做","对"],"title":"编译型语言：","title_tokens":["语言","编译","型","："]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#_3","text":"解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的。 另一个优势是解释器比编译器容易实现 解释型语言最大的优势之一是其平台独立性 解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的 中间语言代码的大小比编译型可执行代码小很多 平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素。 解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存。 由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多。 解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。 原文链接： http://www.codeproject.com/Articles/1825/The-Common-Language-Runtime-CLR-and-Java-Runtime-E","text_tokens":["1825","只","因素","位置","平台","的","使","行号","实现","它们","保证","大量","（","cpu","和","2","内存","降低","几分钟","一名","the","安全","联网","程序员","而且","大小","http","调试","execute","修复","异常","安全性","因为","应用","指明","）","缺点","定位","发生","中间","这样","型","并且","慢","/","语言","编译","检查","and","独立性","，"," ","进一步","运行","指针","fetch","链接","调用","周期","“","额外","严重","相关","一个","空","”","。","不仅","理想","也","language","几分","严密","多","很多","代码优化","复杂","容易","优化","一些","最大","抓取","其","解释","这些","著名","适合","跟踪","编译器","优势","语言所","这是","java","解码","时","提供","clr","分钟","便利","给出",".","编写","是","迫切","占用","web","www","decode","e","消耗","由于","com","智能","函数","并","-","具体","了","代码","成为","解释器","独立","首先","最","性质","articles","释器","资源","必须","原文","就","可","以及","可以","小","堆栈","更","个","codeproject","函数调用","：","迫切需要","需要","程序","高度","—","极佳","互联","环境","互联网","步骤","另","；","重要","common","runtime","比","顺序","无法","为了","一步","执行","速度","支持","之一","信息","会","做",":","存在"],"title":"解释型语言：","title_tokens":["语言","解释","型","："]},{"location":"计算机基础/1.3.编译型语言和解释型语言的优缺点对比.html#pros-and-cons-of-compiled-and-interpreted-languages","text":"Languages can be developed either as fully-compiled, pure-interpreted, or hybrid compiled-interpreted. As a matter of fact, most of the current programming languages have both a compiled and interpreted versions available. Both compiled and interpreted approaches have their advantages and disadvantages. I will start with the compiled languages. Compiled languages One of the biggest advantages of Compiled languages is their execution speed. A program written in C/C++ runs 30-70 % faster then an equivalent program written in Java. Compiled code also takes less memory as compared to an interpreted program. On the down side - a compiler is much more difficult to write than an interpreter. A compiler does not provide much help in debugging a program - how many times have you received a \"Null pointer exception\" in your C code and have spent hours trying to figure out where in your source code did the exception occurred. The executable Compiled code is much bigger in size than an equivalent interpreted code e.g. a C/C++ .exe file is much bigger than an equivalent Java .class file Compiled programs are targeted towards a particular platform and hence are platform dependent. Compiled programs do not allow security to be implemented with in the code - e.g. a compiled program can access any area of the memory, and can do whatever it wants with your PC (most of the viruses are made in compiled languages). Due to loose security and platform dependence - a compiled language is not particularly suited to be used to develop Internet or web-based applications. Interpreted languages Interpreted language provides excellent debugging support. A Java programmer only spends a few minutes fixing a \"Null pointer exception\", because Java runtime not only specifies the nature of exception but also gives the exact line number and function call sequence (the famous stack trace information) where the exception occurred. This facility is something that a compiled language can never provide. Another advantage is that Interpreters are much easier to build then a compiler. One of the biggest advantages of Interpreters is that they make platform-independence possible. Interpreted language also allow high degree of security - something badly needed for an Internet application. An intermediate language code size is much smaller than a compiled executable code. Platform independence, and tight security are the two most important factors that make an interpreted language ideally suited for Internet and web-based applications. Interpreted languages have some serious drawbacks. The interpreted applications take up more memory and CPU resources. This is because in order to run a program written in interpreted language; the corresponding interpreter must be run first. Interpreters are sophisticated, intelligent and resource hungry programs and they take up lot of CPU cycles and RAM. Due to interpreted application's decode-fetch-execute cycle; they are much slower than compiled programs. Interpreters also do lot of code-optimization, security violation checking at run-time; these extra steps take up even more resources and further slows the application down.","text_tokens":["ideally","many","fully","runs","corresponding","an","program","dependent","internet","stack","pointer","cycles","speed","i","intelligent","interpreters","cycle","intermediate","cpu","does","optimization","due","but","factors","call","provide","serious","never","fixing","support","the","develop","particularly","interpreter","pc","exact","resources","number","much","line","for","platform","access","languages","takes","made","execute","both","matter","run","code","write","slower","important","g","even","compiler","make","30","not","fact","do","dependence","excellent",";","towards","current","will","ram","equivalent","few","are","sequence","loose","/","have","and"," ","hybrid","advantages","first","your","suited","function","advantage","fetch","implemented","trace","provides","c","nature","less","of","because","exe","it","spent","extra","s","\"","badly","security","sophisticated","can","be","smaller","programming","tight","developed","language","these","slows","also","exception","faster","facility","build","approaches","times","compared","easier","drawbacks","allow","interpreted","null","time","some","either","must","class","as","is","programs","executable","hence","received","java","'","more","%","did","pure","you","area","(","famous","programmer","order","compiled",".","specifies","this",",","something","lot","c++","where","web","degree","figure","resource","e","decode","spends","difficult","used","bigger","viruses","take","two","steps","minutes","hours","disadvantages","hungry","-","information","application","possible","occurred","further","biggest","up","one","applications","their","or","execution","down","memory","most","whatever","a","violation","debugging","checking","in","versions","out","only","high","targeted","help","particular","side","source","that","size","at","to","start","based","on","needed","runtime","any","gives","written","they",")","another","than","how","wants","independence","trying","file","available","with","then","70"],"title":"Pros and cons of compiled and interpreted languages","title_tokens":["cons","interpreted","pros","languages","and"," ","of","compiled"]},{"location":"计算机基础/1.4.命名空间与作用域.html","text":"命名空间 == Namespace : A namespace is a mapping from names to objects. 命名空间，也称名字空间，是从名字（标识符）到对象的映射。==在 Python 中，命名空间由字典来实现的，即{key:value} ↔{名字:对象}。 命名空间的最重要的作用是避免名字冲突，各个命名空间是独立的，因此不同的命名空间可以重名。 Namespace的种类 常见的命名空间有： 内置命名空间 ：存放着built-in Functions（内置函数）的名字、内置的异常的名字、内置常量，内置类型。 全局命名空间 ：每个模块（ .py 文件）拥有它自己的命名空间，包含了直接定义在模块中的名字，例如类、函数、导入的其它模块等等。 局部命名空间 ：每个函数都有着自已的命名空间，它记录了函数的名字（函数的参数、局部定义的名字） local namespace：局部命名空间 global namespace：全局命名空间 Built-in namespace：内置命名空间 另外： 一个对象的属性集合，也构成了一个命名空间。但通常使用 objname.attrname 的间接方式访问属性，而不是直接访问，故不将其列入命名空间讨论。 类定义的命名空间，通常解释器进入类定义时，即执行到 class ClassName: 语句，会新建一个命名空间。(见官方对类定义的 说明 ) 命名空间的生命周期 标识符产生地点决定标识符所处的命名空间。 不同类型的命名空间有不同的生命周期： built-in：在 Python 解释器启动时创建，解释器退出时销毁 global：在模块定义被解释器读入时创建，通常也会一直保存到解释器退出 local：这里要区分 function 以及 class 定义： 函数的局部命名空间：在函数调用时创建，函数返回或者由未捕获的异常时销毁 类定义的命名空间：在解释器读到类定义创建，类定义结束后销毁。（关于类定义的命名空间，在类定义结束后销毁，但其实类对象就是这个命名空间内容的包装，见官方对类定义的 说明 ） 命名空间的查看 局部命名空间可以通过 locals() 来访问。 全局 （模块级别）命名空间可以通过 globals() 来访问。 locals 实际返回的是一个局部名字空间的拷贝，所以修改 locals() 对象并不会影响局部名字空间。 globals 返回是全局名字空间，而不是其拷贝，所以修改 globals() 对象会影响全局名字。 # 修改局部命名空间无效 def func1 ( i ): x = 123 print ( \"当前的局部作用域\" , locals (), sep = \" \\n \" ) locals ()[ \"x\" ] = 6789 print ( \"修改局部作用域后，并不影响x的值\" ) print ( \"x =\" , x ) 当前的局部作用域 {'i': 10, 'x': 123} 修改局部作用域后，并不影响x的值 x = 123 # 修改全局命名空间生效 y = 456 globals ()[ \"y\" ] = 789 print ( \"y =\" , y ) y = 789 总结 模块的名字空间不仅仅包含模块级的变量和常量，还包括所有在模块中定义的函数和类。除此以外，它还包括了任何被导入到模块中的东西。 内置命名也同样被包含在一个模块中，它被称作 built-in。 回想一下 from module import 和 import module 之间的不同： 使用 import module ，模块自身被导入，但是它保持着自已的名字空间，即 module.function 。 使用 from module import function ，实际上是从另一个模块中将指定的函数和属性导入当前名字空间，因此可以直接访问它们。使用 globals 函数，可以展现这一过程的变化。 作用域 scope : A scopeis a textual region of a Python program where a namespace is directly accessible. 作用域是 Python 的一块文本区域，这个区域中，命名空间可以被“直接引用”。 直接引用：直接使用名字访问，如 name ，这种方式尝试在名字空间中搜索名字 name 。 间接引用：使用形如 objname.attrname 的方式，即属性引用，这种方式不会在命名空间中搜索名字 attrname ，而是搜索名字 objname ，再访问其属性。 作用域与命名空间的关系 现在，命名空间持有了名字。作用域是 Python 的一块文本区域，即一块代码区域，需要代码区域引用名字（访问变量），那么作用域与命名空间之间就有了联系。 顾名思义，名字作用域就是名字可以影响到的代码文本区域，命名空间的作用域就是这个命名空间可以影响到的代码文本区域。那么也存在这样一个代码文本区域，多个命名空间可以影响到它。 作用域只是文本区域，其定义是静态的；而名字空间却是动态的，只有随着解释器的执行，命名空间才会产生。那么，在静态的作用域中访问动态命名空间中的名字，造成了作用域使用的动态性。 那么，可以这样认为： 静态的作用域，是一个或多个命名空间按照一定规则叠加影响代码区域；运行时动态的作用域，是按照特定层次组合起来的命名空间。 在一定程度上，可以认为 动态的作用域就是命名空间 。在后面的表述中，我会把动态的作用域与其对应命名空间等同起来。 在Python中，scope是由namespace按特定的层级结构组合起来的。scope一定是namespace，但namespace不一定是scope. 名字搜索顺序 当一行代码需要使用名字 X 所对应的值，python会从当前层级的Namespace开始，并根据以下顺序，去查找 X 这个名字： local namespace： 包含局部名字的最内层（innermost）作用域，如函数、方法、类的内部局部作用域。 Enclosing 根据嵌套层次从内到外搜索，包含非局部（nonlocal）非全局（nonglobal）名字的任意封闭函数的作用域。如两个嵌套的函数，内层函数的作用域是局部作用域，外层函数作用域就是内层函数的 Enclosing作用域。 Global Built-in 如果 Python 在这些namespace找不到 X ，它将放弃查找并引发一个 NameError 异常： NameError: name 'aa' is not defined 程序在运行时，local、global、built-in三个namespace一定存在，但Enclosing namespace不一定存在。 引用作用域需要注意的问题 不能在名字未定义前引用该名字 if 、 for 语句并不会引入新的作用域 外层作用域不能引用内层作用域的变量 def try_to_define_name (): '''函数中定义了名字i，并绑定了一个整数对象1''' i = 1 try_to_define_name () print ( i ) #引用名字i之前，调用了函数 在引用名字 i 之前，明明调用了函数，定义了名字 i ，可是还是找不到这个名字： Traceback (most recent call last): File \"scope_test.py\", line 20, in <module> print(i) #引用名字i之前，调用了函数 NameError: name 'i' is not defined 虽然定义了名字 i ，但是定义在了函数的局部作用域对应的局部命名空间中，按照 LEGB 搜索规则，在全局作用域中自然访问不到局部作用域；再者，函数调用结束后，这个命名空间被销毁了。 引用变量总是与作用域相关的，因此：在Python中一个名字只有在定义之后，才能在合适的作用域引用。 一般来说， B,G 两个作用域的引入是不能够通过代码操作的（参考命名空间的生命周期），能够通过语句引入的作用域只有 E,L 了。Python中引入新作用域的语句很有限，总的来说只有如下三种： 通过定义函数引入 local 作用域或者 Enclosing 作用域；本质上， lambda 和生成器表达式也是函数，会引入新作用域。 类定义引入 local 作用域； 列表推导式引入 local 作用域，传说在 python2 中列表推导式不引入新的作用域 import语句 ： def import_sys (): '''import sys module''' import sys import_sys () print ( sys . path ) # NameError: name 'sys' is not defined 这个算非正常程序员的写法了，在另一篇文章 《Python进阶 - 对象，名字以及绑定》 中介绍过， import 语句在函数 import_sys 中将名字 sys 和对应模块绑定，那 sys 这个名字还是定义在局部作用域，跟上面的例子没有任务区别。 global 和 nonlocal 的作用 任何时候，python都可以直接读取全局变量，但是却不可以在内层作用域直接改写上层变量，来看一个典型的 闭包 结构： #e.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv = [ 'gv' ] + gv #UnboundLocalError:local variable 'gv' referenced before assignment lv = [] def inn_func (): lv = lv + [ v ] #UnboundLocalError:local variable 'lv' referenced before assignment gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 实际 调用 func() 函数后，上面两处对 gv 和 lv 进行赋值操作的地方都会发生 UnboundLocalError ： 因为 Python 在执行函数前，会首先生成各层命名空间和作用域 ，因此 Python 在执行赋值前会将 func 内的 'gv' 'lv' 写入局部命名空间和闭包命名空间，当 Python 执行 赋值时会在局部作用域、闭包作用域内发现局部命名空间和闭包命名空间内已经具有 'gv' 和 'lv' 标识符，但这两个非全局标识符在该赋值语句执行之前并没有被赋值，也即没有对象与标识符关联，因此无法参与四则运算，从而引发错误。 这段程序本意只是想让具有对象的全局变量 gv 和局部变量 lv 参与运算，为了避免类似的情况发生， Python 便引入了 global 、 nonlocal 语句来说明所修饰的 gv 、 lv 分别来自全局命名空间和局部命名空间 ，声明之后，就可以在 func 和 inn_func 内直接改写上层命名空间内 gv 和 lv 的值： #f.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): global gv gv = [ 'gv' ] + gv lv = [] print ( id ( lv )) def inn_func (): nonlocal lv lv = lv + [ v ] print ( id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) # 2608229974344 a () # 2608229974344 # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] print ( gv ) # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] 如上，全局变量 gv 值被函数改写了， inn_func 修改的也确实是父函数 lv 的值 （依据 ID 判断）。 借壳 那么是不是不使用 global 和 nonlocal 就不能达到上面的目的呢？来看看这段程序： #g.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv . insert ( 0 , 'gv' ) # 注意的是.insert只是对gv的元素进行修改，而不是修改gv整个对象,gv是list，元素可变 lv = [] print ( id ( lv )) def inn_func (): lv . append ( v ) # 注意的是.insert只是对lv的元素进行修改，而不是修改lv整个对象 print ( id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 执行的结果： a = func ( 'is' ) # 2608110869168 a () # 2608110869168 # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] print ( gv ) # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] 可以发现，执行结果同上面完全一致，问题自然来了：“为什么不用 global nonlocal 也可以改写全局变量 gv 和父函数变量 lv 的值？ 为了看清楚这个过程，我们将上面的 gv.insert(0, 'gv') 和 lv.append(v) 改写为 gv[0:0] = ['gv'] 和 lv[:] = [v] ： #h.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv [ 0 : 0 ] = [ 'gv' ] lv = [] print ( id ( lv )) def inn_func (): lv [:] = [ v ] print ( id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 执行结果： a = func ( 'is' ) # 2608229959496 a () # 2608229959496 # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] 同 g.py 文件的执行结果完全一致，事实上两者之间的内在也是完全一样的。 其实，我们其实改写的不是 gv 和 lv ,而是 gv 和 lv 的元素 gv[0:0] 和 lv[:] 。因此，不需要 global 和 nonlocal 修饰就可以直接改写， 这就是“借壳”， 这是因为list是可变对象。 在 nonlocal 尚未引入 Python 中，比如 Python 2.x 若要在子函数中改写父函数变量的值就得通过这种方法。当然借壳蕴藏着一个相对复杂的标识符创建的问题：比如子函数通过借壳修改父函数变量 lv 的值，那么子函数的标识符 lv 是怎么绑定到父函数变量 lv 的值 ID 的上的？ 关于这个问题，这里有个问答就是讨论这个的： python的嵌套函数中局部作用域问题? 这个问题在python函数传参的内容有讲清楚。 global 和 nonlocal 语句对标识符创建的不同影响 另外，需要注意的是：global 语句只是声明该标识符引用的变量来自于全局变量，但并不能直接在当前层创建该标识符；nonlocal 语句则会在子函数命名空间中创建与父函数变量同名的标识符： #j.py gv = 'a global var' def func (): global gv lv = 'a local var' print ( locals ()) def inn_func (): nonlocal lv global gv print ( locals ()) return inn_func 执行结果： c = func () { 'lv' : 'a local var' } #运行 `func` 函数后，`global` 语句并未将 `gv` 变量引入局部命名空间 c () { 'lv' : 'a local var' } #运行闭包函数后，`nonlocal` 语句将父函数变量 `lv` 引入闭包命名空间 之所以 nonlocal 语句与 global 语句的处置不同，在于全局变量的作用域生存期很长，在模块内随时都可以访问，而父函数的局部作用域在父函数执行完毕后便会直接释放，因此 nonlocal 语句必须将父函数变量的标识符和引用写入闭包命名空间。 类的局部命名空间 首先，函数和类执行时都会产生局部命名空间，但类的执行机制不同于函数： # i . py def a (): print ( 'function' ) class A (): print ( 1 ) class B (): print ( 2 ) class C (): print ( 3 ) 执行文件，结果为： 1 2 3 如上，类就是一个可执行的代码块，只要该类被加载，就会被执行，这一点不同于函数。 类之所以这么设计的原因在于：类是创建其他实例（生成其他的类或者具体的对象）的对象，因此必须在实例之前被创建，而类又可能涉及到与其他类的继承、重载等一系列问题，故在代码加载时就被创建利于提高效率和降低逻辑复杂度。 其次，与函数不同的是，类的局部命名空间并非作用域 class A(): a = 1 b = [a + i for i in range(3)] #NameError: name 'a' is not defined 执行上段代码，我们可以发现在类 A 内列表推导式无法调取 a 的值，但函数却可以： def func (): a = 1 b = [ a + i for i in range ( 3 )] print ( b ) func () # [ 1 , 2 , 3 ] 因此， A 中的 a 不同于函数 func 中的 a 在局部命名空间中可以被任意读取，之所以说是“不可以被任意”读取而不是“不可被读取”，原因在于在类 A 的局部空间内， a 其实一定程度上是可以直接被读取的： class A(): a = 1 c = a + 2 执行上段代码后： A.c #3 而上例中 b 的赋值操作不能执行，原因在于列表推导式会创建自己的局部命名空间，因此难以访问到 a 。 总结 啰嗦了这么多，终于该结尾了！ 我们再来回过头来看下文章开头的栗子： 1、为什么 b.py 只是导入 a.py 中的 class A ,却执行了整个 a.py 文件? 答：因为 Python 并不知道 class A 在 a.py 文档的何处，为了能够找到 class A ，Python 需要执行整个文档。 2、为什么 b.py 的导入执行了整个 a.py 文档，却在 b 中难以调用 a 的全局变量 va ？ 答：Python 的全局变量指的是模块全局，因此不可以跨文档，因此 global 语句也是不可以跨文档的。另外， b 只是导入了 a 的 class A ，因此并不会导入 a 中所有的标识符，所以 类似 a.va 这样的调用也是不起作用的。 关于命名空间： 1、赋值、定义类和函数都会产生新的标识符； 2、全局变量的标识符不能跨文档； 3、各级命名空间相互独立互不影响； 4、Python 总是从当前层逐渐向上寻找标识符； 5、内层作用域若想直接修改上层变量，需要通过 global nonlocal 语句先声明； 6、单纯的 global 语句并不能为所在层级创建相应标识符，但 nonlocal 语句可以在闭包空间中创建相应标识符； 7、类的局部命名空间不是作用域。","text_tokens":["assignment","一行","说明","层级","program","段","指","它们","value","一般来说","i","产生","2608229974344","结构","很","f","达到","2","不可","不","降低","层次","说","define","并未","文章","定义","目的","引入","保持","或者","讨论","print","原因","区分","随时","非","即","那","外层","结尾","还是","而类","导入到","789","自身","合适","scopeis","scope","locals","，","再","运行","range","并不知道","难以","那么","未定义","问题","》","lambda","将父","以外","又","不仅","一般","尝试","多个","两个","`","built","无效","一系列","每个","进入","不仅仅","按","具有","中将","is","特定","内层","'","只是",">","时","functions","涉及","销毁","其次","！","可是","传说","方式","之后","类似","名字","间接","l","引用","语句","啰嗦","回过头来","字典","实例","式","实际上","了","return","首先","独立","再者","通过","objects","？","这一","作用域","但","标识","动态","到父","3","如下","不同","不同于","回过","同","生成器","if","完全一致","效率","与","一系","着","这里","这","insert","若想","其他","跨","却是","保存","称作","过","想","要","重要","；","虽然","局部变量","提高效率","任何","无法","系列","有个","会","1","推导","?","存在","释放","终于","层","怎么","可变","textual","从而","类","叠加","不用","之前","attrname","上面","后面","介绍","recent","而是","而父","y","nonglobal","程度","达式","级别","等同","程序员","module","例子","同名","空间","来","有","规则","enclosing","]","异常","读取","重载","导入","创建","总结","被称作","不知","只要","not","子函数","）","三个","而","def","蕴藏","表述","新","自已","单纯","list","区域"," ","使用","两者之间","中","上例","事实","一块","{","names","“","of","放弃","accessible","var","本质","修饰","test","任务","看清楚","正常","很长","但类","innermost","legb","也","动态性","两者","复杂","相对","类型","构成","所","组合","其","相互","这些","class","不到","把","不能引用","123","python","明明","决定","两处","内置","去","(","所处","成器","修改","我会","sys","事实上","整个","e","函数","上层","在","是不是","并","<","见","解释器","集合","global","非正常","最","classname","2608110869168","并非","↔","生命","释器","与其","现在","实际","most","python2","声明","启动","各个","为","必须","当前","可","可以","《","已经","加载","确实","我们","程序","包括","过头","机制","问答","地点","该","捕获","该类","inn","内","完毕","不起作用","本意","v","让","开头","起来","看清","lv","这么","或","py","任意","地方","什么","nameerror","对类","traceback","前","2608229959496","包含","引发","（","联系","表达式","和","按照","同于","未定","栗子","内容","读到","时候","段程序","开始","有限","globals","生存期","for","line","表达","官方","展现","依据","知道","文本","进阶","认为","0","还","在于","生效","全局","va","因此","_","发生","东西","关于","各层","称","id","故","例如","传参","对应","下","关联","向上","之间","function","逻辑","6789","调用","所在","周期","一样","是从","属性","重名","清楚","相关","跟","另外","一个","”","种类","写入","\"","便","。","直接","为什么","区别","后","存放","6","根据","运算","才能","列入","局部","未","完全","除此以外","sep","顾名","访问","元素","避免","能够","生成","高效","值","找到","从","region","返回","寻找","由","func1","作用","-","7","具体","影响","variable","如","算","、","一定","外","a","生存","设计","造成","就","判断","以及","结束","内在","来说","调取","defined","映射","函数调用","改写","呢","常量","查看","先","当","过程","冲突","父","若要","它","last","全局变量","总是","除此","为了",")","执行","就是","一篇","参与","找","各级","注意","这个","aa","形","嵌套","path","顾名思义","对","objname","456","通常","块","自然","的","前会","实现","才","查找","记录","变化","持有","级","b","发现","处置","但是","call","文件","其它","n","封闭","讲清","讲清楚","unboundlocalerror","nonlocal","尚未","利于","namespace","不是","模块","参数","h","因为","g","之所以","方法","一致","比如","没有","标识符","等等","不会","这样","仅仅","四则运算","一直","包装","却","时会","典型","}","当然","c","高效率","等","try","分别","闭包","10","整数","都","总的来说","5","\\","j","互不","绑定","是因为","name","所有","写法","逐渐","参考","则","将","4","以下","gv","local","多","指定","拷贝","得","命名","解释","import","对象","关系","结果","四则","常见","=","#","append","x","看","这种","错误","回想","相应","上","操作","20","继承","拥有","静态","情况","来自",".",",","到","是","where","不能","[","内部","被","看看","赋值","三种","代码","同样","读入","before","退出","存期","随着","生命周期","于","自己","其实","有着","+","新建","in","mapping","只有","变量","提高","一下","需要","复杂度","答","可能","from","to","所以","另","进行","来看","搜索","借壳","func","文档","key","directly","顺序","如果","referenced","一点",":","何处","列表","file","："],"title":"1.4.命名空间与作用域","title_tokens":[".","命名","作用域","作用","空间","1.4","与"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_1","text":"== Namespace : A namespace is a mapping from names to objects. 命名空间，也称名字空间，是从名字（标识符）到对象的映射。==在 Python 中，命名空间由字典来实现的，即{key:value} ↔{名字:对象}。 命名空间的最重要的作用是避免名字冲突，各个命名空间是独立的，因此不同的命名空间可以重名。","text_tokens":["↔","命名","因此","标识符","称","标识","对象","a","各个","的","实现","is","value","，","="," ","即","不同","（","python","可以","中","}","mapping","{","names","映射","是从","避免",".","重名","到","是","名字","空间","来","from","冲突","to","。","重要","namespace","也","字典","key","在","由","作用",":","独立","）","objects","最"],"title":"命名空间","title_tokens":["命名","空间"]},{"location":"计算机基础/1.4.命名空间与作用域.html#namespace","text":"常见的命名空间有： 内置命名空间 ：存放着built-in Functions（内置函数）的名字、内置的异常的名字、内置常量，内置类型。 全局命名空间 ：每个模块（ .py 文件）拥有它自己的命名空间，包含了直接定义在模块中的名字，例如类、函数、导入的其它模块等等。 局部命名空间 ：每个函数都有着自已的命名空间，它记录了函数的名字（函数的参数、局部定义的名字） local namespace：局部命名空间 global namespace：全局命名空间 Built-in namespace：内置命名空间 另外： 一个对象的属性集合，也构成了一个命名空间。但通常使用 objname.attrname 的间接方式访问属性，而不是直接访问，故不将其列入命名空间讨论。 类定义的命名空间，通常解释器进入类定义时，即执行到 class ClassName: 语句，会新建一个命名空间。(见官方对类定义的 说明 )","text_tokens":["objname","py","通常","说明","对类","类","的","包含","记录","attrname","（","不","文件","其它","定义","空间","讨论","有","官方","namespace","不是","异常","模块","参数","导入","）","即","全局","而","等等","例如","自已","故"," ","，","使用","中","属性","都","另外","一个","。","直接","也","将","存放","local","built","类型","构成","每个","命名","进入","列入","其","局部","解释","对象","class","常见","访问","时","内置","functions","拥有","(",".","到","方式","名字","间接","语句","函数","在","-","了","见","解释器","集合","global","classname","、","释器","但","自己","有着","新建","in","着","常量","它",")","执行",":","会","："],"title":"Namespace的种类","title_tokens":["的","种类","namespace"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_2","text":"标识符产生地点决定标识符所处的命名空间。 不同类型的命名空间有不同的生命周期： built-in：在 Python 解释器启动时创建，解释器退出时销毁 global：在模块定义被解释器读入时创建，通常也会一直保存到解释器退出 local：这里要区分 function 以及 class 定义： 函数的局部命名空间：在函数调用时创建，函数返回或者由未捕获的异常时销毁 类定义的命名空间：在解释器读到类定义创建，类定义结束后销毁。（关于类定义的命名空间，在类定义结束后销毁，但其实类对象就是这个命名空间内容的包装，见官方对类定义的 说明 ）","text_tokens":["通常","说明","对类","类","的","产生","（","内容","读到","定义","空间","或者","有","官方","模块","区分","异常","创建","）","标识符","关于","一直"," ","，","包装","function","调用","周期","。","也","后","local","built","类型","命名","局部","解释","未","对象","class","python","决定","时","所处","销毁","到","返回","被","函数","在","由","-","见","解释器","读入","global","退出","生命","释器","但","标识","生命周期","启动","其实","不同","以及","in","结束","函数调用","这里","地点","捕获","保存","要","就是","这个","会","："],"title":"命名空间的生命周期","title_tokens":["命名","生命","空间","生命周期","周期","的"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_3","text":"局部命名空间可以通过 locals() 来访问。 全局 （模块级别）命名空间可以通过 globals() 来访问。 locals 实际返回的是一个局部名字空间的拷贝，所以修改 locals() 对象并不会影响局部名字空间。 globals 返回是全局名字空间，而不是其拷贝，所以修改 globals() 对象会影响全局名字。 # 修改局部命名空间无效 def func1 ( i ): x = 123 print ( \"当前的局部作用域\" , locals (), sep = \" \\n \" ) locals ()[ \"x\" ] = 6789 print ( \"修改局部作用域后，并不影响x的值\" ) print ( \"x =\" , x ) 当前的局部作用域 {'i': 10, 'x': 123} 修改局部作用域后，并不影响x的值 x = 123 # 修改全局命名空间生效 y = 456 globals ()[ \"y\" ] = 789 print ( \"y =\" , y ) y = 789","text_tokens":["456","命名","而","def","其","局部","实际","作用域","不会","789","对象","的","当前","locals"," ","，","i","=","sep","123","（","#","'","可以","通过","x","访问","6789","不","}","y","{","(","n","级别","修改","10",",","是","一个","名字","空间","来","globals","\"","\\","[","所以","值","。","print","]","返回","不是","模块",")","func1","并","作用","后","影响","会","无效",":","生效","）","拷贝","全局"],"title":"命名空间的查看","title_tokens":["命名","的","空间","查看"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_4","text":"模块的名字空间不仅仅包含模块级的变量和常量，还包括所有在模块中定义的函数和类。除此以外，它还包括了任何被导入到模块中的东西。 内置命名也同样被包含在一个模块中，它被称作 built-in。 回想一下 from module import 和 import module 之间的不同： 使用 import module ，模块自身被导入，但是它保持着自已的名字空间，即 module.function 。 使用 from module import function ，实际上是从另一个模块中将指定的函数和属性导入当前名字空间，因此可以直接访问它们。使用 globals 函数，可以展现这一过程的变化。","text_tokens":["类","的","它们","包含","变化","级","和","但是","定义","module","保持","空间","globals","展现","模块","导入","被称作","还","即","因此","东西","导入到","自身","自已","仅仅","，"," ","之间","function","使用","中","是从","属性","以外","一个","。","不仅","直接","所有","也","built","指定","命名","不仅仅","import","中将","除此以外","访问","回想","内置",".","名字","被","函数","在","-","实际上","了","同样","这一","实际","当前","不同","可以","in","变量","着","一下","包括","常量","from","过程","它","称作","另","除此","任何","："],"title":"总结","title_tokens":["总结"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_5","text":"scope : A scopeis a textual region of a Python program where a namespace is directly accessible. 作用域是 Python 的一块文本区域，这个区域中，命名空间可以被“直接引用”。 直接引用：直接使用名字访问，如 name ，这种方式尝试在名字空间中搜索名字 name 。 间接引用：使用形如 objname.attrname 的方式，即属性引用，这种方式不会在命名空间中搜索名字 attrname ，而是搜索名字 objname ，再访问其属性。","text_tokens":["objname","命名","作用域","其","不会","textual","program","a","scopeis","的","is","scope","区域","attrname"," ","，","即","再","python","可以","使用","这种","中","访问","而是","一块","“","of","属性",".","accessible","where","是","”","名字","方式","空间","间接","引用","。","name","直接","region","搜索","namespace","被","directly","尝试","在","作用","文本","这个",":","如","形","："],"title":"作用域","title_tokens":["作用域","作用"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_6","text":"现在，命名空间持有了名字。作用域是 Python 的一块文本区域，即一块代码区域，需要代码区域引用名字（访问变量），那么作用域与命名空间之间就有了联系。 顾名思义，名字作用域就是名字可以影响到的代码文本区域，命名空间的作用域就是这个命名空间可以影响到的代码文本区域。那么也存在这样一个代码文本区域，多个命名空间可以影响到它。 作用域只是文本区域，其定义是静态的；而名字空间却是动态的，只有随着解释器的执行，命名空间才会产生。那么，在静态的作用域中访问动态命名空间中的名字，造成了作用域使用的动态性。 那么，可以这样认为： 静态的作用域，是一个或多个命名空间按照一定规则叠加影响代码区域；运行时动态的作用域，是按照特定层次组合起来的命名空间。 在一定程度上，可以认为 动态的作用域就是命名空间 。在后面的表述中，我会把动态的作用域与其对应命名空间等同起来。 在Python中，scope是由namespace按特定的层级结构组合起来的。scope一定是namespace，但namespace不一定是scope.","text_tokens":["或","层级","的","叠加","才","产生","持有","（","联系","后面","结构","按照","不","层次","程度","等同","定义","空间","有","规则","namespace","文本","认为","）","即","而","表述","这样","对应","区域","scope","，"," ","之间","运行","使用","中","一块","那么","一个","存在","。","也","多个","动态性","命名","组合","其","解释","按","特定","把","python","顾名","只是","访问","时","上","静态","我会",".","到","是","名字","引用","在","由","作用","代码","了","影响","解释器","随着","释器","一定","作用域","现在","动态","与其","但","造成","就","可以","只有","变量","与","需要","却是","它","；","就是","执行","这个","会","起来","顾名思义","："],"title":"作用域与命名空间的关系","title_tokens":["命名","作用域","作用","空间","关系","的","与"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_7","text":"当一行代码需要使用名字 X 所对应的值，python会从当前层级的Namespace开始，并根据以下顺序，去查找 X 这个名字： local namespace： 包含局部名字的最内层（innermost）作用域，如函数、方法、类的内部局部作用域。 Enclosing 根据嵌套层次从内到外搜索，包含非局部（nonlocal）非全局（nonglobal）名字的任意封闭函数的作用域。如两个嵌套的函数，内层函数的作用域是局部作用域，外层函数作用域就是内层函数的 Enclosing作用域。 Global Built-in 如果 Python 在这些namespace找不到 X ，它将放弃查找并引发一个 NameError 异常： NameError: name 'aa' is not defined 程序在运行时，local、global、built-in三个namespace一定存在，但Enclosing namespace不一定存在。","text_tokens":["一行","层级","任意","nameerror","类","的","查找","包含","引发","（","不","层次","nonglobal","封闭","开始","nonlocal","enclosing","namespace","异常","方法","not","非","）","外层","全局","三个","对应","，"," ","运行","使用","放弃","一个","存在","。","innermost","name","将","两个","以下","local","built","根据","所","局部","这些","不到","is","内层","'","python","x","时","去","到","是","名字","值","内部","从","函数","在","并","作用","-","代码","如","global","最","、","一定","作用域","但","外","当前","in","defined","需要","程序","当","它","内","搜索","顺序","如果","就是","找","这个","会",":","aa","嵌套","："],"title":"名字搜索顺序","title_tokens":["搜索","名字","顺序"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_8","text":"不能在名字未定义前引用该名字 if 、 for 语句并不会引入新的作用域 外层作用域不能引用内层作用域的变量 def try_to_define_name (): '''函数中定义了名字i，并绑定了一个整数对象1''' i = 1 try_to_define_name () print ( i ) #引用名字i之前，调用了函数 在引用名字 i 之前，明明调用了函数，定义了名字 i ，可是还是找不到这个名字： Traceback (most recent call last): File \"scope_test.py\", line 20, in <module> print(i) #引用名字i之前，调用了函数 NameError: name 'i' is not defined 虽然定义了名字 i ，但是定义在了函数的局部作用域对应的局部命名空间中，按照 LEGB 搜索规则，在全局作用域中自然访问不到局部作用域；再者，函数调用结束后，这个命名空间被销毁了。 引用变量总是与作用域相关的，因此：在Python中一个名字只有在定义之后，才能在合适的作用域引用。 一般来说， B,G 两个作用域的引入是不能够通过代码操作的（参考命名空间的生命周期），能够通过语句引入的作用域只有 E,L 了。Python中引入新作用域的语句很有限，总的来说只有如下三种： 通过定义函数引入 local 作用域或者 Enclosing 作用域；本质上， lambda 和生成器表达式也是函数，会引入新作用域。 类定义引入 local 作用域； 列表推导式引入 local 作用域，传说在 python2 中列表推导式不引入新的作用域 import语句 ： def import_sys (): '''import sys module''' import sys import_sys () print ( sys . path ) # NameError: name 'sys' is not defined 这个算非正常程序员的写法了，在另一篇文章 《Python进阶 - 对象，名字以及绑定》 中介绍过， import 语句在函数 import_sys 中将名字 sys 和对应模块绑定，那 sys 这个名字还是定义在局部作用域，跟上面的例子没有任务区别。","text_tokens":["py","traceback","nameerror","类","前","的","自然","一般来说","之前","i","上面","（","表达式","b","很","和","recent","按照","介绍","不","未定","但是","call","达式","define","文章","定义","程序员","引入","module","例子","有限","空间","或者","for","line","print","规则","enclosing","表达","模块","进阶","g","not","）","那","外层","全局","因此","_","没有","def","还是","新","不会","对应","合适","scope"," ","，","中","调用","周期","try","未定义","》","整数","相关","总的来说","lambda","跟","一个","本质","test","任务","\"","path","正常","。","绑定","name","legb","一般","也","写法","参考","区别","两个","后","local","才能","命名","局部","import","对象","不到","中将","is","=","内层","不能引用","'","#","python","明明",">","访问","上","操作","20","(","销毁","成器","sys",".",",","可是","能够","之后","是","生成","名字","传说","不能","l","e","引用","语句","被","函数","在","式","并","作用","三种","-","<","代码","了","再者","通过","非正常","算","、","生命","作用域","most","生命周期","python2","如下","以及","in","结束","生成器","《","只有","if","来说","变量","defined","与","函数调用","程序","该","to","另","last","搜索","；","虽然","过","总是",")","一篇","找","这个",":","会","1","推导","列表","file","："],"title":"引用作用域需要注意的问题","title_tokens":["作用域","作用","注意","引用","的","问题","需要"]},{"location":"计算机基础/1.4.命名空间与作用域.html#global-nonlocal","text":"任何时候，python都可以直接读取全局变量，但是却不可以在内层作用域直接改写上层变量，来看一个典型的 闭包 结构： #e.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv = [ 'gv' ] + gv #UnboundLocalError:local variable 'gv' referenced before assignment lv = [] def inn_func (): lv = lv + [ v ] #UnboundLocalError:local variable 'lv' referenced before assignment gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 实际 调用 func() 函数后，上面两处对 gv 和 lv 进行赋值操作的地方都会发生 UnboundLocalError ： 因为 Python 在执行函数前，会首先生成各层命名空间和作用域 ，因此 Python 在执行赋值前会将 func 内的 'gv' 'lv' 写入局部命名空间和闭包命名空间，当 Python 执行 赋值时会在局部作用域、闭包作用域内发现局部命名空间和闭包命名空间内已经具有 'gv' 和 'lv' 标识符，但这两个非全局标识符在该赋值语句执行之前并没有被赋值，也即没有对象与标识符关联，因此无法参与四则运算，从而引发错误。 这段程序本意只是想让具有对象的全局变量 gv 和局部变量 lv 参与运算，为了避免类似的情况发生， Python 便引入了 global 、 nonlocal 语句来说明所修饰的 gv 、 lv 分别来自全局命名空间和局部命名空间 ，声明之后，就可以在 func 和 inn_func 内直接改写上层命名空间内 gv 和 lv 的值： #f.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): global gv gv = [ 'gv' ] + gv lv = [] print ( id ( lv )) def inn_func (): nonlocal lv lv = lv + [ v ] print ( id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func a = func ( 'is' ) # 2608229974344 a () # 2608229974344 # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] print ( gv ) # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] 如上，全局变量 gv 值被函数改写了， inn_func 修改的也确实是父函数 lv 的值 （依据 ID 判断）。","text_tokens":["assignment","py","说明","地方","从而","前","的","前会","之前","上面","引发","2608229974344","（","结构","和","f","不","发现","但是","时候","段程序","引入","unboundlocalerror","空间","来","nonlocal","print","]","依据","读取","因为","0","非","即","）","全局","因此","_","没有","def","发生","各层","标识符","id","lv","四则运算","关联","，"," ","却","时会","典型","调用","分别","闭包","都","var","一个","修饰","写入","便","。","直接","也","将","两个","后","gv","local","运算","命名","所","局部","对象","具有","四则","is","=","内层","'","#","python","两处","只是","错误","上","操作","(","避免","情况","来自",".","修改",",","生成","类似","之后","是","e","[","值","语句","被","函数","上层","在","赋值","作用","并","了","return","variable","首先","before","如","global","、","作用域","声明","实际","标识","但","a","就","判断","+","可以","已经","变量","与","确实","改写","这","insert","程序","当","父","该","想","进行","来看","全局变量","inn","内","局部变量","任何","func","本意","v","无法",")","执行","参与","referenced","让","为了",":","会","1","对","："],"title":"global和 nonlocal的作用","title_tokens":["和","作用","nonlocal","的","global"," "]},{"location":"计算机基础/1.4.命名空间与作用域.html#_9","text":"那么是不是不使用 global 和 nonlocal 就不能达到上面的目的呢？来看看这段程序： #g.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv . insert ( 0 , 'gv' ) # 注意的是.insert只是对gv的元素进行修改，而不是修改gv整个对象,gv是list，元素可变 lv = [] print ( id ( lv )) def inn_func (): lv . append ( v ) # 注意的是.insert只是对lv的元素进行修改，而不是修改lv整个对象 print ( id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 执行的结果： a = func ( 'is' ) # 2608110869168 a () # 2608110869168 # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] print ( gv ) # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] 可以发现，执行结果同上面完全一致，问题自然来了：“为什么不用 global nonlocal 也可以改写全局变量 gv 和父函数变量 lv 的值？ 为了看清楚这个过程，我们将上面的 gv.insert(0, 'gv') 和 lv.append(v) 改写为 gv[0:0] = ['gv'] 和 lv[:] = [v] ： #h.py gv = [ 'a' , 'global' , 'var' ] def func ( v ): gv [ 0 : 0 ] = [ 'gv' ] lv = [] print ( id ( lv )) def inn_func (): lv [:] = [ v ] print ( id ( lv )) gv . insert ( 1 , lv [ 0 ]) return gv return inn_func 执行结果： a = func ( 'is' ) # 2608229959496 a () # 2608229959496 # [ 'gv' , 'is' , 'a' , 'global' , 'var' ] 同 g.py 文件的执行结果完全一致，事实上两者之间的内在也是完全一样的。 其实，我们其实改写的不是 gv 和 lv ,而是 gv 和 lv 的元素 gv[0:0] 和 lv[:] 。因此，不需要 global 和 nonlocal 修饰就可以直接改写， 这就是“借壳”， 这是因为list是可变对象。 在 nonlocal 尚未引入 Python 中，比如 Python 2.x 若要在子函数中改写父函数变量的值就得通过这种方法。当然借壳蕴藏着一个相对复杂的标识符创建的问题：比如子函数通过借壳修改父函数变量 lv 的值，那么子函数的标识符 lv 是怎么绑定到父函数变量 lv 的值 ID 的上的？ 关于这个问题，这里有个问答就是讨论这个的： python的嵌套函数中局部作用域问题? 这个问题在python函数传参的内容有讲清楚。","text_tokens":["py","怎么","可变","什么","自然","的","不用","2608229959496","上面","和","达到","2","不","发现","而是","文件","内容","段程序","讲清","目的","引入","讲清楚","来","nonlocal","讨论","有","尚未","print","]","不是","h","因为","创建","g","0","方法","?","子函数","全局","一致","比如","因此","_","def","而","蕴藏","标识符","关于","id","传参","list"," ","，","之间","使用","两者之间","中","当然","事实","一样","那么","问题","“","清楚","var","一个","”","修饰","看清楚","。","是因为","绑定","直接","也","为什么","将","gv","两者","复杂","相对","得","局部","对象","结果","完全","is","=","'","#","append","python","x","只是","这种","上","(","元素","事实上","修改",".",",","是","整个","不能","[","值","看看","函数","是不是","在","作用","了","return","通过","global","？","2608110869168","作用域","标识","a","为","到父","其实","就","可以","同","内在","完全一致","变量","改写","这","我们","呢","着","这里","需要","程序","insert","问答","过程","父","若要","进行","inn","全局变量","借壳","func","对","v","为了",")","执行","就是","有个","注意","这个",":","1","嵌套","看清","lv","："],"title":"借壳","title_tokens":["借壳"]},{"location":"计算机基础/1.4.命名空间与作用域.html#global-nonlocal_1","text":"另外，需要注意的是：global 语句只是声明该标识符引用的变量来自于全局变量，但并不能直接在当前层创建该标识符；nonlocal 语句则会在子函数命名空间中创建与父函数变量同名的标识符： #j.py gv = 'a global var' def func (): global gv lv = 'a local var' print ( locals ()) def inn_func (): nonlocal lv global gv print ( locals ()) return inn_func 执行结果： c = func () { 'lv' : 'a local var' } #运行 `func` 函数后，`global` 语句并未将 `gv` 变量引入局部命名空间 c () { 'lv' : 'a local var' } #运行闭包函数后，`nonlocal` 语句将父函数变量 `lv` 引入闭包命名空间 之所以 nonlocal 语句与 global 语句的处置不同，在于全局变量的作用域生存期很长，在模块内随时都可以访问，而父函数的局部作用域在父函数执行完毕后便会直接释放，因此 nonlocal 语句必须将父函数变量的标识符和引用写入闭包命名空间。","text_tokens":["释放","py","层","的","和","处置","而父","并未","引入","同名","空间","生存期","nonlocal","print","模块","随时","创建","之所以","在于","子函数","全局","因此","_","def","标识符","locals","，"," ","运行","中","}","c","{","闭包","都","另外","var","将父","写入","便","j","很长","。","直接","则","将","`","后","gv","local","命名","局部","结果","=","'","#","只是","访问","(","来自",".","是","不能","引用","语句","函数","在","并","作用","return","global","存期","作用域","声明","但","标识","a","于","生存","必须","当前","不同","可以","变量","与","需要","父","该","所以","inn","全局变量","；","内","完毕","func",")","执行","注意","会",":","lv","："],"title":"global 和 nonlocal 语句对标识符创建的不同影响","title_tokens":["和","标识符","创建","标识","nonlocal","影响","语句","的","global"," ","对","不同"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_10","text":"首先，函数和类执行时都会产生局部命名空间，但类的执行机制不同于函数： # i . py def a (): print ( 'function' ) class A (): print ( 1 ) class B (): print ( 2 ) class C (): print ( 3 ) 执行文件，结果为： 1 2 3 如上，类就是一个可执行的代码块，只要该类被加载，就会被执行，这一点不同于函数。 类之所以这么设计的原因在于：类是创建其他实例（生成其他的类或者具体的对象）的对象，因此必须在实例之前被创建，而类又可能涉及到与其他类的继承、重载等一系列问题，故在代码加载时就被创建利于提高效率和降低逻辑复杂度。 其次，与函数不同的是，类的局部命名空间并非作用域 class A(): a = 1 b = [a + i for i in range(3)] #NameError: name 'a' is not defined 执行上段代码，我们可以发现在类 A 内列表推导式无法调取 a 的值，但函数却可以： def func (): a = 1 b = [ a + i for i in range ( 3 )] print ( b ) func () # [ 1 , 2 , 3 ] 因此， A 中的 a 不同于函数 func 中的 a 在局部命名空间中可以被任意读取，之所以说是“不可以被任意”读取而不是“不可被读取”，原因在于在类 A 的局部空间内， a 其实一定程度上是可以直接被读取的： class A(): a = 1 c = a + 2 执行上段代码后： A.c #3 而上例中 b 的赋值操作不能执行，原因在于列表推导式会创建自己的局部命名空间，因此难以访问到 a 。","text_tokens":["py","任意","nameerror","块","类","段","的","之前","i","产生","（","b","和","2","不可","发现","同于","降低","不","文件","说","程度","空间","或者","for","print","利于","]","原因","不是","重载","读取","创建","之所以","只要","在于","not","）","因此","def","而","而类","故","，"," ","function","却","逻辑","中","上例","c","高效率","range","等","列表","难以","问题","“","都","一个","”","又","但类","。","name","直接","后","复杂","一系列","命名","局部","对象","结果","class","is","=","'","#","时","访问","上","操作","继承","(","涉及","其次",".",",","生成","到","是","不能","高效","[","值","被","函数","实例","在","赋值","式","作用","代码","具体","首先","如","并非","、","一定","作用域","但","a","3","为","设计","必须","其实","自己","可","就","不同","不同于","+","可以","in","加载","效率","调取","提高","与","defined","一系","这","我们","复杂度","机制","其他","可能","该类","所以","内","提高效率","func","系列","无法",")","执行","就是","一点","会",":","1","推导","这么","："],"title":"类的局部命名空间","title_tokens":["命名","局部","空间","类","的"]},{"location":"计算机基础/1.4.命名空间与作用域.html#_11","text":"啰嗦了这么多，终于该结尾了！ 我们再来回过头来看下文章开头的栗子： 1、为什么 b.py 只是导入 a.py 中的 class A ,却执行了整个 a.py 文件? 答：因为 Python 并不知道 class A 在 a.py 文档的何处，为了能够找到 class A ，Python 需要执行整个文档。 2、为什么 b.py 的导入执行了整个 a.py 文档，却在 b 中难以调用 a 的全局变量 va ？ 答：Python 的全局变量指的是模块全局，因此不可以跨文档，因此 global 语句也是不可以跨文档的。另外， b 只是导入了 a 的 class A ，因此并不会导入 a 中所有的标识符，所以 类似 a.va 这样的调用也是不起作用的。 关于命名空间： 1、赋值、定义类和函数都会产生新的标识符； 2、全局变量的标识符不能跨文档； 3、各级命名空间相互独立互不影响； 4、Python 总是从当前层逐渐向上寻找标识符； 5、内层作用域若想直接修改上层变量，需要通过 global nonlocal 语句先声明； 6、单纯的 global 语句并不能为所在层级创建相应标识符，但 nonlocal 语句可以在闭包空间中创建相应标识符； 7、类的局部命名空间不是作用域。","text_tokens":["py","终于","层级","层","什么","指","类","的","产生","b","2","和","不","文件","栗子","文章","定义","空间","来","nonlocal","知道","不是","模块","导入","因为","创建","不知","结尾","全局","va","因此","标识符","关于","新","这样","不会","单纯","下","，"," ","再","向上","却","中","调用","并不知道","所在","难以","闭包","都","另外","5","。","互不","直接","所有","也","为什么","逐渐","4","多","6","命名","相互","局部","class","内层","python","看","只是","相应","修改",".","！",",","能够","整个","是","类似","不能","语句","啰嗦","找到","从","寻找","回过头来","函数","上层","在","赋值","并","作用","7","了","影响","独立","通过","global","？","、","作用域","声明","但","标识","a","3","为","当前","回过","可以","变量","我们","需要","若想","过头","先","答","跨","该","所以","全局变量","；","总是","不起作用","文档","为了","执行","开头","1","各级","会","?","何处","这么","："],"title":"总结","title_tokens":["总结"]},{"location":"计算机基础/1.5.字符编码.html","text":"相对于数字，字符串比较特殊的是还有一个编码问题。 一般，计算机的系统结构是基于数字信号来搭建的，计算机中的计算基于数字电路。在计算机内部，所有信息最终都是一个二进制值。计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。 每一个二进制位（bit）有 0 和 1 两种状态，最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），因此一个字节可以表示256种状态（$2^8=256$），每一个状态对应一个符号，就是256个符号，从 00000000 到 11111111 。一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是 65535 ，4个字节可以表示的最大整数是 4294967295 。 ASCII码 因为计算机是美国人发明的，所以在上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。ASCII 码一共规定了128个字符的编码，比如空格 SPACE 是32（二进制 00100000 ），大写的字母 A 是65（二进制 01000001 ）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为 0 。 非ASCII码 英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的 é 的编码为130（二进制 10000010 ）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了 é ，在希伯来语编码中却代表了字母 Gimel ( ג )，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。 GB2312码 汉字多达10万左右，要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了 GB2312 编码，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 可以想得到的是，全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。 Unicode 正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode就像它的名字都表示的，这是一种所有符号的编码。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，可以查询 unicode.org ，或者专门的 汉字对应表 。 Unicode 的问题 需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。（ 这里说的储存是储存在 ROM 中，比如说硬盘。 ） 比如，汉字 严 的 Unicode 是十六进制数 4E25 ，转换成二进制数足足有15位（ 100111000100101 ），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0 ，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 因此不能用Unicode码直接储存文件。 它们造成的结果是： 出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。 Unicode 在很长一段时间内无法推广，直到互联网的出现。 UTF-8 互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。 ==强调一下Unicode和UTF-8的区别：UTF-8是Unicode的一种储存形式，但计算机只能读取二进制的内容，因此计算机读取UTF-8编码的文件，需要将文件转码为Unicode（Unicode是完全二进制的形式）。也就是说，文件以UTF-8的形式储存在硬盘上，以Unicode的形式储存在内存（Ram）中。==例如： 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。 所以你看到很多网页的源码上会有类似 <meta charset=\"UTF-8\" /> 的信息，表示该网页正是用的UTF-8编码。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为 0 ，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于 n 字节的符号（ n > 1 ），第一个字节的前 n 位都设为 1 ，第 n + 1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母 x 表示可用编码的位。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） ----------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是 0 ，则这个字节单独就是一个字符；如果第一位是 1 ，则连续有多少个 1 ，就表示当前字符占用多少个字节。 下面，还是以汉字 严 为例，演示如何实现 UTF-8 编码。 严 的 Unicode 是 4E25 （ 100111000100101 ），根据上表，可以发现 4E25 处在第三行的范围内（ 0000 0800 - 0000 FFFF ），因此 严 的 UTF-8 编码需要三个字节，即格式是 1110xxxx 10xxxxxx 10xxxxxx 。然后，从 严 的最后一个二进制位开始，依次从后向前填入格式中的 x ，多出的位补 0 。这样就得到了， 严 的 UTF-8 编码是 11100100 10111000 10100101 ，转换成十六进制就是 E4B8A5 。 UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。 参考 字符编码笔记：ASCII，Unicode 和 UTF-8","text_tokens":["全部","本文","从文件","个字符","体系","相同","全世界","它们","org","大量","推广","结构","2","不可","很","不","应运而生","说","一套","0xxxxxxx","人","普及","三倍","或者","单独","俄语","也就是说","搭建","理论","发信","16","存储","系统结构","非","即","8","一来","还是","法语","不管","强调","服务","/","，","再","收信","space","韩文","否则","那么","问题","十进制","发信人","储存","不管怎样","正如","偏僻","又","状态","至少","不可避免","沿用","能","10000010","一般","多个","形式","两个","ffff","变长","很多","11111111","左右","一些","每个","最大","15","第三行","从后","大出","两种","这是","现代","二进制位","只是","足足","时",">","许多","里","美国","容纳","类似","方式","比如说","名字","特殊","查询","沿用至今","剩下","实际上","完成","数字电路","了","希伯来","同一个","最早","？","jis","算机","电路","0001","但","动态","还有","3","应运","打开","11110xxx","不同","就够","用","出来","更","个","符号","国家","与","这","这里","着","非常简单","gb2312","其他","规定","想","保存","要","前面","虽然","十六进制","许多种","；","最高","无法","数字信号","转码","做","会","计算机","1","最多","存在","好处","怎么","类","跟据","不用","~","数字电","下面","后面","字符串","65536","注音","应该","utf","最后","大多","联网","编","软件","数字","来","32","有","规则","采用","基本","浪费","更大","读取","码是","多出","后文","总结","要求","范围","常用","提及","）","统一","日文","格式","三个","系统","而","新","比特","多达","10111000","编辑","语言"," ","部分","使用","万个","中","如何","为例","看到","130","中文","额外","严重","10100101","特点","专门","很长","上会","显然","也","可用","用到","相对","大多数","这些","音符","把","记事本","决定","第二个","unicode","100","一部","(","笔记","乱码","127","用来","邮件","单字","gimel","计算","在","<","解读","集合","|","四个","最","第","10xxxxxx","现在","实际","一节","处在","必须","为","浏览器","当前","1110xxxx","一律","可以","世界","字符","处理","已经","打印","我们","：","数","包括","110xxxxx","二条","毫无关系","规模","gb","该","内","文字","下表","ג","支持","bit","不断","信息","发展","想得到","或","百种","什么","很大","各国","前","极大","进制","（","和","内存","务器","转换","演示","kr","内容","时候","开始","而且","所说","大小","浏览","电子","11100100","代表","接受","网页","不够","集","知道","上个世纪","同一","一位","你","文本","世纪","0","还","100111000100101","哪怕","因此","_","正是","65535","例如","多万个","对应","下","控制","位","shift","之间","65","出现","一样","4e25","两位","上个","传输","0010","一个","二三倍","\"","编码","以","。","直接","于是","汉字编码","三行","ascii","最广","为什么","区别","汉字","后","根据","才能","多少","一段","完全","不过","上表","发明","电子邮件","继续","字母","至今","表","避免","生成","英语","第三","值","60","成","位设","从","第二","码","英文字母","第一位","非常","e4b8a5","-","7","工作","长度","英文","无关","直到","0800","一段时间","二进制","a","十六","设计","造成","万左右","就","128","足足有","换成","meta","单字节","收信人","这样一来","来说","依次","呢","编码方式","互联","先","当","007f","制定","互联网","冲突","设为","它","混合",")","就是","常常","每","字节","注意","这个","第一","再有","有二到","编入","对","euc","只","希伯来语","4294967295","的","é","毫无","实现","多万","变化","源码","时间","发现","但是","文件","闲置","位补","欧洲","韩国","n","信号","$","甚至","称为","严","就是说","种","不是","因为","看成","历史","0080","填入","rom","编程","比如","没有","对于","ram","向前","这样","不会","必然","charset","一直","却","00100000","转换成","大写","上方","分别","记事","10","整数","都","遗留","强烈","所有","一种","则","参考","00000000","注音符号","4","将","多","中国","简单","最终","位为","作为","表示","解释","关系","只能","结果","=","英文字","连续","二三","x","错误","256","255","上","操作","只用",".","到","是","占用","年代","不能","内部","比较","被","像","操作系统","代码","设","显示","然后","利用","基于","硬盘","怎样","强烈要求","多数","byte","于","段时间","编程语言","0000","+","日本","只有","二个","空格","一下","第一个","一共","需要","07ff","可能","得到","所以","一部分","另","01000001","服务器","如果","^","多种","文本文件","标准","地"],"title":"1.5.字符编码","title_tokens":["1.5","字符","编码","."]},{"location":"计算机基础/1.5.字符编码.html#ascii","text":"因为计算机是美国人发明的，所以在上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。ASCII 码一共规定了128个字符的编码，比如空格 SPACE 是32（二进制 00100000 ），大写的字母 A 是65（二进制 01000001 ）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为 0 。","text_tokens":["只","个字符","的","进制","（","后面","一套","人","称为","32","上个世纪","一位","因为","世纪","0","）","统一","比如","一直","控制","位","，"," ","之间","00100000","space","65","大写","上个","一个","编码","。","沿用","ascii","关系","发明","字母","二进制位","至今","美国","是","英语","占用","年代","不能","60","被","计算","码","在","沿用至今","7","了","最","算机","二进制","a","为","128","出来","字符","打印","个","符号","与","这","空格","一共","包括","制定","所以","规定","01000001","前面","字节","做","计算机","对"],"title":"ASCII码","title_tokens":["ascii","码"]},{"location":"计算机基础/1.5.字符编码.html#ascii_1","text":"英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的 é 的编码为130（二进制 10000010 ）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了 é ，在希伯来语编码中却代表了字母 Gimel ( ג )，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。","text_tokens":["体系","希伯来语","的","é","它们","进制","（","不","但是","注音","闲置","欧洲","有","俄语","代表","不够","0","）","哪怕","比如","因此","一来","法语","新","不管","这样","语言","位","，"," ","却","使用","中","130","上方","出现","一样","问题","都","一个","不管怎样","编码","又","。","所有","于是","10000010","ascii","注音符号","一些","表示","一段","这些","音符","字母","决定","只是","256","255","(","英语","是","方式","127","用来","gimel","码","在","-","了","希伯来","利用","怎样","二进制","为","就","128","不同","就够","用","可以","这样一来","个","符号","国家","这里","这","编码方式","其他","它","另","最高","无法",")","ג","字节","会","最多","编入"],"title":"非ASCII码","title_tokens":["ascii","码","非"]},{"location":"计算机基础/1.5.字符编码.html#gb2312","text":"汉字多达10万左右，要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了 GB2312 编码，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 可以想得到的是，全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。","text_tokens":["euc","百种","类","各国","的","全世界","毫无","和","65536","不可","但是","kr","韩国","utf","编","而且","有","不够","理论","后文","文本","还","日文","8","_","多达","语言","shift","，"," ","使用","中","韩文","出现","中文","10","都","一个","编码","至少","。","不可避免","显然","汉字编码","ascii","多个","两个","汉字","多","中国","左右","表示","关系","结果","=","把","x","unicode","256","里","上","避免","乱码","到","是","不能","在","-","了","无关","显示","最","jis","万左右","就","可以","用","世界","出来","处理","日本","个","符号","与","需要","毫无关系","gb2312","得到","制定","冲突","所以","gb","要","虽然","混合","就是","字节","想得到","会","标准","地"],"title":"GB2312码","title_tokens":["码","gb2312"]},{"location":"计算机基础/1.5.字符编码.html#unicode","text":"正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode就像它的名字都表示的，这是一种所有符号的编码。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，可以查询 unicode.org ，或者专门的 汉字对应表 。","text_tokens":["本文","什么","很大","的","进制","多万","org","（","和","不","应运而生","文件","一套","大多","所说","数字","电子","或者","知道","发信","同一","因为","文本","常用","）","统一","编程","因此","系统","这样","不会","多万个","对应","语言","，"," ","收信","使用","万个","否则","出现","一样","问题","都","发信人","一个","正如","专门","偏僻","编码","。","直接","所有","一种","也","为什么","4","两个","汉字","用到","每个","大多数","表示","解释","电子邮件","把","这是","现代","错误","unicode","里","上","操作","100","表","乱码","容纳",".","到","方式","是","名字","邮件","成","被","查询","像","在","非常","操作系统","了","解读","集合","同一个","最","？","现在","但","一节","二进制","多数","必须","应运","打开","就","不同","编程语言","可以","用","世界","字符","收信人","个","符号","着","需要","编码方式","规模","想","它","要","如果","就是","支持","常常","不断","多种","文本文件","发展","字节","会","标准","再有","存在"],"title":"Unicode","title_tokens":["unicode"]},{"location":"计算机基础/1.5.字符编码.html#unicode_1","text":"需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。（ 这里说的储存是储存在 ROM 中，比如说硬盘。 ） 比如，汉字 严 的 Unicode 是十六进制数 4E25 ，转换成二进制数足足有15位（ 100111000100101 ），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0 ，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 因此不能用Unicode码直接储存文件。 它们造成的结果是： 出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。 Unicode 在很长一段时间内无法推广，直到互联网的出现。","text_tokens":["或","本文","只","怎么","极大","前","的","它们","进制","（","推广","2","和","时间","转换","说","文件","应该","联网","大小","三倍","甚至","严","或者","有","也就是说","就是说","接受","集","知道","浪费","更大","不是","文本","存储","0","）","rom","100111000100101","统一","格式","比如","没有","三个","对于","而","因此","必然","位","，"," ","却","转换成","中","如何","出现","那么","4e25","问题","分别","严重","都","储存","一个","二三倍","至少","。","很长","直接","ascii","区别","4","汉字","两个","多","才能","每个","15","表示","一段","结果","大出","英文字","字母","这是","二三","只是","unicode","足足","第二个","许多","只用","是","方式","比如说","用来","不能","第二","计算","码","英文字母","在","代码","了","英文","四个","？","直到","算机","硬盘","一段时间","二进制","十六","3","段时间","造成","就","不同","足足有","就够","换成","用","可以","更","已经","个","符号","来说","二个","这里","我们","呢","第一个","这","需要","数","互联","其他","可能","互联网","它","规定","内","许多种","十六进制","文字","无法","如果","就是","多种","注意","字节","这个","第一","文本文件","会","计算机","有二到","："],"title":"Unicode 的问题","title_tokens":["的"," ","问题","unicode"]},{"location":"计算机基础/1.5.字符编码.html#utf-8","text":"互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。 ==强调一下Unicode和UTF-8的区别：UTF-8是Unicode的一种储存形式，但计算机只能读取二进制的内容，因此计算机读取UTF-8编码的文件，需要将文件转码为Unicode（Unicode是完全二进制的形式）。也就是说，文件以UTF-8的形式储存在硬盘上，以Unicode的形式储存在内存（Ram）中。==例如： 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。 所以你看到很多网页的源码上会有类似 <meta charset=\"UTF-8\" /> 的信息，表示该网页正是用的UTF-8编码。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为 0 ，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于 n 字节的符号（ n > 1 ），第一个字节的前 n 位都设为 1 ，第 n + 1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母 x 表示可用编码的位。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） ----------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是 0 ，则这个字节单独就是一个字符；如果第一位是 1 ，则连续有多少个 1 ，就表示当前字符占用多少个字节。 下面，还是以汉字 严 为例，演示如何实现 UTF-8 编码。 严 的 Unicode 是 4E25 （ 100111000100101 ），根据上表，可以发现 4E25 处在第三行的范围内（ 0000 0800 - 0000 FFFF ），因此 严 的 UTF-8 编码需要三个字节，即格式是 1110xxxx 10xxxxxx 10xxxxxx 。然后，从 严 的最后一个二进制位开始，依次从后向前填入格式中的 x ，多出的位补 0 。这样就得到了， 严 的 UTF-8 编码是 11100100 10111000 10100101 ，转换成十六进制就是 E4B8A5 。 UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。","text_tokens":["全部","或","从文件","好处","只","相同","前","的","跟据","不用","实现","~","进制","变化","源码","下面","（","大量","后面","和","内存","很","2","发现","务器","转换","演示","文件","位补","内容","utf","时候","n","0xxxxxxx","最后","联网","普及","开始","软件","浏览","或者","32","单独","严","有","11100100","也就是说","规则","网页","就是说","基本","读取","16","你","一位","码是","总结","多出","看成","要求","还","0","范围","历史","0080","提及","）","统一","100111000100101","即","格式","填入","8","因此","正是","对于","ram","而","没有","还是","三个","向前","这样","强调","例如","编辑","服务","10111000","下","/","charset","位","，"," ","再","部分","使用","转换成","中","如何","为例","看到","出现","4e25","两位","传输","记事","0010","10","额外","都","10100101","储存","遗留","一个","\"","强烈","特点","编码","以","。","上会","一种","三行","ascii","可用","最广","则","形式","将","区别","两个","后","4","变长","ffff","很多","汉字","根据","简单","多少","最大","位为","表示","只能","第三行","从后","完全","不过","上表","=","把","字母","连续","继续","二进制位","记事本","x",">","unicode","里","上","一部","(","生成","到","方式","是","类似","英语","占用","第三","单字","位设","从","被","计算","码","在","第一位","剩下","非常","-","7","e4b8a5","实际上","<","完成","设","了","工作","长度","|","解读","四个","然后","算机","第","10xxxxxx","硬盘","0800","但","强烈要求","动态","0001","二进制","处在","十六","为","实际","浏览器","当前","就","11110xxx","1110xxxx","不同","0000","换成","一律","+","用","meta","可以","字符","单字节","只有","个","符号","依次","一下","第一个","需要","07ff","编码方式","包括","二条","110xxxxx","非常简单","互联","当","其他","007f","得到","互联网","设为","所以","该","一部分","保存","它","内","；","十六进制","服务器","下表","如果",")","就是","支持","字节","转码","信息","会","第一","这个","计算机","1","："],"title":"UTF-8","title_tokens":["8","utf","-"]},{"location":"计算机基础/1.5.字符编码.html#_1","text":"字符编码笔记：ASCII，Unicode 和 UTF-8","text_tokens":["8","ascii","和","unicode","字符","-","编码","笔记","utf","，"," ","："],"title":"参考","title_tokens":["参考"]}]}